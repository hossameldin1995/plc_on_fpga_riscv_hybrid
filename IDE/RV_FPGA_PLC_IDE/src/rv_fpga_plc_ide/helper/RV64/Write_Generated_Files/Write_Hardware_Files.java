/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package rv_fpga_plc_ide.helper.RV64.Write_Generated_Files;

import java.io.File;
import rv_fpga_plc_ide.helper.Data;
import rv_fpga_plc_ide.helper.GeneralFunctions;

/**
 *
 * @author hossameldin
 */
public class Write_Hardware_Files {
    public void generate_q_files(String Project_Folder) {
        generate_q_subfolders(Project_Folder+"rtl/");
        generate_project_files(Project_Folder);
        generate_top_level_files(Project_Folder);
        generate_ambalib_files(Project_Folder+"rtl/ambalib/");
        generate_commonlib_files(Project_Folder+"rtl/commonlib/");
        generate_misclib_files(Project_Folder+"rtl/misclib/");
        generate_funcblocklib_files(Project_Folder+"rtl/funcblocklib/");
        generate_techmap_files(Project_Folder+"rtl/techmap/");
        generate_riverlib_files(Project_Folder+"rtl/riverlib/");
        generate_arithlib_files(Project_Folder+"rtl/arithlib/");
        generate_clock_generator_files(Project_Folder+"rtl/clock_generator/");
    }
    
    private void generate_q_subfolders(String Project_Folder) {
        File file;
        file = new File(Project_Folder+"ambalib"); file.mkdirs();
        file = new File(Project_Folder+"arithlib"); file.mkdirs();
        file = new File(Project_Folder+"clock_generator"); file.mkdirs();
        file = new File(Project_Folder+"clock_generator/clock_generator"); file.mkdirs();
        file = new File(Project_Folder+"clock_generator/clock_generator_sim"); file.mkdirs();
        file = new File(Project_Folder+"commonlib"); file.mkdirs();
        file = new File(Project_Folder+"funcblocklib"); file.mkdirs();
        file = new File(Project_Folder+"funcblocklib/TON"); file.mkdirs();
        file = new File(Project_Folder+"funcblocklib/PWM"); file.mkdirs();
        file = new File(Project_Folder+"funcblocklib/time_measurement"); file.mkdirs();
        file = new File(Project_Folder+"misclib"); file.mkdirs();
        file = new File(Project_Folder+"prj"); file.mkdirs();
        file = new File(Project_Folder+"prj/cyclone_v"); file.mkdirs();
        file = new File(Project_Folder+"riverlib/"); file.mkdirs();
        file = new File(Project_Folder+"riverlib/cache"); file.mkdirs();
        file = new File(Project_Folder+"riverlib/dsu"); file.mkdirs();
        file = new File(Project_Folder+"riverlib/core"); file.mkdirs();
        file = new File(Project_Folder+"riverlib/core/arith"); file.mkdirs();
        file = new File(Project_Folder+"riverlib/core/fpu_d"); file.mkdirs();
        file = new File(Project_Folder+"arithlib"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/MULT"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/DIV"); file.mkdirs();
        file = new File(Project_Folder+"techmap"); file.mkdirs();
        file = new File(Project_Folder+"techmap/gencomp"); file.mkdirs();
        file = new File(Project_Folder+"techmap/mem"); file.mkdirs();
        file = new File(Project_Folder+"work"); file.mkdirs();
    }
    
    private void generate_project_files(String Project_Folder_File) {
        generate_River_SoC_qpf_file(Project_Folder_File+"River_SoC.qpf");
        generate_River_SoC_qsf_file(Project_Folder_File+"River_SoC.qsf");
        generate_River_SoC_sdc_file(Project_Folder_File+"River_SoC.sdc");
    }
    
    private void generate_top_level_files(String Project_Folder_File) {
        generate_RV_FPGA_PLC_River_vhd_file(Project_Folder_File+"RV_FPGA_PLC_River.vhd");
        generate_toplevel_vhd_file(Project_Folder_File+"rtl/toplevel.vhd");
        generate_riscv_soc_vhd_file(Project_Folder_File+"rtl/work/riscv_soc.vhd");
        generate_config_cyclone_v_vhd_file(Project_Folder_File+"rtl/prj/cyclone_v/config_cyclone_v.vhd");
    }
    
    private void generate_ambalib_files(String Project_Folder_File) {
        generate_axictrl_bus0_vhd_file(Project_Folder_File+"axictrl_bus0.vhd");
        generate_axislv_vhd_file(Project_Folder_File+"axislv.vhd");
        generate_types_amba4_vhd_file(Project_Folder_File+"types_amba4.vhd");
        generate_types_bus0_vhd_file(Project_Folder_File+"types_bus0.vhd");
    }
    
    private void generate_commonlib_files(String Project_Folder_File) {
        generate_types_common_vhd_file(Project_Folder_File+"types_common.vhd");
        generate_types_util_vhd_file(Project_Folder_File+"types_util.vhd");
    }
    
    private void generate_misclib_files(String Project_Folder_File) {
        generate_types_misc_vhd_file(Project_Folder_File+"types_misc.vhd");
        generate_reset_glb_vhd_file(Project_Folder_File+"reset_glb.vhd");
        generate_axi4_uart_vhd_file(Project_Folder_File+"axi4_uart.vhd");
        generate_axi4_sram_vhd_file(Project_Folder_File+"axi4_sram.vhd");
        generate_axi4_rom_vhd_file(Project_Folder_File+"axi4_rom.vhd");
        generate_axi4_irqctrl_vhd_file(Project_Folder_File+"axi4_irqctrl.vhd");
        generate_axi4_gptimers_vhd_file(Project_Folder_File+"axi4_gptimers.vhd");
        generate_axi4_gpio_vhd_file(Project_Folder_File+"axi4_gpio.vhd");
        generate_axi4_time_measurement_vhd_file(Project_Folder_File+"axi4_time_measurement.vhd");
        generate_axi4_ton_vhd_file(Project_Folder_File+"axi4_ton.vhd");
        generate_axi4_pwm_vhd_file(Project_Folder_File+"axi4_pwm.vhd");
    }
    
    private void generate_funcblocklib_files(String Project_Folder_File) {
        generate_Counter_Down_64_bit_Cin_vhd_file(Project_Folder_File+"TON/Counter_Down_64_bit_Cin.vhd");
        
        generate_PWM_32_bit_vhd_file(Project_Folder_File+"PWM/PWM_32_bit.vhd");
        generate_PWM_Signal_vhd_file(Project_Folder_File+"PWM/PWM_Signal.vhd");
        
        generate_Time_Calculation_vhd_file(Project_Folder_File+"time_measurement/Time_Calculation.vhd");
        generate_Write_To_Hexa_vhd_file(Project_Folder_File+"time_measurement/Write_To_Hexa.vhd");
        generate_SEG7_LUT_4_v_file(Project_Folder_File+"time_measurement/SEG7_LUT_4.v");
        generate_SEG7_LUT_v_file(Project_Folder_File+"time_measurement/SEG7_LUT.v");
    }
    
    private void generate_techmap_files(String Project_Folder_File) {
        generate_gencomp_vhd_file(Project_Folder_File+"gencomp/gencomp.vhd");
        
        generate_types_mem_vhd_file(Project_Folder_File+"mem/types_mem.vhd");
        generate_rom_tech_vhd_file(Project_Folder_File+"mem/rom_tech.vhd");
        generate_ram_tech_vhd_file(Project_Folder_File+"mem/ram_tech.vhd");
        generate_srambytes_tech_vhd_file(Project_Folder_File+"mem/srambytes_tech.vhd");
        generate_sram8_inferred_vhd_file(Project_Folder_File+"mem/sram8_inferred.vhd");
        generate_ram_inferred_vhd_file(Project_Folder_File+"mem/ram_inferred.vhd");
    }
    
    private void generate_riverlib_files(String Project_Folder_File) {
        generate_types_river_vhd_file(Project_Folder_File+"types_river.vhd");
        generate_river_top_vhd_file(Project_Folder_File+"river_top.vhd");
        generate_river_cfg_vhd_file(Project_Folder_File+"river_cfg.vhd");
        generate_river_amba_vhd_file(Project_Folder_File+"river_amba.vhd");
        
        generate_axi_dsu_vhd_file(Project_Folder_File+"dsu/axi_dsu.vhd");
        
        generate_types_cache_vhd_file(Project_Folder_File+"cache/types_cache.vhd");
        generate_iwaymem_vhd_file(Project_Folder_File+"cache/iwaymem.vhd");
        generate_ilru_vhd_file(Project_Folder_File+"cache/ilru.vhd");
        generate_icache_lru_vhd_file(Project_Folder_File+"cache/icache_lru.vhd");
        generate_icache_vhd_file(Project_Folder_File+"cache/icache.vhd");
        generate_dcache_vhd_file(Project_Folder_File+"cache/dcache.vhd");
        generate_cache_top_vhd_file(Project_Folder_File+"cache/cache_top.vhd");
        
        generate_stacktrbuf_vhd_file(Project_Folder_File+"core/stacktrbuf.vhd");
        generate_regibank_vhd_file(Project_Folder_File+"core/regibank.vhd");
        generate_regfbank_vhd_file(Project_Folder_File+"core/regfbank.vhd");
        generate_proc_vhd_file(Project_Folder_File+"core/proc.vhd");
        generate_memaccess_vhd_file(Project_Folder_File+"core/memaccess.vhd");
        generate_fetch_vhd_file(Project_Folder_File+"core/fetch.vhd");
        generate_execute_vhd_file(Project_Folder_File+"core/execute.vhd");
        generate_decoder_vhd_file(Project_Folder_File+"core/decoder.vhd");
        generate_dbg_port_vhd_file(Project_Folder_File+"core/dbg_port.vhd");
        generate_csr_vhd_file(Project_Folder_File+"core/csr.vhd");
        generate_bp_predic_vhd_file(Project_Folder_File+"core/bp_predic.vhd");
        
        generate_l2d_d_vhd_file(Project_Folder_File+"core/fpu_d/l2d_d.vhd");
        generate_imul53_vhd_file(Project_Folder_File+"core/fpu_d/imul53.vhd");
        generate_idiv53_vhd_file(Project_Folder_File+"core/fpu_d/idiv53.vhd");
        generate_fpu_top_vhd_file(Project_Folder_File+"core/fpu_d/fpu_top.vhd");
        generate_fmul_d_vhd_file(Project_Folder_File+"core/fpu_d/fmul_d.vhd");
        generate_fdiv_d_vhd_file(Project_Folder_File+"core/fpu_d/fdiv_d.vhd");
        generate_fadd_d_vhd_file(Project_Folder_File+"core/fpu_d/fadd_d.vhd");
        generate_divstage53_vhd_file(Project_Folder_File+"core/fpu_d/divstage53.vhd");
        generate_d2l_d_vhd_file(Project_Folder_File+"core/fpu_d/d2l_d.vhd");
        
        generate_shift_vhd_file(Project_Folder_File+"core/arith/shift.vhd");
        generate_int_div_vhd_file(Project_Folder_File+"core/arith/int_div.vhd");
        generate_int_mul_cyclone_v_vhd_file(Project_Folder_File+"core/arith/int_mul_cyclone_v.vhd");
        generate_divstage64_vhd_file(Project_Folder_File+"core/arith/divstage64.vhd");
    }
    
    private void generate_arithlib_files(String Project_Folder_File) {
        generate_mul_int_64_vhd_file(Project_Folder_File+"MULT/mul_int_64.vhd");
        generate_mul_int_64_qip_file(Project_Folder_File+"MULT/mul_int_64.qip");
        generate_mul_int_20_7_vhd_file(Project_Folder_File+"MULT/mul_int_20_7.vhd");
        generate_mul_int_20_7_qip_file(Project_Folder_File+"MULT/mul_int_20_7.qip");
        
        generate_div_int_20_7_speed_vhd_file(Project_Folder_File+"DIV/div_int_20_7_speed.vhd");
        generate_div_int_20_7_speed_qip_file(Project_Folder_File+"DIV/div_int_20_7_speed.qip");
        generate_div_int_20_17_speed_vhd_file(Project_Folder_File+"DIV/div_int_20_17_speed.vhd");
        generate_div_int_20_17_speed_qip_file(Project_Folder_File+"DIV/div_int_20_17_speed.qip");
    }
    
    private void generate_clock_generator_files(String Project_Folder_File) {
        generate_clock_generator_vhd_file(Project_Folder_File+"clock_generator.vhd");
        generate_clock_generator_qip_file(Project_Folder_File+"clock_generator.qip");
        generate_clock_generator_sip_file(Project_Folder_File+"clock_generator.sip");
        generate_clock_generator_spd_file(Project_Folder_File+"clock_generator.spd");
        
        generate_clock_generator_0002_v_file(Project_Folder_File+"clock_generator/clock_generator_0002.v");
        generate_clock_generator_0002_qip_file(Project_Folder_File+"clock_generator/clock_generator_0002.qip");
        
        generate_clock_generator_vho_file(Project_Folder_File+"clock_generator_sim/clock_generator.vho");
        
    }
    
    private void generate_River_SoC_qpf_file(String Project_Folder_File) {
        String data =   "# -------------------------------------------------------------------------- #\n" +
                        "#\n" +
                        "# Copyright (C) 2018  Intel Corporation. All rights reserved.\n" +
                        "# Your use of Intel Corporation's design tools, logic functions \n" +
                        "# and other software and tools, and its AMPP partner logic \n" +
                        "# functions, and any output files from any of the foregoing \n" +
                        "# (including device programming or simulation files), and any \n" +
                        "# associated documentation or information are expressly subject \n" +
                        "# to the terms and conditions of the Intel Program License \n" +
                        "# Subscription Agreement, the Intel Quartus Prime License Agreement,\n" +
                        "# the Intel FPGA IP License Agreement, or other applicable license\n" +
                        "# agreement, including, without limitation, that your use is for\n" +
                        "# the sole purpose of programming logic devices manufactured by\n" +
                        "# Intel and sold by Intel or its authorized distributors.  Please\n" +
                        "# refer to the applicable agreement for further details.\n" +
                        "#\n" +
                        "# -------------------------------------------------------------------------- #\n" +
                        "#\n" +
                        "# Quartus Prime\n" +
                        "# Version 18.0.0 Build 614 04/24/2018 SJ Lite Edition\n" +
                        "# Date created = 18:37:11  September 05, 2019\n" +
                        "#\n" +
                        "# -------------------------------------------------------------------------- #\n" +
                        "\n" +
                        "QUARTUS_VERSION = \"18.0\"\n" +
                        "DATE = \"18:37:11  September 05, 2019\"\n" +
                        "\n" +
                        "# Revisions\n" +
                        "\n" +
                        "PROJECT_REVISION = \"River_SoC\"";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_River_SoC_qsf_file(String Project_Folder_File) {
        String data =   "# -------------------------------------------------------------------------- #\n" +
                        "#\n" +
                        "# Copyright (C) 2018  Intel Corporation. All rights reserved.\n" +
                        "# Your use of Intel Corporation's design tools, logic functions \n" +
                        "# and other software and tools, and its AMPP partner logic \n" +
                        "# functions, and any output files from any of the foregoing \n" +
                        "# (including device programming or simulation files), and any \n" +
                        "# associated documentation or information are expressly subject \n" +
                        "# to the terms and conditions of the Intel Program License \n" +
                        "# Subscription Agreement, the Intel Quartus Prime License Agreement,\n" +
                        "# the Intel FPGA IP License Agreement, or other applicable license\n" +
                        "# agreement, including, without limitation, that your use is for\n" +
                        "# the sole purpose of programming logic devices manufactured by\n" +
                        "# Intel and sold by Intel or its authorized distributors.  Please\n" +
                        "# refer to the applicable agreement for further details.\n" +
                        "#\n" +
                        "# -------------------------------------------------------------------------- #\n" +
                        "#\n" +
                        "# Quartus Prime\n" +
                        "# Version 18.0.0 Build 614 04/24/2018 SJ Lite Edition\n" +
                        "# Date created = 18:37:11  September 05, 2019\n" +
                        "#\n" +
                        "# -------------------------------------------------------------------------- #\n" +
                        "#\n" +
                        "# Notes:\n" +
                        "#\n" +
                        "# 1) The default values for assignments are stored in the file:\n" +
                        "#		River_SoC_assignment_defaults.qdf\n" +
                        "#    If this file doesn't exist, see file:\n" +
                        "#		assignment_defaults.qdf\n" +
                        "#\n" +
                        "# 2) Altera recommends that you do not modify this file. This\n" +
                        "#    file is updated automatically by the Quartus Prime software\n" +
                        "#    and any changes you make may be lost or overwritten.\n" +
                        "#\n" +
                        "# -------------------------------------------------------------------------- #\n" +
                        "\n" +
                        "\n" +
                        "set_global_assignment -name FAMILY \"Cyclone V\"\n" +
                        "set_global_assignment -name DEVICE 5CGXFC5C6F27C7\n" +
                        "set_global_assignment -name TOP_LEVEL_ENTITY RV_FPGA_PLC_River\n" +
                        "set_global_assignment -name ORIGINAL_QUARTUS_VERSION 18.0.0\n" +
                        "set_global_assignment -name PROJECT_CREATION_TIME_DATE \"18:37:11  SEPTEMBER 05, 2019\"\n" +
                        "set_global_assignment -name LAST_QUARTUS_VERSION \"18.0.0 Lite Edition\"\n" +
                        "set_global_assignment -name PROJECT_OUTPUT_DIRECTORY output_files\n" +
                        "set_global_assignment -name MIN_CORE_JUNCTION_TEMP 0\n" +
                        "set_global_assignment -name MAX_CORE_JUNCTION_TEMP 85\n" +
                        "set_global_assignment -name ERROR_CHECK_FREQUENCY_DIVISOR 256\n" +
                        "set_global_assignment -name EDA_SIMULATION_TOOL \"ModelSim-Altera (Verilog)\"\n" +
                        "set_global_assignment -name EDA_TIME_SCALE \"1 ps\" -section_id eda_simulation\n" +
                        "set_global_assignment -name EDA_OUTPUT_DATA_FORMAT \"VERILOG HDL\" -section_id eda_simulation\n" +
                        "set_global_assignment -name POWER_PRESET_COOLING_SOLUTION \"23 MM HEAT SINK WITH 200 LFPM AIRFLOW\"\n" +
                        "set_global_assignment -name POWER_BOARD_THERMAL_MODEL \"NONE (CONSERVATIVE)\"\n" +
                        "\n" +
                        "set_global_assignment -name NUM_PARALLEL_PROCESSORS 4\n" +
                        "set_global_assignment -name PARTITION_NETLIST_TYPE SOURCE -section_id Top\n" +
                        "set_global_assignment -name PARTITION_FITTER_PRESERVATION_LEVEL PLACEMENT_AND_ROUTING -section_id Top\n" +
                        "set_global_assignment -name PARTITION_COLOR 16764057 -section_id Top\n" +
                        "set_location_assignment PIN_L9 -to UART_TX\n" +
                        "set_location_assignment PIN_M9 -to UART_RX\n" +
                        "set_location_assignment PIN_AC9 -to SW[0]\n" +
                        "set_location_assignment PIN_AE10 -to SW[1]\n" +
                        "set_location_assignment PIN_AD13 -to SW[2]\n" +
                        "set_location_assignment PIN_AC8 -to SW[3]\n" +
                        "set_location_assignment PIN_W11 -to SW[4]\n" +
                        "set_location_assignment PIN_AB10 -to SW[5]\n" +
                        "set_location_assignment PIN_V10 -to SW[6]\n" +
                        "set_location_assignment PIN_AC10 -to SW[7]\n" +
                        "set_location_assignment PIN_Y11 -to SW[8]\n" +
                        "set_location_assignment PIN_AE19 -to SW[9]\n" +
                        "set_location_assignment PIN_F7 -to LEDR[0]\n" +
                        "set_location_assignment PIN_F6 -to LEDR[1]\n" +
                        "set_location_assignment PIN_G6 -to LEDR[2]\n" +
                        "set_location_assignment PIN_G7 -to LEDR[3]\n" +
                        "set_location_assignment PIN_J8 -to LEDR[4]\n" +
                        "set_location_assignment PIN_J7 -to LEDR[5]\n" +
                        "set_location_assignment PIN_K10 -to LEDR[6]\n" +
                        "set_location_assignment PIN_K8 -to LEDR[7]\n" +
                        "set_location_assignment PIN_H7 -to LEDR[8]\n" +
                        "set_location_assignment PIN_J10 -to LEDR[9]\n" +
                        "set_location_assignment PIN_L7 -to LEDG[0]\n" +
                        "set_location_assignment PIN_K6 -to LEDG[1]\n" +
                        "set_location_assignment PIN_D8 -to LEDG[2]\n" +
                        "set_location_assignment PIN_E9 -to LEDG[3]\n" +
                        "set_location_assignment PIN_A5 -to LEDG[4]\n" +
                        "set_location_assignment PIN_B6 -to LEDG[5]\n" +
                        "set_location_assignment PIN_H8 -to LEDG[6]\n" +
                        "set_location_assignment PIN_H9 -to LEDG[7]\n" +
                        "set_location_assignment PIN_P11 -to KEY_n[0]\n" +
                        "set_location_assignment PIN_P12 -to KEY_n[1]\n" +
                        "set_location_assignment PIN_Y15 -to KEY_n[2]\n" +
                        "set_location_assignment PIN_Y16 -to KEY_n[3]\n" +
                        "set_location_assignment PIN_AA18 -to HEX1[0]\n" +
                        "set_location_assignment PIN_AD26 -to HEX1[1]\n" +
                        "set_location_assignment PIN_AB19 -to HEX1[2]\n" +
                        "set_location_assignment PIN_AE26 -to HEX1[3]\n" +
                        "set_location_assignment PIN_AE25 -to HEX1[4]\n" +
                        "set_location_assignment PIN_AC19 -to HEX1[5]\n" +
                        "set_location_assignment PIN_AF24 -to HEX1[6]\n" +
                        "set_location_assignment PIN_V19 -to HEX0[0]\n" +
                        "set_location_assignment PIN_V18 -to HEX0[1]\n" +
                        "set_location_assignment PIN_V17 -to HEX0[2]\n" +
                        "set_location_assignment PIN_W18 -to HEX0[3]\n" +
                        "set_location_assignment PIN_Y20 -to HEX0[4]\n" +
                        "set_location_assignment PIN_Y19 -to HEX0[5]\n" +
                        "set_location_assignment PIN_Y18 -to HEX0[6]\n" +
                        "set_location_assignment PIN_T13 -to CLOCK_50_B3B\n" +
                        "set_location_assignment PIN_R20 -to CLOCK_50_B5B\n" +
                        "set_location_assignment PIN_N20 -to CLOCK_50_B6A\n" +
                        "set_location_assignment PIN_H12 -to CLOCK_50_B7A\n" +
                        "set_location_assignment PIN_M10 -to CLOCK_50_B8A\n" +
                        "set_location_assignment PIN_U12 -to CLOCK_125_p\n" +
                        "set_location_assignment PIN_AB24 -to CPU_RESET_n\n" +
                        "set_location_assignment PIN_V12 -to \"CLOCK_125_p(n)\"\n" +
                        "set_location_assignment PIN_T21 -to GPIO_IN[0]\n" +
                        "set_location_assignment PIN_D26 -to GPIO_IN[1]\n" +
                        "set_location_assignment PIN_Y9 -to GPIO_IN[17]\n" +
                        "set_location_assignment PIN_F26 -to GPIO_IN[16]\n" +
                        "set_location_assignment PIN_R10 -to GPIO_IN[15]\n" +
                        "set_location_assignment PIN_R9 -to GPIO_IN[14]\n" +
                        "set_location_assignment PIN_R8 -to GPIO_IN[13]\n" +
                        "set_location_assignment PIN_P8 -to GPIO_IN[12]\n" +
                        "set_location_assignment PIN_U22 -to GPIO_IN[11]\n" +
                        "set_location_assignment PIN_U19 -to GPIO_IN[10]\n" +
                        "set_location_assignment PIN_K25 -to GPIO_IN[2]\n" +
                        "set_location_assignment PIN_K26 -to GPIO_IN[4]\n" +
                        "set_location_assignment PIN_E26 -to GPIO_IN[3]\n" +
                        "set_location_assignment PIN_M26 -to GPIO_IN[5]\n" +
                        "set_location_assignment PIN_M21 -to GPIO_IN[6]\n" +
                        "set_location_assignment PIN_P20 -to GPIO_IN[7]\n" +
                        "set_location_assignment PIN_T22 -to GPIO_IN[8]\n" +
                        "set_location_assignment PIN_T19 -to GPIO_IN[9]\n" +
                        "set_location_assignment PIN_Y8 -to GPIO_OUT[1]\n" +
                        "set_location_assignment PIN_AA7 -to GPIO_OUT[2]\n" +
                        "set_location_assignment PIN_G26 -to GPIO_OUT[0]\n" +
                        "set_location_assignment PIN_AA6 -to GPIO_OUT[3]\n" +
                        "\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to CLOCK_50_B3B\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to CLOCK_50_B5B\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to CLOCK_50_B6A\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to CLOCK_50_B7A\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to CLOCK_50_B8A\n" +
                        "set_instance_assignment -name IO_STANDARD LVDS -to CLOCK_125_p\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to CPU_RESET_n\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to HEX0[0]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to HEX0[1]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to HEX0[2]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to HEX0[3]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to HEX0[4]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to HEX0[5]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to HEX0[6]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to HEX1[0]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to HEX1[1]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to HEX1[2]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to HEX1[3]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to HEX1[4]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to HEX1[5]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to HEX1[6]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to KEY_n[3]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to KEY_n[2]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to KEY_n[1]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to KEY_n[0]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDR[9]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDR[8]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDR[7]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDR[6]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDR[5]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDR[4]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDR[3]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDR[2]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDR[1]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDR[0]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDG[7]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDG[6]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDG[5]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDG[4]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDG[3]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDG[2]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDG[1]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDG[0]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to SW[9]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to SW[8]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to SW[7]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to SW[6]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to SW[5]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to SW[4]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to SW[3]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to SW[2]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to SW[1]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to SW[0]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to UART_TX\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to UART_RX\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[0]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[1]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[17]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[16]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[15]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[14]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[13]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[12]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[11]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[10]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[2]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[4]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[3]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[5]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[6]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[7]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[8]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[9]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[1]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[2]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[0]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[3]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[4]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[5]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[6]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[7]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[8]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[9]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[10]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[11]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[12]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[13]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[14]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[15]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[16]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[17]\n" +
                        "set_location_assignment PIN_AD7 -to HEX2[0]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to HEX2[0]\n" +
                        "set_location_assignment PIN_AD6 -to HEX2[1]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to HEX2[1]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to HEX2[2]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to HEX2[3]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to HEX2[4]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to HEX2[5]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to HEX2[6]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to HEX3[0]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to HEX3[1]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to HEX3[2]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to HEX3[3]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to HEX3[4]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to HEX3[5]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to HEX3[6]\n" +
                        "set_location_assignment PIN_U20 -to HEX2[2]\n" +
                        "set_location_assignment PIN_V22 -to HEX2[3]\n" +
                        "set_location_assignment PIN_V20 -to HEX2[4]\n" +
                        "set_location_assignment PIN_W21 -to HEX2[5]\n" +
                        "set_location_assignment PIN_W20 -to HEX2[6]\n" +
                        "set_location_assignment PIN_Y24 -to HEX3[0]\n" +
                        "set_location_assignment PIN_Y23 -to HEX3[1]\n" +
                        "set_location_assignment PIN_AA23 -to HEX3[2]\n" +
                        "set_location_assignment PIN_AA22 -to HEX3[3]\n" +
                        "set_location_assignment PIN_AC24 -to HEX3[4]\n" +
                        "set_location_assignment PIN_AC23 -to HEX3[5]\n" +
                        "set_location_assignment PIN_AC22 -to HEX3[6]\n" +
                        "\n" +
                        "set_global_assignment -name SDC_FILE River_SoC.sdc\n" +
                        "set_global_assignment -name VHDL_FILE RV_FPGA_PLC_River.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/toplevel.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/work/riscv_soc.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/prj/cyclone_v/config_cyclone_v.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/misclib/types_misc.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/misclib/reset_glb.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/misclib/axi4_uart.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/misclib/axi4_sram.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/misclib/axi4_rom.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/misclib/axi4_irqctrl.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/misclib/axi4_gptimers.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/misclib/axi4_gpio.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/misclib/axi4_ton.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/misclib/axi4_pwm.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/misclib/axi4_time_measurement.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/ambalib/types_bus0.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/ambalib/types_amba4.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/ambalib/axislv.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/ambalib/axictrl_bus0.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/techmap/mem/types_mem.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/techmap/mem/rom_tech.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/techmap/mem/ram_tech.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/techmap/mem/srambytes_tech.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/techmap/mem/sram8_inferred.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/techmap/mem/ram_inferred.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/techmap/gencomp/gencomp.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/commonlib/types_util.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/commonlib/types_common.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/cache/types_cache.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/cache/iwaymem.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/cache/ilru.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/cache/icache_lru.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/cache/icache.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/cache/dcache.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/cache/cache_top.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/fpu_d/l2d_d.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/fpu_d/imul53.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/fpu_d/idiv53.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/fpu_d/fpu_top.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/fpu_d/fmul_d.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/fpu_d/fdiv_d.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/fpu_d/fadd_d.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/fpu_d/divstage53.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/fpu_d/d2l_d.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/arith/shift.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/arith/int_div.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/arith/int_mul_cyclone_v.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/arith/divstage64.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/stacktrbuf.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/regibank.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/regfbank.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/proc.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/memaccess.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/fetch.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/execute.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/decoder.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/dbg_port.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/csr.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/bp_predic.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/dsu/axi_dsu.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/types_river.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/river_top.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/river_cfg.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/river_amba.vhd\n" +
                        "set_global_assignment -name QIP_FILE rtl/arithlib/DIV/div_int_20_7_speed.qip\n" +
                        "set_global_assignment -name QIP_FILE rtl/arithlib/DIV/div_int_20_17_speed.qip\n" +
                        "set_global_assignment -name QIP_FILE rtl/arithlib/MULT/mul_int_64.qip\n" +
                        "set_global_assignment -name QIP_FILE rtl/arithlib/MULT/mul_int_20_7.qip\n" +
                        "set_global_assignment -name QIP_FILE rtl/clock_generator/clock_generator.qip\n" +
                        "set_global_assignment -name SIP_FILE rtl/clock_generator/clock_generator.sip\n" +
                        "set_global_assignment -name VHDL_FILE rtl/funcblocklib/PWM/PWM_32_bit.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/funcblocklib/PWM/PWM_Signal.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/funcblocklib/TON/Counter_Down_64_bit_Cin.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/funcblocklib/time_measurement/Write_To_Hexa.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/funcblocklib/time_measurement/Time_Calculation.vhd\n" +
                        "set_global_assignment -name VERILOG_FILE rtl/funcblocklib/time_measurement/SEG7_LUT_4.v\n" +
                        "set_global_assignment -name VERILOG_FILE rtl/funcblocklib/time_measurement/SEG7_LUT.v\n" +
                        "\n" +
                        "set_global_assignment -name FITTER_EFFORT FAST_FIT\n" +
                        "set_global_assignment -name PHYSICAL_SYNTHESIS_EFFORT FAST\n" +
                        "\n" +
                        "set_instance_assignment -name PARTITION_HIERARCHY root_partition -to | -section_id Top";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_River_SoC_sdc_file(String Project_Folder_File) {
        String data =   "#**************************************************************\n" +
                        "# This .sdc file is created by Terasic Tool.\n" +
                        "# Users are recommended to modify this file to match users logic.\n" +
                        "#**************************************************************\n" +
                        "\n" +
                        "#**************************************************************\n" +
                        "# Create Clock\n" +
                        "#**************************************************************\n" +
                        "create_clock -period 8 [get_ports CLOCK_125_p]\n" +
                        "create_clock -period 20 [get_ports CLOCK_50_B5B]\n" +
                        "create_clock -period 20 [get_ports CLOCK_50_B6A]\n" +
                        "create_clock -period 20 [get_ports CLOCK_50_B7A]\n" +
                        "create_clock -period 20 [get_ports CLOCK_50_B8A]\n" +
                        "\n" +
                        "#**************************************************************\n" +
                        "# Create Generated Clock\n" +
                        "#**************************************************************\n" +
                        "derive_pll_clocks -create_base_clocks\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "#**************************************************************\n" +
                        "# Set Clock Latency\n" +
                        "#**************************************************************\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "#**************************************************************\n" +
                        "# Set Clock Uncertainty\n" +
                        "#**************************************************************\n" +
                        "derive_clock_uncertainty\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "#**************************************************************\n" +
                        "# Set Input Delay\n" +
                        "#**************************************************************\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "#**************************************************************\n" +
                        "# Set Output Delay\n" +
                        "#**************************************************************\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "#**************************************************************\n" +
                        "# Set Clock Groups\n" +
                        "#**************************************************************\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "#**************************************************************\n" +
                        "# Set False Path\n" +
                        "#**************************************************************\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "#**************************************************************\n" +
                        "# Set Multicycle Path\n" +
                        "#**************************************************************\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "#**************************************************************\n" +
                        "# Set Maximum Delay\n" +
                        "#**************************************************************\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "#**************************************************************\n" +
                        "# Set Minimum Delay\n" +
                        "#**************************************************************\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "#**************************************************************\n" +
                        "# Set Input Transition\n" +
                        "#**************************************************************\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "#**************************************************************\n" +
                        "# Set Load\n" +
                        "#**************************************************************";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_RV_FPGA_PLC_River_vhd_file(String Project_Folder_File) {
        String data =   "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "\n" +
                        "entity RV_FPGA_PLC_River is\n" +
                        "	port(\n" +
                        "		--------- CLOCK ---------\n" +
                        "		CLOCK_125_p	: in std_logic;\n" +
                        "		CLOCK_50_B3B: in std_logic;\n" +
                        "		CLOCK_50_B5B: in std_logic;\n" +
                        "		CLOCK_50_B6A: in std_logic;\n" +
                        "		CLOCK_50_B7A: in std_logic;\n" +
                        "		CLOCK_50_B8A: in std_logic;\n" +
                        "		\n" +
                        "		--------- CPU ---------\n" +
                        "		CPU_RESET_n	: in std_logic;\n" +
                        "		\n" +
                        "		--------- GPIO ---------\n" +
                        "		GPIO_IN		: in std_logic_vector(17 DOWNTO 0);\n" +
                        "		GPIO_OUT		: out std_logic_vector(17 DOWNTO 0);\n" +
                        "		\n" +
                        "		--------- HEX0 ---------\n" +
                        "		HEX0			: out std_logic_vector(6 DOWNTO 0);\n" +
                        "\n" +
                        "		--------- HEX1 ---------\n" +
                        "		HEX1			: out std_logic_vector(6 DOWNTO 0);\n" +
                        "		\n" +
                        "		--------- HEX2 ---------\n" +
                        "		HEX2			: out std_logic_vector(6 DOWNTO 0);\n" +
                        "		\n" +
                        "		--------- HEX3 ---------\n" +
                        "		HEX3			: out std_logic_vector(6 DOWNTO 0);\n" +
                        "		\n" +
                        "		--------- KEY ---------\n" +
                        "		KEY_n			: in std_logic_vector(3 DOWNTO 0);\n" +
                        "\n" +
                        "		--------- LEDG ---------\n" +
                        "		LEDG			: out std_logic_vector(7 DOWNTO 0);\n" +
                        "\n" +
                        "		--------- LEDR ---------\n" +
                        "		LEDR			: out std_logic_vector(9 DOWNTO 0);\n" +
                        "		\n" +
                        "		--------- SW ---------\n" +
                        "		SW				: in std_logic_vector(9 DOWNTO 0);\n" +
                        "\n" +
                        "		--------- UART ---------\n" +
                        "		UART_RX		: in std_logic;\n" +
                        "		UART_TX		: out std_logic\n" +
                        "	);\n" +
                        "end entity RV_FPGA_PLC_River;\n" +
                        "\n" +
                        "architecture behaviour of RV_FPGA_PLC_River is\n" +
                        "\n" +
                        "	component toplevel is\n" +
                        "		port(\n" +
                        "			clk     	: in  std_logic;\n" +
                        "			reset		: in  std_logic;\n" +
                        "\n" +
                        "			-- UART0 signals:\n" +
                        "			uart0_txd : out std_logic;\n" +
                        "			uart0_rxd : in  std_logic;\n" +
                        "		\n" +
                        "			-- KEY signals\n" +
                        "			KEY			: in std_logic_vector(3 DOWNTO 0);\n" +
                        "			\n" +
                        "			-- SW signals\n" +
                        "			SW				: in std_logic_vector(9 DOWNTO 0);\n" +
                        "			\n" +
                        "			-- LEDG signals\n" +
                        "			LEDG			: out std_logic_vector(7 DOWNTO 0);\n" +
                        "			\n" +
                        "			-- LEDR signals\n" +
                        "			LEDR			: out std_logic_vector(9 DOWNTO 0);\n" +
                        "			\n" +
                        "			-- GPIO signals\n" +
                        "			GPIO_IN		: in std_logic_vector(17 DOWNTO 0);\n" +
                        "			GPIO_OUT		: out std_logic_vector(17 DOWNTO 0);\n" +
                        "			\n" +
                        "			--------- HEX0 ---------\n" +
                        "			HEX0			: out std_logic_vector(6 DOWNTO 0);\n" +
                        "\n" +
                        "			--------- HEX1 ---------\n" +
                        "			HEX1			: out std_logic_vector(6 DOWNTO 0);\n" +
                        "			\n" +
                        "			--------- HEX2 ---------\n" +
                        "			HEX2			: out std_logic_vector(6 DOWNTO 0);\n" +
                        "			\n" +
                        "			--------- HEX3 ---------\n" +
                        "			HEX3			: out std_logic_vector(6 DOWNTO 0)\n" +
                        "		);\n" +
                        "	end component;\n" +
                        "	\n" +
                        "	signal KEY : std_logic_vector(3 DOWNTO 0);\n" +
                        "	signal reset : std_logic;\n" +
                        "	\n" +
                        "	begin\n" +
                        "		\n" +
                        "		KEY <= not(KEY_n);\n" +
                        "		reset <= not(CPU_RESET_n);\n" +
                        "		\n" +
                        "		River_SoC : toplevel\n" +
                        "		port map (\n" +
                        "			clk     		=> CLOCK_125_p,\n" +
                        "			reset   		=> reset,\n" +
                        "\n" +
                        "			-- UART0 signals:\n" +
                        "			uart0_txd 	=> UART_TX,\n" +
                        "			uart0_rxd 	=> UART_RX,\n" +
                        "		\n" +
                        "			-- KEY signals\n" +
                        "			KEY			=> KEY,\n" +
                        "			\n" +
                        "			-- SW signals\n" +
                        "			SW				=> SW,\n" +
                        "			\n" +
                        "			-- LEDG signals\n" +
                        "			LEDG			=> LEDG,\n" +
                        "			\n" +
                        "			-- LEDR signals\n" +
                        "			LEDR			=> LEDR,\n" +
                        "			\n" +
                        "			-- GPIO signals\n" +
                        "			GPIO_IN		=> GPIO_IN,\n" +
                        "			GPIO_OUT		=> GPIO_OUT,\n" +
                        "			\n" +
                        "			--------- HEX0 ---------\n" +
                        "			HEX0			=> HEX0,\n" +
                        "\n" +
                        "			--------- HEX1 ---------\n" +
                        "			HEX1			=> HEX1,\n" +
                        "			\n" +
                        "			--------- HEX2 ---------\n" +
                        "			HEX2			=> HEX2,\n" +
                        "			\n" +
                        "			--------- HEX3 ---------\n" +
                        "			HEX3			=> HEX3\n" +
                        "		);\n" +
                        "		\n" +
                        "end architecture;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_toplevel_vhd_file(String Project_Folder_File) {
        String data =   "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "\n" +
                        "entity toplevel is\n" +
                        "	port(\n" +
                        "		clk	: in  std_logic;\n" +
                        "		reset	: in  std_logic;\n" +
                        "\n" +
                        "		-- UART0 signals:\n" +
                        "		uart0_txd : out std_logic;\n" +
                        "		uart0_rxd : in  std_logic;\n" +
                        "		\n" +
                        "		-- KEY signals\n" +
                        "      KEY			: in std_logic_vector(3 DOWNTO 0);\n" +
                        "		\n" +
                        "		-- SW signals\n" +
                        "      SW				: in std_logic_vector(9 DOWNTO 0);\n" +
                        "		\n" +
                        "		-- LEDG signals\n" +
                        "      LEDG			: out std_logic_vector(7 DOWNTO 0);\n" +
                        "		\n" +
                        "		-- LEDR signals\n" +
                        "      LEDR			: out std_logic_vector(9 DOWNTO 0);\n" +
                        "		\n" +
                        "		-- GPIO signals\n" +
                        "      GPIO_IN		: in std_logic_vector(17 DOWNTO 0);\n" +
                        "      GPIO_OUT		: out std_logic_vector(17 DOWNTO 0);\n" +
                        "		\n" +
                        "		--------- HEX0 ---------\n" +
                        "		HEX0			: out std_logic_vector(6 DOWNTO 0);\n" +
                        "\n" +
                        "		--------- HEX1 ---------\n" +
                        "		HEX1			: out std_logic_vector(6 DOWNTO 0);\n" +
                        "		\n" +
                        "		--------- HEX2 ---------\n" +
                        "		HEX2			: out std_logic_vector(6 DOWNTO 0);\n" +
                        "		\n" +
                        "		--------- HEX3 ---------\n" +
                        "		HEX3			: out std_logic_vector(6 DOWNTO 0)\n" +
                        "	);\n" +
                        "end entity toplevel;\n" +
                        "\n" +
                        "architecture behaviour of toplevel is\n" +
                        "\n" +
                        "	component clock_generator is\n" +
                        "		port (\n" +
                        "			refclk   : in  std_logic := '0'; --  refclk.clk\n" +
                        "			rst      : in  std_logic := '0'; --   reset.reset\n" +
                        "			outclk_0 : out std_logic;        -- outclk0.clk\n" +
                        "			outclk_1 : out std_logic;        -- outclk0.clk\n" +
                        "			locked   : out std_logic         --  locked.export\n" +
                        "		);\n" +
                        "	end component;\n" +
                        "	\n" +
                        "	signal system_rst				: std_logic;\n" +
                        "	signal system_clk				: std_logic;\n" +
                        "	signal clk_pwm					: std_logic;\n" +
                        "	signal system_clk_locked	: std_logic;\n" +
                        "	signal system_gnd				: std_logic;\n" +
                        "	\n" +
                        "begin\n" +
                        "	\n" +
                        "	system_rst <= reset or not(system_clk_locked);\n" +
                        "	system_gnd <= '0';\n" +
                        "	\n" +
                        "	clkgen: clock_generator\n" +
                        "		port map(\n" +
                        "			refclk	=> clk,\n" +
                        "			rst 		=> reset,\n" +
                        "			outclk_0	=> system_clk,\n" +
                        "			outclk_1	=> clk_pwm,\n" +
                        "			locked 	=> system_clk_locked\n" +
                        "		);\n" +
                        "	\n" +
                        "	riscv_soc0: entity work.riscv_soc\n" +
                        "		port map(\n" +
                        "			i_rst				=> system_rst,\n" +
                        "			i_clk				=> system_clk,\n" +
                        "			i_clk_pwm			=> clk_pwm,\n" +
                        "			i_uart1_ctsn	=> system_gnd,\n" +
                        "			i_uart1_rd		=> uart0_rxd,\n" +
                        "			o_uart1_td		=>	uart0_txd,\n" +
                        "			o_uart1_rtsn	=> open,\n" +
                        "			KEY				=> KEY,\n" +
                        "			SW					=> SW,\n" +
                        "			LEDG				=> LEDG,\n" +
                        "			LEDR				=> LEDR,\n" +
                        "			GPIO_IN			=> GPIO_IN,\n" +
                        "			GPIO_OUT			=> GPIO_OUT,\n" +
                        "			HEX0				=> HEX0,\n" +
                        "			HEX1				=> HEX1,\n" +
                        "			HEX2				=> HEX2,\n" +
                        "			HEX3				=> HEX3\n" +
                        "			\n" +
                        "		);\n" +
                        "		\n" +
                        "end architecture behaviour;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_riscv_soc_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "-- axi_address		Size		Peripheral				Discription\n" +
                        "-- 0x00000000		32 KB		Boot ROM\n" +
                        "-- 0x00100000		64 KB		Application ROM\n" +
                        "-- 0x10000000		256KB		RAM\n" +
                        "-- 0x80000000		4  KB		GPIO\n" +
                        "-- 0x80001000		4  KB		UART1\n" +
                        "-- 0x80002000		4  KB		IRQ Controller\n" +
                        "-- 0x80003000		4  KB		GP Timers				Two general purpose timers with RTC\n" +
                        "-- 0x80004000		4  KB		Time Measurement\n";
                        for (int i = 0; ((i < Data.Number_Of_Timers_In_Program) && (Data.Compiling_Type == Data.HW_COMPILING)); i++) {
                            data += "-- 0x800"+new GeneralFunctions().dec2hex_str(5 + i, 2)+"000		4  KB		TON: "+Data.Name_of_Timers[i]+"\n";
                        }
                        for (int i = 0; ((i < Data.Number_Of_PWMs_In_Program) && (Data.Compiling_Type == Data.HW_COMPILING)); i++) {
                            data += "-- 0x800"+new GeneralFunctions().dec2hex_str(Data.Number_Of_Timers_In_Program + 5 + i, 2)+"000		4  KB		PWM: "+Data.Name_of_PWMs[i]+"\n";
                        }
                data += "\n" +
                        "--! Standard library\n" +
                        "library IEEE;\n" +
                        "use IEEE.STD_LOGIC_1164.ALL;\n" +
                        "\n" +
                        "--! Data transformation and math functions library\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "\n" +
                        "--! Technology definition library.\n" +
                        "--library techmap;\n" +
                        "--! Technology constants definition.\n" +
                        "use work.gencomp.all;\n" +
                        "\n" +
                        "--! AMBA system bus specific library\n" +
                        "--library ambalib;\n" +
                        "--! AXI4 configuration constants.\n" +
                        "use work.types_amba4.all;\n" +
                        "use work.types_bus0.all;\n" +
                        "--! Misc modules library\n" +
                        "--library misclib;\n" +
                        "use work.types_misc.all;\n" +
                        "--! Ethernet related declarations.\n" +
                        "--library ethlib;\n" +
                        "--use work.types_eth.all;\n" +
                        "\n" +
                        "--! River CPU specific library\n" +
                        "--library riverlib;\n" +
                        "--! River top level with AMBA interface module declaration\n" +
                        "use work.types_river.all;\n" +
                        "\n" +
                        " --! Top-level implementaion library\n" +
                        "library work;\n" +
                        "--! Target dependable configuration: RTL, FPGA or ASIC.\n" +
                        "use work.config_target.all;\n" +
                        "\n" +
                        "--! @brief   SOC Top-level entity declaration.\n" +
                        "--! @details This module implements full SOC functionality and all IO signals\n" +
                        "--!          are available on FPGA/ASIC IO pins.\n" +
                        "entity riscv_soc is port \n" +
                        "( \n" +
                        "  i_rst     : in std_logic;\n" +
                        "  i_clk  	: in std_logic;\n" +
                        "  i_clk_pwm	: in std_logic;\n" +
                        "  i_uart1_ctsn : in std_logic;\n" +
                        "  i_uart1_rd   : in std_logic;\n" +
                        "  o_uart1_td   : out std_logic;\n" +
                        "  o_uart1_rtsn : out std_logic;\n" +
                        "  KEY				: in std_logic_vector(3 DOWNTO 0);\n" +
                        "  SW				: in std_logic_vector(9 DOWNTO 0);\n" +
                        "  LEDG			: out std_logic_vector(7 DOWNTO 0);\n" +
                        "  LEDR			: out std_logic_vector(9 DOWNTO 0);\n" +
                        "  GPIO_IN		: in std_logic_vector(17 DOWNTO 0);\n" +
                        "  GPIO_OUT		: out std_logic_vector(17 DOWNTO 0);\n" +
                        "  HEX0			: out std_logic_vector(6 DOWNTO 0);\n" +
                        "  HEX1			: out std_logic_vector(6 DOWNTO 0);\n" +
                        "  HEX2			: out std_logic_vector(6 DOWNTO 0);\n" +
                        "  HEX3			: out std_logic_vector(6 DOWNTO 0)\n" +
                        ");\n" +
                        "  --! @}\n" +
                        "\n" +
                        "end riscv_soc;\n" +
                        "\n" +
                        "--! @brief SOC top-level  architecture declaration.\n" +
                        "architecture arch_riscv_soc of riscv_soc is\n" +
                        "\n" +
                        "  signal w_glob_rst  : std_ulogic; -- Global reset active HIGH\n" +
                        "  signal w_glob_nrst : std_ulogic; -- Global reset active LOW\n" +
                        "  signal w_soft_rst : std_ulogic; -- Software reset (acitve HIGH) from DSU\n" +
                        "  signal w_bus_nrst : std_ulogic; -- Global reset and Soft Reset active LOW\n" +
                        "  \n" +
                        "  signal uart1i : uart_in_type;\n" +
                        "  signal uart1o : uart_out_type;\n" +
                        "  --signal uart2i : uart_in_type;\n" +
                        "  --signal uart2o : uart_out_type;\n" +
                        "\n" +
                        "  --! Arbiter is switching only slaves output signal, data from noc\n" +
                        "  --! is connected to all slaves and to the arbiter itself.\n" +
                        "  signal aximi   : bus0_xmst_in_vector;\n" +
                        "  signal aximo   : bus0_xmst_out_vector;\n" +
                        "  signal axisi   : bus0_xslv_in_vector;\n" +
                        "  signal axiso   : bus0_xslv_out_vector;\n" +
                        "  signal slv_cfg : bus0_xslv_cfg_vector;\n" +
                        "  signal mst_cfg : bus0_xmst_cfg_vector;\n" +
                        "  signal w_ext_irq : std_logic;\n" +
                        "  signal dport_i : dport_in_vector;\n" +
                        "  signal dport_o : dport_out_vector;\n" +
                        "  signal wb_bus_util_w : std_logic_vector(CFG_BUS0_XMST_TOTAL-1 downto 0);\n" +
                        "  signal wb_bus_util_r : std_logic_vector(CFG_BUS0_XMST_TOTAL-1 downto 0);\n" +
                        " \n" +
                        "  signal irq_pins : std_logic_vector(CFG_IRQ_TOTAL-1 downto 1);\n" +
                        "begin\n" +
                        "\n" +
                        "\n" +
                        "  w_soft_rst <= '0';\n" +
                        "\n" +
                        "  ------------------------------------\n" +
                        "  --! @brief System Reset device instance.\n" +
                        "  rst0 : reset_global port map (\n" +
                        "    inSysReset  => i_rst,\n" +
                        "    inSysClk    => i_clk,\n" +
                        "    outReset    => w_glob_rst\n" +
                        "  );\n" +
                        "  w_glob_nrst <= not w_glob_rst;\n" +
                        "  w_bus_nrst <= not (w_glob_rst or w_soft_rst);\n" +
                        "\n" +
                        "  --! @brief AXI4 controller.\n" +
                        "  ctrl0 : axictrl_bus0 generic map (\n" +
                        "    async_reset => CFG_ASYNC_RESET\n" +
                        "  ) port map (\n" +
                        "    i_clk    => i_clk,\n" +
                        "    i_nrst   => w_glob_nrst,\n" +
                        "    i_slvcfg => slv_cfg,\n" +
                        "    i_slvo   => axiso,\n" +
                        "    i_msto   => aximo,\n" +
                        "    o_slvi   => axisi,\n" +
                        "    o_msti   => aximi,\n" +
                        "    o_bus_util_w => wb_bus_util_w, -- Bus write access utilization per master statistic\n" +
                        "    o_bus_util_r => wb_bus_util_r  -- Bus read access utilization per master statistic\n" +
                        "  );\n" +
                        "\n" +
                        "  --! @brief RISC-V Processor core (River or Rocket).\n" +
                        "  cpu0 : river_amba generic map (\n" +
                        "    memtech  => CFG_MEMTECH,\n" +
                        "    hartid => 0,\n" +
                        "    async_reset => CFG_ASYNC_RESET\n" +
                        "  ) port map ( \n" +
                        "    i_nrst   => w_bus_nrst,\n" +
                        "    i_clk    => i_clk,\n" +
                        "    i_msti   => aximi(CFG_BUS0_XMST_CPU0),\n" +
                        "    o_msto   => aximo(CFG_BUS0_XMST_CPU0),\n" +
                        "    o_mstcfg => mst_cfg(CFG_BUS0_XMST_CPU0),\n" +
                        "    i_dport => dport_i(0),\n" +
                        "    o_dport => dport_o(0),\n" +
                        "    i_ext_irq => w_ext_irq\n" +
                        "  );\n" +
                        "\n" +
                        "  ------------------------------------\n" +
                        "  --! @brief BOOT ROM module instance with the AXI4 interface.\n" +
                        "  --! @details Map address:\n" +
                        "  --!          0x00000000..0x00007fff (32 KB total)\n" +
                        "  boot0 : axi4_rom generic map (\n" +
                        "    memtech  => CFG_MEMTECH,\n" +
                        "    async_reset => CFG_ASYNC_RESET,\n" +
                        "    xaddr    => 16#00000#,\n" +
                        "    xmask    => 16#ffff8#,\n" +
                        "    sim_hexfile => \"\",\n" +
                        "    cyc_miffile => CFG_CYC_BOOTROM_MIF\n" +
                        "  ) port map (\n" +
                        "    clk  => i_clk,\n" +
                        "    nrst => w_glob_nrst,\n" +
                        "    cfg  => slv_cfg(CFG_BUS0_XSLV_BOOTROM),\n" +
                        "    i    => axisi(CFG_BUS0_XSLV_BOOTROM),\n" +
                        "    o    => axiso(CFG_BUS0_XSLV_BOOTROM)\n" +
                        "  );\n" +
                        "\n" +
                        "  ------------------------------------\n" +
                        "  --! @brief Firmware Image ROM with the AXI4 interface.\n" +
                        "  --! @details Map address:\n" +
                        "  --!          0x00100000..0x0010ffff (64 KB total)\n" +
                        "  --! @warning Don't forget to change ROM_ADDR_WIDTH in rom implementation\n" +
                        "  img0 : axi4_rom generic map (\n" +
                        "    memtech  => CFG_MEMTECH,\n" +
                        "    async_reset => CFG_ASYNC_RESET,\n" +
                        "    xaddr    => 16#00100#,\n" +
                        "    xmask    => 16#FFFF0#,\n" +
                        "    sim_hexfile => \"\",\n" +
                        "    cyc_miffile => CFG_CYC_FWIMAGE_MIF\n" +
                        "  ) port map (\n" +
                        "    clk  => i_clk,\n" +
                        "    nrst => w_glob_nrst,\n" +
                        "    cfg  => slv_cfg(CFG_BUS0_XSLV_ROMIMAGE),\n" +
                        "    i    => axisi(CFG_BUS0_XSLV_ROMIMAGE),\n" +
                        "    o    => axiso(CFG_BUS0_XSLV_ROMIMAGE)\n" +
                        "  );\n" +
                        "\n" +
                        "  ------------------------------------\n" +
                        "  --! Internal SRAM module instance with the AXI4 interface.\n" +
                        "  --! @details Map address:\n" +
                        "  --!          0x10000000..0x1003ffff (256 KB total)\n" +
                        "  ram0 : axi4_sram generic map (\n" +
                        "    memtech  => CFG_MEMTECH,\n" +
                        "    async_reset => CFG_ASYNC_RESET,\n" +
                        "    xaddr    => 16#10000#,\n" +
                        "    xmask    => 16#fffc0#,            -- 256 KB mask -- old (256) fff80\n" +
                        "    abits    => (10 + log2(256)),     -- 256 KB address\n" +
                        "    init_file => \"\"  -- Used only for inferred\n" +
                        "  ) port map (\n" +
                        "    clk  => i_clk,\n" +
                        "    nrst => w_glob_nrst,\n" +
                        "    cfg  => slv_cfg(CFG_BUS0_XSLV_SRAM),\n" +
                        "    i    => axisi(CFG_BUS0_XSLV_SRAM),\n" +
                        "    o    => axiso(CFG_BUS0_XSLV_SRAM)\n" +
                        "  );\n" +
                        "\n" +
                        "\n" +
                        "  ------------------------------------\n" +
                        "  --! @brief Controller of the LEDs, DIPs and GPIO with the AXI4 interface.\n" +
                        "  --! @details Map address:\n" +
                        "  --!          0x80000000..0x80000fff (4 KB total)\n" +
                        "  gpio0 : axi4_gpio generic map (\n" +
                        "    async_reset => CFG_ASYNC_RESET,\n" +
                        "    xaddr    => 16#80000#,\n" +
                        "    xmask    => 16#fffff#,\n" +
                        "    xirq     => 0\n" +
                        "  ) port map (\n" +
                        "    clk   	=> i_clk,\n" +
                        "    nrst  	=> w_glob_nrst,\n" +
                        "    cfg   	=> slv_cfg(CFG_BUS0_XSLV_GPIO),\n" +
                        "    i			=> axisi(CFG_BUS0_XSLV_GPIO),\n" +
                        "    o			=> axiso(CFG_BUS0_XSLV_GPIO),\n" +
                        "    KEY		=> KEY,\n" +
                        "	 SW		=> SW,\n" +
                        "	 LEDG		=> LEDG,\n" +
                        "	 LEDR		=> LEDR,\n" +
                        "	 GPIO_IN	=> GPIO_IN,\n" +
                        "	 GPIO_OUT=> GPIO_OUT\n" +
                        "  );\n" +
                        "  \n" +
                        "  \n" +
                        "  ------------------------------------\n" +
                        "  uart1i.cts   <= not i_uart1_ctsn;\n" +
                        "  uart1i.rd    <= i_uart1_rd;\n" +
                        "\n" +
                        "  --! @brief UART Controller with the AXI4 interface.\n" +
                        "  --! @details Map address:\n" +
                        "  --!          0x80001000..0x80001fff (4 KB total)\n" +
                        "  uart1 : axi4_uart generic map (\n" +
                        "    async_reset => CFG_ASYNC_RESET,\n" +
                        "    xaddr    => 16#80001#,\n" +
                        "    xmask    => 16#FFFFF#,\n" +
                        "    xirq     => CFG_IRQ_UART1,\n" +
                        "    fifosz   => 16\n" +
                        "  ) port map (\n" +
                        "    nrst   => w_glob_nrst, \n" +
                        "    clk    => i_clk, \n" +
                        "    cfg    => slv_cfg(CFG_BUS0_XSLV_UART1),\n" +
                        "    i_uart => uart1i, \n" +
                        "    o_uart => uart1o,\n" +
                        "    i_axi  => axisi(CFG_BUS0_XSLV_UART1),\n" +
                        "    o_axi  => axiso(CFG_BUS0_XSLV_UART1),\n" +
                        "    o_irq  => irq_pins(CFG_IRQ_UART1)\n" +
                        "  );\n" +
                        "  o_uart1_td  <= uart1o.td;\n" +
                        "  o_uart1_rtsn <= not uart1o.rts;\n" +
                        "\n" +
                        "\n" +
                        "  ------------------------------------\n" +
                        "  --! @brief Interrupt controller with the AXI4 interface.\n" +
                        "  --! @details Map address:\n" +
                        "  --!          0x80002000..0x80002fff (4 KB total)\n" +
                        "  irq0 : axi4_irqctrl generic map (\n" +
                        "    async_reset => CFG_ASYNC_RESET,\n" +
                        "    xaddr      => 16#80002#,\n" +
                        "    xmask      => 16#FFFFF#\n" +
                        "  ) port map (\n" +
                        "    clk    => i_clk,\n" +
                        "    nrst   => w_bus_nrst,\n" +
                        "    i_irqs => irq_pins,\n" +
                        "    o_cfg  => slv_cfg(CFG_BUS0_XSLV_IRQCTRL),\n" +
                        "    i_axi  => axisi(CFG_BUS0_XSLV_IRQCTRL),\n" +
                        "    o_axi  => axiso(CFG_BUS0_XSLV_IRQCTRL),\n" +
                        "    o_irq_meip => w_ext_irq\n" +
                        "  );\n" +
                        "\n" +
                        "  --! @brief Timers with the AXI4 interface.\n" +
                        "  --! @details Map address:\n" +
                        "  --!          0x80003000..0x80003fff (4 KB total)\n" +
                        "  gptmr0 : axi4_gptimers  generic map (\n" +
                        "    async_reset => CFG_ASYNC_RESET,\n" +
                        "    xaddr     => 16#80003#,\n" +
                        "    xmask     => 16#fffff#,\n" +
                        "    xirq      => CFG_IRQ_GPTIMERS,\n" +
                        "    tmr_total => 2\n" +
                        "  ) port map (\n" +
                        "    clk    => i_clk,\n" +
                        "    nrst   => w_glob_nrst,\n" +
                        "    cfg    => slv_cfg(CFG_BUS0_XSLV_GPTIMERS),\n" +
                        "    i_axi  => axisi(CFG_BUS0_XSLV_GPTIMERS),\n" +
                        "    o_axi  => axiso(CFG_BUS0_XSLV_GPTIMERS),\n" +
                        "    o_irq  => irq_pins(CFG_IRQ_GPTIMERS)\n" +
                        "  );\n" +
                        "\n" +
                        "  time_measurement : entity work.axi4_time_measurement generic map (\n" +
                        "    async_reset => CFG_ASYNC_RESET,\n" +
                        "    xaddr    => 16#80004#,\n" +
                        "    xmask    => 16#fffff#,\n" +
                        "    xirq     => 0\n" +
                        "  ) port map (\n" +
                        "    clk   	=> i_clk,\n" +
                        "    nrst  	=> w_glob_nrst,\n" +
                        "    cfg   	=> slv_cfg(CFG_BUS0_XSLV_TIME_MEASUREMENT),\n" +
                        "    i			=> axisi(CFG_BUS0_XSLV_TIME_MEASUREMENT),\n" +
                        "    o			=> axiso(CFG_BUS0_XSLV_TIME_MEASUREMENT),\n" +
                        "	 HEX0			=> HEX0,\n" +
                        "	 HEX1			=> HEX1,\n" +
                        "	 HEX2			=> HEX2,\n" +
                        "	 HEX3			=> HEX3\n" +
                        "  );\n" +
                        "\n";
                        for (int i = 0; ((i < Data.Number_Of_Timers_In_Program) && (Data.Compiling_Type == Data.HW_COMPILING)); i++) {
                            data += "  "+Data.Name_of_Timers[i]+" : entity work.axi4_ton generic map (\n" +
                                    "    async_reset => CFG_ASYNC_RESET,\n" +
                                    "    xaddr    => 16#800"+new GeneralFunctions().dec2hex_str(5 + i, 2)+"#,\n" +
                                    "    xmask    => 16#fffff#,\n" +
                                    "    xirq     => 0\n" +
                                    "  ) port map (\n" +
                                    "    clk   	=> i_clk,\n" +
                                    "    nrst  	=> w_glob_nrst,\n" +
                                    "    cfg   	=> slv_cfg(CFG_BUS0_XSLV_TON_"+Data.Name_of_Timers[i]+"),\n" +
                                    "    i			=> axisi(CFG_BUS0_XSLV_TON_"+Data.Name_of_Timers[i]+"),\n" +
                                    "    o			=> axiso(CFG_BUS0_XSLV_TON_"+Data.Name_of_Timers[i]+")\n" +
                                    "  );\n\n";
                        }
                        for (int i = 0; ((i < Data.Number_Of_PWMs_In_Program) && (Data.Compiling_Type == Data.HW_COMPILING)); i++) {
                            data += "  "+Data.Name_of_PWMs[i]+" : entity work.axi4_pwm generic map (\n" +
                                    "    async_reset => CFG_ASYNC_RESET,\n" +
                                    "    xaddr    => 16#800"+new GeneralFunctions().dec2hex_str(Data.Number_Of_Timers_In_Program + 5 + i, 2)+"#,\n" +
                                    "    xmask    => 16#fffff#,\n" +
                                    "    xirq     => 0\n" +
                                    "  ) port map (\n" +
                                    "    clk   	=> i_clk,\n" +
                                    "    clk_pwm 	=> i_clk_pwm,\n" +
                                    "    nrst  	=> w_glob_nrst,\n" +
                                    "    cfg   	=> slv_cfg(CFG_BUS0_XSLV_PWM_"+Data.Name_of_PWMs[i]+"),\n" +
                                    "    i			=> axisi(CFG_BUS0_XSLV_PWM_"+Data.Name_of_PWMs[i]+"),\n" +
                                    "    o			=> axiso(CFG_BUS0_XSLV_PWM_"+Data.Name_of_PWMs[i]+")\n" +
                                    "  );\n\n";
                        }
                data += "end arch_riscv_soc;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_config_cyclone_v_vhd_file(String Project_Folder_File) {
        String data =   "-----------------------------------------------------------------------------\n" +
                        "--! @file\n" +
                        "--! @copyright  Copyright 2019 Hossam Eassa. All right reserved.\n" +
                        "--! @author     Hossam Eassa - hossameassa@gmail.com\n" +
                        "--! @brief	FPGA Cyclone V specific constants definition.\n" +
                        "------------------------------------------------------------------------------\n" +
                        "library IEEE;\n" +
                        "use IEEE.STD_LOGIC_1164.ALL;\n" +
                        "--library techmap;\n" +
                        "use work.gencomp.all;\n" +
                        "\n" +
                        "package config_target is\n" +
                        "-- Technology and synthesis options\n" +
                        "  constant CFG_FABTECH : integer := cyclone_v;\n" +
                        "  constant CFG_MEMTECH : integer := cyclone_v;\n" +
                        "  --constant CFG_PADTECH : integer := cyclone_v;\n" +
                        "  --constant CFG_JTAGTECH : integer := cyclone_v;\n" +
                        "\n" +
                        "  constant CFG_ASYNC_RESET : boolean := true;\n" +
                        "\n" +
                        "  constant CFG_TOPDIR : string := \"./\";\n" +
                        "\n" +
                        "  --! @brief   Dual-core configuration enabling\n" +
                        "  --! @details This config parameter used only with CPU River\n" +
                        "  --constant CFG_COMMON_DUAL_CORE_ENABLE : boolean := false;\n" +
                        "\n" +
                        "  --! @brief   HEX-image for the initialization of the Boot ROM.\n" +
                        "  --! @details This file is used by \\e inferred ROM implementation.\n" +
                        "  --constant CFG_SIM_BOOTROM_HEX : string := \n" +
                        "  --            CFG_TOPDIR & \"bootimage.hex\";\n" +
                        "  constant CFG_CYC_BOOTROM_MIF : string := \n" +
                        "              CFG_TOPDIR & \"bootimage.mif\";\n" +
                        "\n" +
                        "  --! @brief   HEX-image for the initialization of the FwImage ROM.\n" +
                        "  --! @details This file is used by \\e inferred ROM implementation.\n" +
                        "  --constant CFG_SIM_FWIMAGE_HEX : string := \n" +
                        "  --              CFG_TOPDIR & \""+Data.Project_Name+".hex\";\n" +
                        "  constant CFG_CYC_FWIMAGE_MIF : string := \n" +
                        "                CFG_TOPDIR & \""+Data.Project_Name+".mif\";\n" +
                        "               \n" +
                        "\n" +
                        "  --! @brief Hardware SoC Identificator.\n" +
                        "  --!\n" +
                        "  --! @details Read Only unique platform identificator that could be\n" +
                        "  --!          read by firmware from the Plug'n'Play support module.\n" +
                        "  --constant CFG_HW_ID : std_logic_vector(31 downto 0) := X\"20190524\";\n" +
                        "\n" +
                        "  --! @brief Enabling Ethernet MAC interface.\n" +
                        "  --! @details By default MAC module enables support of the debug feature EDCL.\n" +
                        "  --constant CFG_ETHERNET_ENABLE : boolean := false;\n" +
                        "\n" +
                        "  --! @brief Enable/Disable Debug Unit \n" +
                        "  --constant CFG_DSU_ENABLE : boolean := false;\n" +
                        "  \n" +
                        "  constant CFG_FPU_ENABLE : boolean := "+new GeneralFunctions().bool2str(Data.is_fpu_RV64_enabeled)+";\n" +
                        "  constant CFG_MUL_ENABLE : boolean := "+new GeneralFunctions().bool2str(Data.is_mul_RV64_enabeled)+";\n" +
                        "  constant CFG_DIV_ENABLE : boolean := "+new GeneralFunctions().bool2str(Data.is_div_RV64_enabeled)+";\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_axictrl_bus0_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--library ambalib;\n" +
                        "use work.types_amba4.all;\n" +
                        "use work.types_bus0.all;\n" +
                        "\n" +
                        "entity axictrl_bus0 is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk    : in std_logic;\n" +
                        "    i_nrst   : in std_logic;\n" +
                        "    i_slvcfg : in  bus0_xslv_cfg_vector;\n" +
                        "    i_slvo   : in  bus0_xslv_out_vector;\n" +
                        "    i_msto   : in  bus0_xmst_out_vector;\n" +
                        "    o_slvi   : out bus0_xslv_in_vector;\n" +
                        "    o_msti   : out bus0_xmst_in_vector;\n" +
                        "    o_bus_util_w : out std_logic_vector(CFG_BUS0_XMST_TOTAL-1 downto 0);\n" +
                        "    o_bus_util_r : out std_logic_vector(CFG_BUS0_XMST_TOTAL-1 downto 0)\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_axictrl_bus0 of axictrl_bus0 is\n" +
                        "\n" +
                        "  constant MISS_ACCESS_SLAVE : axi4_slave_out_type := (\n" +
                        "      '1', '1', '1', AXI_RESP_DECERR,\n" +
                        "      (others=>'0'), '0', '1', '1', AXI_RESP_DECERR, (others=>'1'), \n" +
                        "      '1', (others=>'0'), '0');\n" +
                        "\n" +
                        "  type nasti_master_out_vector_miss is array (0 to CFG_BUS0_XMST_TOTAL) \n" +
                        "       of axi4_master_out_type;\n" +
                        "\n" +
                        "  type nasti_master_in_vector_miss is array (0 to CFG_BUS0_XMST_TOTAL) \n" +
                        "       of axi4_master_in_type;\n" +
                        "\n" +
                        "  type nasti_slave_out_vector_miss is array (0 to CFG_BUS0_XSLV_TOTAL) \n" +
                        "       of axi4_slave_out_type;\n" +
                        "\n" +
                        "  type nasti_slave_in_vector_miss is array (0 to CFG_BUS0_XSLV_TOTAL) \n" +
                        "       of axi4_slave_in_type;\n" +
                        "       \n" +
                        "  type reg_type is record\n" +
                        "     r_midx : integer range 0 to CFG_BUS0_XMST_TOTAL;\n" +
                        "     r_sidx : integer range 0 to CFG_BUS0_XSLV_TOTAL;\n" +
                        "     w_midx : integer range 0 to CFG_BUS0_XMST_TOTAL;\n" +
                        "     w_sidx : integer range 0 to CFG_BUS0_XSLV_TOTAL;\n" +
                        "     b_midx : integer range 0 to CFG_BUS0_XMST_TOTAL;\n" +
                        "     b_sidx : integer range 0 to CFG_BUS0_XSLV_TOTAL;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : reg_type := (\n" +
                        "      CFG_BUS0_XMST_TOTAL, CFG_BUS0_XSLV_TOTAL,\n" +
                        "      CFG_BUS0_XMST_TOTAL, CFG_BUS0_XSLV_TOTAL,\n" +
                        "      CFG_BUS0_XMST_TOTAL, CFG_BUS0_XSLV_TOTAL);\n" +
                        "\n" +
                        "  signal rin, r : reg_type;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  comblogic : process(i_nrst, i_slvcfg, i_msto, i_slvo, r)\n" +
                        "    variable v : reg_type;\n" +
                        "    variable ar_midx : integer range 0 to CFG_BUS0_XMST_TOTAL;\n" +
                        "    variable aw_midx : integer range 0 to CFG_BUS0_XMST_TOTAL;\n" +
                        "    variable ar_sidx : integer range 0 to CFG_BUS0_XSLV_TOTAL; -- +1 miss access\n" +
                        "    variable aw_sidx : integer range 0 to CFG_BUS0_XSLV_TOTAL; -- +1 miss access\n" +
                        "    variable vmsto : nasti_master_out_vector_miss;\n" +
                        "    variable vmsti : nasti_master_in_vector_miss;\n" +
                        "    variable vslvi : nasti_slave_in_vector_miss;\n" +
                        "    variable vslvo : nasti_slave_out_vector_miss;\n" +
                        "    variable aw_fire : std_logic;\n" +
                        "    variable ar_fire : std_logic;\n" +
                        "    variable w_fire : std_logic;\n" +
                        "    variable w_busy : std_logic;\n" +
                        "    variable r_fire : std_logic;\n" +
                        "    variable r_busy : std_logic;\n" +
                        "    variable b_fire : std_logic;\n" +
                        "    variable b_busy : std_logic;\n" +
                        "    -- Bus statistic signals\n" +
                        "    variable wb_bus_util_w : std_logic_vector(CFG_BUS0_XMST_TOTAL downto 0);\n" +
                        "    variable wb_bus_util_r : std_logic_vector(CFG_BUS0_XMST_TOTAL downto 0);\n" +
                        "\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    for m in 0 to CFG_BUS0_XMST_TOTAL-1 loop\n" +
                        "       vmsto(m) := i_msto(m);\n" +
                        "       vmsti(m) := axi4_master_in_none;\n" +
                        "    end loop;\n" +
                        "    vmsto(CFG_BUS0_XMST_TOTAL) := axi4_master_out_none;\n" +
                        "    vmsti(CFG_BUS0_XMST_TOTAL) := axi4_master_in_none;\n" +
                        "\n" +
                        "    for s in 0 to CFG_BUS0_XSLV_TOTAL-1 loop\n" +
                        "       vslvo(s) := i_slvo(s);\n" +
                        "       vslvi(s) := axi4_slave_in_none;\n" +
                        "    end loop;\n" +
                        "    vslvo(CFG_BUS0_XSLV_TOTAL) := MISS_ACCESS_SLAVE;\n" +
                        "    vslvi(CFG_BUS0_XSLV_TOTAL) := axi4_slave_in_none;\n" +
                        "\n" +
                        "    ar_midx := CFG_BUS0_XMST_TOTAL;\n" +
                        "    aw_midx := CFG_BUS0_XMST_TOTAL;\n" +
                        "    ar_sidx := CFG_BUS0_XSLV_TOTAL;\n" +
                        "    aw_sidx := CFG_BUS0_XSLV_TOTAL;\n" +
                        "\n" +
                        "    -- select master bus:\n" +
                        "    for m in 0 to CFG_BUS0_XMST_TOTAL-1 loop\n" +
                        "        if i_msto(m).ar_valid = '1' then\n" +
                        "            ar_midx := m;\n" +
                        "        end if;\n" +
                        "        if i_msto(m).aw_valid = '1' then\n" +
                        "            aw_midx := m;\n" +
                        "        end if;\n" +
                        "    end loop;\n" +
                        "\n" +
                        "    -- select slave interface\n" +
                        "    for s in 0 to CFG_BUS0_XSLV_TOTAL-1 loop\n" +
                        "        if i_slvcfg(s).xmask /= X\"00000\" and\n" +
                        "           (vmsto(ar_midx).ar_bits.addr(CFG_SYSBUS_ADDR_BITS-1 downto 12) \n" +
                        "            and i_slvcfg(s).xmask) = i_slvcfg(s).xaddr then\n" +
                        "            ar_sidx := s;\n" +
                        "        end if;\n" +
                        "        if i_slvcfg(s).xmask /= X\"00000\" and\n" +
                        "           (vmsto(aw_midx).aw_bits.addr(CFG_SYSBUS_ADDR_BITS-1 downto 12)\n" +
                        "            and i_slvcfg(s).xmask) = i_slvcfg(s).xaddr then\n" +
                        "            aw_sidx := s;\n" +
                        "        end if;\n" +
                        "    end loop;\n" +
                        "\n" +
                        "    -- Read Channel:\n" +
                        "    ar_fire := vmsto(ar_midx).ar_valid and vslvo(ar_sidx).ar_ready;\n" +
                        "    r_fire := vmsto(r.r_midx).r_ready and vslvo(r.r_sidx).r_valid and vslvo(r.r_sidx).r_last;\n" +
                        "    -- Write channel:\n" +
                        "    aw_fire := vmsto(aw_midx).aw_valid and vslvo(aw_sidx).aw_ready;\n" +
                        "    w_fire := vmsto(r.w_midx).w_valid and vmsto(r.w_midx).w_last and vslvo(r.w_sidx).w_ready;\n" +
                        "    -- Write confirm channel\n" +
                        "    b_fire := vmsto(r.b_midx).b_ready and vslvo(r.b_sidx).b_valid;\n" +
                        "\n" +
                        "    r_busy := '0';\n" +
                        "    if r.r_sidx /= CFG_BUS0_XSLV_TOTAL and r_fire = '0' then\n" +
                        "        r_busy := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_busy := '0';\n" +
                        "    if (r.w_sidx /= CFG_BUS0_XSLV_TOTAL and w_fire = '0') \n" +
                        "       or (r.b_sidx /= CFG_BUS0_XSLV_TOTAL and b_fire = '0') then\n" +
                        "        w_busy := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    b_busy := '0';\n" +
                        "    if (r.b_sidx /= CFG_BUS0_XSLV_TOTAL and b_fire = '0')  then\n" +
                        "        b_busy := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if ar_fire = '1' and r_busy = '0' then\n" +
                        "        v.r_sidx := ar_sidx;\n" +
                        "        v.r_midx := ar_midx;\n" +
                        "    elsif r_fire = '1' then\n" +
                        "        v.r_sidx := CFG_BUS0_XSLV_TOTAL;\n" +
                        "        v.r_midx := CFG_BUS0_XMST_TOTAL;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if aw_fire = '1' and w_busy = '0' then\n" +
                        "        v.w_sidx := aw_sidx;\n" +
                        "        v.w_midx := aw_midx;\n" +
                        "    elsif w_fire = '1' and b_busy = '0' then\n" +
                        "        v.w_sidx := CFG_BUS0_XSLV_TOTAL;\n" +
                        "        v.w_midx := CFG_BUS0_XMST_TOTAL;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if w_fire = '1' and b_busy = '0' then\n" +
                        "        v.b_sidx := r.w_sidx;\n" +
                        "        v.b_midx := r.w_midx;\n" +
                        "    elsif b_fire = '1' then\n" +
                        "        v.b_sidx := CFG_BUS0_XSLV_TOTAL;\n" +
                        "        v.b_midx := CFG_BUS0_XMST_TOTAL;\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    vmsti(ar_midx).ar_ready := vslvo(ar_sidx).ar_ready and not r_busy;\n" +
                        "    vslvi(ar_sidx).ar_valid := vmsto(ar_midx).ar_valid and not r_busy;\n" +
                        "    vslvi(ar_sidx).ar_bits  := vmsto(ar_midx).ar_bits;\n" +
                        "    vslvi(ar_sidx).ar_id    := vmsto(ar_midx).ar_id;\n" +
                        "    vslvi(ar_sidx).ar_user  := vmsto(ar_midx).ar_user;\n" +
                        "\n" +
                        "    vmsti(r.r_midx).r_valid := vslvo(r.r_sidx).r_valid;\n" +
                        "    vmsti(r.r_midx).r_resp  := vslvo(r.r_sidx).r_resp;\n" +
                        "    vmsti(r.r_midx).r_data  := vslvo(r.r_sidx).r_data;\n" +
                        "    vmsti(r.r_midx).r_last  := vslvo(r.r_sidx).r_last;\n" +
                        "    vmsti(r.r_midx).r_id    := vslvo(r.r_sidx).r_id;\n" +
                        "    vmsti(r.r_midx).r_user  := vslvo(r.r_sidx).r_user;\n" +
                        "    vslvi(r.r_sidx).r_ready := vmsto(r.r_midx).r_ready;\n" +
                        "\n" +
                        "    vmsti(aw_midx).aw_ready := vslvo(aw_sidx).aw_ready and not w_busy;\n" +
                        "    vslvi(aw_sidx).aw_valid := vmsto(aw_midx).aw_valid and not w_busy;\n" +
                        "    vslvi(aw_sidx).aw_bits  := vmsto(aw_midx).aw_bits;\n" +
                        "    vslvi(aw_sidx).aw_id    := vmsto(aw_midx).aw_id;\n" +
                        "    vslvi(aw_sidx).aw_user  := vmsto(aw_midx).aw_user;\n" +
                        "\n" +
                        "    vmsti(r.w_midx).w_ready := vslvo(r.w_sidx).w_ready and not b_busy;\n" +
                        "    vslvi(r.w_sidx).w_valid := vmsto(r.w_midx).w_valid and not b_busy;\n" +
                        "    vslvi(r.w_sidx).w_data := vmsto(r.w_midx).w_data;\n" +
                        "    vslvi(r.w_sidx).w_last := vmsto(r.w_midx).w_last;\n" +
                        "    vslvi(r.w_sidx).w_strb := vmsto(r.w_midx).w_strb;\n" +
                        "    vslvi(r.w_sidx).w_user := vmsto(r.w_midx).w_user;\n" +
                        "\n" +
                        "    vmsti(r.b_midx).b_valid := vslvo(r.b_sidx).b_valid;\n" +
                        "    vmsti(r.b_midx).b_resp := vslvo(r.b_sidx).b_resp;\n" +
                        "    vmsti(r.b_midx).b_id := vslvo(r.b_sidx).b_id;\n" +
                        "    vmsti(r.b_midx).b_user := vslvo(r.b_sidx).b_user;\n" +
                        "    vslvi(r.b_sidx).b_ready := vmsto(r.b_midx).b_ready;\n" +
                        "\n" +
                        "    -- Statistic\n" +
                        "    wb_bus_util_w := (others => '0');\n" +
                        "    wb_bus_util_w(r.w_midx) :=  '1';\n" +
                        "    wb_bus_util_r := (others => '0');\n" +
                        "    wb_bus_util_r(r.r_midx) := '1';\n" +
                        "\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        " \n" +
                        "    rin <= v;\n" +
                        "\n" +
                        "    for m in 0 to CFG_BUS0_XMST_TOTAL-1 loop\n" +
                        "       o_msti(m) <= vmsti(m);\n" +
                        "    end loop;\n" +
                        "    for s in 0 to CFG_BUS0_XSLV_TOTAL-1 loop\n" +
                        "       o_slvi(s) <= vslvi(s);\n" +
                        "    end loop;\n" +
                        "    o_bus_util_w <= wb_bus_util_w(CFG_BUS0_XMST_TOTAL-1 downto 0);\n" +
                        "    o_bus_util_r <= wb_bus_util_r(CFG_BUS0_XMST_TOTAL-1 downto 0);\n" +
                        "  end process;\n" +
                        "\n" +
                        "  regs : process(i_clk, i_nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "         r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "         r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_axislv_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--library ambalib;\n" +
                        "use work.types_amba4.all;\n" +
                        "\n" +
                        "entity axi4_slave is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_xcfg : in axi4_slave_config_type;\n" +
                        "    i_xslvi : in axi4_slave_in_type;\n" +
                        "    o_xslvo : out axi4_slave_out_type;\n" +
                        "    i_ready : in std_logic;\n" +
                        "    i_rdata : in std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "    o_re : out std_logic;\n" +
                        "    o_r32 : out std_logic;\n" +
                        "    o_radr : out global_addr_array_type;\n" +
                        "    o_wadr : out global_addr_array_type;\n" +
                        "    o_we : out std_logic;\n" +
                        "    o_wstrb : out std_logic_vector(CFG_SYSBUS_DATA_BYTES-1 downto 0);\n" +
                        "    o_wdata : out std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0)\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_axi4_slave of axi4_slave is\n" +
                        "\n" +
                        "  --! Slave device states during reading value operation.\n" +
                        "  type axi_slave_rstatetype is (rwait, rtrans);\n" +
                        "  --! Slave device states during writting data operation.\n" +
                        "  type axi_slave_wstatetype is (wwait, wtrans);\n" +
                        "\n" +
                        "  --! @brief Template bank of registers for any slave device.\n" +
                        "  type axi_slave_bank_type is record\n" +
                        "    rstate : axi_slave_rstatetype;\n" +
                        "    wstate : axi_slave_wstatetype;\n" +
                        "\n" +
                        "    rburst : std_logic_vector(1 downto 0);\n" +
                        "    rsize  : integer;\n" +
                        "    raddr  : global_addr_array_type;\n" +
                        "    rlen   : integer;                       --! AXI4 supports 256 burst operation\n" +
                        "    rid    : std_logic_vector(CFG_ROCKET_ID_BITS-1 downto 0);\n" +
                        "    rresp  : std_logic_vector(1 downto 0);  --! OK=0\n" +
                        "    ruser  : std_logic;\n" +
                        "    rswap : std_logic;\n" +
                        "    rwaitready : std_logic;                 --! Reading wait state flag: 0=waiting. User's waitstates\n" +
                        "    \n" +
                        "    wburst : std_logic_vector(1 downto 0);  -- 0=INCREMENT\n" +
                        "    wsize  : integer;                       -- code in range 0=1 Bytes upto 7=128 Bytes. \n" +
                        "    waddr  : global_addr_array_type;        --! 4 KB bank\n" +
                        "    wlen   : integer;                       --! AXI4 supports 256 burst operation\n" +
                        "    wid    : std_logic_vector(CFG_ROCKET_ID_BITS-1 downto 0);\n" +
                        "    wresp  : std_logic_vector(1 downto 0);  --! OK=0\n" +
                        "    wuser  : std_logic;\n" +
                        "    wswap : std_logic;\n" +
                        "    b_valid : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  --! Reset value of the template bank of registers of a slave device.\n" +
                        "  constant AXI_SLAVE_BANK_RESET : axi_slave_bank_type := (\n" +
                        "    rwait, wwait,\n" +
                        "    AXI_BURST_FIXED, 0, (others=>(others=>'0')), 0, (others=>'0'), AXI_RESP_OKAY, '0', '0', '1',\n" +
                        "    AXI_BURST_FIXED, 0, (others=>(others=>'0')), 0, (others=>'0'), AXI_RESP_OKAY, '0', '0', '0'\n" +
                        "  );\n" +
                        "\n" +
                        "  signal rin, r : axi_slave_bank_type;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  comblogic : process(i_nrst, i_xcfg, i_xslvi, i_ready, i_rdata, r)\n" +
                        "    variable v : axi_slave_bank_type;\n" +
                        "    variable traddr : std_logic_vector(CFG_SYSBUS_ADDR_BITS-1 downto 0);\n" +
                        "    variable twaddr : std_logic_vector(CFG_SYSBUS_ADDR_BITS-1 downto 0);\n" +
                        "    variable v_radr_inc : global_addr_array_type;\n" +
                        "    variable v_wadr_inc : global_addr_array_type;\n" +
                        "    variable v_re : std_logic;\n" +
                        "    variable v_r32 : std_logic;\n" +
                        "    variable v_radr : global_addr_array_type;\n" +
                        "    variable v_wadr : global_addr_array_type;\n" +
                        "    variable v_we : std_logic_vector(CFG_SYSBUS_DATA_BYTES-1 downto 0);\n" +
                        "    variable v_wstrb : std_logic_vector(CFG_SYSBUS_DATA_BYTES-1 downto 0);\n" +
                        "    variable v_wdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "    variable v_aw_ready : std_logic;\n" +
                        "    variable v_w_ready : std_logic;\n" +
                        "    variable v_ar_ready : std_logic;\n" +
                        "    variable v_r_valid : std_logic;\n" +
                        "    variable v_r_last : std_logic;\n" +
                        "    variable vb_r_data : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    traddr := (i_xslvi.ar_bits.addr(CFG_SYSBUS_ADDR_BITS-1 downto 12) and (not i_xcfg.xmask))\n" +
                        "             & i_xslvi.ar_bits.addr(11 downto 0);\n" +
                        "\n" +
                        "    twaddr := (i_xslvi.aw_bits.addr(CFG_SYSBUS_ADDR_BITS-1 downto 12) and (not i_xcfg.xmask))\n" +
                        "             & i_xslvi.aw_bits.addr(11 downto 0);\n" +
                        "\n" +
                        "    for n in 0 to CFG_WORDS_ON_BUS-1 loop\n" +
                        "        v_radr_inc(n) := traddr + n*CFG_ALIGN_BYTES;\n" +
                        "        v_wadr_inc(n) := twaddr + n*CFG_ALIGN_BYTES;\n" +
                        "    end loop;\n" +
                        "\n" +
                        "    v_re := '0';\n" +
                        "    v_r32 := '0';\n" +
                        "    v_radr(0) := (others => '0');\n" +
                        "    v_radr(1) := (others => '0');\n" +
                        "\n" +
                        "    if r.waddr(0)(2) = '0' then\n" +
                        "       v_wadr := r.waddr;\n" +
                        "    else\n" +
                        "       v_wadr(0) := r.waddr(1);\n" +
                        "       v_wadr(1) := r.waddr(0);\n" +
                        "    end if;\n" +
                        "    v_we := (others => '0');\n" +
                        "\n" +
                        "    -- Reading state machine:\n" +
                        "    case r.rstate is\n" +
                        "    when rwait =>\n" +
                        "        if i_xslvi.ar_valid = '1' and i_ready = '1'\n" +
                        "           and i_xslvi.aw_valid = '0' and r.wstate = wwait then\n" +
                        "            v.rstate := rtrans;\n" +
                        "            v_re := '1';\n" +
                        "\n" +
                        "            if i_xslvi.ar_bits.addr(2) = '0' then\n" +
                        "                v_radr := v_radr_inc;\n" +
                        "            else\n" +
                        "                v_radr(0) := v_radr_inc(1);\n" +
                        "                v_radr(1) := v_radr_inc(0);\n" +
                        "            end if;\n" +
                        "            for n in 0 to CFG_WORDS_ON_BUS-1 loop\n" +
                        "                v.raddr(n) := v_radr(n) + XSizeToBytes(conv_integer(i_xslvi.ar_bits.size));\n" +
                        "                if i_xslvi.ar_bits.burst = AXI_BURST_WRAP then\n" +
                        "                    -- i_bank.rsize = 8 and i_bank.rlen = 3\n" +
                        "                    -- 8 x 4 = 32 bytes \n" +
                        "                    v.raddr(n)(CFG_SYSBUS_ADDR_BITS-1 downto 5) \n" +
                        "                         := v_radr(n)(CFG_SYSBUS_ADDR_BITS-1 downto 5);\n" +
                        "                end if;\n" +
                        "            end loop;\n" +
                        "            if i_xslvi.ar_bits.size = \"010\" then\n" +
                        "                v_r32 := '1';\n" +
                        "            end if;\n" +
                        "            v.rswap := i_xslvi.ar_bits.addr(2);\n" +
                        "            v.rsize := XSizeToBytes(conv_integer(i_xslvi.ar_bits.size));\n" +
                        "            v.rburst := i_xslvi.ar_bits.burst;\n" +
                        "            v.rlen := conv_integer(i_xslvi.ar_bits.len);\n" +
                        "            v.rid := i_xslvi.ar_id;\n" +
                        "            v.rresp := AXI_RESP_OKAY;\n" +
                        "            v.ruser := i_xslvi.ar_user;\n" +
                        "        end if;\n" +
                        "    when rtrans =>\n" +
                        "        v_re := '1';\n" +
                        "        if v.rsize = 4 then\n" +
                        "            v_r32 := '1';\n" +
                        "        end if;\n" +
                        "        if r.raddr(0)(2) = '0' then\n" +
                        "            v_radr := r.raddr;\n" +
                        "        else\n" +
                        "            v_radr(0) := r.raddr(1);\n" +
                        "            v_radr(1) := r.raddr(0);\n" +
                        "        end if;\n" +
                        "        if i_xslvi.r_ready = '1' and i_ready = '1' then\n" +
                        "            if r.rsize = 4 then\n" +
                        "                v.rswap := not r.rswap;\n" +
                        "            end if;\n" +
                        "            for n in 0 to CFG_WORDS_ON_BUS-1 loop\n" +
                        "                v.raddr(n) := r.raddr(n) + r.rsize;\n" +
                        "            end loop;\n" +
                        "            if r.rburst = AXI_BURST_WRAP then\n" +
                        "                for n in 0 to CFG_WORDS_ON_BUS-1 loop\n" +
                        "                    -- i_bank.rsize = 8 and i_bank.rlen = 3\n" +
                        "                    -- 8 x 4 = 32 bytes \n" +
                        "                    v.raddr(n)(CFG_SYSBUS_ADDR_BITS-1 downto 5) \n" +
                        "                         := r.raddr(n)(CFG_SYSBUS_ADDR_BITS-1 downto 5);\n" +
                        "                end loop;\n" +
                        "            end if;\n" +
                        "            -- End of transaction (or process another one):\n" +
                        "            if r.rlen = 0 then\n" +
                        "                if i_xslvi.ar_valid = '1' and i_xslvi.aw_valid = '0' then\n" +
                        "                    v.rswap := i_xslvi.ar_bits.addr(2);\n" +
                        "                    if i_xslvi.ar_bits.size = \"010\" then\n" +
                        "                        v_r32 := '1';\n" +
                        "                    end if;\n" +
                        "                    if i_xslvi.ar_bits.addr(2) = '0' then\n" +
                        "                        v_radr := v_radr_inc;\n" +
                        "                    else\n" +
                        "                        v_radr(0) := v_radr_inc(1);\n" +
                        "                        v_radr(1) := v_radr_inc(0);\n" +
                        "                    end if;\n" +
                        "                    for n in 0 to CFG_WORDS_ON_BUS-1 loop\n" +
                        "                        v.raddr(n) := v_radr(n) + XSizeToBytes(conv_integer(i_xslvi.ar_bits.size));\n" +
                        "                        if i_xslvi.ar_bits.burst = AXI_BURST_WRAP then\n" +
                        "                            v.raddr(n)(CFG_SYSBUS_ADDR_BITS-1 downto 5) \n" +
                        "                                := v_radr(n)(CFG_SYSBUS_ADDR_BITS-1 downto 5);\n" +
                        "                        end if;\n" +
                        "                    end loop;\n" +
                        "                    v.rsize := XSizeToBytes(conv_integer(i_xslvi.ar_bits.size));\n" +
                        "                    v.rburst := i_xslvi.ar_bits.burst;\n" +
                        "                    v.rlen := conv_integer(i_xslvi.ar_bits.len);\n" +
                        "                    v.rid := i_xslvi.ar_id;\n" +
                        "                    v.rresp := AXI_RESP_OKAY;\n" +
                        "                    v.ruser := i_xslvi.ar_user;\n" +
                        "                else\n" +
                        "                    v.rstate := rwait;\n" +
                        "                    v_re := '0';\n" +
                        "                end if;\n" +
                        "            else\n" +
                        "                v.rlen := r.rlen - 1;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    end case;\n" +
                        "\n" +
                        "    -- Writing state machine:\n" +
                        "    case r.wstate is\n" +
                        "    when wwait =>\n" +
                        "        if i_xslvi.aw_valid = '1' and i_ready = '1' and r.rlen = 0 then\n" +
                        "            if i_xslvi.w_valid = '0' then\n" +
                        "                -- Full AXI bus protocol\n" +
                        "                v.wstate := wtrans;\n" +
                        "            else\n" +
                        "                -- AXI lite (no burst support)\n" +
                        "                v_we := (others => '1');\n" +
                        "                if i_xslvi.aw_bits.addr(2) = '0' then\n" +
                        "                    v_wadr := v_wadr_inc;\n" +
                        "                else\n" +
                        "                    v_wadr(0) := v_wadr_inc(1);\n" +
                        "                    v_wadr(1) := v_wadr_inc(0);\n" +
                        "                end if;\n" +
                        "            end if;\n" +
                        "\n" +
                        "            for n in 0 to CFG_WORDS_ON_BUS-1 loop\n" +
                        "               v.waddr(n) := v_wadr_inc(n);\n" +
                        "            end loop;\n" +
                        "            v.wswap := i_xslvi.aw_bits.addr(2);\n" +
                        "            v.wsize := XSizeToBytes(conv_integer(i_xslvi.aw_bits.size));\n" +
                        "            v.wburst := i_xslvi.aw_bits.burst;\n" +
                        "            v.wlen := conv_integer(i_xslvi.aw_bits.len);\n" +
                        "            v.wid := i_xslvi.aw_id;\n" +
                        "            v.wresp := AXI_RESP_OKAY;\n" +
                        "            v.wuser := i_xslvi.aw_user;\n" +
                        "        end if;\n" +
                        "    when wtrans =>\n" +
                        "        v_we := (others => '1');\n" +
                        "        if i_xslvi.w_valid = '1' and i_ready = '1' then\n" +
                        "            if r.wsize = 4 then\n" +
                        "                v.wswap := not r.wswap;\n" +
                        "            end if;\n" +
                        "            if r.wburst = AXI_BURST_INCR then\n" +
                        "              for n in 0 to CFG_WORDS_ON_BUS-1 loop\n" +
                        "                v.waddr(n) := r.waddr(n) + r.wsize;\n" +
                        "              end loop;\n" +
                        "            end if;\n" +
                        "            -- End of transaction:\n" +
                        "            if r.wlen = 0 then\n" +
                        "                v.b_valid := '1';\n" +
                        "                if i_xslvi.aw_valid = '0' then\n" +
                        "                    v.wstate := wwait;\n" +
                        "                else\n" +
                        "                    -- Only Full AXI Bus protocol support here\n" +
                        "                    for n in 0 to CFG_WORDS_ON_BUS-1 loop\n" +
                        "                        v.waddr(n) := v_wadr_inc(n);\n" +
                        "                    end loop;\n" +
                        "                    v.wswap := i_xslvi.aw_bits.addr(2);\n" +
                        "                    v.wsize := XSizeToBytes(conv_integer(i_xslvi.aw_bits.size));\n" +
                        "                    v.wburst := i_xslvi.aw_bits.burst;\n" +
                        "                    v.wlen := conv_integer(i_xslvi.aw_bits.len);\n" +
                        "                    v.wid := i_xslvi.aw_id;\n" +
                        "                    v.wresp := AXI_RESP_OKAY;\n" +
                        "                    v.wuser := i_xslvi.aw_user;\n" +
                        "                end if;\n" +
                        "            else\n" +
                        "                v.wlen := r.wlen - 1;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    end case;\n" +
                        "\n" +
                        "    if i_xslvi.b_ready = '1' and r.b_valid = '1' then\n" +
                        "        if r.wstate = wtrans and i_xslvi.w_valid = '1' and r.wlen = 0 then\n" +
                        "            v.b_valid := '1';\n" +
                        "        else\n" +
                        "            v.b_valid := '0';\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- AXI Lite must be 8-byte aligned in this implementation\n" +
                        "    if r.wswap = '0' then\n" +
                        "        v_wdata := i_xslvi.w_data;\n" +
                        "        v_wstrb := i_xslvi.w_strb and v_we;\n" +
                        "    else\n" +
                        "        v_wdata(31 downto 0) := i_xslvi.w_data(63 downto 32);\n" +
                        "        v_wdata(63 downto 32) := i_xslvi.w_data(31 downto 0);\n" +
                        "        v_wstrb := (i_xslvi.w_strb(3 downto 0) & i_xslvi.w_strb(7 downto 4))\n" +
                        "               and (v_we(3 downto 0) & v_we(7 downto 4));\n" +
                        "    end if;\n" +
                        "\n" +
                        "    o_re <= v_re;\n" +
                        "    o_radr <= v_radr;\n" +
                        "    o_r32 <= v_r32;\n" +
                        "    o_wadr <= v_wadr;\n" +
                        "    o_we <= v_we(0);\n" +
                        "    o_wdata <= v_wdata;\n" +
                        "    o_wstrb <= v_wstrb;\n" +
                        "\n" +
                        "    --! Device to AXI4 signals:\n" +
                        "\n" +
                        "    v_aw_ready := i_ready;\n" +
                        "    v_w_ready := '1';\n" +
                        "    v_ar_ready := i_ready;\n" +
                        "\n" +
                        "    if i_xslvi.aw_valid = '1' then\n" +
                        "        v_ar_ready := '0';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    v_r_last := '0';\n" +
                        "    if r.rstate = rtrans then\n" +
                        "        if r.rlen = 0 then\n" +
                        "            v_r_last := '1';\n" +
                        "        else\n" +
                        "            v_aw_ready := '0';\n" +
                        "            v_w_ready := '0';\n" +
                        "            v_ar_ready := '0';\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if i_ready = '1' and r.rstate = rtrans then\n" +
                        "        v_r_valid   := '1';\n" +
                        "    else\n" +
                        "        v_r_valid   := '0';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if r.rswap = '0' then\n" +
                        "        vb_r_data := i_rdata;\n" +
                        "    else\n" +
                        "        vb_r_data := i_rdata(31 downto 0) & i_rdata(63 downto 32);\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Write transfer:\n" +
                        "    if r.wstate = wtrans then\n" +
                        "        v_ar_ready := '0';\n" +
                        "        if r.wlen /= 0 then\n" +
                        "            v_aw_ready := '0';\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := AXI_SLAVE_BANK_RESET;\n" +
                        "    end if;\n" +
                        " \n" +
                        "    rin <= v;\n" +
                        "\n" +
                        "    o_xslvo.aw_ready <= v_aw_ready;\n" +
                        "    o_xslvo.w_ready <= v_w_ready;\n" +
                        "    o_xslvo.ar_ready <= v_ar_ready;\n" +
                        "    o_xslvo.r_valid <= v_r_valid;\n" +
                        "    o_xslvo.r_last <= v_r_last;\n" +
                        "    o_xslvo.r_data <= vb_r_data;\n" +
                        "    o_xslvo.r_id <= r.rid;\n" +
                        "    o_xslvo.r_resp <= r.rresp;\n" +
                        "    o_xslvo.r_user <= r.ruser;\n" +
                        "\n" +
                        "    -- Write Handshaking:\n" +
                        "    o_xslvo.b_id <= r.wid;\n" +
                        "    o_xslvo.b_resp <= r.wresp;\n" +
                        "    o_xslvo.b_user <= r.wuser;\n" +
                        "    o_xslvo.b_valid <= r.b_valid;\n" +
                        "\n" +
                        "  end process;\n" +
                        "\n" +
                        "  -- registers\n" +
                        "  regs : process(i_clk, i_nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "         r <= AXI_SLAVE_BANK_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "         r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_types_amba4_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "--! Standard library\n" +
                        "library ieee;\n" +
                        "--! Standard signal types import\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--! Standard numerical types import\n" +
                        "use ieee.numeric_std.all;\n" +
                        "--! Common constants and data conversion functions library\n" +
                        "--library commonlib;\n" +
                        "--! Import SoC specific types common for all devices\n" +
                        "use work.types_common.all;\n" +
                        "\n" +
                        "--! @brief   System bus AMBA AXI(NASTI) types definition.\n" +
                        "--! @details This package provides general constants, data structures and\n" +
                        "--!          and functions description that define behaviour of all\n" +
                        "--!          peripheries devices implementing AXI4 interface.\n" +
                        "package types_amba4 is\n" +
                        "\n" +
                        "--! @defgroup scala_cfg_group SCALA generated parameters\n" +
                        "--! @ingroup axi4_config_generic_group\n" +
                        "--! @details  This constant must correspond to Scala defined ones.\n" +
                        "--! @{\n" +
                        "\n" +
                        "--! User defined address ID bitwidth (aw_id / ar_id fields).\n" +
                        "constant CFG_ROCKET_ID_BITS      : integer := 5;\n" +
                        "--! Data bus bits width.\n" +
                        "constant CFG_SYSBUS_DATA_BITS    : integer := 64;\n" +
                        "--! Data bus bytes width\n" +
                        "constant CFG_SYSBUS_DATA_BYTES   : integer := CFG_SYSBUS_DATA_BITS / 8;\n" +
                        "\n" +
                        "--! Address bus bits width.\n" +
                        "constant CFG_SYSBUS_ADDR_BITS    : integer := 32;\n" +
                        "--! Definition of number of bits in address bus per one data transaction.\n" +
                        "constant CFG_SYSBUS_ADDR_OFFSET  : integer := log2(CFG_SYSBUS_DATA_BYTES);\n" +
                        "--! @brief Number of address bits used for device addressing. \n" +
                        "--! @details Default is 12 bits = 4 KB of address space minimum per each \n" +
                        "--!          mapped device.\n" +
                        "constant CFG_SYSBUS_CFG_ADDR_BITS : integer := CFG_SYSBUS_ADDR_BITS-12;\n" +
                        "--! @brief Global alignment is set 32 bits.\n" +
                        "constant CFG_ALIGN_BYTES         : integer := 4;\n" +
                        "--! @brief  Number of parallel access to the atomic data.\n" +
                        "constant CFG_WORDS_ON_BUS        : integer := CFG_SYSBUS_DATA_BYTES/CFG_ALIGN_BYTES;\n" +
                        "--! @}\n" +
                        "\n" +
                        "--! @name   AXI Response values\n" +
                        "--! @brief  AMBA 4.0 specified response types from a slave device.\n" +
                        "--! @{\n" +
                        "\n" +
                        "--! @brief Normal access success. \n" +
                        "--! @details Indicates that a normal access has been\n" +
                        "--! successful. Can also indicate an exclusive access has failed. \n" +
                        "constant AXI_RESP_OKAY     : std_logic_vector(1 downto 0) := \"00\";\n" +
                        "--! @brief Exclusive access okay. \n" +
                        "--! @details Indicates that either the read or write\n" +
                        "--! portion of an exclusive access has been successful.\n" +
                        "constant AXI_RESP_EXOKAY   : std_logic_vector(1 downto 0) := \"01\";\n" +
                        "--! @brief Slave error. \n" +
                        "--! @details Used when the access has reached the slave successfully,\n" +
                        "--! but the slave wishes to return an error condition to the originating\n" +
                        "--! master.\n" +
                        "constant AXI_RESP_SLVERR   : std_logic_vector(1 downto 0) := \"10\";\n" +
                        "--! @brief Decode error. \n" +
                        "--! @details Generated, typically by an interconnect component,\n" +
                        "--! to indicate that there is no slave at the transaction address.\n" +
                        "constant AXI_RESP_DECERR   : std_logic_vector(1 downto 0) := \"11\";\n" +
                        "--! @}\n" +
                        "\n" +
                        "--! @name   AXI burst request type.\n" +
                        "--! @brief  AMBA 4.0 specified burst operation request types.\n" +
                        "--! @{\n" +
                        "\n" +
                        "--! @brief Fixed address burst operation.\n" +
                        "--! @details The address is the same for every transfer in the burst \n" +
                        "--!          (FIFO type)\n" +
                        "constant AXI_BURST_FIXED   : std_logic_vector(1 downto 0) := \"00\";\n" +
                        "--! @brief Burst operation with address increment.\n" +
                        "--! @details The address for each transfer in the burst is an increment of\n" +
                        "--!        the address for the previous transfer. The increment value depends \n" +
                        "--!        on the size of the transfer.\n" +
                        "constant AXI_BURST_INCR    : std_logic_vector(1 downto 0) := \"01\";\n" +
                        "--! @brief Burst operation with address increment and wrapping.\n" +
                        "--! @details A wrapping burst is similar to an incrementing burst, except that\n" +
                        "--!          the address wraps around to a lower address if an upper address \n" +
                        "--!          limit is reached\n" +
                        "constant AXI_BURST_WRAP    : std_logic_vector(1 downto 0) := \"10\";\n" +
                        "--! @}\n" +
                        "\n" +
                        "--! @name Vendor IDs defintion.\n" +
                        "--! @{\n" +
                        "\n" +
                        "--! GNSS Sensor Ltd. vendor identificator.\n" +
                        "constant VENDOR_GNSSSENSOR        : std_logic_vector(15 downto 0) := X\"00F1\"; \n" +
                        "--! @}\n" +
                        "\n" +
                        "--! @name Master Device IDs definition:\n" +
                        "--! @{\n" +
                        "\n" +
                        "--! Empty master slot device\n" +
                        "constant MST_DID_EMPTY            : std_logic_vector(15 downto 0) := X\"7755\";\n" +
                        "--! RISC-V \"Rocket-chip\" core Cached TileLink master device.\n" +
                        "constant RISCV_CACHED_TILELINK    : std_logic_vector(15 downto 0) := X\"0500\";\n" +
                        "--! RISC-V \"Rocket-chip\" core Uncached TileLink master device.\n" +
                        "constant RISCV_UNCACHED_TILELINK  : std_logic_vector(15 downto 0) := X\"0501\";\n" +
                        "--! Ethernet MAC master device.\n" +
                        "constant GAISLER_ETH_MAC_MASTER   : std_logic_vector(15 downto 0) := X\"0502\";\n" +
                        "--! Ethernet MAC master debug interface (EDCL).\n" +
                        "constant GAISLER_ETH_EDCL_MASTER  : std_logic_vector(15 downto 0) := X\"0503\";\n" +
                        "--! \"River\" CPU Device ID.\n" +
                        "constant RISCV_RIVER_CPU          : std_logic_vector(15 downto 0) := X\"0505\";\n" +
                        "--! UART with DMA: Test Access Point (TAP)\n" +
                        "constant GNSSSENSOR_UART_TAP      : std_logic_vector(15 downto 0) := X\"050A\";\n" +
                        "--! JTAG Test Access Point (TAP)\n" +
                        "constant GNSSSENSOR_JTAG_TAP      : std_logic_vector(15 downto 0) := X\"050B\";\n" +
                        "--! @}\n" +
                        "\n" +
                        "--! @name Slave Device IDs definition:\n" +
                        "--! @{\n" +
                        "\n" +
                        "--! Empty slave slot device\n" +
                        "constant SLV_DID_EMPTY           : std_logic_vector(15 downto 0) := X\"5577\";\n" +
                        "--! GNSS Engine Stub device\n" +
                        "constant GNSSSENSOR_ENGINE_STUB   : std_logic_vector(15 downto 0) := X\"0068\";\n" +
                        "--! Fast Search Engines Device ID provided by gnsslib\n" +
                        "constant GNSSSENSOR_FSE_V2_GPS    : std_logic_vector(15 downto 0) := X\"0069\";\n" +
                        "--! Boot ROM Device ID\n" +
                        "constant GNSSSENSOR_ROM           : std_logic_vector(15 downto 0) := X\"0071\";\n" +
                        "--! Internal SRAM block Device ID\n" +
                        "constant GNSSSENSOR_SRAM          : std_logic_vector(15 downto 0) := X\"0073\";\n" +
                        "--! Configuration Registers Module Device ID provided by gnsslib\n" +
                        "constant GNSSSENSOR_PNP           : std_logic_vector(15 downto 0) := X\"0074\";\n" +
                        "--! SD-card controller Device ID provided by gnsslib\n" +
                        "constant GNSSSENSOR_SPI_FLASH     : std_logic_vector(15 downto 0) := X\"0075\";\n" +
                        "--! General purpose IOs Device ID provided by gnsslib\n" +
                        "constant GNSSSENSOR_GPIO          : std_logic_vector(15 downto 0) := X\"0076\";\n" +
                        "--! RF front-end controller Device ID provided by gnsslib\n" +
                        "constant GNSSSENSOR_RF_CONTROL    : std_logic_vector(15 downto 0) := X\"0077\";\n" +
                        "--! GNSS Engine Device ID provided by gnsslib\n" +
                        "constant GNSSSENSOR_ENGINE        : std_logic_vector(15 downto 0) := X\"0078\";\n" +
                        "--! rs-232 UART Device ID\n" +
                        "constant GNSSSENSOR_UART          : std_logic_vector(15 downto 0) := X\"007a\";\n" +
                        "--! Accelerometer Device ID provided by gnsslib\n" +
                        "constant GNSSSENSOR_ACCELEROMETER : std_logic_vector(15 downto 0) := X\"007b\";\n" +
                        "--! Gyroscope Device ID provided by gnsslib\n" +
                        "constant GNSSSENSOR_GYROSCOPE     : std_logic_vector(15 downto 0) := X\"007c\";\n" +
                        "--! Interrupt controller\n" +
                        "constant GNSSSENSOR_IRQCTRL       : std_logic_vector(15 downto 0) := X\"007d\";\n" +
                        "--! Ethernet MAC inherited from Gaisler greth module.\n" +
                        "constant GNSSSENSOR_ETHMAC        : std_logic_vector(15 downto 0) := X\"007f\";\n" +
                        "--! Debug Support Unit device id.\n" +
                        "constant GNSSSENSOR_DSU           : std_logic_vector(15 downto 0) := X\"0080\";\n" +
                        "--! GP Timers device id.\n" +
                        "constant GNSSSENSOR_GPTIMERS      : std_logic_vector(15 downto 0) := X\"0081\";\n" +
                        "--! ADC samples recorder\n" +
                        "constant GNSSSENSOR_ADC_RECORDER  : std_logic_vector(15 downto 0) := X\"0082\";\n" +
                        "--! @}\n" +
                        "\n" +
                        "--! @name Decoder of the transaction size.\n" +
                        "--! @{\n" +
                        "\n" +
                        "--! Burst length size decoder\n" +
                        "constant XSIZE_TOTAL : integer := 8;\n" +
                        "--! Definition of the AXI bytes converter.\n" +
                        "type xsize_type is array (0 to XSIZE_TOTAL-1) of integer;\n" +
                        "--! Decoder of the transaction bytes from AXI format to Bytes.\n" +
                        "constant XSizeToBytes : xsize_type := (\n" +
                        "   0 => 1,\n" +
                        "   1 => 2,\n" +
                        "   2 => 4,\n" +
                        "   3 => 8,\n" +
                        "   4 => 16,\n" +
                        "   5 => 32,\n" +
                        "   6 => 64,\n" +
                        "   7 => 128\n" +
                        ");\n" +
                        "--! @}\n" +
                        "\n" +
                        "--! @name Plug'n'Play descriptor constants.\n" +
                        "--! @{\n" +
                        "--! Undefined type of the descriptor (empty device).\n" +
                        "constant PNP_CFG_TYPE_INVALID   : std_logic_vector := \"00\";\n" +
                        "--! AXI slave device standard descriptor.\n" +
                        "constant PNP_CFG_TYPE_MASTER  : std_logic_vector := \"01\";\n" +
                        "--! AXI master device standard descriptor.\n" +
                        "constant PNP_CFG_TYPE_SLAVE : std_logic_vector := \"10\";\n" +
                        "--! @brief Size in bytes of the standard slave descriptor..\n" +
                        "--! @details Firmware uses this value instead of sizeof(nasti_slave_config_type).\n" +
                        "constant PNP_CFG_SLAVE_DESCR_BYTES : std_logic_vector(7 downto 0) := X\"10\";\n" +
                        "--! @brief Size in bytes of the standard master descriptor.\n" +
                        "--! @details Firmware uses this value instead of sizeof(nasti_master_config_type).\n" +
                        "constant PNP_CFG_MASTER_DESCR_BYTES : std_logic_vector(7 downto 0) := X\"08\";\n" +
                        "--! @}\n" +
                        "\n" +
                        "\n" +
                        "--! @brief   Plug-n-play descriptor structure for slave device.\n" +
                        "--! @details Each slave device must generates this datatype output that\n" +
                        "--!          is connected directly to the 'pnp' slave module on system bus.\n" +
                        "type axi4_slave_config_type is record\n" +
                        "    --! Descriptor size in bytes.\n" +
                        "    descrsize : std_logic_vector(7 downto 0);\n" +
                        "    --! Descriptor type.\n" +
                        "    descrtype : std_logic_vector(1 downto 0);\n" +
                        "    --! Descriptor size in bytes.\n" +
                        "    irq_idx : std_logic_vector(7 downto 0);\n" +
                        "    --! Base address value.\n" +
                        "    xaddr  : std_logic_vector(CFG_SYSBUS_CFG_ADDR_BITS-1 downto 0);\n" +
                        "    --! Maskable bits of the base address.\n" +
                        "    xmask  : std_logic_vector(CFG_SYSBUS_CFG_ADDR_BITS-1 downto 0);\n" +
                        "    --! Vendor ID.\n" +
                        "    vid    : std_logic_vector(15 downto 0);\n" +
                        "    --! Device ID.\n" +
                        "    did    : std_logic_vector(15 downto 0);\n" +
                        "end record;\n" +
                        "\n" +
                        "--! @brief Default slave config value.\n" +
                        "--! @default This value corresponds to an empty device and often used\n" +
                        "--!          as assignment of outputs for the disabled device.\n" +
                        "constant axi4_slave_config_none : axi4_slave_config_type := (\n" +
                        "    PNP_CFG_SLAVE_DESCR_BYTES, PNP_CFG_TYPE_SLAVE, (others => '0'), \n" +
                        "    (others => '0'), (others => '0'), VENDOR_GNSSSENSOR, SLV_DID_EMPTY);\n" +
                        "\n" +
                        "\n" +
                        "--! @brief   Plug-n-play descriptor structure for master device.\n" +
                        "--! @details Each master device must generates this datatype output that\n" +
                        "--!          is connected directly to the 'pnp' slave module on system bus.\n" +
                        "type axi4_master_config_type is record\n" +
                        "    --! Descriptor size in bytes.\n" +
                        "    descrsize : std_logic_vector(7 downto 0);\n" +
                        "    --! Descriptor type.\n" +
                        "    descrtype : std_logic_vector(1 downto 0);\n" +
                        "    --! Vendor ID.\n" +
                        "    vid    : std_logic_vector(15 downto 0);\n" +
                        "    --! Device ID.\n" +
                        "    did    : std_logic_vector(15 downto 0);\n" +
                        "end record;\n" +
                        "\n" +
                        "--! @brief Default master config value.\n" +
                        "constant axi4_master_config_none : axi4_master_config_type := (\n" +
                        "    PNP_CFG_MASTER_DESCR_BYTES, PNP_CFG_TYPE_MASTER, \n" +
                        "    VENDOR_GNSSSENSOR, MST_DID_EMPTY);\n" +
                        "\n" +
                        "\n" +
                        "--! @brief AMBA AXI4 compliant data structure.\n" +
                        "type axi4_metadata_type is record\n" +
                        "  --! @brief Read address.\n" +
                        "  --! @details The read address gives the address of the first transfer\n" +
                        "  --!          in a read burst transaction.\n" +
                        "  addr   : std_logic_vector(CFG_SYSBUS_ADDR_BITS-1 downto 0);\n" +
                        "  --! @brief   Burst length.\n" +
                        "  --! @details This signal indicates the exact number of transfers in \n" +
                        "  --!          a burst. This changes between AXI3 and AXI4. nastiXLenBits=8 so\n" +
                        "  --!          this is an AXI4 implementation.\n" +
                        "  --!              Burst_Length = len[7:0] + 1\n" +
                        "  len    : std_logic_vector(7 downto 0);\n" +
                        "  --! @brief   Burst size.\n" +
                        "  --! @details This signal indicates the size of each transfer \n" +
                        "  --!          in the burst: 0=1 byte; ..., 6=64 bytes; 7=128 bytes;\n" +
                        "  size   : std_logic_vector(2 downto 0);\n" +
                        "  --! @brief   Read response.\n" +
                        "  --! @details This signal indicates the status of the read transfer. \n" +
                        "  --! The responses are:\n" +
                        "  --!      0b00 FIXED - In a fixed burst, the address is the same for every transfer \n" +
                        "  --!                  in the burst. Typically is used for FIFO.\n" +
                        "  --!      0b01 INCR - Incrementing. In an incrementing burst, the address for each\n" +
                        "  --!                  transfer in the burst is an increment of the address for the \n" +
                        "  --!                  previous transfer. The increment value depends on the size of \n" +
                        "  --!                  the transfer.\n" +
                        "  --!      0b10 WRAP - A wrapping burst is similar to an incrementing burst, except \n" +
                        "  --!                  that the address wraps around to a lower address if an upper address \n" +
                        "  --!                  limit is reached.\n" +
                        "  --!      0b11 resrved.\n" +
                        "  burst  : std_logic_vector(1 downto 0);\n" +
                        "  --! @brief   Lock type.\n" +
                        "  --! @details Not supported in AXI4.\n" +
                        "  lock   : std_logic;\n" +
                        "  --! @brief   Memory type.\n" +
                        "  --! @details See table for write and read transactions.\n" +
                        "  cache  : std_logic_vector(3 downto 0);\n" +
                        "  --! @brief   Protection type.\n" +
                        "  --! @details This signal indicates the privilege and security level \n" +
                        "  --!          of the transaction, and whether the transaction is a data access\n" +
                        "  --!          or an instruction access:\n" +
                        "  --!  [0] :   0 = Unpriviledge access\n" +
                        "  --!          1 = Priviledge access\n" +
                        "  --!  [1] :   0 = Secure access\n" +
                        "  --!          1 = Non-secure access\n" +
                        "  --!  [2] :   0 = Data access\n" +
                        "  --!          1 = Instruction access\n" +
                        "  prot   : std_logic_vector(2 downto 0);\n" +
                        "  --! @brief   Quality of Service, QoS. \n" +
                        "  --! @details QoS identifier sent for each read transaction. \n" +
                        "  --!          Implemented only in AXI4:\n" +
                        "  --!              0b0000 - default value. Indicates that the interface is \n" +
                        "  --!                       not participating in any QoS scheme.\n" +
                        "  qos    : std_logic_vector(3 downto 0);\n" +
                        "  --! @brief Region identifier.\n" +
                        "  --! @details Permits a single physical interface on a slave to be used for \n" +
                        "  --!          multiple logical interfaces. Implemented only in AXI4. This is \n" +
                        "  --!          similar to the banks implementation in Leon3 without address \n" +
                        "  --!          decoding.\n" +
                        "  region : std_logic_vector(3 downto 0);\n" +
                        "end record;\n" +
                        "\n" +
                        "--! @brief Empty metadata value.\n" +
                        "constant META_NONE : axi4_metadata_type := (\n" +
                        "  (others =>'0'), X\"00\", \"000\", AXI_BURST_INCR, '0', X\"0\", \"000\", \"0000\", \"0000\"\n" +
                        ");\n" +
                        "\n" +
                        "--! @brief Master device output signals\n" +
                        "type axi4_master_out_type is record\n" +
                        "  --! Write Address channel:\n" +
                        "  aw_valid : std_logic;\n" +
                        "  --! metadata of the read channel.\n" +
                        "  aw_bits : axi4_metadata_type;\n" +
                        "  --! Write address ID. Identification tag used for a trasaction ordering.\n" +
                        "  aw_id   : std_logic_vector(CFG_ROCKET_ID_BITS-1 downto 0);\n" +
                        "  --! Optional user defined signal in a write address channel.\n" +
                        "  aw_user : std_logic;\n" +
                        "  --! Write Data channel valid flag\n" +
                        "  w_valid : std_logic;\n" +
                        "  --! Write channel data value\n" +
                        "  w_data : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "  --! Write Data channel last address in a burst marker.\n" +
                        "  w_last : std_logic;\n" +
                        "  --! Write Data channel strob signals selecting certain bytes.\n" +
                        "  w_strb : std_logic_vector(CFG_SYSBUS_DATA_BYTES-1 downto 0);\n" +
                        "  --! Optional user defined signal in write channel.\n" +
                        "  w_user : std_logic;\n" +
                        "  --! Write Response channel accepted by master.\n" +
                        "  b_ready : std_logic;\n" +
                        "  --! Read Address Channel data valid.\n" +
                        "  ar_valid : std_logic;\n" +
                        "  --! Read Address channel metadata.\n" +
                        "  ar_bits : axi4_metadata_type;\n" +
                        "  --! Read address ID. Identification tag used for a trasaction ordering.\n" +
                        "  ar_id   : std_logic_vector(CFG_ROCKET_ID_BITS-1 downto 0);\n" +
                        "  --! Optional user defined signal in read address channel.\n" +
                        "  ar_user : std_logic;\n" +
                        "  --! Read Data channel:\n" +
                        "  r_ready : std_logic;\n" +
                        "end record;\n" +
                        "\n" +
                        "--! @brief   Master device empty value.\n" +
                        "--! @warning If the master is not connected to the vector then vector value\n" +
                        "--!          MUST BE initialized by this value.\n" +
                        "constant axi4_master_out_none : axi4_master_out_type := (\n" +
                        "      '0', META_NONE, (others=>'0'), '0',\n" +
                        "      '0', (others=>'0'), '0', (others=>'0'), '0', \n" +
                        "      '0', '0', META_NONE, (others=>'0'), '0', '0');\n" +
                        "\n" +
                        "\n" +
                        "--! @brief Master device input signals.\n" +
                        "type axi4_master_in_type is record\n" +
                        "  --! Write Address channel.\n" +
                        "  aw_ready : std_logic;\n" +
                        "  --! Write Data channel.\n" +
                        "  w_ready : std_logic;\n" +
                        "  --! Write Response channel:\n" +
                        "  b_valid : std_logic;\n" +
                        "  b_resp : std_logic_vector(1 downto 0);\n" +
                        "  b_id   : std_logic_vector(CFG_ROCKET_ID_BITS-1 downto 0);\n" +
                        "  b_user : std_logic;\n" +
                        "  --! Read Address Channel\n" +
                        "  ar_ready : std_logic;\n" +
                        "  --! Read valid.\n" +
                        "  r_valid : std_logic;\n" +
                        "  --! @brief Read response. \n" +
                        "  --! @details This signal indicates the status of the read transfer. \n" +
                        "  --!  The responses are:\n" +
                        "  --!      0b00 OKAY - Normal access success. Indicates that a normal access has\n" +
                        "  --!                  been successful. Can also indicate an exclusive access\n" +
                        "  --!                  has failed.\n" +
                        "  --!      0b01 EXOKAY - Exclusive access okay. Indicates that either the read or\n" +
                        "  --!                  write portion of an exclusive access has been successful.\n" +
                        "  --!      0b10 SLVERR - Slave error. Used when the access has reached the slave \n" +
                        "  --!                  successfully, but the slave wishes to return an error\n" +
                        "  --!                  condition to the originating master.\n" +
                        "  --!      0b11 DECERR - Decode error. Generated, typically by an interconnect \n" +
                        "  --!                  component, to indicate that there is no slave at the\n" +
                        "  --!                  transaction address.\n" +
                        "  r_resp : std_logic_vector(1 downto 0);\n" +
                        "  --! Read data\n" +
                        "  r_data : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "  --! @brief  Read last. \n" +
                        "  --! @details This signal indicates the last transfer in a read burst.\n" +
                        "  r_last : std_logic;\n" +
                        "  --! @brief Read ID tag.\n" +
                        "  --! @details This signal is the identification tag for the read data\n" +
                        "  --!          group of signals generated by the slave.\n" +
                        "  r_id   : std_logic_vector(CFG_ROCKET_ID_BITS-1 downto 0);\n" +
                        "  --! @brief User signal. \n" +
                        "  --! @details Optional User-defined signal in the read channel. Supported \n" +
                        "  --!          only in AXI4.\n" +
                        "  r_user : std_logic;\n" +
                        "end record;\n" +
                        "\n" +
                        "constant axi4_master_in_none : axi4_master_in_type := (\n" +
                        "      '0', '0', '0', AXI_RESP_OKAY, (others=>'0'), '0',\n" +
                        "      '0', '0', AXI_RESP_OKAY, (others=>'0'), '0', (others=>'0'), '0');\n" +
                        "\n" +
                        "\n" +
                        "--! @brief Slave device AMBA AXI input signals.\n" +
                        "type axi4_slave_in_type is record\n" +
                        "  --! Write Address channel:\n" +
                        "  aw_valid : std_logic;\n" +
                        "  aw_bits : axi4_metadata_type;\n" +
                        "  aw_id   : std_logic_vector(CFG_ROCKET_ID_BITS-1 downto 0);\n" +
                        "  aw_user : std_logic;\n" +
                        "  --! Write Data channel:\n" +
                        "  w_valid : std_logic;\n" +
                        "  w_data : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "  w_last : std_logic;\n" +
                        "  w_strb : std_logic_vector(CFG_SYSBUS_DATA_BYTES-1 downto 0);\n" +
                        "  w_user : std_logic;\n" +
                        "  --! Write Response channel:\n" +
                        "  b_ready : std_logic;\n" +
                        "  --! Read Address Channel:\n" +
                        "  ar_valid : std_logic;\n" +
                        "  ar_bits : axi4_metadata_type;\n" +
                        "  ar_id   : std_logic_vector(CFG_ROCKET_ID_BITS-1 downto 0);\n" +
                        "  ar_user : std_logic;\n" +
                        "  --! Read Data channel:\n" +
                        "  r_ready : std_logic;\n" +
                        "end record;\n" +
                        "\n" +
                        "constant axi4_slave_in_none : axi4_slave_in_type := (\n" +
                        "      '0', META_NONE, (others=>'0'), '0', '0',\n" +
                        "      (others=>'0'), '0', (others=>'0'), '0', '0', '0', META_NONE,\n" +
                        "      (others=>'0'), '0', '0');\n" +
                        "\n" +
                        "\n" +
                        "--! @brief Slave device AMBA AXI output signals.\n" +
                        "type axi4_slave_out_type is record\n" +
                        "  --! Write Address channel:\n" +
                        "  aw_ready : std_logic;\n" +
                        "  --! Write Data channel:\n" +
                        "  w_ready : std_logic;\n" +
                        "  --! Write Response channel:\n" +
                        "  b_valid : std_logic;\n" +
                        "  b_resp : std_logic_vector(1 downto 0);\n" +
                        "  b_id   : std_logic_vector(CFG_ROCKET_ID_BITS-1 downto 0);\n" +
                        "  b_user : std_logic;\n" +
                        "  --! Read Address Channel\n" +
                        "  ar_ready : std_logic;\n" +
                        "  --! Read Data channel:\n" +
                        "  r_valid : std_logic;\n" +
                        "  --! @brief Read response.\n" +
                        "  --! @details This signal indicates the status of the read transfer. \n" +
                        "  --!  The responses are:\n" +
                        "  --!      0b00 OKAY - Normal access success. Indicates that a normal access has\n" +
                        "  --!                  been successful. Can also indicate an exclusive access\n" +
                        "  --!                  has failed.\n" +
                        "  --!      0b01 EXOKAY - Exclusive access okay. Indicates that either the read or\n" +
                        "  --!                  write portion of an exclusive access has been successful.\n" +
                        "  --!      0b10 SLVERR - Slave error. Used when the access has reached the slave \n" +
                        "  --!                  successfully, but the slave wishes to return an error\n" +
                        "  --!                  condition to the originating master.\n" +
                        "  --!      0b11 DECERR - Decode error. Generated, typically by an interconnect \n" +
                        "  --!                  component, to indicate that there is no slave at the\n" +
                        "  --!                  transaction address.\n" +
                        "  r_resp : std_logic_vector(1 downto 0);\n" +
                        "  --! Read data\n" +
                        "  r_data : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "  --! Read last. This signal indicates the last transfer in a read burst.\n" +
                        "  r_last : std_logic;\n" +
                        "  --! @brief Read ID tag. \n" +
                        "  --! @details This signal is the identification tag for the read data\n" +
                        "  --!           group of signals generated by the slave.\n" +
                        "  r_id   : std_logic_vector(CFG_ROCKET_ID_BITS-1 downto 0);\n" +
                        "  --! @brief User signal. \n" +
                        "  --! @details Optinal User-defined signal in the read channel. Supported \n" +
                        "  --!          only in AXI4.\n" +
                        "  r_user : std_logic;--_vector(0 downto 0);\n" +
                        "end record;\n" +
                        "\n" +
                        "--! @brief Slave output signals connected to system bus.\n" +
                        "--! @details If the slave is not connected to the vector then vector value\n" +
                        "--! MUST BE initialized by this value.\n" +
                        "constant axi4_slave_out_none : axi4_slave_out_type := (\n" +
                        "      '0', '0', '0', AXI_RESP_EXOKAY,\n" +
                        "      (others=>'0'), '0', '0', '0', AXI_RESP_EXOKAY, (others=>'1'), \n" +
                        "      '0', (others=>'0'), '0');\n" +
                        "\n" +
                        "\n" +
                        "--! Array of addresses providing word aligned access.\n" +
                        "type global_addr_array_type is array (0 to CFG_WORDS_ON_BUS-1) \n" +
                        "       of std_logic_vector(CFG_SYSBUS_ADDR_BITS-1 downto 0);\n" +
                        "\n" +
                        "  type dma_state_type is (\n" +
                        "     DMA_STATE_IDLE,\n" +
                        "     DMA_STATE_R_WAIT_RESP,\n" +
                        "     DMA_STATE_R_WAIT_NEXT,\n" +
                        "     DMA_STATE_W,\n" +
                        "     DMA_STATE_W_WAIT_REQ,\n" +
                        "     DMA_STATE_B\n" +
                        "  );\n" +
                        "\n" +
                        "--! @brief Master device to DMA engine request signals\n" +
                        "  type dma_request_type is record\n" +
                        "    valid : std_logic; -- response is valid\n" +
                        "    ready : std_logic; -- ready to accept response\n" +
                        "    write : std_logic;\n" +
                        "    addr : std_logic_vector(CFG_SYSBUS_ADDR_BITS-1 downto 0);\n" +
                        "    bytes : std_logic_vector(10 downto 0);\n" +
                        "    size  : std_logic_vector(2 downto 0); -- 010=4 bytes; 011=8 bytes\n" +
                        "    wdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "  end record;\n" +
                        "\n" +
                        "--! @brief DMA engine to Master device response signals\n" +
                        "  type dma_response_type is record\n" +
                        "    ready : std_logic;  -- ready to accespt request\n" +
                        "    valid : std_logic;  -- response is valid\n" +
                        "    rdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "  end record;\n" +
                        "\n" +
                        "--! DMA engine registers bank\n" +
                        "  type dma_bank_type is record\n" +
                        "    state : dma_state_type;\n" +
                        "    addr2 : std_logic;	          -- addr[2] bits to select low/high dword\n" +
                        "    len   : integer range 0 to 255; -- burst (length-1)\n" +
                        "    op32  : std_logic;\n" +
                        "    wdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant DMA_BANK_RESET : dma_bank_type := (DMA_STATE_IDLE, '0', 0, '0', (others => '0'));\n" +
                        "\n" +
                        "--! Device's DMA engine template procedure with AXI interface.\n" +
                        "--! @param [in]  i_request Device to DMA engine request.\n" +
                        "--! @param [out] o_response DMA Engine to Device response.\n" +
                        "--! @param [in]  i_bank Bank of registers implemented by master device.\n" +
                        "--! @param [out] o_bank Updated value for the master bank of registers.\n" +
                        "--! @param [in]  i_msti AMBA to AXI master device signal.\n" +
                        "--! @param [out] o_msto AXI master device signal to AMBA controller signals.\n" +
                        "procedure procedureAxi4DMA(\n" +
                        "      i_request : in dma_request_type;\n" +
                        "      o_response : out dma_response_type;\n" +
                        "      i_bank : in dma_bank_type;\n" +
                        "      o_bank : out dma_bank_type;\n" +
                        "      i_msti : in axi4_master_in_type;\n" +
                        "      o_msto : out axi4_master_out_type\n" +
                        ");\n" +
                        "\n" +
                        "--! AXI4 slave interface.\n" +
                        "--! @param [in]  i_xcfg  AXI Slave confguration descriptor defining memory base address.\n" +
                        "--! @param [in]  i_xslvi AXI4 slave input interface.\n" +
                        "--! @param [out] o_xslvo AXI4 slave output interface.\n" +
                        "--! @param [in]  i_ready Memory device is ready to accept request.\n" +
                        "--! @param [in]  i_rdata Read data value\n" +
                        "--! @param [out] o_re Read enable\n" +
                        "--! @param [out] o_rswap Read high word32 from 64-bits bus\n" +
                        "--! @param [out] o_radr Memory interface read address array.\n" +
                        "--! @param [out] o_wadr Memory interface write address array.\n" +
                        "--! @param [in]  o_we Write enable\n" +
                        "--! @param [out] o_wstrb Memory interface per byte write enable strobs.\n" +
                        "--! @param [out] o_wdata Memory interface write data value.\n" +
                        "component axi4_slave is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_xcfg : in axi4_slave_config_type;\n" +
                        "    i_xslvi : in axi4_slave_in_type;\n" +
                        "    o_xslvo : out axi4_slave_out_type;\n" +
                        "    i_ready : in std_logic;\n" +
                        "    i_rdata : in std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "    o_re : out std_logic;\n" +
                        "    o_r32 : out std_logic;\n" +
                        "    o_radr : out global_addr_array_type;\n" +
                        "    o_wadr : out global_addr_array_type;\n" +
                        "    o_we : out std_logic;\n" +
                        "    o_wstrb : out std_logic_vector(CFG_SYSBUS_DATA_BYTES-1 downto 0);\n" +
                        "    o_wdata : out std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0)\n" +
                        "  );\n" +
                        "end component; \n" +
                        "\n" +
                        "\n" +
                        "end; -- package declaration\n" +
                        "\n" +
                        "--! Implementation of the declared sub-programs (functions and\n" +
                        "--! procedures).\n" +
                        "package body types_amba4 is\n" +
                        "\n" +
                        "  --! Device's DMA engine template procedure with AXI interface.\n" +
                        "  --! @param [in]  i_request Device to DMA engine request.\n" +
                        "  --! @param [out] o_response DMA Engine to Device response.\n" +
                        "  --! @param [in]  i_bank Bank of registers implemented by master device.\n" +
                        "  --! @param [out] o_bank Updated value for the master bank of registers.\n" +
                        "  --! @param [in]  i_msti AMBA to AXI master device signal.\n" +
                        "  --! @param [out] o_msto AXI master device signal to AMBA controller signals.\n" +
                        "  procedure procedureAxi4DMA(\n" +
                        "      i_request : in dma_request_type;\n" +
                        "      o_response : out dma_response_type;\n" +
                        "      i_bank : in dma_bank_type;\n" +
                        "      o_bank : out dma_bank_type;\n" +
                        "      i_msti : in axi4_master_in_type;\n" +
                        "      o_msto : out axi4_master_out_type\n" +
                        "  ) is\n" +
                        "    variable tmp_len : integer;\n" +
                        "  begin\n" +
                        "    o_bank := i_bank;\n" +
                        "    o_msto := axi4_master_out_none;\n" +
                        "    o_msto.ar_user       := '0';\n" +
                        "    o_msto.ar_id         := conv_std_logic_vector(0, CFG_ROCKET_ID_BITS);\n" +
                        "    o_msto.ar_bits.size  := (others => '0');\n" +
                        "    o_msto.ar_bits.burst := AXI_BURST_INCR;\n" +
                        "    o_msto.aw_user       := '0';\n" +
                        "    o_msto.aw_id         := conv_std_logic_vector(0, CFG_ROCKET_ID_BITS);\n" +
                        "    o_msto.aw_bits.size  := (others => '0');\n" +
                        "    o_msto.aw_bits.burst := AXI_BURST_INCR;\n" +
                        "\n" +
                        "    o_response.ready := '0';\n" +
                        "    o_response.valid := '0';\n" +
                        "    o_response.rdata := (others => '0');\n" +
                        "\n" +
                        "    case i_bank.state is\n" +
                        "    when DMA_STATE_IDLE =>\n" +
                        "        o_msto.ar_valid := i_request.valid and not i_request.write;\n" +
                        "        o_msto.aw_valid := i_request.valid and i_request.write;\n" +
                        "        tmp_len := conv_integer(i_request.bytes(10 downto 2)) - 1;\n" +
                        "        if i_request.valid = '1' and i_request.write = '1' then\n" +
                        "            o_msto.aw_bits.addr  := i_request.addr(CFG_SYSBUS_ADDR_BITS-1 downto 3) & \"000\";\n" +
                        "            o_bank.addr2         := i_request.addr(2);\n" +
                        "            o_bank.len  := tmp_len;\n" +
                        "            o_msto.aw_bits.size  := i_request.size; -- 4/8 bytes\n" +
                        "            o_msto.aw_bits.len := conv_std_logic_vector(tmp_len, 8);\n" +
                        "            o_bank.wdata := i_request.wdata;\n" +
                        "            if i_msti.aw_ready = '1' then\n" +
                        "                o_response.ready := '1';\n" +
                        "                o_bank.state := DMA_STATE_W;\n" +
                        "            end if;\n" +
                        "        elsif i_request.valid = '1' and i_request.write = '0' then\n" +
                        "            o_msto.ar_bits.addr  := i_request.addr;\n" +
                        "            o_bank.addr2         := i_request.addr(2);\n" +
                        "            o_bank.len  := tmp_len;\n" +
                        "            o_msto.ar_bits.size  := i_request.size; -- 4/8 bytes\n" +
                        "            o_msto.ar_bits.len := conv_std_logic_vector(tmp_len, 8);\n" +
                        "            if i_msti.ar_ready = '1' then\n" +
                        "                o_response.ready := '1';\n" +
                        "                o_bank.state := DMA_STATE_R_WAIT_RESP;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "        if i_request.size = \"010\" then\n" +
                        "           o_bank.op32 := '1';\n" +
                        "        else\n" +
                        "           o_bank.op32 := '0';\n" +
                        "        end if;\n" +
                        "      \n" +
                        "    when DMA_STATE_R_WAIT_RESP =>\n" +
                        "        o_msto.r_ready := i_request.ready;\n" +
                        "        o_response.valid := i_msti.r_valid;\n" +
                        "        if (i_request.ready and i_msti.r_valid) = '1' then\n" +
                        "            if i_bank.op32 = '1' and i_bank.addr2 = '1' then\n" +
                        "                o_response.rdata := i_msti.r_data(63 downto 32) & i_msti.r_data(31 downto 0);\n" +
                        "            else\n" +
                        "                o_response.rdata := i_msti.r_data;\n" +
                        "            end if;\n" +
                        "\n" +
                        "            if i_msti.r_last = '1' then\n" +
                        "                o_bank.state := DMA_STATE_IDLE;\n" +
                        "            else\n" +
                        "                if i_request.valid = '1' and i_request.write = '0' then\n" +
                        "                    o_response.ready := '1';\n" +
                        "                else\n" +
                        "                    o_bank.state := DMA_STATE_R_WAIT_NEXT;\n" +
                        "                end if;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "\n" +
                        "    when DMA_STATE_R_WAIT_NEXT =>\n" +
                        "        if i_request.valid = '1' and i_request.write = '0' then\n" +
                        "            o_response.ready := '1';\n" +
                        "            o_bank.state := DMA_STATE_R_WAIT_RESP;\n" +
                        "        end if;\n" +
                        "\n" +
                        "    when DMA_STATE_W =>\n" +
                        "        o_msto.w_valid := '1';\n" +
                        "        if i_bank.op32 = '1' then\n" +
                        "            case i_bank.addr2 is\n" +
                        "            when '0' => o_msto.w_strb := X\"0f\";\n" +
                        "            when '1' => o_msto.w_strb := X\"f0\";\n" +
                        "            when others =>\n" +
                        "            end case;\n" +
                        "        else\n" +
                        "            o_msto.w_strb := X\"ff\";\n" +
                        "        end if;\n" +
                        "        o_msto.w_data := i_bank.wdata;\n" +
                        "        \n" +
                        "        if i_msti.w_ready = '1' then\n" +
                        "            if i_bank.len = 0 then\n" +
                        "                o_bank.state := DMA_STATE_B;\n" +
                        "                o_msto.w_last := '1';\n" +
                        "            elsif i_request.valid = '1' and i_request.write = '1' then\n" +
                        "                o_bank.len := i_bank.len - 1;\n" +
                        "                o_bank.wdata := i_request.wdata;\n" +
                        "                o_response.ready := '1';\n" +
                        "                -- Address will be incremented on slave side\n" +
                        "                --v.waddr2 := not r.waddr2;\n" +
                        "            else\n" +
                        "                o_bank.state := DMA_STATE_W_WAIT_REQ;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "\n" +
                        "    when DMA_STATE_W_WAIT_REQ =>\n" +
                        "        if i_request.valid = '1' and i_request.write = '1' then\n" +
                        "            o_bank.len := i_bank.len - 1;\n" +
                        "            o_bank.wdata := i_request.wdata;\n" +
                        "            o_response.ready := '1';\n" +
                        "            o_bank.state := DMA_STATE_W;\n" +
                        "        end if;\n" +
                        "\n" +
                        "    when DMA_STATE_B =>\n" +
                        "        o_msto.w_last := '0';\n" +
                        "        o_msto.b_ready := '1';\n" +
                        "        if i_msti.b_valid = '1' then\n" +
                        "            o_bank.state := DMA_STATE_IDLE;\n" +
                        "        end if;\n" +
                        "    when others =>\n" +
                        "    end case;\n" +
                        "  end; -- procedure\n" +
                        "\n" +
                        "end; -- package body";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_types_bus0_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "--! Standard library\n" +
                        "library ieee;\n" +
                        "--! Standard signal types import\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--! Common constants and data conversion functions library\n" +
                        "--library commonlib;\n" +
                        "--! Import SoC specific types common for all devices\n" +
                        "use work.types_common.all;\n" +
                        "--library ambalib;\n" +
                        "use work.types_amba4.all;\n" +
                        "\n" +
                        "package types_bus0 is\n" +
                        "\n" +
                        "--! @defgroup slave_id_group AMBA AXI slaves generic IDs.\n" +
                        "--! @ingroup axi4_config_generic_group\n" +
                        "--! @details Each module in a SoC has to be indexed by unique identificator.\n" +
                        "--!          In current implementation it is used sequential indexing for it.\n" +
                        "--!          Indexes are used to specify a device bus item in a vectors.\n" +
                        "--! @{\n" +
                        "\n" +
                        "--! @brief Configuration index of the Boot ROM module visible by the firmware.\n" +
                        "constant CFG_BUS0_XSLV_BOOTROM  : integer := 0; \n" +
                        "--! Configuration index of the Firmware ROM Image module.\n" +
                        "constant CFG_BUS0_XSLV_ROMIMAGE : integer := 1;\n" +
                        "--! Configuration index of the SRAM module visible by the firmware.\n" +
                        "constant CFG_BUS0_XSLV_SRAM     : integer := 2;\n" +
                        "--! Configuration index of the UART module.\n" +
                        "constant CFG_BUS0_XSLV_UART1    : integer := 3;\n" +
                        "--! Configuration index of the GPIO (General Purpose In/Out) module.\n" +
                        "constant CFG_BUS0_XSLV_GPIO     : integer := 4;\n" +
                        "--! Configuration index of the Interrupt Controller module.\n" +
                        "constant CFG_BUS0_XSLV_IRQCTRL  : integer := 5;\n" +
                        "--! Configuration index of the GPtimer module.\n" +
                        "constant CFG_BUS0_XSLV_GPTIMERS : integer := 6;\n" +
                        "constant CFG_BUS0_XSLV_TIME_MEASUREMENT : integer := 7;\n";
                        for (int i = 0; ((i < Data.Number_Of_Timers_In_Program) && (Data.Compiling_Type == Data.HW_COMPILING)); i++) {
                            data += "constant CFG_BUS0_XSLV_TON_"+Data.Name_of_Timers[i]+" : integer := "+(8+i)+";\n";
                        }
                        for (int i = 0; ((i < Data.Number_Of_PWMs_In_Program) && (Data.Compiling_Type == Data.HW_COMPILING)); i++) {
                            data += "constant CFG_BUS0_XSLV_PWM_"+Data.Name_of_PWMs[i]+" : integer := "+(Data.Number_Of_Timers_In_Program+8+i)+";\n";
                        }
                        int NumberOfSlaves;
                        if (Data.Compiling_Type == Data.HW_COMPILING) {
                            NumberOfSlaves = (8+Data.Number_Of_Timers_In_Program+Data.Number_Of_PWMs_In_Program);
                        } else {
                            NumberOfSlaves = 8;
                        }
                data += "--! Total number of the slaves devices.\n" +
                        "constant CFG_BUS0_XSLV_TOTAL   : integer := "+NumberOfSlaves+";  \n" +
                        "--! @}\n" +
                        "\n" +
                        "--! @defgroup master_id_group AXI4 masters generic IDs.\n" +
                        "--! @ingroup axi4_config_generic_group\n" +
                        "--! @details Each master must be assigned to a specific ID that used\n" +
                        "--!          as an index in the vector array of AXI master bus.\n" +
                        "--! @{\n" +
                        "\n" +
                        "--! Cached TileLinkIO bus.\n" +
                        "constant CFG_BUS0_XMST_CPU0     : integer := 0;\n" +
                        "--! Uncached TileLinkIO bus.\n" +
                        "--constant CFG_BUS0_XMST_CPU1     : integer := 1;\n" +
                        "--! Ethernet MAC master interface generic index.\n" +
                        "--constant CFG_BUS0_XMST_ETHMAC   : integer := 2;\n" +
                        "--! Tap via UART (debug port) generic index.\n" +
                        "--constant CFG_BUS0_XMST_MSTUART  : integer := 3;\n" +
                        "--! Tap via JTAG generic index.\n" +
                        "--constant CFG_BUS0_XMST_JTAG     : integer := 4;\n" +
                        "--! Total Number of master devices on system bus.\n" +
                        "constant CFG_BUS0_XMST_TOTAL    : integer := 1;\n" +
                        "--! @}\n" +
                        "\n" +
                        "\n" +
                        "type bus0_xslv_cfg_vector is array (0 to CFG_BUS0_XSLV_TOTAL-1) \n" +
                        "       of axi4_slave_config_type;\n" +
                        "\n" +
                        "type bus0_xmst_cfg_vector is array (0 to CFG_BUS0_XMST_TOTAL-1) \n" +
                        "       of axi4_master_config_type;\n" +
                        "\n" +
                        "type bus0_xmst_out_vector is array (0 to CFG_BUS0_XMST_TOTAL-1) \n" +
                        "       of axi4_master_out_type;\n" +
                        "\n" +
                        "type bus0_xmst_in_vector is array (0 to CFG_BUS0_XMST_TOTAL-1) \n" +
                        "       of axi4_master_in_type;\n" +
                        "\n" +
                        "type bus0_xslv_in_vector is array (0 to CFG_BUS0_XSLV_TOTAL-1) \n" +
                        "       of axi4_slave_in_type;\n" +
                        "\n" +
                        "type bus0_xslv_out_vector is array (0 to CFG_BUS0_XSLV_TOTAL-1) \n" +
                        "       of axi4_slave_out_type;\n" +
                        "\n" +
                        "--! @brief   AXI bus controller. \n" +
                        "--! @param [in] watchdog_memop \n" +
                        "--! @param [in] i_clk System bus clock.\n" +
                        "--! @param [in] i_nrst Reset with active LOW level.\n" +
                        "--! @param [in] i_slvcfg Slaves configuration vector.\n" +
                        "--! @param [in] i_slvo Vector of slaves output signals.\n" +
                        "--! @param [in] i_msto Vector of masters output signals.\n" +
                        "--! @param [out] o_slvi Vector of slave inputs.\n" +
                        "--! @param [out] o_msti Vector of master inputs.\n" +
                        "--! @param [out] o_bus_util_w Write access bus utilization\n" +
                        "--! @param [out] o_bus_util_r Read access bus utilization\n" +
                        "--! @todo    Round-robin priority algorithm.\n" +
                        "component axictrl_bus0 is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk    : in std_logic;\n" +
                        "    i_nrst   : in std_logic;\n" +
                        "    i_slvcfg : in  bus0_xslv_cfg_vector;\n" +
                        "    i_slvo   : in  bus0_xslv_out_vector;\n" +
                        "    i_msto   : in  bus0_xmst_out_vector;\n" +
                        "    o_slvi   : out bus0_xslv_in_vector;\n" +
                        "    o_msti   : out bus0_xmst_in_vector;\n" +
                        "    o_bus_util_w : out std_logic_vector(CFG_BUS0_XMST_TOTAL-1 downto 0);\n" +
                        "    o_bus_util_r : out std_logic_vector(CFG_BUS0_XMST_TOTAL-1 downto 0)\n" +
                        "  );\n" +
                        "end component;\n" +
                        "\n" +
                        "end; -- package body";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_types_common_vhd_file(String Project_Folder_File) {
        String data =   "-----------------------------------------------------------------------------\n" +
                        "--! @file\n" +
                        "--! @copyright Copyright 2015 GNSS Sensor Ltd. All right reserved.\n" +
                        "--! @author    Sergey Khabarov - sergeykhbr@gmail.com\n" +
                        "--! @brief     Declaration and implementation of the types_common package.\n" +
                        "------------------------------------------------------------------------------\n" +
                        "\n" +
                        "--! Standard library\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.numeric_std.all;\n" +
                        "use std.textio.all;\n" +
                        "\n" +
                        "--! @brief   Definition of the generic VHDL methods and constants.\n" +
                        "--! @details This package defines common mathematical methods and\n" +
                        "--!          utility methods for the VHDL types conversions.\n" +
                        "package types_common is\n" +
                        "\n" +
                        "--! @brief Array declaration of the pre-computed log2 values.\n" +
                        "type log2arr is array(0 to 512) of integer;\n" +
                        "\n" +
                        "--! @brief Array definition of the pre-computed log2 values.\n" +
                        "--! @details These values are used as an argument in bus width\n" +
                        "--!          declaration. \n" +
                        "--!\n" +
                        "--! Example usage:\n" +
                        "--! @code \n" +
                        "--!   component foo_component is\n" +
                        "--!   generic (\n" +
                        "--!     max_clients  : integer := 8\n" +
                        "--!   );\n" +
                        "--!   port (\n" +
                        "--!     foo : inout  std_logic_vector(log2(max_clients)-1 downto 0)\n" +
                        "--!   );\n" +
                        "--!   end component;\n" +
                        "--! @endcode \n" +
                        "constant log2   : log2arr := (\n" +
                        "0,0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n" +
                        "  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n" +
                        "  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n" +
                        "  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n" +
                        "  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n" +
                        "  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n" +
                        "  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n" +
                        "  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n" +
                        "  others => 9);\n" +
                        "\n" +
                        "constant log2x  : log2arr := (\n" +
                        "0,1,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n" +
                        "  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n" +
                        "  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n" +
                        "  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n" +
                        "  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n" +
                        "  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n" +
                        "  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n" +
                        "  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n" +
                        "  others => 9);\n" +
                        "  \n" +
                        "constant zero32 : std_logic_vector(31 downto 0) := X\"00000000\";\n" +
                        "constant zero64 : std_logic_vector(63 downto 0) := zero32 & zero32;\n" +
                        "\n" +
                        "\n" +
                        "function \"-\" (i : integer; d : std_logic_vector) return std_logic_vector;\n" +
                        "function \"-\" (d : std_logic_vector; i : integer) return std_logic_vector;\n" +
                        "function \"-\" (a, b : std_logic_vector) return std_logic_vector;\n" +
                        "function \"+\" (d : std_logic_vector; i : integer) return std_logic_vector;\n" +
                        "function \"+\" (a, b : std_logic_vector) return std_logic_vector;\n" +
                        "function \"+\" (d : std_logic_vector; i : std_ulogic) return std_logic_vector;\n" +
                        "function \"*\" (a, b : std_logic_vector) return std_logic_vector;\n" +
                        "\n" +
                        "function conv_integer(v : std_logic_vector) return integer;\n" +
                        "function conv_integer(v : std_logic) return integer;\n" +
                        "function conv_std_logic_vector(i : integer; w : integer) return std_logic_vector;\n" +
                        "function conv_std_logic_vector_signed(i : integer; w : integer) return std_logic_vector;\n" +
                        "function conv_std_logic(b : boolean) return std_ulogic;\n" +
                        "\n" +
                        "end;\n" +
                        "\n" +
                        "\n" +
                        "package body types_common is\n" +
                        "\n" +
                        "\n" +
                        "function conv_integer(v : std_logic_vector) return integer is\n" +
                        "begin\n" +
                        "  if not is_x(v) then return(to_integer(unsigned(v)));\n" +
                        "  else return(0); end if;\n" +
                        "end;\n" +
                        "\n" +
                        "function conv_integer(v : std_logic) return integer is\n" +
                        "begin\n" +
                        "  if not is_x(v) then\n" +
                        "    if v = '1' then return(1);\n" +
                        "    else return(0); end if;\n" +
                        "  else return(0); end if;\n" +
                        "end;\n" +
                        "\n" +
                        "function conv_std_logic_vector(i : integer; w : integer) return std_logic_vector is\n" +
                        "variable tmp : std_logic_vector(w-1 downto 0);\n" +
                        "begin\n" +
                        "  tmp := std_logic_vector(to_unsigned(i, w));\n" +
                        "  return(tmp);\n" +
                        "end;\n" +
                        "\n" +
                        "function conv_std_logic_vector_signed(i : integer; w : integer) return std_logic_vector is\n" +
                        "variable tmp : std_logic_vector(w-1 downto 0);\n" +
                        "begin\n" +
                        "  tmp := std_logic_vector(to_signed(i, w));\n" +
                        "  return(tmp);\n" +
                        "end;\n" +
                        "\n" +
                        "function conv_std_logic(b : boolean) return std_ulogic is\n" +
                        "begin\n" +
                        "  if b then return('1'); else return('0'); end if;\n" +
                        "end;\n" +
                        "\n" +
                        "function \"+\" (d : std_logic_vector; i : integer) return std_logic_vector is\n" +
                        "variable x : std_logic_vector(d'length-1 downto 0);\n" +
                        "begin\n" +
                        "-- pragma translate_off\n" +
                        "  if not is_x(d) then\n" +
                        "-- pragma translate_on\n" +
                        "    return(std_logic_vector(unsigned(d) + i));\n" +
                        "-- pragma translate_off\n" +
                        "  else x := (others =>'X'); return(x);\n" +
                        "  end if;\n" +
                        "-- pragma translate_on\n" +
                        "end;\n" +
                        "\n" +
                        "function \"+\" (a, b : std_logic_vector) return std_logic_vector is\n" +
                        "variable x : std_logic_vector(a'length-1 downto 0);\n" +
                        "variable y : std_logic_vector(b'length-1 downto 0);\n" +
                        "begin\n" +
                        "-- pragma translate_off\n" +
                        "  if not is_x(a&b) then\n" +
                        "-- pragma translate_on\n" +
                        "    return(std_logic_vector(unsigned(a) + unsigned(b)));\n" +
                        "-- pragma translate_off\n" +
                        "  else\n" +
                        "     x := (others =>'X'); y := (others =>'X');\n" +
                        "     if (x'length > y'length) then return(x); else return(y); end if;\n" +
                        "  end if;\n" +
                        "-- pragma translate_on\n" +
                        "end;\n" +
                        "\n" +
                        "function \"+\" (d : std_logic_vector; i : std_ulogic) return std_logic_vector is\n" +
                        "variable x : std_logic_vector(d'length-1 downto 0);\n" +
                        "variable y : std_logic_vector(0 downto 0);\n" +
                        "begin\n" +
                        "  y(0) := i;\n" +
                        "-- pragma translate_off\n" +
                        "  if not is_x(d) then\n" +
                        "-- pragma translate_on\n" +
                        "    return(std_logic_vector(unsigned(d) + unsigned(y)));\n" +
                        "-- pragma translate_off\n" +
                        "  else x := (others =>'X'); return(x); \n" +
                        "  end if;\n" +
                        "-- pragma translate_on\n" +
                        "end;\n" +
                        "\n" +
                        "\n" +
                        "function \"-\" (i : integer; d : std_logic_vector) return std_logic_vector is\n" +
                        "variable x : std_logic_vector(d'length-1 downto 0);\n" +
                        "begin\n" +
                        "-- pragma translate_off\n" +
                        "  if not is_x(d) then\n" +
                        "-- pragma translate_on\n" +
                        "    return(std_logic_vector(i - unsigned(d)));\n" +
                        "-- pragma translate_off\n" +
                        "  else x := (others =>'X'); return(x); \n" +
                        "  end if;\n" +
                        "-- pragma translate_on\n" +
                        "end;\n" +
                        "\n" +
                        "function \"-\" (d : std_logic_vector; i : integer) return std_logic_vector is\n" +
                        "variable x : std_logic_vector(d'length-1 downto 0);\n" +
                        "begin\n" +
                        "-- pragma translate_off\n" +
                        "  if not is_x(d) then\n" +
                        "-- pragma translate_on\n" +
                        "    return(std_logic_vector(unsigned(d) - i));\n" +
                        "-- pragma translate_off\n" +
                        "  else x := (others =>'X'); return(x); \n" +
                        "  end if;\n" +
                        "-- pragma translate_on\n" +
                        "end;\n" +
                        "\n" +
                        "function \"-\" (a, b : std_logic_vector) return std_logic_vector is\n" +
                        "variable x : std_logic_vector(a'length-1 downto 0);\n" +
                        "variable y : std_logic_vector(b'length-1 downto 0);\n" +
                        "begin\n" +
                        "-- pragma translate_off\n" +
                        "  if not is_x(a&b) then\n" +
                        "-- pragma translate_on\n" +
                        "    return(std_logic_vector(unsigned(a) - unsigned(b)));\n" +
                        "-- pragma translate_off\n" +
                        "  else\n" +
                        "     x := (others =>'X'); y := (others =>'X');\n" +
                        "     if (x'length > y'length) then return(x); else return(y); end if; \n" +
                        "  end if;\n" +
                        "-- pragma translate_on\n" +
                        "end;\n" +
                        "\n" +
                        "function \"*\" (a, b : std_logic_vector) return std_logic_vector is\n" +
                        "variable z : std_logic_vector(a'length+b'length-1 downto 0);\n" +
                        "begin\n" +
                        "-- pragma translate_off\n" +
                        "  if not is_x(a&b) then\n" +
                        "-- pragma translate_on\n" +
                        "    return(std_logic_vector(unsigned(a) * unsigned(b)));\n" +
                        "-- pragma translate_off\n" +
                        "  else\n" +
                        "     z := (others =>'X'); return(z);\n" +
                        "  end if;\n" +
                        "-- pragma translate_on\n" +
                        "end;\n" +
                        "\n" +
                        "\n" +
                        "end;\n" +
                        "";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_types_util_vhd_file(String Project_Folder_File) {
        String data =   "-----------------------------------------------------------------------------\n" +
                        "--! @file\n" +
                        "--! @copyright Copyright 2015 GNSS Sensor Ltd. All right reserved.\n" +
                        "--! @author    Sergey Khabarov - sergeykhbr@gmail.com\n" +
                        "--! @brief	    Package for common testbenches implementation.\n" +
                        "------------------------------------------------------------------------------\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.numeric_std.all;\n" +
                        "library std;\n" +
                        "use std.textio.all;\n" +
                        "\n" +
                        "package types_util is\n" +
                        "\n" +
                        "function strlen(s: in string) return integer;\n" +
                        "function StringToUVector(inStr: string) return std_ulogic_vector;\n" +
                        "function StringToSVector(inStr: string) return std_logic_vector;\n" +
                        "function UnsignedToSigned(inUnsigned: std_ulogic_vector) return std_logic_vector;\n" +
                        "function SignalFromString(inStr: string; ind : integer ) return std_logic;\n" +
                        "function SymbolToSVector(inStr: string; idx: integer) return std_logic_vector;\n" +
                        "\n" +
                        "function tost(v:std_logic_vector) return string;\n" +
                        "function tost(v:std_logic) return string;\n" +
                        "function tost(i : integer) return string;\n" +
                        "procedure print(s : string);\n" +
                        "\n" +
                        "end;\n" +
                        "\n" +
                        "package body types_util is\n" +
                        "\n" +
                        "  function strlen(s: in string) return integer is\n" +
                        "    variable n: integer:=0; variable sj: integer:=s'left;\n" +
                        "  begin\n" +
                        "    loop\n" +
                        "      if    sj>s'right then exit;\n" +
                        "      elsif s(sj)=NUL  then exit; --sequential if protects sj > length\n" +
                        "      else                  sj:=sj+1; n:=n+1;\n" +
                        "      end if;\n" +
                        "    end loop;\n" +
                        "    return n;\n" +
                        "  end strlen;\n" +
                        "\n" +
                        "  function SignalFromString(inStr: string; ind : integer ) return std_logic is\n" +
                        "    variable temp: std_logic := 'X';\n" +
                        "  begin\n" +
                        "    if(inStr(inStr'high-ind)='1')    then temp := '1';\n" +
                        "    elsif(inStr(inStr'high-ind)='0') then temp := '0';\n" +
                        "    end if;\n" +
                        "    return temp;\n" +
                        "  end function SignalFromString;\n" +
                        "\n" +
                        "\n" +
                        "  function StringToUVector(inStr: string) return std_ulogic_vector is\n" +
                        "    variable temp: std_ulogic_vector(inStr'range) := (others => 'X');\n" +
                        "  begin\n" +
                        "    for i in inStr'range loop --\n" +
                        "      if(inStr(inStr'high-i+1)='1')    then temp(i) := '1';\n" +
                        "      elsif(inStr(inStr'high-i+1)='0') then temp(i) := '0';\n" +
                        "      end if;\n" +
                        "    end loop;\n" +
                        "    return temp(inStr'high downto 1);\n" +
                        "  end function StringToUVector;\n" +
                        "  -- conversion function\n" +
                        "  \n" +
                        "  function StringToSVector(inStr: string) return std_logic_vector is\n" +
                        "    variable temp: std_logic_vector(inStr'range) := (others => 'X');\n" +
                        "  begin\n" +
                        "    for i in inStr'range loop --\n" +
                        "      if(inStr(inStr'high-i+1)='1')    then temp(i) := '1';\n" +
                        "      elsif(inStr(inStr'high-i+1)='0') then temp(i) := '0';\n" +
                        "      end if;\n" +
                        "    end loop;\n" +
                        "    return temp(inStr'high downto 1);\n" +
                        "  end function StringToSVector;\n" +
                        "\n" +
                        "  function SymbolToSVector(inStr: string; idx: integer) return std_logic_vector is\n" +
                        "    constant ss: string(1 to inStr'length) := inStr;\n" +
                        "    variable c : integer;\n" +
                        "    variable temp: std_logic_vector(7 downto 0) := (others => 'X');\n" +
                        "  begin\n" +
                        "    c := character'pos(ss(idx+1));\n" +
                        "    for i in 0 to 7 loop --\n" +
                        "      temp(i) := to_unsigned(c,8)(i);\n" +
                        "    end loop;\n" +
                        "    return temp;\n" +
                        "  end function SymbolToSVector;\n" +
                        "  \n" +
                        "\n" +
                        "  function UnsignedToSigned(inUnsigned: std_ulogic_vector) \n" +
                        "    return std_logic_vector is\n" +
                        "    variable temp: std_logic_vector(inUnsigned'length-1 downto 0) := (others => 'X');\n" +
                        "    variable i: integer:=0;\n" +
                        "  begin\n" +
                        "    while i < inUnsigned'length loop\n" +
                        "      if(inUnsigned(i)='1')    then temp(i) := '1';\n" +
                        "      elsif(inUnsigned(i)='0') then temp(i) := '0';\n" +
                        "      end if;\n" +
                        "      i := i+1;\n" +
                        "    end loop;\n" +
                        "    return temp;\n" +
                        "  end function UnsignedToSigned;\n" +
                        "\n" +
                        "\n" +
                        "  subtype nibble is std_logic_vector(3 downto 0);\n" +
                        "\n" +
                        "  function todec(i:integer) return character is\n" +
                        "  begin\n" +
                        "    case i is\n" +
                        "    when 0 => return('0');\n" +
                        "    when 1 => return('1');\n" +
                        "    when 2 => return('2');\n" +
                        "    when 3 => return('3');\n" +
                        "    when 4 => return('4');\n" +
                        "    when 5 => return('5');\n" +
                        "    when 6 => return('6');\n" +
                        "    when 7 => return('7');\n" +
                        "    when 8 => return('8');\n" +
                        "    when 9 => return('9');\n" +
                        "    when others => return('0');\n" +
                        "    end case;\n" +
                        "  end;\n" +
                        "\n" +
                        "\n" +
                        "  function tohex(n:nibble) return character is\n" +
                        "  begin\n" +
                        "    case n is\n" +
                        "    when \"0000\" => return('0');\n" +
                        "    when \"0001\" => return('1');\n" +
                        "    when \"0010\" => return('2');\n" +
                        "    when \"0011\" => return('3');\n" +
                        "    when \"0100\" => return('4');\n" +
                        "    when \"0101\" => return('5');\n" +
                        "    when \"0110\" => return('6');\n" +
                        "    when \"0111\" => return('7');\n" +
                        "    when \"1000\" => return('8');\n" +
                        "    when \"1001\" => return('9');\n" +
                        "    when \"1010\" => return('a');\n" +
                        "    when \"1011\" => return('b');\n" +
                        "    when \"1100\" => return('c');\n" +
                        "    when \"1101\" => return('d');\n" +
                        "    when \"1110\" => return('e');\n" +
                        "    when \"1111\" => return('f');\n" +
                        "    when others => return('X');\n" +
                        "    end case;\n" +
                        "  end;\n" +
                        "\n" +
                        "\n" +
                        "  function tost(v:std_logic_vector) return string is\n" +
                        "    constant vlen : natural := v'length; --'\n" +
                        "    constant slen : natural := (vlen+3)/4;\n" +
                        "    variable vv : std_logic_vector(0 to slen*4-1) := (others => '0');\n" +
                        "    variable s : string(1 to slen);\n" +
                        "    variable nz : boolean := false;\n" +
                        "    variable index : integer := -1;\n" +
                        "  begin\n" +
                        "    vv(slen*4-vlen to slen*4-1) := v;\n" +
                        "    for i in 0 to slen-1 loop\n" +
                        "      if (vv(i*4 to i*4+3) = \"0000\") and nz and (i /= (slen-1)) then\n" +
                        "        index := i;\n" +
                        "      else\n" +
                        "        nz := false;\n" +
                        "        s(i+1) := tohex(vv(i*4 to i*4+3));\n" +
                        "      end if;\n" +
                        "    end loop;\n" +
                        "    if ((index +2) = slen) then return(s(slen to slen));\n" +
                        "    else return(string'(\"0x\") & s(index+2 to slen)); end if; --'\n" +
                        "  end;\n" +
                        "\n" +
                        "\n" +
                        "  function tost(v:std_logic) return string is\n" +
                        "  begin\n" +
                        "    if to_x01(v) = '1' then return(\"1\"); else return(\"0\"); end if;\n" +
                        "  end;\n" +
                        "\n" +
                        "\n" +
                        "  function tost(i : integer) return string is\n" +
                        "    variable L : line;\n" +
                        "    variable s, x : string(1 to 128);\n" +
                        "    variable n, tmp : integer := 0;\n" +
                        "  begin\n" +
                        "    tmp := i;\n" +
                        "    if i < 0 then tmp := -i; end if;\n" +
                        "    loop\n" +
                        "      s(128-n) := todec(tmp mod 10);\n" +
                        "      tmp := tmp / 10;\n" +
                        "      n := n+1;\n" +
                        "      if tmp = 0 then exit; end if;\n" +
                        "    end loop;\n" +
                        "    x(1 to n) := s(129-n to 128);\n" +
                        "    if i < 0 then return \"-\" & x(1 to n); end if;\n" +
                        "    return(x(1 to n));\n" +
                        "  end;\n" +
                        "\n" +
                        "  procedure print(s : string) is\n" +
                        "    variable L : line;\n" +
                        "  begin\n" +
                        "    L := new string'(s); writeline(output, L);\n" +
                        "  end;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_types_misc_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2018 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "--! Standard library.\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.numeric_std.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--! Technology definition library.\n" +
                        "--library techmap;\n" +
                        "use work.gencomp.all;\n" +
                        "--! CPU, System Bus and common peripheries library.\n" +
                        "--library ambalib;\n" +
                        "use work.types_amba4.all;\n" +
                        "use work.types_bus0.all;\n" +
                        "\n" +
                        "--! @brief   Declaration of components visible on SoC top level.\n" +
                        "package types_misc is\n" +
                        "\n" +
                        "--! @defgroup irq_id_group AXI4 interrupt generic IDs.\n" +
                        "--! @ingroup axi4_config_generic_group\n" +
                        "--! @details Unique indentificator of the interrupt pin also used\n" +
                        "--!          as an index in the interrupts bus.\n" +
                        "--! @{\n" +
                        "\n" +
                        "--! Zero interrupt index must be unused.\n" +
                        "constant CFG_IRQ_UNUSED         : integer := 0;\n" +
                        "--! UART_A interrupt pin.\n" +
                        "constant CFG_IRQ_UART1          : integer := 1;\n" +
                        "--! Ethernet MAC interrupt pin.\n" +
                        "--constant CFG_IRQ_ETHMAC         : integer := 2;\n" +
                        "--! GP Timers interrupt pin\n" +
                        "constant CFG_IRQ_GPTIMERS       : integer := 2;\n" +
                        "--! GNSS Engine IRQ pin that generates 1 msec pulses.\n" +
                        "--constant CFG_IRQ_GNSSENGINE     : integer := 4;\n" +
                        "--! Total number of used interrupts in a system\n" +
                        "constant CFG_IRQ_TOTAL          : integer := 3;\n" +
                        "--! @}\n" +
                        "\n" +
                        "--! @brief SOC global reset former.\n" +
                        "--! @details This module produces output reset signal in a case if\n" +
                        "--!          button 'Reset' was pushed or PLL isn't a 'lock' state.\n" +
                        "--! param[in]  inSysReset Button generated signal\n" +
                        "--! param[in]  inSysClk Clock from the PLL. Bus clock.\n" +
                        "--! param[out] outReset Output reset signal with active 'High' (1 = reset).\n" +
                        "component reset_global\n" +
                        "port (\n" +
                        "  inSysReset  : in std_ulogic;\n" +
                        "  inSysClk    : in std_ulogic;\n" +
                        "  outReset    : out std_ulogic );\n" +
                        "end component;\n" +
                        "\n" +
                        "\n" +
                        "--! Boot ROM with AXI4 interface declaration.\n" +
                        "component axi4_rom is\n" +
                        "generic (\n" +
                        "    memtech  : integer := inferred;\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr    : integer := 0;\n" +
                        "    xmask    : integer := 16#fffff#;\n" +
                        "    sim_hexfile : string;\n" +
                        "    cyc_miffile : string\n" +
                        "  );\n" +
                        "port (\n" +
                        "    clk  : in std_logic;\n" +
                        "    nrst : in std_logic;\n" +
                        "    cfg  : out axi4_slave_config_type;\n" +
                        "    i    : in  axi4_slave_in_type;\n" +
                        "    o    : out axi4_slave_out_type\n" +
                        "  );\n" +
                        "end component; \n" +
                        "\n" +
                        "--! Internal RAM with AXI4 interface declaration.\n" +
                        "component axi4_sram is\n" +
                        "  generic (\n" +
                        "    memtech  : integer := inferred;\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr    : integer := 0;\n" +
                        "    xmask    : integer := 16#fffff#;\n" +
                        "    abits    : integer := 17;\n" +
                        "    init_file : string := \"\" -- only for 'inferred'\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk  : in std_logic;\n" +
                        "    nrst : in std_logic;\n" +
                        "    cfg  : out axi4_slave_config_type;\n" +
                        "    i    : in  axi4_slave_in_type;\n" +
                        "    o    : out axi4_slave_out_type\n" +
                        "  );\n" +
                        "end component; \n" +
                        "\n" +
                        "--! AXI4 to SPI brdige for external Flash IC Micron M25AA1024\n" +
                        "type spi_in_type is record\n" +
                        "    SDI : std_logic;\n" +
                        "end record;\n" +
                        "\n" +
                        "type spi_out_type is record\n" +
                        "    SDO : std_logic;\n" +
                        "    SCK : std_logic;\n" +
                        "    nCS : std_logic;\n" +
                        "    nWP : std_logic;\n" +
                        "    nHOLD : std_logic;\n" +
                        "    RESET : std_logic;\n" +
                        "end record;\n" +
                        "\n" +
                        "component axi4_flashspi is\n" +
                        "  generic (\n" +
                        "    xaddr   : integer := 0;\n" +
                        "    xmask   : integer := 16#fffff#\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk    : in  std_logic;\n" +
                        "    nrst   : in  std_logic;\n" +
                        "    cfg    : out axi4_slave_config_type;\n" +
                        "    i_spi  : in  spi_in_type;\n" +
                        "    o_spi  : out spi_out_type;\n" +
                        "    i_axi  : in  axi4_slave_in_type;\n" +
                        "    o_axi  : out axi4_slave_out_type  );\n" +
                        "end component; \n" +
                        "\n" +
                        "--! @brief AXI4 GPIO controller\n" +
                        "component axi4_gpio is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr    : integer := 0;\n" +
                        "    xmask    : integer := 16#fffff#;\n" +
                        "    xirq     : integer := 0\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk  		: in std_logic;\n" +
                        "    nrst		: in std_logic;\n" +
                        "    cfg  		: out axi4_slave_config_type;\n" +
                        "    i    		: in  axi4_slave_in_type;\n" +
                        "    o    		: out axi4_slave_out_type;\n" +
                        "    KEY			: in std_logic_vector(3 DOWNTO 0);\n" +
                        "	 SW			: in std_logic_vector(9 DOWNTO 0);\n" +
                        "    LEDG		: out std_logic_vector(7 DOWNTO 0);\n" +
                        "    LEDR		: out std_logic_vector(9 DOWNTO 0);\n" +
                        "    GPIO_IN		: in std_logic_vector(17 DOWNTO 0);\n" +
                        "    GPIO_OUT	: out std_logic_vector(17 DOWNTO 0)\n" +
                        "  );\n" +
                        "end component; \n" +
                        "\n" +
                        "type uart_in_type is record\n" +
                        "  rd   	: std_ulogic;\n" +
                        "  cts   : std_ulogic;\n" +
                        "end record;\n" +
                        "\n" +
                        "type uart_out_type is record\n" +
                        "  td   	: std_ulogic;\n" +
                        "  rts   : std_ulogic;\n" +
                        "end record;\n" +
                        "\n" +
                        "--! UART with the AXI4 interface declaration.\n" +
                        "component axi4_uart is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr   : integer := 0;\n" +
                        "    xmask   : integer := 16#fffff#;\n" +
                        "    xirq    : integer := 0;\n" +
                        "    fifosz  : integer := 16\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk    : in  std_logic;\n" +
                        "    nrst   : in  std_logic;\n" +
                        "    cfg    : out axi4_slave_config_type;\n" +
                        "    i_uart : in  uart_in_type;\n" +
                        "    o_uart : out uart_out_type;\n" +
                        "    i_axi  : in  axi4_slave_in_type;\n" +
                        "    o_axi  : out axi4_slave_out_type;\n" +
                        "    o_irq  : out std_logic);\n" +
                        "end component;\n" +
                        "\n" +
                        "--! Test Access Point via UART (debug access)\n" +
                        "component uart_tap is\n" +
                        "  port (\n" +
                        "    nrst     : in std_logic;\n" +
                        "    clk      : in std_logic;\n" +
                        "    i_uart   : in  uart_in_type;\n" +
                        "    o_uart   : out uart_out_type;\n" +
                        "    i_msti   : in axi4_master_in_type;\n" +
                        "    o_msto   : out axi4_master_out_type;\n" +
                        "    o_mstcfg : out axi4_master_config_type\n" +
                        "  );\n" +
                        "end component; \n" +
                        "\n" +
                        "-- JTAG TAP\n" +
                        "component tap_jtag is\n" +
                        "  generic (\n" +
                        "    ainst  : integer range 0 to 255 := 2;\n" +
                        "    dinst  : integer range 0 to 255 := 3);\n" +
                        "  port (\n" +
                        "    nrst  : in std_logic;\n" +
                        "    clk  : in std_logic;\n" +
                        "    i_tck   : in std_logic;   -- in: Test Clock\n" +
                        "    i_ntrst   : in std_logic;   -- in: \n" +
                        "    i_tms   : in std_logic;   -- in: Test Mode State\n" +
                        "    i_tdi   : in std_logic;   -- in: Test Data Input\n" +
                        "    o_tdo   : out std_logic;   -- out: Test Data Output\n" +
                        "    o_jtag_vref : out std_logic;\n" +
                        "    i_msti   : in axi4_master_in_type;\n" +
                        "    o_msto   : out axi4_master_out_type;\n" +
                        "    o_mstcfg : out axi4_master_config_type\n" +
                        "    );\n" +
                        "end component;\n" +
                        "\n" +
                        "\n" +
                        "--! @brief   Interrupt controller with the AXI4 interface declaration.\n" +
                        "--! @details To rise interrupt on certain CPU HostIO interface is used.\n" +
                        "component axi4_irqctrl is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr    : integer := 0;\n" +
                        "    xmask    : integer := 16#fffff#\n" +
                        "  );\n" +
                        "  port \n" +
                        " (\n" +
                        "    clk    : in std_logic;\n" +
                        "    nrst   : in std_logic;\n" +
                        "    i_irqs : in std_logic_vector(CFG_IRQ_TOTAL-1 downto 1);\n" +
                        "    o_cfg  : out axi4_slave_config_type;\n" +
                        "    i_axi  : in axi4_slave_in_type;\n" +
                        "    o_axi  : out axi4_slave_out_type;\n" +
                        "    o_irq_meip : out std_logic\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "  --! @brief   General Purpose Timers with the AXI interface.\n" +
                        "  --! @details This module provides high precision counter and\n" +
                        "  --!          generic number of GP timers.\n" +
                        "  component axi4_gptimers is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr   : integer := 0;\n" +
                        "    xmask   : integer := 16#fffff#;\n" +
                        "    xirq    : integer := 0;\n" +
                        "    tmr_total  : integer := 2\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk    : in  std_logic;\n" +
                        "    nrst   : in  std_logic;\n" +
                        "    cfg    : out axi4_slave_config_type;\n" +
                        "    i_axi  : in  axi4_slave_in_type;\n" +
                        "    o_axi  : out axi4_slave_out_type;\n" +
                        "    o_irq  : out std_logic\n" +
                        "  );\n" +
                        "  end component; \n" +
                        "\n" +
                        "--! @brief   Plug-n-Play support module with AXI4 interface declaration.\n" +
                        "--! @details Each device in a system hase to implements sideband signal\n" +
                        "--!          structure 'nasti_slave_config_type' that allows FW to\n" +
                        "--!          detect Hardware configuration in a run-time.\n" +
                        "--! @todo Implements PnP signals for all Masters devices.\n" +
                        "component axi4_pnp is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr   : integer := 0;\n" +
                        "    xmask   : integer := 16#fffff#;\n" +
                        "    tech    : integer := 0;\n" +
                        "    hw_id   : std_logic_vector(31 downto 0) := X\"20170101\"\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    sys_clk : in  std_logic;\n" +
                        "    adc_clk : in  std_logic;\n" +
                        "    nrst   : in  std_logic;\n" +
                        "    mstcfg : in  bus0_xmst_cfg_vector;\n" +
                        "    slvcfg : in  bus0_xslv_cfg_vector;\n" +
                        "    cfg    : out  axi4_slave_config_type;\n" +
                        "    i      : in  axi4_slave_in_type;\n" +
                        "    o      : out axi4_slave_out_type\n" +
                        "  );\n" +
                        "end component; \n" +
                        "\n" +
                        "end; -- package declaration";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_reset_glb_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2018 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "\n" +
                        "--! @brief NoC global reset former.\n" +
                        "--! @details This module produces output reset signal in a case if\n" +
                        "--!          button 'Reset' was pushed or PLL isn't a 'lock' state.\n" +
                        "--! param[in]  inSysReset Button generated signal\n" +
                        "--! param[in]  inSysClk Clock from the PLL. Bus clock.\n" +
                        "--! param[in]  inPllLock PLL status.\n" +
                        "--! param[out] outReset Output reset signal with active 'High' (1 = reset).\n" +
                        "entity reset_global is\n" +
                        "  port (\n" +
                        "    inSysReset  : in std_ulogic;\n" +
                        "    inSysClk    : in std_ulogic;\n" +
                        "    outReset    : out std_ulogic\n" +
                        "    );\n" +
                        "end;\n" +
                        "\n" +
                        "architecture arch_reset_global of reset_global is\n" +
                        "\n" +
                        "  type reg_type is record\n" +
                        "    delay_cnt : std_logic_vector(7 downto 0);\n" +
                        "  end record;\n" +
                        "\n" +
                        "  signal r : reg_type;\n" +
                        "begin\n" +
                        "\n" +
                        "  proc_rst : process (inSysClk, inSysReset, r) \n" +
                        "    variable wb_delay_cnt : std_logic_vector(7 downto 0);\n" +
                        "    variable sys_reset : std_logic;\n" +
                        "  begin\n" +
                        "\n" +
                        "    sys_reset := inSysReset;\n" +
                        "    \n" +
                        "    wb_delay_cnt := r.delay_cnt;\n" +
                        "    if r.delay_cnt(7) = '0' then\n" +
                        "      wb_delay_cnt := r.delay_cnt + 1;\n" +
                        "    end if;\n" +
                        "    \n" +
                        "    if sys_reset = '1' then\n" +
                        "      r.delay_cnt <= (others => '0');\n" +
                        "    elsif rising_edge(inSysClk) then \n" +
                        "      r.delay_cnt  <= wb_delay_cnt;\n" +
                        "    end if;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  outReset <= not r.delay_cnt(7);\n" +
                        "  \n" +
                        "end;  ";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_axi4_uart_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--! AMBA system bus specific library.\n" +
                        "--library ambalib;\n" +
                        "--! AXI4 configuration constants.\n" +
                        "use work.types_amba4.all;\n" +
                        "--library misclib;\n" +
                        "use work.types_misc.all;\n" +
                        "\n" +
                        "entity axi4_uart is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr   : integer := 0;\n" +
                        "    xmask   : integer := 16#fffff#;\n" +
                        "    xirq    : integer := 0;\n" +
                        "    fifosz  : integer := 16\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk    : in  std_logic;\n" +
                        "    nrst   : in  std_logic;\n" +
                        "    cfg    : out axi4_slave_config_type;\n" +
                        "    i_uart : in  uart_in_type;\n" +
                        "    o_uart : out uart_out_type;\n" +
                        "    i_axi  : in  axi4_slave_in_type;\n" +
                        "    o_axi  : out axi4_slave_out_type;\n" +
                        "    o_irq  : out std_logic\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_axi4_uart of axi4_uart is\n" +
                        "\n" +
                        "  constant xconfig : axi4_slave_config_type := (\n" +
                        "     descrtype => PNP_CFG_TYPE_SLAVE,\n" +
                        "     descrsize => PNP_CFG_SLAVE_DESCR_BYTES,\n" +
                        "     irq_idx => conv_std_logic_vector(xirq, 8),\n" +
                        "     xaddr => conv_std_logic_vector(xaddr, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     xmask => conv_std_logic_vector(xmask, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     vid => VENDOR_GNSSSENSOR,\n" +
                        "     did => GNSSSENSOR_UART\n" +
                        "  );\n" +
                        "\n" +
                        "  type fifo_mem is array (0 to fifosz-1) of std_logic_vector(7 downto 0);\n" +
                        "  type state_type is (idle, startbit, data, parity, stopbit);\n" +
                        "\n" +
                        "  type fifo_in_type is record\n" +
                        "    raddr : integer range 0 to fifosz-1;\n" +
                        "    waddr : integer range 0 to fifosz-1;\n" +
                        "    we : std_logic;\n" +
                        "    wdata : std_logic_vector(7 downto 0);\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant fifo_in_none : fifo_in_type := (0, 0, '0', X\"00\");\n" +
                        "\n" +
                        "  signal rfifoi : fifo_in_type;\n" +
                        "  signal rx_fifo_rdata : std_logic_vector(7 downto 0);\n" +
                        "  signal rx_fifo : fifo_mem;\n" +
                        "\n" +
                        "  signal tfifoi : fifo_in_type;\n" +
                        "  signal tx_fifo_rdata : std_logic_vector(7 downto 0);\n" +
                        "  signal tx_fifo   : fifo_mem;\n" +
                        "\n" +
                        "  type registers is record\n" +
                        "      tx_state  : state_type;\n" +
                        "      tx_wr_cnt : std_logic_vector(log2(fifosz)-1 downto 0);\n" +
                        "      tx_rd_cnt : std_logic_vector(log2(fifosz)-1 downto 0);\n" +
                        "      tx_byte_cnt : std_logic_vector(log2(fifosz)-1 downto 0);\n" +
                        "      tx_shift  : std_logic_vector(10 downto 0); --! stopbit=1,parity=xor,data[7:0],startbit=0\n" +
                        "      tx_data_cnt : integer range 0 to 11;\n" +
                        "      tx_scaler_cnt : integer;\n" +
                        "      tx_level : std_logic;\n" +
                        "      tx_irq_thresh : std_logic_vector(log2(fifosz)-1 downto 0);\n" +
                        "      tx_more_thresh : std_logic_vector(1 downto 0);\n" +
                        "\n" +
                        "      rx_state  : state_type;\n" +
                        "      rx_wr_cnt : std_logic_vector(log2(fifosz)-1 downto 0);\n" +
                        "      rx_rd_cnt : std_logic_vector(log2(fifosz)-1 downto 0);\n" +
                        "      rx_byte_cnt : std_logic_vector(log2(fifosz)-1 downto 0);\n" +
                        "      rx_shift  : std_logic_vector(7 downto 0);\n" +
                        "      rx_data_cnt : integer range 0 to 7;\n" +
                        "      rx_scaler_cnt : integer;\n" +
                        "      rx_level : std_logic;\n" +
                        "      rx_irq_thresh : std_logic_vector(log2(fifosz)-1 downto 0);\n" +
                        "      rx_more_thresh : std_logic_vector(1 downto 0);\n" +
                        "\n" +
                        "      rdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "      scaler : integer;\n" +
                        "      err_parity : std_logic;\n" +
                        "      err_stopbit : std_logic;\n" +
                        "      parity_bit : std_logic;\n" +
                        "      tx_irq_ena : std_logic;\n" +
                        "      rx_irq_ena : std_logic;\n" +
                        "      fwcpuid : std_logic_vector(31 downto 0);\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : registers := (\n" +
                        "        idle,  -- tx_state\n" +
                        "        (others => '0'), (others => '0'),  -- tx_wr_cnt, tx_rd_cnt\n" +
                        "        (others => '0'),  -- tx_byte_cnt\n" +
                        "        (others => '0'),  -- tx_shift\n" +
                        "        0, -- tx_data_cnt\n" +
                        "        0, -- tx_scaler_cnt\n" +
                        "        '0', -- tx_level\n" +
                        "        (others => '0'), -- tx_irq_thresh\n" +
                        "        (others => '0'), -- tx_more_thresh\n" +
                        "        idle, -- rx_state\n" +
                        "        (others => '0'), (others => '0'), -- rx_wr_cnt , rx_rd_cnt\n" +
                        "        (others => '0'), -- rx_byte_cnt\n" +
                        "        (others => '0'), -- rx_shift\n" +
                        "        0, -- rx_data_cnt\n" +
                        "        0, -- rx_scaler_cnt\n" +
                        "        '1', -- rx_level\n" +
                        "        (others => '0'), -- rx_irq_thresh\n" +
                        "        (others => '0'), -- rx_more_thresh\n" +
                        "        (others => '0'), -- rdata\n" +
                        "        0, -- scaler\n" +
                        "        '0', -- err_parity\n" +
                        "        '0', -- err_stopbit\n" +
                        "        '0', -- parity_bit\n" +
                        "        '1', -- tx_irq_ena\n" +
                        "        '1', -- rx_irq_ena\n" +
                        "        (others => '0')); -- fwcpuid\n" +
                        "\n" +
                        "signal r, rin : registers;\n" +
                        "\n" +
                        "signal wb_bus_raddr : global_addr_array_type;\n" +
                        "signal w_bus_re    : std_logic;\n" +
                        "signal wb_bus_waddr : global_addr_array_type;\n" +
                        "signal w_bus_we    : std_logic;\n" +
                        "signal wb_bus_wstrb : std_logic_vector(CFG_SYSBUS_DATA_BYTES-1 downto 0);\n" +
                        "signal wb_bus_wdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  axi0 :  axi4_slave generic map (\n" +
                        "    async_reset => async_reset\n" +
                        "  ) port map (\n" +
                        "    i_clk => clk,\n" +
                        "    i_nrst => nrst,\n" +
                        "    i_xcfg => xconfig, \n" +
                        "    i_xslvi => i_axi,\n" +
                        "    o_xslvo => o_axi,\n" +
                        "    i_ready => '1',\n" +
                        "    i_rdata => r.rdata,\n" +
                        "    o_re => w_bus_re,\n" +
                        "    o_r32 => open,\n" +
                        "    o_radr => wb_bus_raddr,\n" +
                        "    o_wadr => wb_bus_waddr,\n" +
                        "    o_we => w_bus_we,\n" +
                        "    o_wstrb => wb_bus_wstrb,\n" +
                        "    o_wdata => wb_bus_wdata\n" +
                        "  );\n" +
                        "\n" +
                        "  comblogic : process(nrst, i_uart, r, tx_fifo_rdata, rx_fifo_rdata,\n" +
                        "                      w_bus_re, wb_bus_raddr, wb_bus_waddr, w_bus_we,\n" +
                        "                      wb_bus_wstrb, wb_bus_wdata)\n" +
                        "    variable v : registers;\n" +
                        "    variable tmp : std_logic_vector(31 downto 0);\n" +
                        "\n" +
                        "    variable v_rfifoi : fifo_in_type;\n" +
                        "    variable v_tfifoi : fifo_in_type;\n" +
                        "    variable posedge_flag : std_logic;\n" +
                        "    variable negedge_flag : std_logic;\n" +
                        "    variable tx_fifo_empty : std_logic;\n" +
                        "    variable tx_fifo_full : std_logic;\n" +
                        "    variable rx_fifo_empty : std_logic;\n" +
                        "    variable rx_fifo_full : std_logic;\n" +
                        "    variable t_tx, t_rx : std_logic_vector(7 downto 0);\n" +
                        "    variable par : std_logic;\n" +
                        "    variable irq_ena : std_logic;\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    v_rfifoi := fifo_in_none;\n" +
                        "    v_rfifoi.raddr := conv_integer(r.rx_rd_cnt);\n" +
                        "    v_rfifoi.waddr := conv_integer(r.rx_wr_cnt);\n" +
                        "    v_rfifoi.wdata := r.rx_shift;\n" +
                        "\n" +
                        "    v_tfifoi := fifo_in_none;\n" +
                        "    v_tfifoi.raddr := conv_integer(r.tx_rd_cnt);\n" +
                        "    v_tfifoi.waddr := conv_integer(r.tx_wr_cnt);\n" +
                        "\n" +
                        "    -- Check FIFOs counters with thresholds:\n" +
                        "    v.tx_more_thresh := r.tx_more_thresh(0) & '0';\n" +
                        "    if r.tx_byte_cnt > r.tx_irq_thresh then\n" +
                        "      v.tx_more_thresh(0) := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    v.rx_more_thresh := r.rx_more_thresh(0) & '0';\n" +
                        "    if r.rx_byte_cnt > r.rx_irq_thresh then\n" +
                        "      v.rx_more_thresh(0) := '1';\n" +
                        "    end if;\n" +
                        "    \n" +
                        "    irq_ena := '0';\n" +
                        "    if (r.tx_more_thresh(1) and not r.tx_more_thresh(0)) = '1' then\n" +
                        "       irq_ena := r.tx_irq_ena;\n" +
                        "    end if;\n" +
                        "    if (not r.rx_more_thresh(1) and r.rx_more_thresh(0)) = '1' then\n" +
                        "       irq_ena := irq_ena or r.rx_irq_ena;\n" +
                        "    end if;\n" +
                        "    \n" +
                        "    -- system bus clock scaler to baudrate:\n" +
                        "    posedge_flag := '0';\n" +
                        "    negedge_flag := '0';\n" +
                        "    if r.scaler /= 0 then\n" +
                        "        if r.tx_scaler_cnt = (r.scaler-1) then\n" +
                        "            v.tx_scaler_cnt := 0;\n" +
                        "            v.tx_level := not r.tx_level;\n" +
                        "            posedge_flag := not r.tx_level;\n" +
                        "        else\n" +
                        "            v.tx_scaler_cnt := r.tx_scaler_cnt + 1;\n" +
                        "        end if;\n" +
                        "\n" +
                        "        if r.rx_state = idle and i_uart.rd = '1' then\n" +
                        "            v.rx_scaler_cnt := 0;\n" +
                        "            v.rx_level := '1';\n" +
                        "        elsif r.rx_scaler_cnt = (r.scaler-1) then\n" +
                        "            v.rx_scaler_cnt := 0;\n" +
                        "            v.rx_level := not r.rx_level;\n" +
                        "            negedge_flag := r.rx_level;\n" +
                        "        else\n" +
                        "            v.rx_scaler_cnt := r.rx_scaler_cnt + 1;\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Transmitter's FIFO:\n" +
                        "    tx_fifo_full := '0';\n" +
                        "    if (r.tx_wr_cnt + 1) = r.tx_rd_cnt then\n" +
                        "        tx_fifo_full := '1';\n" +
                        "    end if;\n" +
                        "    tx_fifo_empty := '0';\n" +
                        "    if r.tx_rd_cnt = r.tx_wr_cnt then\n" +
                        "        tx_fifo_empty := '1';\n" +
                        "        v.tx_byte_cnt := (others => '0');\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Receiver's FIFO:\n" +
                        "    rx_fifo_full := '0';\n" +
                        "    if (r.rx_wr_cnt + 1) = r.rx_rd_cnt then\n" +
                        "        rx_fifo_full := '1';\n" +
                        "    end if;\n" +
                        "    rx_fifo_empty := '0';\n" +
                        "    if r.rx_rd_cnt = r.rx_wr_cnt then\n" +
                        "        rx_fifo_empty := '1';\n" +
                        "        v.rx_byte_cnt := (others => '0');\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Transmitter's state machine:\n" +
                        "    if i_uart.cts = '1' and posedge_flag = '1' then\n" +
                        "        case r.tx_state is\n" +
                        "        when idle =>\n" +
                        "            if tx_fifo_empty = '0' then\n" +
                        "                -- stopbit=1,parity=xor,data[7:0],startbit=0\n" +
                        "                t_tx := tx_fifo_rdata; --r.tx_fifo(conv_integer(r.tx_rd_cnt));\n" +
                        "                if r.parity_bit = '1' then\n" +
                        "                    par := t_tx(7) xor t_tx(6) xor t_tx(5) xor t_tx(4)\n" +
                        "                         xor t_tx(3) xor t_tx(2) xor t_tx(1) xor t_tx(0);\n" +
                        "                    v.tx_shift := '1' & par & t_tx & '0';\n" +
                        "                else\n" +
                        "                    v.tx_shift := \"11\" & t_tx & '0';\n" +
                        "                end if;\n" +
                        "                \n" +
                        "                v.tx_state := startbit;\n" +
                        "                v.tx_rd_cnt := r.tx_rd_cnt + 1;\n" +
                        "                v.tx_byte_cnt := r.tx_byte_cnt - 1;\n" +
                        "                v.tx_data_cnt := 0;\n" +
                        "            end if;\n" +
                        "        when startbit =>\n" +
                        "            v.tx_state := data;\n" +
                        "        when data =>\n" +
                        "            if r.tx_data_cnt = 8 then\n" +
                        "                if r.parity_bit = '1' then\n" +
                        "                    v.tx_state := parity;\n" +
                        "                else\n" +
                        "                    v.tx_state := stopbit;\n" +
                        "                end if;\n" +
                        "            end if;\n" +
                        "        when parity =>\n" +
                        "            v.tx_state := stopbit;\n" +
                        "        when stopbit =>\n" +
                        "            v.tx_state := idle;\n" +
                        "        when others =>\n" +
                        "        end case;\n" +
                        "        \n" +
                        "        if r.tx_state /= idle then\n" +
                        "            v.tx_data_cnt := r.tx_data_cnt + 1;\n" +
                        "            v.tx_shift := '1' & r.tx_shift(10 downto 1);\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    --! Receiver's state machine:\n" +
                        "    if negedge_flag = '1' then\n" +
                        "        case r.rx_state is\n" +
                        "        when idle =>\n" +
                        "            if i_uart.rd = '0' then\n" +
                        "                v.rx_state := data;\n" +
                        "                v.rx_shift := (others => '0');\n" +
                        "                v.rx_data_cnt := 0;\n" +
                        "            end if;\n" +
                        "        when data =>\n" +
                        "            v.rx_shift := i_uart.rd & r.rx_shift(7 downto 1);\n" +
                        "            if r.rx_data_cnt = 7 then\n" +
                        "                if r.parity_bit = '1' then\n" +
                        "                    v.rx_state := parity;\n" +
                        "                else\n" +
                        "                    v.rx_state := stopbit;\n" +
                        "                end if;\n" +
                        "            else\n" +
                        "                v.rx_data_cnt := r.rx_data_cnt + 1;\n" +
                        "            end if;\n" +
                        "        when parity =>\n" +
                        "            t_rx := r.rx_shift;\n" +
                        "            par := t_rx(7) xor t_rx(6) xor t_rx(5) xor t_rx(4)\n" +
                        "               xor t_rx(3) xor t_rx(2) xor t_rx(1) xor t_rx(0);\n" +
                        "            if par = i_uart.rd then\n" +
                        "                v.err_parity := '0';\n" +
                        "            else \n" +
                        "                v.err_parity := '1';\n" +
                        "            end if;\n" +
                        "            v.rx_state := stopbit;\n" +
                        "        when stopbit =>\n" +
                        "            if i_uart.rd = '0' then\n" +
                        "                v.err_stopbit := '1';\n" +
                        "            else\n" +
                        "                v.err_stopbit := '0';\n" +
                        "            end if;\n" +
                        "            if rx_fifo_full = '0' then\n" +
                        "                v_rfifoi.we := '1';\n" +
                        "                --v.rx_fifo(conv_integer(r.rx_wr_cnt)) := r.rx_shift;\n" +
                        "                v.rx_wr_cnt := r.rx_wr_cnt + 1;\n" +
                        "                v.rx_byte_cnt := r.rx_byte_cnt + 1;\n" +
                        "            end if;\n" +
                        "            v.rx_state := idle;\n" +
                        "        when others =>\n" +
                        "        end case;\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    o_uart.rts <= '1';\n" +
                        "    if r.tx_state = idle then\n" +
                        "        o_uart.td <= '1';\n" +
                        "    else\n" +
                        "        o_uart.td <= r.tx_shift(0);\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    for n in 0 to CFG_WORDS_ON_BUS-1 loop\n" +
                        "       tmp := (others => '0');\n" +
                        "       case conv_integer(wb_bus_raddr(n)(11 downto 2)) is\n" +
                        "          when 0 => \n" +
                        "                tmp(1 downto 0) := tx_fifo_empty & tx_fifo_full;\n" +
                        "                tmp(5 downto 4) := rx_fifo_empty & rx_fifo_full;\n" +
                        "                tmp(9 downto 8) := r.err_stopbit & r.err_parity;\n" +
                        "                tmp(13) := r.rx_irq_ena;\n" +
                        "                tmp(14) := r.tx_irq_ena;\n" +
                        "                tmp(15) := r.parity_bit;\n" +
                        "          when 1 => \n" +
                        "                tmp := conv_std_logic_vector(r.scaler,32);\n" +
                        "          when 2 => \n" +
                        "                tmp := r.fwcpuid;\n" +
                        "          when 4 => \n" +
                        "                if rx_fifo_empty = '0' and w_bus_re = '1' then\n" +
                        "                    tmp(7 downto 0) := rx_fifo_rdata; \n" +
                        "                    v.rx_rd_cnt := r.rx_rd_cnt + 1;\n" +
                        "                    v.rx_byte_cnt := r.rx_byte_cnt - 1;\n" +
                        "                end if;\n" +
                        "          when others => \n" +
                        "       end case;\n" +
                        "       v.rdata(8*CFG_ALIGN_BYTES*(n+1)-1 downto 8*CFG_ALIGN_BYTES*n) := tmp;\n" +
                        "    end loop;\n" +
                        "\n" +
                        "\n" +
                        "    if w_bus_we = '1' then\n" +
                        "      for n in 0 to CFG_WORDS_ON_BUS-1 loop\n" +
                        "         if conv_integer(wb_bus_wstrb(CFG_ALIGN_BYTES*(n+1)-1 downto CFG_ALIGN_BYTES*n)) /= 0 then\n" +
                        "           tmp := wb_bus_wdata(8*CFG_ALIGN_BYTES*(n+1)-1 downto 8*CFG_ALIGN_BYTES*n);\n" +
                        "           case conv_integer(wb_bus_waddr(n)(11 downto 2)) is\n" +
                        "             when 0 =>\n" +
                        "                    v.parity_bit := tmp(15);\n" +
                        "                    v.tx_irq_ena := tmp(14);\n" +
                        "                    v.rx_irq_ena := tmp(13);\n" +
                        "             when 1 => \n" +
                        "                    v.scaler     := conv_integer(tmp);\n" +
                        "                    v.rx_scaler_cnt := 0;\n" +
                        "                    v.tx_scaler_cnt := 0;\n" +
                        "             when 2 => \n" +
                        "                    if r.fwcpuid = X\"00000000\" or tmp = X\"00000000\" then\n" +
                        "                        v.fwcpuid := tmp;\n" +
                        "                    end if;\n" +
                        "             when 4 => \n" +
                        "                    if tx_fifo_full = '0' then\n" +
                        "                        v_tfifoi.we := '1';\n" +
                        "                        v_tfifoi.wdata := tmp(7 downto 0);\n" +
                        "                        v.tx_wr_cnt := r.tx_wr_cnt + 1;\n" +
                        "                        v.tx_byte_cnt := r.tx_byte_cnt + 1;\n" +
                        "                    end if;\n" +
                        "             when others =>\n" +
                        "           end case;\n" +
                        "         end if;\n" +
                        "      end loop;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if not async_reset and nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    rin <= v;\n" +
                        "\n" +
                        "    rfifoi <= v_rfifoi;\n" +
                        "    tfifoi <= v_tfifoi;\n" +
                        "\n" +
                        "    o_irq <= irq_ena;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  cfg <= xconfig;\n" +
                        "\n" +
                        "  -- fifo pseudo memory:\n" +
                        "  tfifo0 : process(clk, tfifoi, tx_fifo)\n" +
                        "  begin \n" +
                        "     if rising_edge(clk) then \n" +
                        "        if tfifoi.we = '1' then\n" +
                        "            tx_fifo(tfifoi.waddr) <= tfifoi.wdata;\n" +
                        "        end if;\n" +
                        "     end if; \n" +
                        "     tx_fifo_rdata <= tx_fifo(tfifoi.raddr);\n" +
                        "  end process;\n" +
                        "\n" +
                        "  rfifo0 : process(clk, rfifoi, rx_fifo)\n" +
                        "  begin \n" +
                        "     if rising_edge(clk) then \n" +
                        "        if rfifoi.we = '1' then\n" +
                        "            rx_fifo(rfifoi.waddr) <= rfifoi.wdata;\n" +
                        "        end if;\n" +
                        "     end if; \n" +
                        "     rx_fifo_rdata <= rx_fifo(rfifoi.raddr);\n" +
                        "  end process;\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(clk, nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_axi4_sram_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "\n" +
                        "--library techmap;\n" +
                        "use work.gencomp.all;\n" +
                        "use work.types_mem.all;\n" +
                        "\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "\n" +
                        "--! AMBA system bus specific library.\n" +
                        "--library ambalib;\n" +
                        "--! AXI4 configuration constants.\n" +
                        "use work.types_amba4.all;\n" +
                        "\n" +
                        "\n" +
                        "entity axi4_sram is\n" +
                        "  generic (\n" +
                        "    memtech  : integer := inferred;\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr    : integer := 0;\n" +
                        "    xmask    : integer := 16#fffff#;\n" +
                        "    abits    : integer := 17;\n" +
                        "    init_file : string := \"\" -- only for inferred\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk  : in std_logic;\n" +
                        "    nrst : in std_logic;\n" +
                        "    cfg  : out axi4_slave_config_type;\n" +
                        "    i    : in  axi4_slave_in_type;\n" +
                        "    o    : out axi4_slave_out_type\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_axi4_sram of axi4_sram is\n" +
                        "\n" +
                        "  constant xconfig : axi4_slave_config_type := (\n" +
                        "     descrtype => PNP_CFG_TYPE_SLAVE,\n" +
                        "     descrsize => PNP_CFG_SLAVE_DESCR_BYTES,\n" +
                        "     irq_idx => conv_std_logic_vector(0, 8),\n" +
                        "     xaddr => conv_std_logic_vector(xaddr, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     xmask => conv_std_logic_vector(xmask, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     vid => VENDOR_GNSSSENSOR,\n" +
                        "     did => GNSSSENSOR_SRAM\n" +
                        "  );\n" +
                        "\n" +
                        "  type ram_in_type is record\n" +
                        "    raddr : global_addr_array_type;\n" +
                        "    re    : std_logic;\n" +
                        "    waddr : global_addr_array_type;\n" +
                        "    we    : std_logic;\n" +
                        "    wstrb : std_logic_vector(CFG_SYSBUS_DATA_BYTES-1 downto 0);\n" +
                        "    wdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "  end record;\n" +
                        "\n" +
                        "signal rdata_mux : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "signal rami : ram_in_type;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  cfg  <= xconfig;\n" +
                        "\n" +
                        "  axi0 :  axi4_slave generic map (\n" +
                        "    async_reset => async_reset\n" +
                        "  ) port map (\n" +
                        "    i_clk => clk,\n" +
                        "    i_nrst => nrst,\n" +
                        "    i_xcfg => xconfig, \n" +
                        "    i_xslvi => i,\n" +
                        "    o_xslvo => o,\n" +
                        "    i_ready => '1',\n" +
                        "    i_rdata => rdata_mux,\n" +
                        "    o_re => rami.re,\n" +
                        "    o_r32 => open,\n" +
                        "    o_radr => rami.raddr,\n" +
                        "    o_wadr => rami.waddr,\n" +
                        "    o_we => rami.we,\n" +
                        "    o_wstrb => rami.wstrb,\n" +
                        "    o_wdata => rami.wdata\n" +
                        "  );\n" +
                        "\n" +
                        "  tech0 : srambytes_tech generic map (\n" +
                        "    memtech   => memtech,\n" +
                        "    abits     => abits,\n" +
                        "    init_file => init_file -- only for 'inferred'\n" +
                        "  ) port map (\n" +
                        "    clk     => clk,\n" +
                        "    raddr   => rami.raddr,\n" +
                        "    rdata   => rdata_mux,\n" +
                        "    waddr   => rami.waddr,\n" +
                        "    we      => rami.we,\n" +
                        "    wstrb   => rami.wstrb,\n" +
                        "    wdata   => rami.wdata\n" +
                        "  );\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_axi4_rom_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "\n" +
                        "--library techmap;\n" +
                        "use work.gencomp.all;\n" +
                        "use work.types_mem.all;\n" +
                        "\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "\n" +
                        "--! AMBA system bus specific library\n" +
                        "--library ambalib;\n" +
                        "--! AXI4 configuration constants.\n" +
                        "use work.types_amba4.all;\n" +
                        "\n" +
                        "entity axi4_rom is\n" +
                        "  generic (\n" +
                        "    memtech  : integer := inferred;\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr    : integer := 0;\n" +
                        "    xmask    : integer := 16#fffff#;\n" +
                        "    sim_hexfile : string;\n" +
                        "	 cyc_miffile : string\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk  : in std_logic;\n" +
                        "    nrst : in std_logic;\n" +
                        "    cfg  : out axi4_slave_config_type;\n" +
                        "    i    : in  axi4_slave_in_type;\n" +
                        "    o    : out axi4_slave_out_type\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_axi4_rom of axi4_rom is\n" +
                        "\n" +
                        "  -- To avoid warning 'literal negative value' use -1048576 instead of 16#fff00000#\n" +
                        "  constant size_4kbytes : integer := -(xmask - 1048576); \n" +
                        "  constant abits : integer := 12 + log2(size_4kbytes);\n" +
                        "\n" +
                        "  constant xconfig : axi4_slave_config_type := (\n" +
                        "     descrtype => PNP_CFG_TYPE_SLAVE,\n" +
                        "     descrsize => PNP_CFG_SLAVE_DESCR_BYTES,\n" +
                        "     irq_idx => conv_std_logic_vector(0, 8),\n" +
                        "     xaddr => conv_std_logic_vector(xaddr, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     xmask => conv_std_logic_vector(xmask, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     vid => VENDOR_GNSSSENSOR,\n" +
                        "     did => GNSSSENSOR_ROM\n" +
                        "  );\n" +
                        "\n" +
                        "  signal raddr : global_addr_array_type;\n" +
                        "  signal rdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "  cfg  <= xconfig;\n" +
                        "\n" +
                        "  axi0 :  axi4_slave generic map (\n" +
                        "    async_reset => async_reset\n" +
                        "  ) port map (\n" +
                        "    i_clk => clk,\n" +
                        "    i_nrst => nrst,\n" +
                        "    i_xcfg => xconfig, \n" +
                        "    i_xslvi => i,\n" +
                        "    o_xslvo => o,\n" +
                        "    i_ready => '1',\n" +
                        "    i_rdata => rdata,\n" +
                        "    o_re => open,\n" +
                        "    o_r32 => open,\n" +
                        "    o_radr => raddr,\n" +
                        "    o_wadr => open,\n" +
                        "    o_we => open,\n" +
                        "    o_wstrb => open,\n" +
                        "    o_wdata => open\n" +
                        "  );\n" +
                        "\n" +
                        "  tech0 : Rom_tech generic map (\n" +
                        "    memtech => memtech,\n" +
                        "    abits => abits,\n" +
                        "    sim_hexfile => sim_hexfile,\n" +
                        "	 cyc_miffile => cyc_miffile\n" +
                        "  ) port map (\n" +
                        "    clk => clk,\n" +
                        "    address => raddr,\n" +
                        "    data => rdata\n" +
                        "  );\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_axi4_irqctrl_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.numeric_std.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--! AMBA system bus specific library.\n" +
                        "--library ambalib;\n" +
                        "--! AXI4 configuration constants.\n" +
                        "use work.types_amba4.all;\n" +
                        "--library misclib;\n" +
                        "use work.types_misc.all;\n" +
                        "\n" +
                        "entity axi4_irqctrl is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr : integer := 0;\n" +
                        "    xmask : integer := 16#fffff#\n" +
                        "  );\n" +
                        "  port \n" +
                        " (\n" +
                        "    clk    : in std_logic;\n" +
                        "    nrst   : in std_logic;\n" +
                        "    i_irqs : in std_logic_vector(CFG_IRQ_TOTAL-1 downto 1);\n" +
                        "    o_cfg  : out axi4_slave_config_type;\n" +
                        "    i_axi  : in axi4_slave_in_type;\n" +
                        "    o_axi  : out axi4_slave_out_type;\n" +
                        "    o_irq_meip : out std_logic\n" +
                        "  );\n" +
                        "end;\n" +
                        "\n" +
                        "architecture axi4_irqctrl_rtl of axi4_irqctrl is\n" +
                        "\n" +
                        "  constant xconfig : axi4_slave_config_type := (\n" +
                        "     descrtype => PNP_CFG_TYPE_SLAVE,\n" +
                        "     descrsize => PNP_CFG_SLAVE_DESCR_BYTES,\n" +
                        "     irq_idx => conv_std_logic_vector(0, 8),\n" +
                        "     xaddr => conv_std_logic_vector(xaddr, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     xmask => conv_std_logic_vector(xmask, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     vid => VENDOR_GNSSSENSOR,\n" +
                        "     did => GNSSSENSOR_IRQCTRL\n" +
                        "  );\n" +
                        "\n" +
                        "  constant IRQ_ZERO : std_logic_vector(CFG_IRQ_TOTAL-1 downto 1) := (others => '0');\n" +
                        "\n" +
                        "  type registers is record\n" +
                        "    --! interrupt signal delay signal to detect interrupt positive edge\n" +
                        "    irqs_z        : std_logic_vector(CFG_IRQ_TOTAL-1 downto 1);  \n" +
                        "    irqs_zz       : std_logic_vector(CFG_IRQ_TOTAL-1 downto 1);  \n" +
                        "\n" +
                        "    --! mask irq disabled: 1=disabled; 0=enabled\n" +
                        "    irqs_mask     : std_logic_vector(CFG_IRQ_TOTAL-1 downto 1);\n" +
                        "    --! irq pending bit mask\n" +
                        "    irqs_pending  : std_logic_vector(CFG_IRQ_TOTAL-1 downto 1);\n" +
                        "    --! interrupt handler address initialized by FW:\n" +
                        "    isr_table     : std_logic_vector(63 downto 0);\n" +
                        "    --! hold-on generation of interrupt.\n" +
                        "    irq_lock      : std_logic;\n" +
                        "    --! delayed interrupt\n" +
                        "    irq_wait_unlock : std_logic_vector(CFG_IRQ_TOTAL-1 downto 1);\n" +
                        "    irq_cause_idx : std_logic_vector(31 downto 0);\n" +
                        "    --! Function trap_entry copies the values of CSRs into these two regs:\n" +
                        "    dbg_cause    : std_logic_vector(63 downto 0);\n" +
                        "    dbg_epc      : std_logic_vector(63 downto 0);\n" +
                        "    raddr : global_addr_array_type;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : registers := (\n" +
                        "    (others => '0'), (others => '0'),  -- irqs_z, irqs_zz\n" +
                        "    (others => '1'), (others => '0'),  -- irqs_mask, irqs_pending\n" +
                        "    (others => '0'), '0',              -- isr_table, isr_lock\n" +
                        "    (others => '0'), (others => '0'),  -- irq_wait_unlock, irq_cause_idx\n" +
                        "    (others => '0'), (others => '0'),  -- dbg_cause, dbg_epc\n" +
                        "    ((others => '0'), (others => '0'))\n" +
                        "  );\n" +
                        "\n" +
                        "  signal r, rin: registers;\n" +
                        "\n" +
                        "  signal wb_dev_rdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "  signal wb_bus_raddr : global_addr_array_type;\n" +
                        "  signal w_bus_re    : std_logic;\n" +
                        "  signal wb_bus_waddr : global_addr_array_type;\n" +
                        "  signal w_bus_we    : std_logic;\n" +
                        "  signal wb_bus_wstrb : std_logic_vector(CFG_SYSBUS_DATA_BYTES-1 downto 0);\n" +
                        "  signal wb_bus_wdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  axi0 :  axi4_slave generic map (\n" +
                        "    async_reset => async_reset\n" +
                        "  ) port map (\n" +
                        "    i_clk => clk,\n" +
                        "    i_nrst => nrst,\n" +
                        "    i_xcfg => xconfig, \n" +
                        "    i_xslvi => i_axi,\n" +
                        "    o_xslvo => o_axi,\n" +
                        "    i_ready => '1',\n" +
                        "    i_rdata => wb_dev_rdata,\n" +
                        "    o_re => w_bus_re,\n" +
                        "    o_r32 => open,\n" +
                        "    o_radr => wb_bus_raddr,\n" +
                        "    o_wadr => wb_bus_waddr,\n" +
                        "    o_we => w_bus_we,\n" +
                        "    o_wstrb => wb_bus_wstrb,\n" +
                        "    o_wdata => wb_bus_wdata\n" +
                        "  );\n" +
                        "\n" +
                        "  comblogic : process(nrst, i_irqs, r, w_bus_re, wb_bus_raddr, wb_bus_waddr,\n" +
                        "                      w_bus_we, wb_bus_wstrb, wb_bus_wdata)\n" +
                        "    variable v : registers;\n" +
                        "    variable raddr : integer;\n" +
                        "    variable waddr : integer;\n" +
                        "    variable vrdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "    variable tmp : std_logic_vector(31 downto 0);\n" +
                        "    variable wstrb : std_logic_vector(CFG_ALIGN_BYTES-1 downto 0);\n" +
                        "    variable w_generate_ipi : std_logic;\n" +
                        "  begin\n" +
                        "    v := r;\n" +
                        "    v.raddr := wb_bus_raddr;\n" +
                        "    w_generate_ipi := '0';\n" +
                        "\n" +
                        "    vrdata := (others => '0');\n" +
                        "    for n in 0 to CFG_WORDS_ON_BUS-1 loop\n" +
                        "       raddr := conv_integer(r.raddr(n)(11 downto 2));\n" +
                        "       tmp := (others => '0');\n" +
                        "       case raddr is\n" +
                        "         when 0      => tmp(CFG_IRQ_TOTAL-1 downto 1) := r.irqs_mask;     --! [RW]: 1=irq disable; 0=enable\n" +
                        "         when 1      => tmp(CFG_IRQ_TOTAL-1 downto 1) := r.irqs_pending;  --! [RO]: Rised interrupts.\n" +
                        "         when 2      => tmp := (others => '0');                           --! [WO]: Clear interrupts mask.\n" +
                        "         when 3      => tmp := (others => '0');                           --! [WO]: Rise interrupts mask.\n" +
                        "         when 4      => tmp := r.isr_table(31 downto 0);                  --! [RW]: LSB of the function address\n" +
                        "         when 5      => tmp := r.isr_table(63 downto 32);                 --! [RW]: MSB of the function address\n" +
                        "         when 6      => tmp := r.dbg_cause(31 downto 0);                  --! [RW]: Cause of the interrupt\n" +
                        "         when 7      => tmp := r.dbg_cause(63 downto 32);                 --! [RW]: \n" +
                        "         when 8      => tmp := r.dbg_epc(31 downto 0);                    --! [RW]: Instruction pointer\n" +
                        "         when 9      => tmp := r.dbg_epc(63 downto 32);                   --! [RW]: \n" +
                        "         when 10     => tmp(0) := r.irq_lock;\n" +
                        "         when 11     => tmp := r.irq_cause_idx;\n" +
                        "         when others =>\n" +
                        "       end case;\n" +
                        "       vrdata(8*CFG_ALIGN_BYTES*(n+1)-1 downto 8*CFG_ALIGN_BYTES*n) := tmp;\n" +
                        "    end loop;\n" +
                        "\n" +
                        "    if w_bus_we = '1' then\n" +
                        "      for n in 0 to CFG_WORDS_ON_BUS-1 loop\n" +
                        "         if conv_integer(wb_bus_wstrb(CFG_ALIGN_BYTES*(n+1)-1 downto CFG_ALIGN_BYTES*n)) /= 0 then\n" +
                        "             waddr := conv_integer(wb_bus_waddr(n)(11 downto 2));\n" +
                        "             tmp := wb_bus_wdata(32*(n+1)-1 downto 32*n);\n" +
                        "\n" +
                        "             case waddr is\n" +
                        "             when 0 => v.irqs_mask := tmp(CFG_IRQ_TOTAL-1 downto 1);\n" +
                        "             when 1 =>     --! Read only\n" +
                        "             when 2 => \n" +
                        "                v.irqs_pending := r.irqs_pending and (not tmp(CFG_IRQ_TOTAL-1 downto 1));\n" +
                        "             when 3 => \n" +
                        "                w_generate_ipi := '1';\n" +
                        "                v.irqs_pending := (not r.irqs_mask) and tmp(CFG_IRQ_TOTAL-1 downto 1);\n" +
                        "             when 4 => v.isr_table(31 downto 0) := tmp;\n" +
                        "             when 5 => v.isr_table(63 downto 32) := tmp;\n" +
                        "             when 6 => v.dbg_cause(31 downto 0) := tmp;\n" +
                        "             when 7 => v.dbg_cause(63 downto 32) := tmp;\n" +
                        "             when 8 => v.dbg_epc(31 downto 0) := tmp;\n" +
                        "             when 9 => v.dbg_epc(63 downto 32) := tmp;\n" +
                        "             when 10 => v.irq_lock := tmp(0);\n" +
                        "             when 11 => v.irq_cause_idx := tmp;\n" +
                        "             when others =>\n" +
                        "             end case;\n" +
                        "         end if;\n" +
                        "      end loop;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    v.irqs_z := i_irqs;\n" +
                        "    v.irqs_zz := r.irqs_z;\n" +
                        "    for n in 1 to CFG_IRQ_TOTAL-1 loop\n" +
                        "      if (r.irqs_z(n) = '1' and r.irqs_zz(n) = '0') or r.irq_wait_unlock(n) = '1' then\n" +
                        "         if r.irq_lock = '0' then\n" +
                        "             v.irq_wait_unlock(n) := '0';\n" +
                        "             v.irqs_pending(n) := not r.irqs_mask(n);\n" +
                        "             w_generate_ipi := w_generate_ipi or (not r.irqs_mask(n));\n" +
                        "         else\n" +
                        "             v.irq_wait_unlock(n) := '1';\n" +
                        "         end if;\n" +
                        "      end if;\n" +
                        "    end loop;\n" +
                        "\n" +
                        "\n" +
                        "    if r.irqs_pending = IRQ_ZERO or r.irq_lock = '1' then\n" +
                        "      o_irq_meip <= '0';\n" +
                        "    else\n" +
                        "      o_irq_meip <= '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if not async_reset and nrst = '0' then \n" +
                        "       v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    rin <= v;\n" +
                        "    wb_dev_rdata <= vrdata;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  o_cfg  <= xconfig;\n" +
                        "\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(clk, nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_axi4_gptimers_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--! AMBA system bus specific library.\n" +
                        "--library ambalib;\n" +
                        "--! AXI4 configuration constants.\n" +
                        "use work.types_amba4.all;\n" +
                        "--library misclib;\n" +
                        "use work.types_misc.all;\n" +
                        "\n" +
                        "entity axi4_gptimers is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr   : integer := 0;\n" +
                        "    xmask   : integer := 16#fffff#;\n" +
                        "    xirq    : integer := 0;\n" +
                        "    tmr_total  : integer := 2\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk    : in  std_logic;\n" +
                        "    nrst   : in  std_logic;\n" +
                        "    cfg    : out axi4_slave_config_type;\n" +
                        "    i_axi  : in  axi4_slave_in_type;\n" +
                        "    o_axi  : out axi4_slave_out_type;\n" +
                        "    o_irq  : out std_logic\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_axi4_gptimers of axi4_gptimers is\n" +
                        "\n" +
                        "  constant xconfig : axi4_slave_config_type := (\n" +
                        "     descrtype => PNP_CFG_TYPE_SLAVE,\n" +
                        "     descrsize => PNP_CFG_SLAVE_DESCR_BYTES,\n" +
                        "     irq_idx => conv_std_logic_vector(xirq, 8),\n" +
                        "     xaddr => conv_std_logic_vector(xaddr, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     xmask => conv_std_logic_vector(xmask, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     vid => VENDOR_GNSSSENSOR,\n" +
                        "     did => GNSSSENSOR_GPTIMERS\n" +
                        "  );\n" +
                        "\n" +
                        "  constant zero64 : std_logic_vector(63 downto 0) := (others => '0');\n" +
                        "\n" +
                        "  type timer_type is record\n" +
                        "      count_ena : std_logic;\n" +
                        "      irq_ena   : std_logic;\n" +
                        "		overflow  : std_logic;\n" +
                        "      value : std_logic_vector(63 downto 0);\n" +
                        "      init_value : std_logic_vector(63 downto 0);\n" +
                        "  end record;\n" +
                        "  \n" +
                        "  constant timer_type_reset : timer_type := \n" +
                        "     ('0', '0', '0', (others => '0'), (others => '0'));\n" +
                        "\n" +
                        "  type vector_timer_type is array (0 to tmr_total-1) of timer_type;\n" +
                        "\n" +
                        "  type registers is record\n" +
                        "    tmr  : vector_timer_type;\n" +
                        "    highcnt : std_logic_vector(63 downto 0);\n" +
                        "    pending : std_logic_vector(tmr_total-1 downto 0);\n" +
                        "    raddr : global_addr_array_type;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : registers := (\n" +
                        "      (others => timer_type_reset), (others => '0'), (others => '0'),\n" +
                        "      ((others => '0'), (others => '0'))\n" +
                        "  );\n" +
                        "\n" +
                        "  signal r, rin : registers;\n" +
                        "\n" +
                        "  signal wb_dev_rdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "  signal wb_bus_raddr : global_addr_array_type;\n" +
                        "  signal w_bus_re    : std_logic;\n" +
                        "  signal wb_bus_waddr : global_addr_array_type;\n" +
                        "  signal w_bus_we    : std_logic;\n" +
                        "  signal wb_bus_wstrb : std_logic_vector(CFG_SYSBUS_DATA_BYTES-1 downto 0);\n" +
                        "  signal wb_bus_wdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  axi0 :  axi4_slave generic map (\n" +
                        "    async_reset => async_reset\n" +
                        "  ) port map (\n" +
                        "    i_clk => clk,\n" +
                        "    i_nrst => nrst,\n" +
                        "    i_xcfg => xconfig, \n" +
                        "    i_xslvi => i_axi,\n" +
                        "    o_xslvo => o_axi,\n" +
                        "    i_ready => '1',\n" +
                        "    i_rdata => wb_dev_rdata,\n" +
                        "    o_re => w_bus_re,\n" +
                        "    o_r32 => open,\n" +
                        "    o_radr => wb_bus_raddr,\n" +
                        "    o_wadr => wb_bus_waddr,\n" +
                        "    o_we => w_bus_we,\n" +
                        "    o_wstrb => wb_bus_wstrb,\n" +
                        "    o_wdata => wb_bus_wdata\n" +
                        "  );\n" +
                        "\n" +
                        "  comblogic : process(nrst, r, w_bus_re, wb_bus_raddr, wb_bus_waddr,\n" +
                        "                      w_bus_we, wb_bus_wstrb, wb_bus_wdata)\n" +
                        "    variable v : registers;\n" +
                        "    variable raddr : integer;\n" +
                        "    variable waddr : integer;\n" +
                        "    variable vrdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "    variable tmp : std_logic_vector(31 downto 0);\n" +
                        "    variable irq_ena : std_logic;\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    v.raddr := wb_bus_raddr;\n" +
                        "\n" +
                        "    v.highcnt := r.highcnt + 1;\n" +
                        "\n" +
                        "    irq_ena := '0';\n" +
                        "    for n in 0 to tmr_total-1 loop\n" +
                        "        if r.tmr(n).count_ena = '1' then \n" +
                        "           if r.tmr(n).value = zero64 then\n" +
                        "               irq_ena := irq_ena or r.tmr(n).irq_ena;\n" +
                        "               v.pending(n) := r.tmr(n).irq_ena;\n" +
                        "               v.tmr(n).value := r.tmr(n).init_value;\n" +
                        "					v.tmr(n).overflow := '1';\n" +
                        "           else\n" +
                        "               v.tmr(n).value := r.tmr(n).value - 1;\n" +
                        "           end if;\n" +
                        "        else\n" +
                        "           v.tmr(n).value := r.tmr(n).init_value;\n" +
                        "        end if;\n" +
                        "    end loop;\n" +
                        "\n" +
                        "\n" +
                        "    for n in 0 to CFG_WORDS_ON_BUS-1 loop\n" +
                        "       tmp := (others => '0');\n" +
                        "       raddr := conv_integer(r.raddr(n)(11 downto 2));\n" +
                        "       case raddr is\n" +
                        "          when 0 => \n" +
                        "                tmp := r.highcnt(31 downto 0);\n" +
                        "          when 1 => \n" +
                        "                tmp := r.highcnt(63 downto 32);\n" +
                        "          when 2 => \n" +
                        "                tmp(tmr_total-1 downto 0) := r.pending;\n" +
                        "          when others => \n" +
                        "                for k in 0 to tmr_total-1 loop\n" +
                        "                   if raddr = (16 + 6*k) then\n" +
                        "                      tmp(0) := r.tmr(k).count_ena;\n" +
                        "                      tmp(1) := r.tmr(k).irq_ena;\n" +
                        "                      tmp(2) := r.tmr(k).overflow;\n" +
                        "                   elsif raddr = (16 + 6*k + 2) then\n" +
                        "                      tmp := r.tmr(k).value(31 downto 0);\n" +
                        "                   elsif raddr = (16 + 6*k + 3) then\n" +
                        "                      tmp := r.tmr(k).value(63 downto 32);\n" +
                        "                   elsif raddr = (16 + 6*k + 4) then\n" +
                        "                      tmp := r.tmr(k).init_value(31 downto 0);\n" +
                        "                   elsif raddr = (16 + 6*k + 5) then\n" +
                        "                      tmp := r.tmr(k).init_value(63 downto 32);\n" +
                        "                   end if;\n" +
                        "                end loop;\n" +
                        "       end case;\n" +
                        "       vrdata(8*CFG_ALIGN_BYTES*(n+1)-1 downto 8*CFG_ALIGN_BYTES*n) := tmp;\n" +
                        "    end loop;\n" +
                        "\n" +
                        "\n" +
                        "    if w_bus_we = '1' then\n" +
                        "      for n in 0 to CFG_WORDS_ON_BUS-1 loop\n" +
                        "\n" +
                        "         if conv_integer(wb_bus_wstrb(CFG_ALIGN_BYTES*(n+1)-1 downto CFG_ALIGN_BYTES*n)) /= 0 then\n" +
                        "           tmp := wb_bus_wdata(8*CFG_ALIGN_BYTES*(n+1)-1 downto 8*CFG_ALIGN_BYTES*n);\n" +
                        "           waddr := conv_integer(wb_bus_waddr(n)(11 downto 2));\n" +
                        "           case waddr is\n" +
                        "             when 2 => \n" +
                        "                v.pending := tmp(tmr_total-1 downto 0);\n" +
                        "             when others =>\n" +
                        "                for k in 0 to tmr_total-1 loop\n" +
                        "                   if waddr = (16 + 6*k) then\n" +
                        "                      v.tmr(k).count_ena := tmp(0);\n" +
                        "                      v.tmr(k).irq_ena := tmp(1);\n" +
                        "                      v.tmr(k).overflow := tmp(2);\n" +
                        "                   elsif waddr = (16 + 6*k + 2) then\n" +
                        "                      v.tmr(k).value(31 downto 0) := tmp;\n" +
                        "                   elsif waddr = (16 + 6*k + 3) then\n" +
                        "                      v.tmr(k).value(63 downto 32) := tmp;\n" +
                        "                   elsif waddr = (16 + 6*k + 4) then\n" +
                        "                      v.tmr(k).init_value(31 downto 0) := tmp;\n" +
                        "                   elsif waddr = (16 + 6*k + 5) then\n" +
                        "                      v.tmr(k).init_value(63 downto 32) := tmp;\n" +
                        "                   end if;\n" +
                        "                end loop;\n" +
                        "           end case;\n" +
                        "         end if;\n" +
                        "      end loop;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if not async_reset and nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "    rin <= v;\n" +
                        "\n" +
                        "    o_irq <= irq_ena;\n" +
                        "    wb_dev_rdata <= vrdata;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  cfg <= xconfig;\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(clk, nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_axi4_gpio_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.numeric_std.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--! AMBA system bus specific library.\n" +
                        "--library ambalib;\n" +
                        "--! AXI4 configuration constants.\n" +
                        "use work.types_amba4.all;\n" +
                        "\n" +
                        "entity axi4_gpio is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr    : integer := 0;\n" +
                        "    xmask    : integer := 16#fffff#;\n" +
                        "    xirq     : integer := 0\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk  		: in std_logic;\n" +
                        "    nrst 		: in std_logic;\n" +
                        "    cfg  		: out axi4_slave_config_type;\n" +
                        "    i    		: in  axi4_slave_in_type;\n" +
                        "    o  		  	: out axi4_slave_out_type;\n" +
                        "    KEY			: in std_logic_vector(3 DOWNTO 0);\n" +
                        "	 SW			: in std_logic_vector(9 DOWNTO 0);\n" +
                        "    LEDG			: out std_logic_vector(7 DOWNTO 0);\n" +
                        "    LEDR			: out std_logic_vector(9 DOWNTO 0);\n" +
                        "    GPIO_IN		: in std_logic_vector(17 DOWNTO 0);\n" +
                        "    GPIO_OUT	: out std_logic_vector(17 DOWNTO 0)\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_axi4_gpio of axi4_gpio is\n" +
                        "\n" +
                        "  constant xconfig : axi4_slave_config_type := (\n" +
                        "     descrtype => PNP_CFG_TYPE_SLAVE,\n" +
                        "     descrsize => PNP_CFG_SLAVE_DESCR_BYTES,\n" +
                        "     irq_idx => conv_std_logic_vector(xirq, 8),\n" +
                        "     xaddr => conv_std_logic_vector(xaddr, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     xmask => conv_std_logic_vector(xmask, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     vid => VENDOR_GNSSSENSOR,\n" +
                        "     did => GNSSSENSOR_GPIO\n" +
                        "  );\n" +
                        "\n" +
                        "  signal wb_dev_rdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "  signal wb_bus_raddr : global_addr_array_type;\n" +
                        "  signal w_bus_re    : std_logic;\n" +
                        "  signal wb_bus_waddr : global_addr_array_type;\n" +
                        "  signal w_bus_we    : std_logic;\n" +
                        "  signal wb_bus_wstrb : std_logic_vector(CFG_SYSBUS_DATA_BYTES-1 downto 0);\n" +
                        "  signal wb_bus_wdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "\n" +
                        "  signal address_w		: STD_LOGIC_VECTOR(31 DOWNTO 0);\n" +
                        "  signal wstrb				: global_addr_array_type;\n" +
                        "  \n" +
                        "  signal register_in		: STD_LOGIC_VECTOR(63 DOWNTO 0);   -- 32 - 0\n" +
                        "  signal register_out	: STD_LOGIC_VECTOR(63 DOWNTO 0);   -- 36 - 0\n" +
                        "  signal OUT_Data_1		: STD_LOGIC;\n" +
                        "  signal OUT_Data_2		: STD_LOGIC;\n" +
                        "	\n" +
                        "begin\n" +
                        "\n" +
                        "  axi0 :  axi4_slave generic map (\n" +
                        "    async_reset => async_reset\n" +
                        "  ) port map (\n" +
                        "    i_clk => clk,\n" +
                        "    i_nrst => nrst,\n" +
                        "    i_xcfg => xconfig, \n" +
                        "    i_xslvi => i,\n" +
                        "    o_xslvo => o,\n" +
                        "    i_ready => '1',\n" +
                        "    i_rdata => wb_dev_rdata,\n" +
                        "    o_re => w_bus_re,\n" +
                        "    o_r32 => open,\n" +
                        "    o_radr => wb_bus_raddr,\n" +
                        "    o_wadr => wb_bus_waddr,\n" +
                        "    o_we => w_bus_we,\n" +
                        "    o_wstrb => wb_bus_wstrb,\n" +
                        "    o_wdata => wb_bus_wdata\n" +
                        "  );\n" +
                        "\n" +
                        "  wb_dev_rdata <= \"0000000000000000000000000000000\" & OUT_Data_2 &\"0000000000000000000000000000000\" & OUT_Data_1;\n" +
                        "  cfg  <= xconfig;\n" +
                        "  \n" +
                        "  wstrb(0) <= (others => wb_bus_wstrb(0));\n" +
                        "  wstrb(1) <= (others => wb_bus_wstrb(4));\n" +
                        "  address_w <= ((wb_bus_waddr(0) and wstrb(0)) or (wb_bus_waddr(1) and wstrb(1)));\n" +
                        "  \n" +
                        "  -- registers:\n" +
                        "  regs : process(clk, nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and nrst = '0' then\n" +
                        "        register_in	<= (OTHERS => '0');\n" +
                        "		  register_out	<= (OTHERS => '0');\n" +
                        "		  GPIO_OUT		<= (OTHERS => '0');\n" +
                        "		  LEDR			<= (OTHERS => '0');\n" +
                        "		  LEDG			<= (OTHERS => '0');\n" +
                        "		  OUT_Data_1	<= '0';\n" +
                        "		  OUT_Data_2	<= '0';\n" +
                        "     elsif rising_edge(clk) then \n" +
                        "        if w_bus_we = '1' then   -- write\n" +
                        "				if address_w(8 downto 2) = \"1111111\" then\n" +
                        "					register_in        <= \"00000000000000000000000000000000\" & KEY & SW & GPIO_IN;\n" +
                        "					GPIO_OUT           <= register_out(17 downto 0);\n" +
                        "					LEDR               <= register_out(27 downto 18);\n" +
                        "					LEDG               <= register_out(35 downto 28);\n" +
                        "				else\n" +
                        "					register_out(to_integer(unsigned(address_w(7 downto 2)))) <= wb_bus_wdata(0);\n" +
                        "				end if;\n" +
                        "			elsif w_bus_re = '1' then -- read\n" +
                        "				if wb_bus_raddr(0)(8) = '0' then   -- read inputs\n" +
                        "					OUT_Data_1 <= register_in(to_integer(unsigned(wb_bus_raddr(0)(7 downto 2))));\n" +
                        "				else                       -- read outputs\n" +
                        "					OUT_Data_1 <= register_out(to_integer(unsigned(wb_bus_raddr(0)(7 downto 2))));\n" +
                        "				end if;\n" +
                        "				if wb_bus_raddr(1)(8) = '0' then   -- read inputs\n" +
                        "					OUT_Data_2 <= register_in(to_integer(unsigned(wb_bus_raddr(1)(7 downto 2))));\n" +
                        "				else                       -- read outputs\n" +
                        "					OUT_Data_2 <= register_out(to_integer(unsigned(wb_bus_raddr(1)(7 downto 2))));\n" +
                        "				end if;\n" +
                        "		   end if;\n" +
                        "     end if; \n" +
                        "  end process;  \n" +
                        "  \n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_axi4_time_measurement_vhd_file(String Project_Folder_File) {
        String data =   "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.numeric_std.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--! AMBA system bus specific library.\n" +
                        "--library ambalib;\n" +
                        "--! AXI4 configuration constants.\n" +
                        "use work.types_amba4.all;\n" +
                        "\n" +
                        "--! The following registers are defined:\n" +
                        "--! |---------|-------------------|\n" +
                        "--! | Address | Description       |\n" +
                        "--! |---------|-------------------|\n" +
                        "--! | 0b00    | START_STOP_A      |\n" +
                        "--! | 0b10    | MICRO_NANO_A      |\n" +
                        "--! | 0b00    | READ_TIME_A       |\n" +
                        "--! | 0b11    |                   |\n" +
                        "--! |---------|-------------------|\n" +
                        "\n" +
                        "entity axi4_time_measurement is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr    : integer := 0;\n" +
                        "    xmask    : integer := 16#fffff#;\n" +
                        "    xirq     : integer := 0\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk  		: in std_logic;\n" +
                        "    nrst 		: in std_logic;\n" +
                        "    cfg  		: out axi4_slave_config_type;\n" +
                        "    i    		: in  axi4_slave_in_type;\n" +
                        "    o  		  	: out axi4_slave_out_type;\n" +
                        "	 \n" +
                        "	 -- HEX interface\n" +
                        "	 HEX0			: OUT STD_LOGIC_VECTOR(6 DOWNTO 0);\n" +
                        "	 HEX1			: OUT STD_LOGIC_VECTOR(6 DOWNTO 0);\n" +
                        "	 HEX2			: OUT STD_LOGIC_VECTOR(6 DOWNTO 0);\n" +
                        "	 HEX3			: OUT STD_LOGIC_VECTOR(6 DOWNTO 0)\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_axi4_time_measurement  of axi4_time_measurement is\n" +
                        "\n" +
                        "  constant xconfig : axi4_slave_config_type := (\n" +
                        "     descrtype => PNP_CFG_TYPE_SLAVE,\n" +
                        "     descrsize => PNP_CFG_SLAVE_DESCR_BYTES,\n" +
                        "     irq_idx => conv_std_logic_vector(xirq, 8),\n" +
                        "     xaddr => conv_std_logic_vector(xaddr, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     xmask => conv_std_logic_vector(xmask, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     vid => VENDOR_GNSSSENSOR,\n" +
                        "     did => GNSSSENSOR_GPIO\n" +
                        "  );\n" +
                        "\n" +
                        "  signal wb_dev_rdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "  signal wb_bus_raddr : global_addr_array_type;\n" +
                        "  signal w_bus_re    : std_logic;\n" +
                        "  signal wb_bus_waddr : global_addr_array_type;\n" +
                        "  signal w_bus_we    : std_logic;\n" +
                        "  signal wb_bus_wstrb : std_logic_vector(CFG_SYSBUS_DATA_BYTES-1 downto 0);\n" +
                        "  signal wb_bus_wdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "	\n" +
                        "  \n" +
                        "  signal Micro_Nano				: std_logic := '0'; -- Micro = 1, Nano = 0\n" +
                        "  signal Start_Stop				: std_logic := '0'; -- Start = 1, Stop = 0\n" +
                        "begin\n" +
                        "\n" +
                        "  axi0 :  axi4_slave generic map (\n" +
                        "    async_reset => async_reset\n" +
                        "  ) port map (\n" +
                        "    i_clk => clk,\n" +
                        "    i_nrst => nrst,\n" +
                        "    i_xcfg => xconfig, \n" +
                        "    i_xslvi => i,\n" +
                        "    o_xslvo => o,\n" +
                        "    i_ready => '1',\n" +
                        "    i_rdata => wb_dev_rdata,\n" +
                        "    o_re => w_bus_re,\n" +
                        "    o_r32 => open,\n" +
                        "    o_radr => wb_bus_raddr,\n" +
                        "    o_wadr => wb_bus_waddr,\n" +
                        "    o_we => w_bus_we,\n" +
                        "    o_wstrb => wb_bus_wstrb,\n" +
                        "    o_wdata => wb_bus_wdata\n" +
                        "  );\n" +
                        "  \n" +
                        "  cfg  <= xconfig;\n" +
                        "  \n" +
                        "  -- registers:\n" +
                        "  regs : process(clk, nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and nrst = '0' then\n" +
                        "			\n" +
                        "			\n" +
                        "     elsif rising_edge(clk) then \n" +
                        "			if w_bus_we = '1' then --write\n" +
                        "				IF (wb_bus_waddr(0)(4 downto 2) = \"000\") THEN\n" +
                        "					if wb_bus_wdata(7 downto 0) = X\"71\" then\n" +
                        "						Start_Stop <= '1';\n" +
                        "					elsif wb_bus_wdata(7 downto 0) = X\"53\" then\n" +
                        "						Start_Stop <= '0';\n" +
                        "					end if;\n" +
                        "				ELSIF (wb_bus_waddr(0)(4 downto 2) = \"010\") THEN\n" +
                        "					if wb_bus_wdata(7 downto 0) = X\"36\" then\n" +
                        "						Micro_Nano <= '1';\n" +
                        "					elsif wb_bus_wdata(7 downto 0) = X\"42\" then\n" +
                        "						Micro_Nano <= '0';\n" +
                        "					end if;\n" +
                        "				END IF;\n" +
                        "			elsif w_bus_re = '1' then -- read\n" +
                        "				\n" +
                        "			end if;\n" +
                        "     end if;\n" +
                        "  end process;\n" +
                        "  \n" +
                        "  TimeCalculation: entity work.Time_Calculation\n" +
                        "		port map(\n" +
                        "			clk 			=> clk,\n" +
                        "			nrst 			=> nrst,\n" +
                        "			\n" +
                        "			-- Time Signals\n" +
                        "			Time_Micro_Nano	=> open,\n" +
                        "			Micro_Nano			=> Micro_Nano,\n" +
                        "			Start_Stop			=> Start_Stop,\n" +
                        "			\n" +
                        "			-- HEX interface\n" +
                        "			HEX0					=> HEX0,\n" +
                        "			HEX1					=> HEX1,\n" +
                        "			HEX2					=> HEX2,\n" +
                        "			HEX3					=> HEX3\n" +
                        "		);\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_axi4_ton_vhd_file(String Project_Folder_File) {
        String data =   "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.numeric_std.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--! AMBA system bus specific library.\n" +
                        "--library ambalib;\n" +
                        "--! AXI4 configuration constants.\n" +
                        "use work.types_amba4.all;\n" +
                        "\n" +
                        "--! The following registers are defined:\n" +
                        "--! |---------|-------------------|\n" +
                        "--! | Address | Description       |\n" +
                        "--! |---------|-------------------|\n" +
                        "--! | 0x00 r  | Elapsed Time (64) |\n" +
                        "--! | 0x08 r  | Q                 |\n" +
                        "--! | 0x00 w  | Preset  Time (64) |\n" +
                        "--! | 0x08 w  | IN                |\n" +
                        "--! |---------|-------------------|\n" +
                        "\n" +
                        "entity axi4_ton is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr    : integer := 0;\n" +
                        "    xmask    : integer := 16#fffff#;\n" +
                        "    xirq     : integer := 0\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk  		: in std_logic;\n" +
                        "    nrst 		: in std_logic;\n" +
                        "    cfg  		: out axi4_slave_config_type;\n" +
                        "    i    		: in  axi4_slave_in_type;\n" +
                        "    o  		  	: out axi4_slave_out_type\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_axi4_ton  of axi4_ton is\n" +
                        "\n" +
                        "  constant xconfig : axi4_slave_config_type := (\n" +
                        "     descrtype => PNP_CFG_TYPE_SLAVE,\n" +
                        "     descrsize => PNP_CFG_SLAVE_DESCR_BYTES,\n" +
                        "     irq_idx => conv_std_logic_vector(xirq, 8),\n" +
                        "     xaddr => conv_std_logic_vector(xaddr, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     xmask => conv_std_logic_vector(xmask, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     vid => VENDOR_GNSSSENSOR,\n" +
                        "     did => GNSSSENSOR_GPIO\n" +
                        "  );\n" +
                        "\n" +
                        "  signal wb_dev_rdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "  signal wb_bus_raddr : global_addr_array_type;\n" +
                        "  signal w_bus_re    : std_logic;\n" +
                        "  signal wb_bus_waddr : global_addr_array_type;\n" +
                        "  signal w_bus_we    : std_logic;\n" +
                        "  signal wb_bus_wstrb : std_logic_vector(CFG_SYSBUS_DATA_BYTES-1 downto 0);\n" +
                        "  signal wb_bus_wdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "  \n" +
                        "  signal IN_T, Q   : std_logic;\n" +
                        "  signal PT, ET    : std_logic_vector(63 DOWNTO 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  axi0 :  axi4_slave generic map (\n" +
                        "    async_reset => async_reset\n" +
                        "  ) port map (\n" +
                        "    i_clk => clk,\n" +
                        "    i_nrst => nrst,\n" +
                        "    i_xcfg => xconfig, \n" +
                        "    i_xslvi => i,\n" +
                        "    o_xslvo => o,\n" +
                        "    i_ready => '1',\n" +
                        "    i_rdata => wb_dev_rdata,\n" +
                        "    o_re => w_bus_re,\n" +
                        "    o_r32 => open,\n" +
                        "    o_radr => wb_bus_raddr,\n" +
                        "    o_wadr => wb_bus_waddr,\n" +
                        "    o_we => w_bus_we,\n" +
                        "    o_wstrb => wb_bus_wstrb,\n" +
                        "    o_wdata => wb_bus_wdata\n" +
                        "  );\n" +
                        "  \n" +
                        "  Counter: entity work.Counter_Down_64_bit_Cin  PORT MAP(IN_T, clk, PT, Q, ET);\n" +
                        "\n" +
                        "  cfg  <= xconfig;\n" +
                        "  \n" +
                        "  -- registers:\n" +
                        "  regs : process(clk, nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and nrst = '0' then\n" +
                        "			wb_dev_rdata<= (OTHERS => '0');\n" +
                        "			PT       <= (OTHERS => '0');\n" +
                        "			IN_T     <= '0';\n" +
                        "     elsif rising_edge(clk) then \n" +
                        "			if w_bus_we = '1' then --write\n" +
                        "				IF (wb_bus_waddr(0)(3 downto 2) = \"00\") THEN\n" +
                        "					PT  <= wb_bus_wdata;\n" +
                        "				ELSIF (wb_bus_waddr(0)(3 downto 2) = \"10\") THEN\n" +
                        "					IN_T <= wb_bus_wdata(0);\n" +
                        "				END IF;\n" +
                        "			elsif w_bus_re = '1' then -- read\n" +
                        "				IF (wb_bus_raddr(0)(3 downto 2) = \"00\") THEN\n" +
                        "					wb_dev_rdata  <= ET;\n" +
                        "				ELSIF (wb_bus_raddr(0)(3 downto 2) = \"10\") THEN\n" +
                        "					wb_dev_rdata(0) <= Q;\n" +
                        "				ELSE\n" +
                        "					wb_dev_rdata <= (others => '0');\n" +
                        "				END IF;\n" +
                        "			end if;\n" +
                        "     end if;\n" +
                        "	  \n" +
                        "  end process;  \n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_axi4_pwm_vhd_file(String Project_Folder_File) {
        String data =   "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.numeric_std.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--! AMBA system bus specific library.\n" +
                        "--library ambalib;\n" +
                        "--! AXI4 configuration constants.\n" +
                        "use work.types_amba4.all;\n" +
                        "\n" +
                        "--! The following registers are defined:\n" +
                        "--! |---------|-------------------|\n" +
                        "--! | Address | Description       |\n" +
                        "--! |---------|-------------------|\n" +
                        "--! | 0x00 r  | Q                 |\n" +
                        "--! | 0x00 w  | Frequency         |\n" +
                        "--! | 0x04 w  | Duty Cycle        |\n" +
                        "--! |---------|-------------------|\n" +
                        "\n" +
                        "entity axi4_pwm is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr    : integer := 0;\n" +
                        "    xmask    : integer := 16#fffff#;\n" +
                        "    xirq     : integer := 0\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk  		: in std_logic;\n" +
                        "    clk_pwm 		: in std_logic;\n" +
                        "    nrst 		: in std_logic;\n" +
                        "    cfg  		: out axi4_slave_config_type;\n" +
                        "    i    		: in  axi4_slave_in_type;\n" +
                        "    o  		  	: out axi4_slave_out_type\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_axi4_pwm  of axi4_pwm is\n" +
                        "\n" +
                        "  constant xconfig : axi4_slave_config_type := (\n" +
                        "     descrtype => PNP_CFG_TYPE_SLAVE,\n" +
                        "     descrsize => PNP_CFG_SLAVE_DESCR_BYTES,\n" +
                        "     irq_idx => conv_std_logic_vector(xirq, 8),\n" +
                        "     xaddr => conv_std_logic_vector(xaddr, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     xmask => conv_std_logic_vector(xmask, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     vid => VENDOR_GNSSSENSOR,\n" +
                        "     did => GNSSSENSOR_GPIO\n" +
                        "  );\n" +
                        "\n" +
                        "  signal wb_dev_rdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "  signal wb_bus_raddr : global_addr_array_type;\n" +
                        "  signal w_bus_re    : std_logic;\n" +
                        "  signal wb_bus_waddr : global_addr_array_type;\n" +
                        "  signal w_bus_we    : std_logic;\n" +
                        "  signal wb_bus_wstrb : std_logic_vector(CFG_SYSBUS_DATA_BYTES-1 downto 0);\n" +
                        "  signal wb_bus_wdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "  \n" +
                        "  SIGNAL EN, Q		: std_logic;\n" +
                        "  SIGNAL DC	: std_logic_vector(6 DOWNTO 0);\n" +
                        "  SIGNAL Frq	: std_logic_vector(16 DOWNTO 0);\n" +
                        "	\n" +
                        "  SIGNAL T_Count, Comp_Count	: STD_LOGIC_VECTOR(19 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  axi0 :  axi4_slave generic map (\n" +
                        "    async_reset => async_reset\n" +
                        "  ) port map (\n" +
                        "    i_clk => clk,\n" +
                        "    i_nrst => nrst,\n" +
                        "    i_xcfg => xconfig, \n" +
                        "    i_xslvi => i,\n" +
                        "    o_xslvo => o,\n" +
                        "    i_ready => '1',\n" +
                        "    i_rdata => wb_dev_rdata,\n" +
                        "    o_re => w_bus_re,\n" +
                        "    o_r32 => open,\n" +
                        "    o_radr => wb_bus_raddr,\n" +
                        "    o_wadr => wb_bus_waddr,\n" +
                        "    o_we => w_bus_we,\n" +
                        "    o_wstrb => wb_bus_wstrb,\n" +
                        "    o_wdata => wb_bus_wdata\n" +
                        "  );\n" +
                        "  \n" +
                        "  PWM			: entity work.PWM_32_bit	PORT MAP(clk_pwm, nrst, EN, T_Count, Comp_Count, Q);\n" +
                        "  PWM_Sig	: entity work.PWM_Signal	PORT MAP(nrst, Frq, DC, T_Count, Comp_Count);\n" +
                        "\n" +
                        "  EN			<= '1';\n" +
                        "  cfg  <= xconfig;\n" +
                        "  \n" +
                        "  -- registers:\n" +
                        "  regs : process(clk, nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and nrst = '0' then\n" +
                        "			wb_dev_rdata<= (OTHERS => '0');\n" +
                        "			Frq			<= (OTHERS => '1');\n" +
                        "			DC				<= (OTHERS => '0');\n" +
                        "     elsif rising_edge(clk) then \n" +
                        "			if w_bus_we = '1' then --write\n" +
                        "				Frq	<= wb_bus_wdata(16 downto 0);\n" +
                        "				DC		<= wb_bus_wdata(38 downto 32);\n" +
                        "			elsif w_bus_re = '1' then -- read\n" +
                        "				wb_dev_rdata(0) <= Q;\n" +
                        "			end if;\n" +
                        "     end if;\n" +
                        "  end process;\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_Counter_Down_64_bit_Cin_vhd_file(String Project_Folder_File) {
        String data =   "--\n" +
                        "-- VHDL Architecture Hossameldin_VHDL.Counter_Up_Down_4_bit_Cin_2_to_13.rtl\n" +
                        "--\n" +
                        "-- Created:\n" +
                        "--          by - Hossameldin.UNKNOWN (HOSSAMELDIN-PC)\n" +
                        "--          at - 13:34:57 11/20/2016\n" +
                        "--\n" +
                        "-- using Mentor Graphics HDL Designer(TM) 2007.1 (Build 19)\n" +
                        "--\n" +
                        "LIBRARY ieee;\n" +
                        "USE ieee.std_logic_1164.ALL;\n" +
                        "USE IEEE.STD_LOGIC_ARITH.ALL;\n" +
                        "\n" +
                        "ENTITY Counter_Down_64_bit_Cin IS\n" +
                        "	port(En, clk  : in std_logic;\n" +
                        "        C_in     : in std_logic_vector(63 downto 0);\n" +
                        "        ov       : out std_logic;    -- over flow\n" +
                        "        C_Out    : out std_logic_vector(63 downto 0)\n" +
                        "	); \n" +
                        "END ENTITY Counter_Down_64_bit_Cin;\n" +
                        "\n" +
                        "--\n" +
                        "ARCHITECTURE rtl OF Counter_Down_64_bit_Cin IS\n" +
                        "signal C_Tmp, C_O_Tmp, C_in_un : unsigned(63 downto 0);\n" +
                        "BEGIN\n" +
                        "	process(clk, En)\n" +
                        "	begin\n" +
                        "		C_in_un <= unsigned(C_in);\n" +
                        "		if En = '0' then \n" +
                        "			C_Tmp   <= C_in_un;\n" +
                        "			C_O_Tmp <= (others => '0'); \n" +
                        "			ov <='0';\n" +
                        "		elsif rising_edge(clk) then\n" +
                        "			if C_Tmp < 1 then \n" +
                        "				C_Tmp   <= (others => '0'); \n" +
                        "				ov <='1';\n" +
                        "			else \n" +
                        "				C_Tmp   <= C_Tmp - 1;\n" +
                        "				C_O_Tmp <= C_O_Tmp + 1;\n" +
                        "				ov <='0';\n" +
                        "			end if;\n" +
                        "		end if;\n" +
                        "	end process;\n" +
                        "	C_Out <= std_logic_vector(C_O_Tmp);\n" +
                        "END ARCHITECTURE rtl;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_PWM_32_bit_vhd_file(String Project_Folder_File) {
        String data =   "library IEEE;\n" +
                        "USE IEEE.STD_LOGIC_1164.ALL;\n" +
                        "USE IEEE.STD_LOGIC_UNSIGNED.ALL;\n" +
                        "USE IEEE.NUMERIC_STD.ALL;\n" +
                        "\n" +
                        "entity PWM_32_bit is\n" +
                        "port( clk, nrst	: in STD_LOGIC;\n" +
                        "		EN				: in STD_LOGIC;\n" +
                        "		T_Count		: in STD_LOGIC_VECTOR(19 downto 0);\n" +
                        "		Comp_Count	: in STD_LOGIC_VECTOR(19 downto 0);\n" +
                        "		Y_OUT			: out STD_LOGIC\n" +
                        "		);\n" +
                        "end;\n" +
                        "\n" +
                        "architecture RTL of PWM_32_bit is\n" +
                        "	SIGNAL T_Count_T, Comp_Count_T	: STD_LOGIC_VECTOR(19 downto 0);\n" +
                        "	\n" +
                        "	begin\n" +
                        "	\n" +
                        "	process(clk, nrst)\n" +
                        "		begin\n" +
                        "		if nrst = '0' then \n" +
                        "			T_Count_T		<= (others => '0');\n" +
                        "			Comp_Count_T	<= (others => '0');\n" +
                        "			Y_OUT				<= '0';\n" +
                        "		elsif (rising_edge(clk) and EN = '1') then\n" +
                        "			if T_Count_T = \"00000000000000000000\" then\n" +
                        "				T_Count_T		<= T_Count;\n" +
                        "				Comp_Count_T	<= Comp_Count;\n" +
                        "				Y_OUT				<= '0';\n" +
                        "			else\n" +
                        "				T_Count_T	<= T_Count_T - \"00000000000000000001\";\n" +
                        "				if unsigned(T_Count_T) < unsigned(Comp_Count_T) then\n" +
                        "					Y_OUT <= '1';\n" +
                        "				else\n" +
                        "					Y_OUT <= '0';\n" +
                        "				end if;\n" +
                        "			end if;\n" +
                        "		end if;\n" +
                        "	end process;\n" +
                        "	\n" +
                        "end RTL;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_PWM_Signal_vhd_file(String Project_Folder_File) {
        String data =   "library IEEE;\n" +
                        "USE IEEE.STD_LOGIC_1164.ALL;\n" +
                        "\n" +
                        "--------------------------------\n" +
                        "-- T_Count = clk_Hz / Frq\n" +
                        "-- Comp_Count_0 = (T_Count/100)\n" +
                        "-- Comp_Count = Comp_Count_0 * DC\n" +
                        "--------------------------------\n" +
                        "\n" +
                        "entity PWM_Signal is\n" +
                        "port( nrst			: in STD_LOGIC;\n" +
                        "		Frq			: in STD_LOGIC_VECTOR(16 downto 0);\n" +
                        "		DC				: in STD_LOGIC_VECTOR(6 downto 0);\n" +
                        "		T_Count		: out STD_LOGIC_VECTOR(19 downto 0);\n" +
                        "		Comp_Count	: out STD_LOGIC_VECTOR(19 downto 0)\n" +
                        "		);\n" +
                        "end;\n" +
                        "\n" +
                        "architecture RTL of PWM_Signal is\n" +
                        "	\n" +
                        "	signal Comp_Count_0, T_Count_T	: std_logic_vector(19 downto 0);\n" +
                        "	signal Frq_T	: std_logic_vector(16 downto 0);\n" +
                        "	signal result			: std_logic_vector(26 downto 0);\n" +
                        "	begin\n" +
                        "	\n" +
                        "	Comp_Count	<= result(19 downto 0);\n" +
                        "	T_Count	<= T_Count_T;\n" +
                        "	\n" +
                        "	Div1: entity work.div_int_20_17_speed	PORT MAP(Frq_T, X\"F4240\", T_Count_T, open);	-- T_Count = clk_Hz / Frq\n" +
                        "	Div2: entity work.div_int_20_7_speed	PORT MAP(\"1100100\", T_Count_T, Comp_Count_0, open);	-- Comp_Count_0 = (T_Count/100)\n" +
                        "	Mult: entity work.mul_int_20_7	PORT MAP(Comp_Count_0, DC, result);							-- Comp_Count = Comp_Count_0 * DC\n" +
                        "	\n" +
                        "	process(Frq)\n" +
                        "	begin\n" +
                        "		if( Frq = \"00000000000000000\") or (nrst = '0') then\n" +
                        "			Frq_T <= (others => '1');\n" +
                        "		else\n" +
                        "			Frq_T <= Frq;\n" +
                        "		end if;\n" +
                        "	end process;\n" +
                        "end RTL;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_Time_Calculation_vhd_file(String Project_Folder_File) {
        String data =   "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.numeric_std.all;\n" +
                        "\n" +
                        "entity Time_Calculation is\n" +
                        "	port(\n" +
                        "		clk 			: in std_logic;\n" +
                        "		nrst 		: in std_logic;\n" +
                        "		\n" +
                        "		-- Time Signals\n" +
                        "		Time_Micro_Nano	: out std_logic_vector(31 downto 0);\n" +
                        "		Micro_Nano			: in std_logic; -- Micro = 1, Nano = 0\n" +
                        "		Start_Stop			: in std_logic; -- Start = 1, Stop = 0\n" +
                        "		\n" +
                        "		-- HEX interface\n" +
                        "		HEX0					: OUT STD_LOGIC_VECTOR(6 DOWNTO 0);\n" +
                        "		HEX1					: OUT STD_LOGIC_VECTOR(6 DOWNTO 0);\n" +
                        "		HEX2					: OUT STD_LOGIC_VECTOR(6 DOWNTO 0);\n" +
                        "		HEX3					: OUT STD_LOGIC_VECTOR(6 DOWNTO 0)\n" +
                        "	);\n" +
                        "end entity Time_Calculation;\n" +
                        "\n" +
                        "architecture behaviour of Time_Calculation is\n" +
                        "\n" +
                        "signal counter 					: unsigned(31 downto 0);\n" +
                        "signal Time_Micro_Nano_S		: unsigned(31 downto 0);\n" +
                        "signal Time_Micro_Nano_S_64	: unsigned(63 downto 0);\n" +
                        "signal Time_Micro_Nano_S_std	: std_logic_vector(31 downto 0);\n" +
                        "signal write_data					: std_logic;\n" +
                        "\n" +
                        "begin\n" +
                        "	process(clk, nrst, Micro_Nano, Start_Stop)\n" +
                        "	begin\n" +
                        "		if rising_edge(clk) then\n" +
                        "			if nrst = '0' then\n" +
                        "				counter <= (others => '0');\n" +
                        "				Time_Micro_Nano_S <= (others => '0');\n" +
                        "				write_data <= '1';\n" +
                        "			else\n" +
                        "				if Start_Stop = '1' then -- Starting or started\n" +
                        "					write_data <= '0';\n" +
                        "					counter <= counter + 1;\n" +
                        "					--if Micro_Nano = '1' then -- Micro\n" +
                        "						--Time_Micro_Nano_S	<= counter / 100;\n" +
                        "						Time_Micro_Nano_S	<= counter; -- mult and div take time (will not used)\n" +
                        "					--else -- Nano\n" +
                        "						--Time_Micro_Nano_S_64	<= counter * 10;\n" +
                        "						--Time_Micro_Nano_S		<= Time_Micro_Nano_S_64(31 downto 0);\n" +
                        "						--Time_Micro_Nano_S	<= counter; -- mult and div take time (will not used)\n" +
                        "					--end if;\n" +
                        "				else -- Stopping or stop\n" +
                        "					counter <= (others => '0');\n" +
                        "					write_data <= '1';\n" +
                        "				end if;\n" +
                        "			end if;\n" +
                        "		end if;\n" +
                        "	end process;\n" +
                        "	\n" +
                        "	Time_Micro_Nano_S_std <= std_logic_vector(Time_Micro_Nano_S);\n" +
                        "	--Time_Micro_Nano <= Time_Micro_Nano_S_std;\n" +
                        "	\n" +
                        "	WriteToHexa: entity work.Write_To_Hexa\n" +
                        "		port map(\n" +
                        "			clk					=> clk,\n" +
                        "			nrst					=> nrst,\n" +
                        "			\n" +
                        "			-- Time Signals\n" +
                        "			Time_micro_Nano	=> Time_Micro_Nano_S_std,\n" +
                        "			write_data			=> write_data,\n" +
                        "			\n" +
                        "			-- HEX interface\n" +
                        "			HEX0					=> HEX0,\n" +
                        "			HEX1					=> HEX1,\n" +
                        "			HEX2					=> HEX2,\n" +
                        "			HEX3					=> HEX3\n" +
                        "		);\n" +
                        "		\n" +
                        "end architecture behaviour;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_Write_To_Hexa_vhd_file(String Project_Folder_File) {
        String data =   "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.numeric_std.all;\n" +
                        "\n" +
                        "entity Write_To_Hexa is\n" +
                        "	port(\n" +
                        "		clk					: in std_logic;\n" +
                        "		nrst					: in std_logic;\n" +
                        "		\n" +
                        "		-- Time Signals\n" +
                        "		Time_micro_Nano	: in std_logic_vector(31 downto 0);\n" +
                        "		write_data			: in std_logic;\n" +
                        "		\n" +
                        "		-- HEX interface\n" +
                        "		HEX0					: OUT STD_LOGIC_VECTOR(6 DOWNTO 0);\n" +
                        "		HEX1					: OUT STD_LOGIC_VECTOR(6 DOWNTO 0);\n" +
                        "		HEX2					: OUT STD_LOGIC_VECTOR(6 DOWNTO 0);\n" +
                        "		HEX3					: OUT STD_LOGIC_VECTOR(6 DOWNTO 0)\n" +
                        "	);\n" +
                        "end entity Write_To_Hexa;\n" +
                        "\n" +
                        "architecture behaviour of Write_To_Hexa is\n" +
                        "\n" +
                        "component SEG7_LUT_4 is\n" +
                        "		port(\n" +
                        "			iDIG	: in  std_logic_vector(31 downto 0);\n" +
                        "			\n" +
                        "			oSEG0	: out std_logic_vector(6 downto 0);\n" +
                        "			oSEG1	: out std_logic_vector(6 downto 0);\n" +
                        "			oSEG2	: out std_logic_vector(6 downto 0);\n" +
                        "			oSEG3	: out std_logic_vector(6 downto 0)\n" +
                        "		);\n" +
                        "	end component;\n" +
                        "	\n" +
                        "signal Time_micro_Nano_S	: std_logic_vector(31 downto 0);\n" +
                        "signal count					: unsigned(31 downto 0) := (others => '0');\n" +
                        "signal ovf						: std_logic;\n" +
                        "\n" +
                        "begin\n" +
                        "	process(clk, nrst)\n" +
                        "	begin\n" +
                        "		if rising_edge(clk) then\n" +
                        "			if nrst = '0' then\n" +
                        "				Time_micro_Nano_S <= (others => '0');\n" +
                        "			else\n" +
                        "				if ((write_data = '1') and (ovf = '1')) then\n" +
                        "					Time_micro_Nano_S <= Time_micro_Nano;\n" +
                        "				end if;\n" +
                        "				if (count >= 10000000) then\n" +
                        "					ovf <= '1';\n" +
                        "					if write_data = '1' then\n" +
                        "						count <= (others => '0');\n" +
                        "					end if;\n" +
                        "				else\n" +
                        "					count <= count + 1;\n" +
                        "					ovf <= '0';\n" +
                        "				end if;\n" +
                        "			end if;\n" +
                        "		end if;\n" +
                        "	end process;\n" +
                        "	\n" +
                        "	lut_4: SEG7_LUT_4\n" +
                        "		port map(\n" +
                        "			iDIG => Time_micro_Nano_S,\n" +
                        "			oSEG0 => HEX0,\n" +
                        "			oSEG1 => HEX1,\n" +
                        "			oSEG2 => HEX2,\n" +
                        "			oSEG3 => HEX3\n" +
                        "		);\n" +
                        "		\n" +
                        "end architecture behaviour;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_SEG7_LUT_4_v_file(String Project_Folder_File) {
        String data =   "module SEG7_LUT_4 (	oSEG0,oSEG1,oSEG2,oSEG3,iDIG );\n" +
                        "input	[31:0]	iDIG;\n" +
                        "output	[6:0]	oSEG0,oSEG1,oSEG2,oSEG3;\n" +
                        "\n" +
                        "SEG7_LUT	u0	(	oSEG0,iDIG[3:0]		);\n" +
                        "SEG7_LUT	u1	(	oSEG1,iDIG[7:4]		);\n" +
                        "SEG7_LUT	u2	(	oSEG2,iDIG[11:8]	);\n" +
                        "SEG7_LUT	u3	(	oSEG3,iDIG[15:12]	);\n" +
                        "\n" +
                        "\n" +
                        "endmodule";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_SEG7_LUT_v_file(String Project_Folder_File) {
        String data =   "module SEG7_LUT	(	oSEG,iDIG	);\n" +
                        "input	[3:0]	iDIG;\n" +
                        "output	[6:0]	oSEG;\n" +
                        "reg		[6:0]	oSEG;\n" +
                        "\n" +
                        "always @(iDIG)\n" +
                        "begin\n" +
                        "		case(iDIG)\n" +
                        "		4'h1: oSEG = 7'b1111001;	// ---t----\n" +
                        "		4'h2: oSEG = 7'b0100100; 	// |	  |\n" +
                        "		4'h3: oSEG = 7'b0110000; 	// lt	 rt\n" +
                        "		4'h4: oSEG = 7'b0011001; 	// |	  |\n" +
                        "		4'h5: oSEG = 7'b0010010; 	// ---m----\n" +
                        "		4'h6: oSEG = 7'b0000010; 	// |	  |\n" +
                        "		4'h7: oSEG = 7'b1111000; 	// lb	 rb\n" +
                        "		4'h8: oSEG = 7'b0000000; 	// |	  |\n" +
                        "		4'h9: oSEG = 7'b0011000; 	// ---b----\n" +
                        "		4'ha: oSEG = 7'b0001000;\n" +
                        "		4'hb: oSEG = 7'b0000011;\n" +
                        "		4'hc: oSEG = 7'b1000110;\n" +
                        "		4'hd: oSEG = 7'b0100001;\n" +
                        "		4'he: oSEG = 7'b0000110;\n" +
                        "		4'hf: oSEG = 7'b0001110;\n" +
                        "		4'h0: oSEG = 7'b1000000;\n" +
                        "		endcase\n" +
                        "end\n" +
                        "\n" +
                        "endmodule";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_gencomp_vhd_file(String Project_Folder_File) {
        String data =   "-----------------------------------------------------------------------------\n" +
                        "--! @file\n" +
                        "--! @copyright Copyright 2015 GNSS Sensor Ltd. All right reserved.\n" +
                        "--! @author    Sergey Khabarov - sergeykhbr@gmail.com\n" +
                        "--! @brief     Definition of the gencomp package.\n" +
                        "--! @details   This file defines constants that are used to enable/disable\n" +
                        "--!            target dependable modules.\n" +
                        "--!            This file inherits values from the \\e grlib library that\n" +
                        "--!            that are published under GPL license. All unused values may\n" +
                        "--!            freely removed or reassigned on others values.\n" +
                        "------------------------------------------------------------------------------\n" +
                        "\n" +
                        "--! Standard library\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "\n" +
                        "--! @brief   Technologies names definition\n" +
                        "--! @details This package must be built first in a case of manual compilation\n" +
                        "--!          order (\\e ModelSim).\n" +
                        "package gencomp is\n" +
                        "\n" +
                        "--! @brief   Total number of the known technologies.\n" +
                        "--! @details These values was inherited from the \\e grlib library.\n" +
                        "constant NTECH : integer := 53;\n" +
                        "\n" +
                        "--! Prototype of the data type for mapping name on certain index.\n" +
                        "type tech_ability_type is array (0 to NTECH) of integer;\n" +
                        "\n" +
                        "--! @name  Techologies names.\n" +
                        "--! @brief Set of the predefined technology names.\n" +
                        "--! @{\n" +
                        "constant inferred    : integer := 0;  --! Behaviour simulation target.\n" +
                        "constant virtex      : integer := 1;  --! Not implemented.\n" +
                        "constant virtex2     : integer := 2;  --! Not implemented.\n" +
                        "constant memvirage   : integer := 3;  --! Not implemented.\n" +
                        "constant axcel       : integer := 4;  --! Not implemented.\n" +
                        "constant proasic     : integer := 5;  --! Not implemented.\n" +
                        "constant atc18s      : integer := 6;  --! Not implemented.\n" +
                        "constant altera      : integer := 7;  --! Not implemented.\n" +
                        "constant umc         : integer := 8;  --! Not implemented.\n" +
                        "constant rhumc       : integer := 9;  --! Not implemented.\n" +
                        "constant apa3        : integer := 10; --! Not implemented.\n" +
                        "constant spartan3    : integer := 11; --! Not implemented.\n" +
                        "constant ihp25       : integer := 12; --! Not implemented.\n" +
                        "constant rhlib18t    : integer := 13; --! Not implemented.\n" +
                        "constant virtex4     : integer := 14; --! Not implemented.\n" +
                        "constant lattice     : integer := 15; --! Not implemented.\n" +
                        "constant ut25        : integer := 16; --! Not implemented.\n" +
                        "constant spartan3e   : integer := 17; --! Not implemented.\n" +
                        "constant peregrine   : integer := 18; --! Not implemented.\n" +
                        "constant memartisan  : integer := 19; --! Not implemented.\n" +
                        "constant virtex5     : integer := 20; --! Not implemented.\n" +
                        "constant custom1     : integer := 21; --! Not implemented.\n" +
                        "constant ihp25rh     : integer := 22; --! Not implemented.\n" +
                        "constant stratix1    : integer := 23; --! Not implemented.\n" +
                        "constant stratix2    : integer := 24; --! Not implemented.\n" +
                        "constant eclipse     : integer := 25; --! Not implemented.\n" +
                        "constant stratix3    : integer := 26; --! Not implemented.\n" +
                        "constant cyclone3    : integer := 27; --! Not implemented.\n" +
                        "constant memvirage90 : integer := 28; --! Not implemented.\n" +
                        "constant tsmc90      : integer := 29; --! Not implemented.\n" +
                        "constant easic90     : integer := 30; --! Not implemented.\n" +
                        "constant atc18rha    : integer := 31; --! Not implemented.\n" +
                        "constant smic013     : integer := 32; --! Not implemented.\n" +
                        "constant tm65gpl     : integer := 33; --! Not implemented.\n" +
                        "constant axdsp       : integer := 34; --! Not implemented.\n" +
                        "constant spartan6    : integer := 35; --! Supported. Use files with the '_s6' suffix.\n" +
                        "constant virtex6     : integer := 36; --! Supported. Use files with the '_v6' suffix.\n" +
                        "constant actfus      : integer := 37; --! Not implemented.\n" +
                        "constant stratix4    : integer := 38; --! Not implemented.\n" +
                        "constant st65lp      : integer := 39; --! Not implemented.\n" +
                        "constant st65gp      : integer := 40; --! Not implemented.\n" +
                        "constant easic45     : integer := 41; --! Not implemented.\n" +
                        "constant cmos9sf     : integer := 42; --! Not implemented.\n" +
                        "constant apa3e       : integer := 43; --! Not implemented.\n" +
                        "constant apa3l       : integer := 44; --! Not implemented.\n" +
                        "constant ut130       : integer := 45; --! Not implemented.\n" +
                        "constant ut90        : integer := 46; --! Not implemented.\n" +
                        "constant gf65        : integer := 47; --! Not implemented.\n" +
                        "constant virtex7     : integer := 48; --! Not implemented.\n" +
                        "constant kintex7     : integer := 49; --! Supported. Use files with the '_k7' suffix.\n" +
                        "constant artix7      : integer := 50; --! Not implemented.\n" +
                        "constant zynq7000    : integer := 51; --! Not implemented.\n" +
                        "constant rhlib13t    : integer := 52; --! Not implemented.\n" +
                        "constant micron180   : integer := 53; --! Mikron 180nm. Use files with the '_micron180' suffix.\n" +
                        "constant cyclone_v   : integer := 53; --! Altera Cyclone V\n" +
                        "\n" +
                        "--! @}\n" +
                        "\n" +
                        "--! @name    FPGAs technologies group.\n" +
                        "--! @details It is convinient sometimes to implement one module for a group of\n" +
                        "--!          technologies, this array specifies FPGA group.\n" +
                        "constant is_fpga : tech_ability_type :=\n" +
                        "	(inferred => 1, virtex => 1, virtex2 => 1, axcel => 1,\n" +
                        "	 proasic => 1, altera => 1, apa3 => 1, spartan3 => 1,\n" +
                        "         virtex4 => 1, lattice => 1, spartan3e => 1, virtex5 => 1,\n" +
                        "	 stratix1 => 1, stratix2 => 1, eclipse => 1,\n" +
                        "	 stratix3 => 1, cyclone3 => 1, axdsp => 1,\n" +
                        "	 spartan6 => 1, virtex6 => 1, actfus => 1,\n" +
                        "	 stratix4 => 1, apa3e => 1, apa3l => 1, virtex7 => 1, kintex7 => 1,\n" +
                        "	 artix7 => 1, zynq7000 => 1, cyclone_v => 1,\n" +
                        "	 others => 0);\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_types_mem_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "--! Standard library\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--! Provide common generic log() function\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--! AMBA system bus specific library.\n" +
                        "--library ambalib;\n" +
                        "--! AXI4 configuration constants.\n" +
                        "use work.types_amba4.all;\n" +
                        "\n" +
                        "--! @brief      Declaration of 'virtual' Memory components.\n" +
                        "package types_mem is\n" +
                        "\n" +
                        "  --! @brief   Declaration of the \"virtual\" BootROM component.\n" +
                        "  --! @details BootRom start address must implements address matching to the\n" +
                        "  --!          CPU reset vector (0x200) and all processing after power-on is\n" +
                        "  --!          using this memory block. BootRom size depends of the configuration\n" +
                        "  --!          and size of the generated hex file. \n" +
                        "  --!          Component implements one-clock access to the\n" +
                        "  --!          ROM without wait-staits. Datawidth depends of the AXI4 bus\n" +
                        "  --!          configuration.\n" +
                        "  --! @param[in] tech    Generic technology selector.\n" +
                        "  --! @param[in] hex_filename     Generic argument defining hex-file location.\n" +
                        "  --! @param[in] clk     System bus clock.\n" +
                        "  --! @param[in] address Input address.\n" +
                        "  --! @param[out] data   Output data value.\n" +
                        "  component Rom_tech is\n" +
                        "  generic (\n" +
                        "	memtech : integer := 0;\n" +
                        "	abits : integer;\n" +
                        "	sim_hexfile : string;\n" +
                        "	cyc_miffile : string\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk       : in std_logic;\n" +
                        "    address   : in global_addr_array_type;\n" +
                        "    data      : out std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0)\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "\n" +
                        "  ------------------------------------------------------------------------------\n" +
                        "  --! @brief   Galileo PRN codes ROM storage:\n" +
                        "  --! @details This ROM is used in FSE Engine to form reference E1 reference\n" +
                        "  --!          signals. HEX-file isn't used for this ROM because 'inferred'\n" +
                        "  --!          module was built using \"case when\" operators.\n" +
                        "  component RomPrn_tech is\n" +
                        "  generic (\n" +
                        "    generic_tech : integer := 0\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk       : in std_logic;\n" +
                        "    i_address   : in std_logic_vector(12 downto 0);\n" +
                        "    o_data      : out std_logic_vector(31 downto 0)\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "  --! @brief   Declaration of the \"virtual\" SRAM component with unaligned access.\n" +
                        "  --! @details This module implements internal SRAM and support unaligned access \n" +
                        "  --!          without wait-states. For example it allows to read 4 bytes from\n" +
                        "  --!          address 0x3 for one clock.\n" +
                        "  --!          Component implements one-clock access without wait-staits. \n" +
                        "  --!          Datawidth depends of the AXI4 bus configuration.\n" +
                        "  --! @param[in] memtech Generic technology selector.\n" +
                        "  --! @param[in] abits   Generic argument defining SRAM size as 2**abits.\n" +
                        "  --! @param[in] clk     System bus clock.\n" +
                        "  --! @param[in] raddr   Read address.\n" +
                        "  --! @param[out] rdata  Output data value.\n" +
                        "  --! @param[in] waddr   Write address.\n" +
                        "  --! @param[in] we      Write enable.\n" +
                        "  --! @param[in] wstrb   Byte selector to form write only for the specified bytes.\n" +
                        "  --! @param[in] wdata   Write data.\n" +
                        "  component srambytes_tech is\n" +
                        "  generic (\n" +
                        "    memtech : integer := 0;\n" +
                        "    abits   : integer := 16;\n" +
                        "    init_file : string := \"\"\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk       : in std_logic;\n" +
                        "    raddr     : in global_addr_array_type;\n" +
                        "    rdata     : out std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "    waddr     : in global_addr_array_type;\n" +
                        "    we        : in std_logic;\n" +
                        "    wstrb     : in std_logic_vector(CFG_SYSBUS_DATA_BYTES-1 downto 0);\n" +
                        "    wdata     : in std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0)\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "\n" +
                        "  --! @brief Virtual SRAM block with fixed 32-bits data width.\n" +
                        "  --! @details This module doesn't support byte access and always implements\n" +
                        "  --!          4-bytes alignment.\n" +
                        "  component Ram32_tech\n" +
                        "  generic (\n" +
                        "    generic_tech   : integer := 0;\n" +
                        "    generic_abits : integer := 10\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk      : in std_logic;\n" +
                        "    i_address  : in std_logic_vector(generic_abits-1 downto 0);\n" +
                        "    i_wr_ena   : in std_logic;\n" +
                        "    i_data     : in std_logic_vector(31 downto 0);\n" +
                        "    o_data     : out std_logic_vector(31 downto 0)\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "  --! @brief Virtual SRAM block with fixed 64-bits data width.\n" +
                        "  --! @details This module doesn't support byte access and always implements\n" +
                        "  --!          4-bytes alignment.\n" +
                        "  component Ram32x2_tech\n" +
                        "  generic (\n" +
                        "    generic_tech   : integer := 0;\n" +
                        "    generic_kWords : integer := 1\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk      : in std_logic;\n" +
                        "    i_address  : in std_logic_vector(10+log2(generic_kWords)-1 downto 0);\n" +
                        "    i_wr_ena   : in std_logic_vector(1 downto 0);\n" +
                        "    i_data     : in std_logic_vector(63 downto 0);\n" +
                        "    o_data     : out std_logic_vector(63 downto 0)\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "  --! @brief Virtual SRAM block with fixed 64-bits data width.\n" +
                        "  --! @details This module doesn't support byte access and always implements\n" +
                        "  --!          8-bytes alignment.\n" +
                        "  component Ram64_tech\n" +
                        "  generic (\n" +
                        "    generic_tech   : integer := 0;\n" +
                        "    generic_abits  : integer := 4\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk      : in std_logic;\n" +
                        "    i_address  : in std_logic_vector(generic_abits-1 downto 0);\n" +
                        "    i_wr_ena   : in std_logic;\n" +
                        "    i_data     : in std_logic_vector(63 downto 0);\n" +
                        "    o_data     : out std_logic_vector(63 downto 0)\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "  --! @brief dual-port RAM declaration.\n" +
                        "  component syncram_2p_tech is\n" +
                        "  generic (\n" +
                        "    tech : integer := 0;\n" +
                        "    abits : integer := 6;\n" +
                        "    dbits : integer := 8;\n" +
                        "    sepclk : integer := 0;\n" +
                        "    wrfst : integer := 0;\n" +
                        "    testen : integer := 0;\n" +
                        "    words : integer := 0;\n" +
                        "    custombits : integer := 1\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    rclk     : in std_ulogic;\n" +
                        "    renable  : in std_ulogic;\n" +
                        "    raddress : in std_logic_vector((abits -1) downto 0);\n" +
                        "    dataout  : out std_logic_vector((dbits -1) downto 0);\n" +
                        "    wclk     : in std_ulogic;\n" +
                        "    write    : in std_ulogic;\n" +
                        "    waddress : in std_logic_vector((abits -1) downto 0);\n" +
                        "    datain   : in std_logic_vector((dbits -1) downto 0)\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "  component dpram_tech is\n" +
                        "  generic (\n" +
                        "    memtech : integer := 0;\n" +
                        "    abits   : integer := 12;\n" +
                        "    dbits   : integer := 64\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk   : in std_logic;\n" +
                        "    i_raddr : in std_logic_vector(abits-1 downto 0);\n" +
                        "    o_rdata : out std_logic_vector(dbits-1 downto 0);\n" +
                        "    i_waddr : in std_logic_vector(abits-1 downto 0);\n" +
                        "    i_wena  : in std_logic;\n" +
                        "    i_wdata : in std_logic_vector(dbits-1 downto 0)\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "  component ram_tech is generic (\n" +
                        "    memtech : integer := 0;\n" +
                        "    abits   : integer := 12;\n" +
                        "    dbits   : integer := 64\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk   : in std_logic;\n" +
                        "    i_addr  : in std_logic_vector(abits-1 downto 0);\n" +
                        "    o_rdata : out std_logic_vector(dbits-1 downto 0);\n" +
                        "    i_wena  : in std_logic;\n" +
                        "    i_wdata : in std_logic_vector(dbits-1 downto 0)\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_rom_tech_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library techmap;\n" +
                        "use work.gencomp.all;\n" +
                        "use work.types_mem.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--! AMBA system bus specific library\n" +
                        "--library ambalib;\n" +
                        "--! AXI4 configuration constants.\n" +
                        "use work.types_amba4.all;\n" +
                        "\n" +
                        "\n" +
                        "LIBRARY altera_mf;\n" +
                        "USE altera_mf.altera_mf_components.all;\n" +
                        "\n" +
                        "entity Rom_tech is\n" +
                        "generic (\n" +
                        "    memtech : integer := 0;\n" +
                        "    abits : integer;\n" +
                        "    sim_hexfile : string;\n" +
                        "	 cyc_miffile : string\n" +
                        ");\n" +
                        "port (\n" +
                        "    clk       : in std_logic;\n" +
                        "    address   : in global_addr_array_type;\n" +
                        "    data      : out std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0)\n" +
                        ");\n" +
                        "end;\n" +
                        "\n" +
                        "architecture rtl of Rom_tech is\n" +
                        "\n" +
                        "  component Rom_inferred is\n" +
                        "  generic (\n" +
                        "    abits : integer;\n" +
                        "    hex_filename : string\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk     : in  std_ulogic;\n" +
                        "    address : in global_addr_array_type;\n" +
                        "    data    : out std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0)\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "	genrom0 : if memtech = inferred or (is_fpga(memtech) /= 0 and memtech /= cyclone_v) generate\n" +
                        "      infer0 : Rom_inferred  generic map (abits, sim_hexfile)\n" +
                        "               port map (clk, address, data);\n" +
                        "	end generate;\n" +
                        "  \n" +
                        "	genrom1 : if memtech = inferred or (is_fpga(memtech) /= 0 and memtech = cyclone_v) generate\n" +
                        "		altsyncram_component : altsyncram\n" +
                        "		GENERIC MAP (\n" +
                        "			address_aclr_a => \"NONE\",\n" +
                        "			clock_enable_input_a => \"BYPASS\",\n" +
                        "			clock_enable_output_a => \"BYPASS\",\n" +
                        "			init_file => cyc_miffile,\n" +
                        "			intended_device_family => \"Cyclone V\",\n" +
                        "			lpm_hint => \"ENABLE_RUNTIME_MOD=NO\",\n" +
                        "			lpm_type => \"altsyncram\",\n" +
                        "			numwords_a => 2**(abits-3),\n" +
                        "			operation_mode => \"ROM\",\n" +
                        "			outdata_aclr_a => \"NONE\",\n" +
                        "			outdata_reg_a => \"UNREGISTERED\",\n" +
                        "			widthad_a => abits-3,\n" +
                        "			width_a => CFG_SYSBUS_DATA_BITS,\n" +
                        "			width_byteena_a => 1\n" +
                        "		)\n" +
                        "		PORT MAP (\n" +
                        "			address_a => address(0)(abits-1 downto 3),\n" +
                        "			clock0 => clk,\n" +
                        "			q_a => data\n" +
                        "		);\n" +
                        "	end generate;\n" +
                        "\n" +
                        "end; \n" +
                        "";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_ram_tech_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "\n" +
                        "--library techmap;\n" +
                        "use work.gencomp.all;\n" +
                        "use work.types_mem.all;\n" +
                        "\n" +
                        "entity ram_tech is generic (\n" +
                        "    memtech : integer := 0;\n" +
                        "    abits   : integer := 12;\n" +
                        "    dbits   : integer := 64\n" +
                        ");\n" +
                        "port (\n" +
                        "    i_clk   : in std_logic;\n" +
                        "    i_addr : in std_logic_vector(abits-1 downto 0);\n" +
                        "    o_rdata : out std_logic_vector(dbits-1 downto 0);\n" +
                        "    i_wena  : in std_logic;\n" +
                        "    i_wdata : in std_logic_vector(dbits-1 downto 0)\n" +
                        ");\n" +
                        "end;\n" +
                        "\n" +
                        "architecture rtl of ram_tech is\n" +
                        "\n" +
                        "  component ram_inferred is\n" +
                        "  generic (\n" +
                        "     abits : integer := 12;\n" +
                        "     dbits : integer := 64\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk   : in std_logic;\n" +
                        "    i_addr : in std_logic_vector(abits-1 downto 0);\n" +
                        "    o_rdata : out std_logic_vector(dbits-1 downto 0);\n" +
                        "    i_wena  : in std_logic;\n" +
                        "    i_wdata : in std_logic_vector(dbits-1 downto 0)\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  inf0 : if memtech = inferred or is_fpga(memtech) /= 0 generate\n" +
                        "      x0 : ram_inferred generic map \n" +
                        "      (\n" +
                        "          abits => abits,\n" +
                        "          dbits => dbits\n" +
                        "      ) port map (\n" +
                        "          i_clk   => i_clk,\n" +
                        "          i_addr  => i_addr,\n" +
                        "          o_rdata => o_rdata,\n" +
                        "          i_wena  => i_wena,\n" +
                        "          i_wdata => i_wdata\n" +
                        "      );\n" +
                        "  end generate;\n" +
                        "\n" +
                        "end; \n";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_srambytes_tech_vhd_file(String Project_Folder_File) {
        String data =   "----------------------------------------------------------------------------\n" +
                        "--! @file\n" +
                        "--! @copyright  Copyright 2015 GNSS Sensor Ltd. All right reserved.\n" +
                        "--! @author     Sergey Khabarov\n" +
                        "--! @brief      Internal SRAM implementation with the byte access.\n" +
                        "------------------------------------------------------------------------------\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "\n" +
                        "--library techmap;\n" +
                        "use work.gencomp.all;\n" +
                        "use work.types_mem.all;\n" +
                        "\n" +
                        "--! AMBA system bus specific library.\n" +
                        "--library ambalib;\n" +
                        "--! AXI4 configuration constants.\n" +
                        "use work.types_amba4.all;\n" +
                        "\n" +
                        "LIBRARY altera_mf;\n" +
                        "USE altera_mf.altera_mf_components.all;\n" +
                        "\n" +
                        "entity srambytes_tech is\n" +
                        "generic (\n" +
                        "    memtech : integer := 0;\n" +
                        "    abits   : integer := 16;\n" +
                        "    init_file : string := \"\"\n" +
                        ");\n" +
                        "port (\n" +
                        "    clk       : in std_logic;\n" +
                        "    raddr     : in global_addr_array_type;\n" +
                        "    rdata     : out std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "    waddr     : in global_addr_array_type;\n" +
                        "    we        : in std_logic;\n" +
                        "    wstrb     : in std_logic_vector(CFG_SYSBUS_DATA_BYTES-1 downto 0);\n" +
                        "    wdata     : in std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0)\n" +
                        ");\n" +
                        "end;\n" +
                        "\n" +
                        "architecture rtl of srambytes_tech is\n" +
                        "\n" +
                        "--! reduced name of configuration constant:\n" +
                        "constant dw : integer := CFG_SYSBUS_ADDR_OFFSET;\n" +
                        "\n" +
                        "type local_addr_type is array (0 to CFG_SYSBUS_DATA_BYTES-1) of\n" +
                        "   std_logic_vector(abits-dw-1 downto 0);\n" +
                        "\n" +
                        "signal address : local_addr_type;\n" +
                        "signal wr_ena : std_logic_vector(CFG_SYSBUS_DATA_BYTES-1 downto 0);\n" +
                        "\n" +
                        "  --! @brief   Declaration of the one-byte SRAM element.\n" +
                        "  --! @details This component is used for the FPGA implementation.\n" +
                        "  component sram8_inferred is\n" +
                        "  generic (\n" +
                        "     abits : integer := 12;\n" +
                        "     byte_idx : integer := 0\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk     : in  std_ulogic;\n" +
                        "    address : in  std_logic_vector(abits-1 downto 0);\n" +
                        "    rdata   : out std_logic_vector(7 downto 0);\n" +
                        "    we      : in  std_logic;\n" +
                        "    wdata   : in  std_logic_vector(7 downto 0)\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "  --! @brief   Declaration of the one-byte SRAM element with init function.\n" +
                        "  --! @details This component is used for the RTL simulation.\n" +
                        "  component sram8_inferred_init is\n" +
                        "  generic (\n" +
                        "     abits     : integer := 12;\n" +
                        "     byte_idx  : integer := 0;\n" +
                        "     init_file : string\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk     : in  std_ulogic;\n" +
                        "    address : in  std_logic_vector(abits-1 downto 0);\n" +
                        "    rdata   : out std_logic_vector(7 downto 0);\n" +
                        "    we      : in  std_logic;\n" +
                        "    wdata   : in  std_logic_vector(7 downto 0)\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "     \n" +
                        "  --! Instantiate component for RTL simulation\n" +
                        "  rtlsim0 : if memtech = inferred generate\n" +
                        "    rx : for n in 0 to CFG_SYSBUS_DATA_BYTES-1 generate\n" +
                        "\n" +
                        "      wr_ena(n) <= we and wstrb(n);\n" +
                        "      address(n) <= waddr(n / CFG_ALIGN_BYTES)(abits-1 downto dw) when we = '1'\n" +
                        "                else raddr(n / CFG_ALIGN_BYTES)(abits-1 downto dw);\n" +
                        "                  \n" +
                        "      x0 : sram8_inferred_init generic map \n" +
                        "      (\n" +
                        "          abits => abits-dw,\n" +
                        "          byte_idx => n,\n" +
                        "          init_file => init_file\n" +
                        "      ) port map (\n" +
                        "          clk, \n" +
                        "          address => address(n),\n" +
                        "          rdata => rdata(8*(n+1)-1 downto 8*n),\n" +
                        "          we => wr_ena(n), \n" +
                        "          wdata => wdata(8*(n+1)-1 downto 8*n)\n" +
                        "      );\n" +
                        "    end generate; -- cycle\n" +
                        "  end generate; -- tech=inferred\n" +
                        "\n" +
                        "\n" +
                        "  --! Instantiate component for FPGA (checked with Xilinx)\n" +
                        "  fpgaXilinxsim0 : if memtech /= inferred and is_fpga(memtech) /= 0 and memtech = cyclone_v generate\n" +
                        "    rx : for n in 0 to CFG_SYSBUS_DATA_BYTES-1 generate\n" +
                        "\n" +
                        "      wr_ena(n) <= we and wstrb(n);\n" +
                        "      address(n) <= waddr(n / CFG_ALIGN_BYTES)(abits-1 downto dw) when we = '1'\n" +
                        "                else raddr(n / CFG_ALIGN_BYTES)(abits-1 downto dw);\n" +
                        "\n" +
                        "      x0 : sram8_inferred generic map \n" +
                        "      (\n" +
                        "          abits => abits-dw,\n" +
                        "          byte_idx => n\n" +
                        "      ) port map (\n" +
                        "          clk, \n" +
                        "          address => address(n),\n" +
                        "          rdata => rdata(8*(n+1)-1 downto 8*n),\n" +
                        "          we => wr_ena(n), \n" +
                        "          wdata => wdata(8*(n+1)-1 downto 8*n)\n" +
                        "      );\n" +
                        "    end generate; -- cycle\n" +
                        "  end generate; -- tech=Xilinx\n" +
                        "  \n" +
                        "  --! Instantiate component for FPGA (checked with cyclone_v)\n" +
                        "  fpgaCyclonesim0 : if memtech /= inferred and is_fpga(memtech) /= 0 and memtech /= cyclone_v generate\n" +
                        "    rx : for n in 0 to CFG_SYSBUS_DATA_BYTES-1 generate\n" +
                        "\n" +
                        "      wr_ena(n) <= we and wstrb(n);\n" +
                        "      address(n) <= waddr(n / CFG_ALIGN_BYTES)(abits-1 downto dw) when we = '1'\n" +
                        "                else raddr(n / CFG_ALIGN_BYTES)(abits-1 downto dw);\n" +
                        "\n" +
                        "      x0 : altsyncram\n" +
                        "		GENERIC MAP (\n" +
                        "			clock_enable_input_a => \"BYPASS\",\n" +
                        "			clock_enable_output_a => \"BYPASS\",\n" +
                        "			intended_device_family => \"Cyclone V\",\n" +
                        "			lpm_hint => \"ENABLE_RUNTIME_MOD=NO\",\n" +
                        "			lpm_type => \"altsyncram\",\n" +
                        "			numwords_a => 2**(abits-dw),\n" +
                        "			operation_mode => \"SINGLE_PORT\",\n" +
                        "			outdata_aclr_a => \"NONE\",\n" +
                        "			outdata_reg_a => \"CLOCK0\",\n" +
                        "			power_up_uninitialized => \"FALSE\",\n" +
                        "			read_during_write_mode_port_a => \"DONT_CARE\",\n" +
                        "			widthad_a => abits-dw,\n" +
                        "			width_a => 8,\n" +
                        "			width_byteena_a => 1\n" +
                        "		)\n" +
                        "		PORT MAP (\n" +
                        "			clock0 => clk,\n" +
                        "			address_a	=> address(n),\n" +
                        "			q_a 			=> rdata(8*(n+1)-1 downto 8*n),\n" +
                        "			wren_a 		=> wr_ena(n),\n" +
                        "			data_a 		=> wdata(8*(n+1)-1 downto 8*n)\n" +
                        "		);\n" +
                        "    end generate; -- cycle\n" +
                        "  end generate; -- tech=cyclone_v\n" +
                        "  \n" +
                        "end; \n" +
                        "";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_sram8_inferred_vhd_file(String Project_Folder_File) {
        String data =   "----------------------------------------------------------------------------\n" +
                        "--! @file\n" +
                        "--! @copyright  Copyright 2015 GNSS Sensor Ltd. All right reserved.\n" +
                        "--! @author     Sergey Khabarov\n" +
                        "--! @brief      8-bits memory block with the generic data size parameter.\n" +
                        "------------------------------------------------------------------------------\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.numeric_std.ALL;\n" +
                        "use IEEE.STD_LOGIC_TEXTIO.ALL;\n" +
                        "use std.textio.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "\n" +
                        "entity sram8_inferred is\n" +
                        "  generic (\n" +
                        "    abits : integer := 12;\n" +
                        "    byte_idx : integer := 0\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk     : in  std_ulogic;\n" +
                        "    address : in  std_logic_vector(abits-1 downto 0);\n" +
                        "    rdata   : out std_logic_vector(7 downto 0);\n" +
                        "    we      : in  std_logic;\n" +
                        "    wdata   : in  std_logic_vector(7 downto 0)\n" +
                        "  );\n" +
                        "end;\n" +
                        "\n" +
                        "architecture arch_sram8_inferred of sram8_inferred is\n" +
                        "\n" +
                        "constant SRAM_LENGTH : integer := 2**abits;\n" +
                        "type ram_type is array (0 to SRAM_LENGTH-1) of std_logic_vector(7 downto 0);\n" +
                        "\n" +
                        "signal ram : ram_type;\n" +
                        "signal adr : std_logic_vector(abits-1 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  reg : process (clk, address, wdata) begin\n" +
                        "    if rising_edge(clk) then \n" +
                        "      if we = '1' then\n" +
                        "        ram(conv_integer(address)) <= wdata;\n" +
                        "      end if;\n" +
                        "      adr <= address;\n" +
                        "    end if;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  rdata <= ram(conv_integer(adr));\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_ram_inferred_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.numeric_std.ALL;\n" +
                        "use std.textio.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "\n" +
                        "entity ram_inferred is generic (\n" +
                        "    abits : integer := 12;\n" +
                        "    dbits : integer := 64\n" +
                        ");\n" +
                        "port (\n" +
                        "    i_clk   : in std_logic;\n" +
                        "    i_addr : in std_logic_vector(abits-1 downto 0);\n" +
                        "    o_rdata : out std_logic_vector(dbits-1 downto 0);\n" +
                        "    i_wena  : in std_logic;\n" +
                        "    i_wdata : in std_logic_vector(dbits-1 downto 0)\n" +
                        ");\n" +
                        "end;\n" +
                        "\n" +
                        "architecture rtl of ram_inferred is\n" +
                        "\n" +
                        "constant SRAM_LENGTH : integer := 2**abits;\n" +
                        "type ram_type is array (0 to SRAM_LENGTH-1) of std_logic_vector(dbits-1 downto 0);\n" +
                        "\n" +
                        "signal ram : ram_type;\n" +
                        "signal radr : std_logic_vector(abits-1 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  reg : process (i_clk) begin\n" +
                        "    if rising_edge(i_clk) then \n" +
                        "      radr <= i_addr;\n" +
                        "      if i_wena = '1' then\n" +
                        "        ram(conv_integer(i_addr)) <= i_wdata;\n" +
                        "      end if;\n" +
                        "    end if;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  o_rdata <= ram(conv_integer(radr));\n" +
                        "\n" +
                        "end; \n" +
                        "";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_types_river_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2018 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "--! Standard library.\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.numeric_std.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--! AMBA system bus specific library.\n" +
                        "--library ambalib;\n" +
                        "--! AXI4 configuration constants.\n" +
                        "use work.types_amba4.all;\n" +
                        "use work.types_bus0.all; -- TODO: REMOVE ME when update dsu\n" +
                        "\n" +
                        "--! RIVER CPU specific library.\n" +
                        "--library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use work.river_cfg.all;\n" +
                        "\n" +
                        "--! @brief   Declaration of components visible on SoC top level.\n" +
                        "package types_river is\n" +
                        "\n" +
                        "constant CFG_CORES_PER_DSU_MAX : integer := 2;\n" +
                        "\n" +
                        "type dport_in_type is record\n" +
                        "    valid : std_logic;\n" +
                        "    write : std_logic;\n" +
                        "    region : std_logic_vector(1 downto 0);\n" +
                        "    addr : std_logic_vector(11 downto 0);\n" +
                        "    wdata : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "end record;\n" +
                        "\n" +
                        "constant dport_in_none : dport_in_type := (\n" +
                        "  '0', '0', (others => '0'), (others => '0'), (others => '0'));\n" +
                        "\n" +
                        "type dport_in_vector is array (0 to CFG_CORES_PER_DSU_MAX-1) \n" +
                        "       of dport_in_type;\n" +
                        "\n" +
                        "\n" +
                        "type dport_out_type is record\n" +
                        "    halted : std_logic;\n" +
                        "    ready : std_logic;\n" +
                        "    rdata : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "end record;\n" +
                        "\n" +
                        "constant dport_out_none : dport_out_type := (\n" +
                        "    '0', '1', (others => '0'));\n" +
                        "\n" +
                        "type dport_out_vector is array (0 to CFG_CORES_PER_DSU_MAX-1) \n" +
                        "     of dport_out_type;\n" +
                        "\n" +
                        "  --! @brief   Declaration of the Debug Support Unit with the AXI interface.\n" +
                        "  --! @details This module provides access to processors CSRs via HostIO bus.\n" +
                        "  --! @param[in] clk           System clock (BUS/CPU clock).\n" +
                        "  --! @param[in] rstn          Reset signal with active LOW level.\n" +
                        "  --! @param[in] i_axi         Slave slot input signals.\n" +
                        "  --! @param[out] o_axi        Slave slot output signals.\n" +
                        "  --! @param[out] o_dporti     Debug port output signals connected to River CPU.\n" +
                        "  --! @param[in] i_dporto      River CPU debug port response signals.\n" +
                        "  --! @param[out] o_soft_rstn  Software reset CPU and interrupt controller. Active HIGH\n" +
                        "  --! @param[in] i_bus_util_w  Write bus access utilization per master statistic\n" +
                        "  --! @param[in] i_bus_util_r  Write bus access utilization per master statistic\n" +
                        "  component axi_dsu is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr    : integer := 0;\n" +
                        "    xmask    : integer := 16#fffff#\n" +
                        "  );\n" +
                        "  port \n" +
                        "  (\n" +
                        "    clk    : in std_logic;\n" +
                        "    nrst   : in std_logic;\n" +
                        "    o_cfg  : out axi4_slave_config_type;\n" +
                        "    i_axi  : in axi4_slave_in_type;\n" +
                        "    o_axi  : out axi4_slave_out_type;\n" +
                        "    o_dporti : out dport_in_vector;\n" +
                        "    i_dporto : in dport_out_vector;\n" +
                        "    o_soft_rst : out std_logic;\n" +
                        "    i_bus_util_w : in std_logic_vector(CFG_BUS0_XMST_TOTAL-1 downto 0);\n" +
                        "    i_bus_util_r : in std_logic_vector(CFG_BUS0_XMST_TOTAL-1 downto 0)\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "\n" +
                        "--! @brief   RIVER CPU component declaration.\n" +
                        "--! @details This module implements Risc-V CPU Core named as\n" +
                        "--!          \"RIVER\" with AXI interface.\n" +
                        "--! @param[in] xindex AXI master index\n" +
                        "--! @param[in] i_rstn     Reset signal with active LOW level.\n" +
                        "--! @param[in] i_clk      System clock (BUS/CPU clock).\n" +
                        "--! @param[in] i_msti     Bus-to-Master device signals.\n" +
                        "--! @param[out] o_msto    CachedTile-to-Bus request signals.\n" +
                        "--! @param[in] i_ext_irq  Interrupts line supported by Rocket chip.\n" +
                        "component river_amba is \n" +
                        "  generic (\n" +
                        "    memtech : integer;\n" +
                        "    hartid : integer;\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port ( \n" +
                        "    i_nrst   : in std_logic;\n" +
                        "    i_clk    : in std_logic;\n" +
                        "    i_msti   : in axi4_master_in_type;\n" +
                        "    o_msto   : out axi4_master_out_type;\n" +
                        "    o_mstcfg : out axi4_master_config_type;\n" +
                        "    i_dport  : in dport_in_type;\n" +
                        "    o_dport  : out dport_out_type;\n" +
                        "    i_ext_irq : in std_logic\n" +
                        "  );\n" +
                        "end component;\n" +
                        "\n" +
                        "end; -- package body";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_river_top_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2018 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "--library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use work.river_cfg.all;\n" +
                        "\n" +
                        "entity river_top is\n" +
                        "  generic (\n" +
                        "    memtech : integer := 0;\n" +
                        "    hartid : integer := 0;\n" +
                        "    async_reset : boolean := false\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;                                             -- CPU clock\n" +
                        "    i_nrst : in std_logic;                                            -- Reset. Active LOW.\n" +
                        "    -- Memory interface:\n" +
                        "    i_req_mem_ready : in std_logic;                                   -- AXI request was accepted\n" +
                        "    o_req_mem_valid : out std_logic;                                  -- AXI memory request is valid\n" +
                        "    o_req_mem_write : out std_logic;                                  -- AXI memory request is write type\n" +
                        "    o_req_mem_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0); -- AXI memory request address\n" +
                        "    o_req_mem_strob : out std_logic_vector(BUS_DATA_BYTES-1 downto 0);-- Writing strob. 1 bit per Byte\n" +
                        "    o_req_mem_data : out std_logic_vector(BUS_DATA_WIDTH-1 downto 0); -- Writing data\n" +
                        "    o_req_mem_len : out std_logic_vector(7 downto 0);                 -- burst length\n" +
                        "    o_req_mem_burst : out std_logic_vector(1 downto 0);               -- burst type: \"00\" FIX; \"01\" INCR; \"10\" WRAP\n" +
                        "    i_resp_mem_data_valid : in std_logic;                             -- AXI response is valid\n" +
                        "    i_resp_mem_data : in std_logic_vector(BUS_DATA_WIDTH-1 downto 0); -- Read data\n" +
                        "    i_resp_mem_load_fault : in std_logic;                             -- Bus response with SLVERR or DECERR on read\n" +
                        "    i_resp_mem_store_fault : in std_logic;                            -- Bus response with SLVERR or DECERR on write\n" +
                        "    i_resp_mem_store_fault_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    -- Interrupt line from external interrupts controller (PLIC).\n" +
                        "    i_ext_irq : in std_logic;\n" +
                        "    o_time : out std_logic_vector(63 downto 0);                       -- Timer. Clock counter except halt state.\n" +
                        "    -- Debug interface:\n" +
                        "    i_dport_valid : in std_logic;                                     -- Debug access from DSU is valid\n" +
                        "    i_dport_write : in std_logic;                                     -- Write command flag\n" +
                        "    i_dport_region : in std_logic_vector(1 downto 0);                 -- Registers region ID: 0=CSR; 1=IREGS; 2=Control\n" +
                        "    i_dport_addr : in std_logic_vector(11 downto 0);                  -- Register idx\n" +
                        "    i_dport_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0);       -- Write value\n" +
                        "    o_dport_ready : out std_logic;                                    -- Response is ready\n" +
                        "    o_dport_rdata : out std_logic_vector(RISCV_ARCH-1 downto 0);      -- Response value\n" +
                        "    o_halted : out std_logic\n" +
                        "  );\n" +
                        "end;\n" +
                        " \n" +
                        "architecture arch_RiverTop of river_top is\n" +
                        "\n" +
                        "  -- Control path:\n" +
                        "  signal w_req_ctrl_ready : std_logic;\n" +
                        "  signal w_req_ctrl_valid : std_logic;\n" +
                        "  signal wb_req_ctrl_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "  signal w_resp_ctrl_valid : std_logic;\n" +
                        "  signal wb_resp_ctrl_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "  signal wb_resp_ctrl_data : std_logic_vector(31 downto 0);\n" +
                        "  signal w_resp_ctrl_load_fault : std_logic;\n" +
                        "  signal w_resp_ctrl_ready : std_logic;\n" +
                        "  -- Data path:\n" +
                        "  signal w_req_data_ready : std_logic;\n" +
                        "  signal w_req_data_valid : std_logic;\n" +
                        "  signal w_req_data_write : std_logic;\n" +
                        "  signal wb_req_data_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "  signal wb_req_data_size : std_logic_vector(1 downto 0);\n" +
                        "  signal wb_req_data_data : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "  signal w_resp_data_valid : std_logic;\n" +
                        "  signal wb_resp_data_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "  signal wb_resp_data_data : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "  signal w_resp_data_load_fault : std_logic;\n" +
                        "  signal w_resp_data_store_fault : std_logic;\n" +
                        "  signal wb_resp_data_store_fault_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "  signal w_resp_data_ready : std_logic;\n" +
                        "  signal wb_flush_address : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "  signal w_flush_valid : std_logic;\n" +
                        "  signal wb_istate : std_logic_vector(1 downto 0);\n" +
                        "  signal wb_dstate : std_logic_vector(1 downto 0);\n" +
                        "  signal wb_cstate : std_logic_vector(1 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "    proc0 : Processor generic map (\n" +
                        "        hartid => hartid,\n" +
                        "        async_reset => async_reset\n" +
                        "      ) port map (\n" +
                        "        i_clk => i_clk,\n" +
                        "        i_nrst => i_nrst,\n" +
                        "        i_req_ctrl_ready => w_req_ctrl_ready,\n" +
                        "        o_req_ctrl_valid => w_req_ctrl_valid,\n" +
                        "        o_req_ctrl_addr => wb_req_ctrl_addr,\n" +
                        "        i_resp_ctrl_valid => w_resp_ctrl_valid,\n" +
                        "        i_resp_ctrl_addr => wb_resp_ctrl_addr,\n" +
                        "        i_resp_ctrl_data => wb_resp_ctrl_data,\n" +
                        "        i_resp_ctrl_load_fault => w_resp_ctrl_load_fault,\n" +
                        "        o_resp_ctrl_ready => w_resp_ctrl_ready,\n" +
                        "        i_req_data_ready => w_req_data_ready,\n" +
                        "        o_req_data_valid => w_req_data_valid,\n" +
                        "        o_req_data_write => w_req_data_write,\n" +
                        "        o_req_data_addr => wb_req_data_addr,\n" +
                        "        o_req_data_size => wb_req_data_size,\n" +
                        "        o_req_data_data => wb_req_data_data,\n" +
                        "        i_resp_data_valid => w_resp_data_valid,\n" +
                        "        i_resp_data_addr => wb_resp_data_addr,\n" +
                        "        i_resp_data_data => wb_resp_data_data,\n" +
                        "        i_resp_data_load_fault => w_resp_data_load_fault,\n" +
                        "        i_resp_data_store_fault => w_resp_data_store_fault,\n" +
                        "        i_resp_data_store_fault_addr => wb_resp_data_store_fault_addr,\n" +
                        "        o_resp_data_ready => w_resp_data_ready,\n" +
                        "        i_ext_irq => i_ext_irq,\n" +
                        "        o_time => o_time,\n" +
                        "        i_dport_valid => i_dport_valid,\n" +
                        "        i_dport_write => i_dport_write,\n" +
                        "        i_dport_region => i_dport_region,\n" +
                        "        i_dport_addr => i_dport_addr,\n" +
                        "        i_dport_wdata => i_dport_wdata,\n" +
                        "        o_dport_ready => o_dport_ready,\n" +
                        "        o_dport_rdata => o_dport_rdata,\n" +
                        "        o_halted => o_halted,\n" +
                        "        o_flush_address => wb_flush_address,\n" +
                        "        o_flush_valid => w_flush_valid,\n" +
                        "        i_istate => wb_istate,\n" +
                        "        i_dstate => wb_dstate,\n" +
                        "        i_cstate => wb_cstate);\n" +
                        "\n" +
                        "    cache0 :  CacheTop generic map (\n" +
                        "        memtech => memtech,\n" +
                        "        async_reset => async_reset\n" +
                        "     ) port map (\n" +
                        "        i_clk => i_clk,\n" +
                        "        i_nrst => i_nrst,\n" +
                        "        i_req_ctrl_valid => w_req_ctrl_valid,\n" +
                        "        i_req_ctrl_addr => wb_req_ctrl_addr,\n" +
                        "        o_req_ctrl_ready => w_req_ctrl_ready,\n" +
                        "        o_resp_ctrl_valid => w_resp_ctrl_valid,\n" +
                        "        o_resp_ctrl_addr => wb_resp_ctrl_addr,\n" +
                        "        o_resp_ctrl_data => wb_resp_ctrl_data,\n" +
                        "        o_resp_ctrl_load_fault => w_resp_ctrl_load_fault,\n" +
                        "        i_resp_ctrl_ready => w_resp_ctrl_ready,\n" +
                        "        i_req_data_valid => w_req_data_valid,\n" +
                        "        i_req_data_write => w_req_data_write,\n" +
                        "        i_req_data_addr => wb_req_data_addr,\n" +
                        "        i_req_data_size => wb_req_data_size,\n" +
                        "        i_req_data_data => wb_req_data_data,\n" +
                        "        o_req_data_ready => w_req_data_ready,\n" +
                        "        o_resp_data_valid => w_resp_data_valid,\n" +
                        "        o_resp_data_addr => wb_resp_data_addr,\n" +
                        "        o_resp_data_data => wb_resp_data_data,\n" +
                        "        o_resp_data_load_fault => w_resp_data_load_fault,\n" +
                        "        o_resp_data_store_fault => w_resp_data_store_fault,\n" +
                        "        o_resp_data_store_fault_addr => wb_resp_data_store_fault_addr,\n" +
                        "        i_resp_data_ready => w_resp_data_ready,\n" +
                        "        i_req_mem_ready => i_req_mem_ready,\n" +
                        "        o_req_mem_valid => o_req_mem_valid,\n" +
                        "        o_req_mem_write => o_req_mem_write,\n" +
                        "        o_req_mem_addr => o_req_mem_addr,\n" +
                        "        o_req_mem_strob => o_req_mem_strob,\n" +
                        "        o_req_mem_data => o_req_mem_data,\n" +
                        "        o_req_mem_len => o_req_mem_len,\n" +
                        "        o_req_mem_burst => o_req_mem_burst,\n" +
                        "        i_resp_mem_data_valid => i_resp_mem_data_valid,\n" +
                        "        i_resp_mem_data => i_resp_mem_data,\n" +
                        "        i_resp_mem_load_fault => i_resp_mem_load_fault,\n" +
                        "        i_resp_mem_store_fault => i_resp_mem_store_fault,\n" +
                        "        i_resp_mem_store_fault_addr => i_resp_mem_store_fault_addr,\n" +
                        "        i_flush_address => wb_flush_address,\n" +
                        "        i_flush_valid => w_flush_valid,\n" +
                        "        o_istate => wb_istate,\n" +
                        "        o_dstate => wb_dstate,\n" +
                        "        o_cstate => wb_cstate);\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_river_cfg_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2018 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "--! Standard library.\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.numeric_std.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "\n" +
                        "library work;\n" +
                        "--! Target dependable configuration: RTL, FPGA or ASIC.\n" +
                        "use work.config_target.all;\n" +
                        "\n" +
                        "--! @brief   Library global parameters.\n" +
                        "package river_cfg is\n" +
                        "\n" +
                        "  constant CFG_VENDOR_ID : std_logic_vector(31 downto 0) := X\"000000F1\";\n" +
                        "  constant CFG_IMPLEMENTATION_ID : std_logic_vector(31 downto 0) := X\"20190521\";\n" +
                        "  constant CFG_HW_FPU_ENABLE : boolean := CFG_FPU_ENABLE;\n" +
                        "\n" +
                        "  -- When false use Dual-port memory banks\n" +
                        "  constant CFG_SINGLEPORT_CACHE : boolean := true;\n" +
                        "\n" +
                        "  -- [13:6]  8: index: 8 KB per odd/even ways (64 KB total: ways=4)\n" +
                        "  -- [12:6]  7: index: 4 KB per odd/even ways (32 KB total: ways=4)\n" +
                        "  -- [11:6]  6: index: 2 KB per odd/even ways (16 KB total: ways=4)\n" +
                        "  constant CFG_IINDEX_WIDTH : integer := 6;    -- log2(LINES_PER_WAY)\n" +
                        "\n" +
                        "  --! Architecture size difinition.\n" +
                        "  constant RISCV_ARCH : integer := 64;\n" +
                        "\n" +
                        "  --! @name System bus parameters\n" +
                        "  --! @brief Constants specify AXI bus global settigns\n" +
                        "  --! @{\n" +
                        "\n" +
                        "  --! @brief   Address bus bit-size.\n" +
                        "  constant BUS_ADDR_WIDTH : integer := 32;\n" +
                        "  --! @brief   Data bus bit-size.\n" +
                        "  constant BUS_DATA_WIDTH : integer := 64;\n" +
                        "  --! @brief   Num of data bytes per transaction.\n" +
                        "  constant BUS_DATA_BYTES : integer := BUS_DATA_WIDTH / 8;\n" +
                        "  --! @}\n" +
                        "\n" +
                        "  --! @name   Encoded Memory operation size values\n" +
                        "  --! @{\n" +
                        "\n" +
                        "  constant MEMOP_8B : std_logic_vector(1 downto 0) := \"11\";\n" +
                        "  constant MEMOP_4B : std_logic_vector(1 downto 0) := \"10\";\n" +
                        "  constant MEMOP_2B : std_logic_vector(1 downto 0) := \"01\";\n" +
                        "  constant MEMOP_1B : std_logic_vector(1 downto 0) := \"00\";\n" +
                        "  --! @}\n" +
                        "  \n" +
                        "  --! Non-maskable interrupts (exceptions) table.\n" +
                        "  --!  It can be freely changed to optimize memory consumption/performance\n" +
                        "  --!\n" +
                        "  constant CFG_NMI_RESET_VECTOR         : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0) := X\"00000000\";\n" +
                        "  constant CFG_NMI_INSTR_UNALIGNED_ADDR : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0) := X\"00000008\";\n" +
                        "  constant CFG_NMI_INSTR_FAULT_ADDR     : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0) := X\"00000010\";\n" +
                        "  constant CFG_NMI_INSTR_ILLEGAL_ADDR   : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0) := X\"00000018\";\n" +
                        "  constant CFG_NMI_BREAKPOINT_ADDR      : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0) := X\"00000020\";\n" +
                        "  constant CFG_NMI_LOAD_UNALIGNED_ADDR  : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0) := X\"00000028\";\n" +
                        "  constant CFG_NMI_LOAD_FAULT_ADDR      : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0) := X\"00000030\";\n" +
                        "  constant CFG_NMI_STORE_UNALIGNED_ADDR : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0) := X\"00000038\";\n" +
                        "  constant CFG_NMI_STORE_FAULT_ADDR     : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0) := X\"00000040\";\n" +
                        "  constant CFG_NMI_CALL_FROM_UMODE_ADDR : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0) := X\"00000048\";\n" +
                        "  constant CFG_NMI_CALL_FROM_SMODE_ADDR : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0) := X\"00000050\";\n" +
                        "  constant CFG_NMI_CALL_FROM_HMODE_ADDR : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0) := X\"00000058\";\n" +
                        "  constant CFG_NMI_CALL_FROM_MMODE_ADDR : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0) := X\"00000060\";\n" +
                        "  constant CFG_NMI_STACK_OVERFLOW_ADDR  : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0) := X\"00000068\";\n" +
                        "  constant CFG_NMI_STACK_UNDERFLOW_ADDR : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0) := X\"00000070\";\n" +
                        "\n" +
                        "  constant DBG_FETCH_TRACE_SIZE : integer := 4;\n" +
                        "\n" +
                        "  --! Number of elements each 2*CFG_ADDR_WIDTH in stack trace buffer, 0 = disabled\n" +
                        "  constant CFG_STACK_TRACE_BUF_SIZE : integer := 32;\n" +
                        "\n" +
                        "  --! @name   Integer Registers specified by ISA\n" +
                        "  --! @{\n" +
                        "    constant Reg_Zero : integer := 0;\n" +
                        "    constant Reg_ra : integer := 1;       -- [1] Return address\n" +
                        "    constant Reg_sp : integer := 2;       -- [2] Stack pointer\n" +
                        "    constant Reg_gp : integer := 3;       -- [3] Global pointer\n" +
                        "    constant Reg_tp : integer := 4;       -- [4] Thread pointer\n" +
                        "    constant Reg_t0 : integer := 5;       -- [5] Temporaries 0 s3\n" +
                        "    constant Reg_t1 : integer := 6;       -- [6] Temporaries 1 s4\n" +
                        "    constant Reg_t2 : integer := 7;       -- [7] Temporaries 2 s5\n" +
                        "    constant Reg_s0 : integer := 8;       -- [8] s0/fp Saved register/frame pointer\n" +
                        "    constant Reg_s1 : integer := 9;       -- [9] Saved register 1\n" +
                        "    constant Reg_a0 : integer := 10;      -- [10] Function argumentes 0\n" +
                        "    constant Reg_a1 : integer := 11;      -- [11] Function argumentes 1\n" +
                        "    constant Reg_a2 : integer := 12;      -- [12] Function argumentes 2\n" +
                        "    constant Reg_a3 : integer := 13;      -- [13] Function argumentes 3\n" +
                        "    constant Reg_a4 : integer := 14;      -- [14] Function argumentes 4\n" +
                        "    constant Reg_a5 : integer := 15;      -- [15] Function argumentes 5\n" +
                        "    constant Reg_a6 : integer := 16;      -- [16] Function argumentes 6\n" +
                        "    constant Reg_a7 : integer := 17;      -- [17] Function argumentes 7\n" +
                        "    constant Reg_s2 : integer := 18;      -- [18] Saved register 2\n" +
                        "    constant Reg_s3 : integer := 19;      -- [19] Saved register 3\n" +
                        "    constant Reg_s4 : integer := 20;      -- [20] Saved register 4\n" +
                        "    constant Reg_s5 : integer := 21;      -- [21] Saved register 5\n" +
                        "    constant Reg_s6 : integer := 22;      -- [22] Saved register 6\n" +
                        "    constant Reg_s7 : integer := 23;      -- [23] Saved register 7\n" +
                        "    constant Reg_s8 : integer := 24;      -- [24] Saved register 8\n" +
                        "    constant Reg_s9 : integer := 25;      -- [25] Saved register 9\n" +
                        "    constant Reg_s10 : integer := 26;     -- [26] Saved register 10\n" +
                        "    constant Reg_s11 : integer := 27;     -- [27] Saved register 11\n" +
                        "    constant Reg_t3 : integer := 28;      -- [28] \n" +
                        "    constant Reg_t4 : integer := 29;      -- [29] \n" +
                        "    constant Reg_t5 : integer := 30;      -- [30] \n" +
                        "    constant Reg_t6 : integer := 31;      -- [31] \n" +
                        "    constant Reg_Total : integer := 32;\n" +
                        "  --! @}\n" +
                        "\n" +
                        "  --! @name   Floating Point Unit Registers specified by ISA\n" +
                        "  --! @{\n" +
                        "    constant Reg_f0 : integer := 0;      -- ft0 temporary register\n" +
                        "    constant Reg_f1 : integer := 1;      -- ft1\n" +
                        "    constant Reg_f2 : integer := 2;      -- ft2\n" +
                        "    constant Reg_f3 : integer := 3;      -- ft3\n" +
                        "    constant Reg_f4 : integer := 4;      -- ft4\n" +
                        "    constant Reg_f5 : integer := 5;      -- ft5\n" +
                        "    constant Reg_f6 : integer := 6;      -- ft6\n" +
                        "    constant Reg_f7 : integer := 7;      -- ft7\n" +
                        "    constant Reg_f8 : integer := 8;      -- fs0 saved register\n" +
                        "    constant Reg_f9 : integer := 9;      -- fs1\n" +
                        "    constant Reg_f10 : integer := 10;    -- fa0 argument/return value\n" +
                        "    constant Reg_f11 : integer := 11;    -- fa1 argument/return value\n" +
                        "    constant Reg_f12 : integer := 12;    -- fa2 argument register\n" +
                        "    constant Reg_f13 : integer := 13;    -- fa3\n" +
                        "    constant Reg_f14 : integer := 14;    -- fa4\n" +
                        "    constant Reg_f15 : integer := 15;    -- fa5\n" +
                        "    constant Reg_f16 : integer := 16;    -- fa6\n" +
                        "    constant Reg_f17 : integer := 17;    -- fa7\n" +
                        "    constant Reg_f18 : integer := 18;    -- fs2 saved register\n" +
                        "    constant Reg_f19 : integer := 19;    -- fs3\n" +
                        "    constant Reg_f20 : integer := 20;    -- fs4\n" +
                        "    constant Reg_f21 : integer := 21;    -- fs5\n" +
                        "    constant Reg_f22 : integer := 22;    -- fs6\n" +
                        "    constant Reg_f23 : integer := 23;    -- fs7\n" +
                        "    constant Reg_f24 : integer := 24;    -- fs8\n" +
                        "    constant Reg_f25 : integer := 25;    -- fs9\n" +
                        "    constant Reg_f26 : integer := 26;    -- fs10\n" +
                        "    constant Reg_f27 : integer := 27;    -- fs11\n" +
                        "    constant Reg_f28 : integer := 28;    -- ft8 temporary register\n" +
                        "    constant Reg_f29 : integer := 29;    -- ft9\n" +
                        "    constant Reg_f30 : integer := 30;    -- ft10\n" +
                        "    constant Reg_f31 : integer := 31;    -- ft11\n" +
                        "    constant RegFpu_Total  : integer := 32;\n" +
                        "  --! @}\n" +
                        "\n" +
                        "  --! @name   Instruction formats specified by ISA specification\n" +
                        "  --! @{\n" +
                        "  constant ISA_R_type : integer := 0;\n" +
                        "  constant ISA_I_type : integer := 1;\n" +
                        "  constant ISA_S_type : integer := 2;\n" +
                        "  constant ISA_SB_type : integer := 3;\n" +
                        "  constant ISA_U_type : integer := 4;\n" +
                        "  constant ISA_UJ_type : integer := 5;\n" +
                        "  constant ISA_Total : integer := 6;\n" +
                        "  --! @}\n" +
                        "\n" +
                        "\n" +
                        "  --! @name   Implemented instruction list and its indexes\n" +
                        "  --! @{\n" +
                        "  constant Instr_ADD : integer := 0;\n" +
                        "  constant Instr_ADDI : integer := 1;\n" +
                        "  constant Instr_ADDIW : integer := 2;\n" +
                        "  constant Instr_ADDW : integer := 3;\n" +
                        "  constant Instr_AND : integer := 4;\n" +
                        "  constant Instr_ANDI : integer := 5;\n" +
                        "  constant Instr_AUIPC : integer := 6;\n" +
                        "  constant Instr_BEQ : integer := 7;\n" +
                        "  constant Instr_BGE : integer := 8;\n" +
                        "  constant Instr_BGEU : integer := 9;\n" +
                        "  constant Instr_BLT : integer := 10;\n" +
                        "  constant Instr_BLTU : integer := 11;\n" +
                        "  constant Instr_BNE : integer := 12;\n" +
                        "  constant Instr_JAL : integer := 13;\n" +
                        "  constant Instr_JALR : integer := 14;\n" +
                        "  constant Instr_LB : integer := 15;\n" +
                        "  constant Instr_LH : integer := 16;\n" +
                        "  constant Instr_LW : integer := 17;\n" +
                        "  constant Instr_LD : integer := 18;\n" +
                        "  constant Instr_LBU : integer := 19;\n" +
                        "  constant Instr_LHU : integer := 20;\n" +
                        "  constant Instr_LWU : integer := 21;\n" +
                        "  constant Instr_LUI : integer := 22;\n" +
                        "  constant Instr_OR : integer := 23;\n" +
                        "  constant Instr_ORI : integer := 24;\n" +
                        "  constant Instr_SLLI : integer := 25;\n" +
                        "  constant Instr_SLT : integer := 26;\n" +
                        "  constant Instr_SLTI : integer := 27;\n" +
                        "  constant Instr_SLTU : integer := 28;\n" +
                        "  constant Instr_SLTIU : integer := 29;\n" +
                        "  constant Instr_SLL : integer := 30;\n" +
                        "  constant Instr_SLLW : integer := 31;\n" +
                        "  constant Instr_SLLIW : integer := 32;\n" +
                        "  constant Instr_SRA : integer := 33;\n" +
                        "  constant Instr_SRAW : integer := 34;\n" +
                        "  constant Instr_SRAI : integer := 35;\n" +
                        "  constant Instr_SRAIW : integer := 36;\n" +
                        "  constant Instr_SRL : integer := 37;\n" +
                        "  constant Instr_SRLI : integer := 38;\n" +
                        "  constant Instr_SRLIW : integer := 39;\n" +
                        "  constant Instr_SRLW : integer := 40;\n" +
                        "  constant Instr_SB : integer := 41;\n" +
                        "  constant Instr_SH : integer := 42;\n" +
                        "  constant Instr_SW : integer := 43;\n" +
                        "  constant Instr_SD : integer := 44;\n" +
                        "  constant Instr_SUB : integer := 45;\n" +
                        "  constant Instr_SUBW : integer := 46;\n" +
                        "  constant Instr_XOR : integer := 47;\n" +
                        "  constant Instr_XORI : integer := 48;\n" +
                        "  constant Instr_CSRRW : integer := 49;\n" +
                        "  constant Instr_CSRRS : integer := 50;\n" +
                        "  constant Instr_CSRRC : integer := 51;\n" +
                        "  constant Instr_CSRRWI : integer := 52;\n" +
                        "  constant Instr_CSRRCI : integer := 53;\n" +
                        "  constant Instr_CSRRSI : integer := 54;\n" +
                        "  constant Instr_URET : integer := 55;\n" +
                        "  constant Instr_SRET : integer := 56;\n" +
                        "  constant Instr_HRET : integer := 57;\n" +
                        "  constant Instr_MRET : integer := 58;\n" +
                        "  constant Instr_FENCE : integer := 59;\n" +
                        "  constant Instr_FENCE_I : integer := 60;\n" +
                        "  constant Instr_DIV : integer := 61;\n" +
                        "  constant Instr_DIVU : integer := 62;\n" +
                        "  constant Instr_DIVW : integer := 63;\n" +
                        "  constant Instr_DIVUW : integer := 64;\n" +
                        "  constant Instr_MUL : integer := 65;\n" +
                        "  constant Instr_MULW : integer := 66;\n" +
                        "  constant Instr_REM : integer := 67;\n" +
                        "  constant Instr_REMU : integer := 68;\n" +
                        "  constant Instr_REMW : integer := 69;\n" +
                        "  constant Instr_REMUW : integer := 70;\n" +
                        "  constant Instr_ECALL : integer := 71;\n" +
                        "  constant Instr_EBREAK : integer := 72;\n" +
                        "  constant Instr_FADD_D : integer := 73;\n" +
                        "  constant Instr_FCVT_D_W : integer := 74;\n" +
                        "  constant Instr_FCVT_D_WU : integer := 75;\n" +
                        "  constant Instr_FCVT_D_L : integer := 76;\n" +
                        "  constant Instr_FCVT_D_LU : integer := 77;\n" +
                        "  constant Instr_FCVT_W_D : integer := 78;\n" +
                        "  constant Instr_FCVT_WU_D : integer := 79;\n" +
                        "  constant Instr_FCVT_L_D : integer := 80;\n" +
                        "  constant Instr_FCVT_LU_D : integer := 81;\n" +
                        "  constant Instr_FDIV_D : integer := 82;\n" +
                        "  constant Instr_FEQ_D : integer := 83;\n" +
                        "  constant Instr_FLD : integer := 84;\n" +
                        "  constant Instr_FLE_D : integer := 85;\n" +
                        "  constant Instr_FLT_D : integer := 86;\n" +
                        "  constant Instr_FMAX_D : integer := 87;\n" +
                        "  constant Instr_FMIN_D : integer := 88;\n" +
                        "  constant Instr_FMOV_D_X : integer := 89;\n" +
                        "  constant Instr_FMOV_X_D : integer := 90;\n" +
                        "  constant Instr_FMUL_D : integer := 91;\n" +
                        "  constant Instr_FSD : integer := 92;\n" +
                        "  constant Instr_FSUB_D : integer := 93;\n" +
                        "  constant Instr_Total : integer := 94;\n" +
                        "\n" +
                        "  constant Instr_FPU_Total : integer := Instr_FSUB_D - Instr_FADD_D + 1;\n" +
                        "  --! @}\n" +
                        "\n" +
                        "  --! @name PRV bits possible values:\n" +
                        "  --!\n" +
                        "  --! @{\n" +
                        "  --! User-mode\n" +
                        "  constant PRV_U : std_logic_vector(1 downto 0) := \"00\";\n" +
                        "  --! super-visor mode\n" +
                        "  constant PRV_S : std_logic_vector(1 downto 0) := \"01\";\n" +
                        "  --! hyper-visor mode\n" +
                        "  constant PRV_H : std_logic_vector(1 downto 0) := \"10\";\n" +
                        "  --! machine mode\n" +
                        "  constant PRV_M : std_logic_vector(1 downto 0) := \"11\";\n" +
                        "  --! @}\n" +
                        "\n" +
                        "\n" +
                        "  --! @name CSR registers.\n" +
                        "  --!\n" +
                        "  --! @{\n" +
                        "  \n" +
                        "  -- FPU Accrued Exceptions fields from FCSR\n" +
                        "  constant CSR_fflags            : std_logic_vector(11 downto 0) := X\"001\";\n" +
                        "  -- FPU dynamic Rounding Mode fields from FCSR\n" +
                        "  constant CSR_frm               : std_logic_vector(11 downto 0) := X\"002\";\n" +
                        "  -- FPU Control and Status register (frm + fflags)\n" +
                        "  constant CSR_fcsr              : std_logic_vector(11 downto 0) := X\"003\";\n" +
                        "  -- ISA and extensions supported.\n" +
                        "  constant CSR_misa              : std_logic_vector(11 downto 0) := X\"f10\";\n" +
                        "  -- Vendor ID.\n" +
                        "  constant CSR_mvendorid         : std_logic_vector(11 downto 0) := X\"f11\";\n" +
                        "  -- Architecture ID.\n" +
                        "  constant CSR_marchid           : std_logic_vector(11 downto 0) := X\"f12\";\n" +
                        "  -- Vendor ID.\n" +
                        "  constant CSR_mimplementationid : std_logic_vector(11 downto 0) := X\"f13\";\n" +
                        "  -- Thread id (the same as core).\n" +
                        "  constant CSR_mhartid           : std_logic_vector(11 downto 0) := X\"f14\";\n" +
                        "  -- Machine wall-clock time\n" +
                        "  constant CSR_mtime         : std_logic_vector(11 downto 0) := X\"701\";\n" +
                        "  -- Software reset.\n" +
                        "  constant CSR_mreset        : std_logic_vector(11 downto 0) := X\"782\";\n" +
                        "\n" +
                        "  -- machine mode status read/write register.\n" +
                        "  constant CSR_mstatus       : std_logic_vector(11 downto 0) := X\"300\";\n" +
                        "  -- Machine exception delegation\n" +
                        "  constant CSR_medeleg       : std_logic_vector(11 downto 0) := X\"302\";\n" +
                        "  -- Machine interrupt delegation\n" +
                        "  constant CSR_mideleg       : std_logic_vector(11 downto 0) := X\"303\";\n" +
                        "  -- Machine interrupt enable\n" +
                        "  constant CSR_mie           : std_logic_vector(11 downto 0) := X\"304\";\n" +
                        "  -- The base address of the M-mode trap vector.\n" +
                        "  constant CSR_mtvec         : std_logic_vector(11 downto 0) := X\"305\";\n" +
                        "  -- Machine wall-clock timer compare value.\n" +
                        "  constant CSR_mtimecmp      : std_logic_vector(11 downto 0) := X\"321\";\n" +
                        "  -- Scratch register for machine trap handlers.\n" +
                        "  constant CSR_mscratch      : std_logic_vector(11 downto 0) := X\"340\";\n" +
                        "  -- Exception program counters.\n" +
                        "  constant CSR_uepc          : std_logic_vector(11 downto 0) := X\"041\";\n" +
                        "  constant CSR_sepc          : std_logic_vector(11 downto 0) := X\"141\";\n" +
                        "  constant CSR_hepc          : std_logic_vector(11 downto 0) := X\"241\";\n" +
                        "  constant CSR_mepc          : std_logic_vector(11 downto 0) := X\"341\";\n" +
                        "  -- Machine trap cause\n" +
                        "  constant CSR_mcause        : std_logic_vector(11 downto 0) := X\"342\";\n" +
                        "  -- Machine bad address.\n" +
                        "  constant CSR_mbadaddr      : std_logic_vector(11 downto 0) := X\"343\";\n" +
                        "  -- Machine interrupt pending\n" +
                        "  constant CSR_mip           : std_logic_vector(11 downto 0) := X\"344\";\n" +
                        "  -- Machine stack overflow\n" +
                        "  constant CSR_mstackovr     : std_logic_vector(11 downto 0) := X\"350\";\n" +
                        "  -- Machine stack underflow\n" +
                        "  constant CSR_mstackund     : std_logic_vector(11 downto 0) := X\"351\";\n" +
                        "  --! @}\n" +
                        "\n" +
                        "  --! @name   Exceptions\n" +
                        "  --! @{\n" +
                        "  -- Instruction address misaligned\n" +
                        "  constant EXCEPTION_InstrMisalign   : std_logic_vector(4 downto 0) := \"00000\";\n" +
                        "  -- Instruction access fault\n" +
                        "  constant EXCEPTION_InstrFault      : std_logic_vector(4 downto 0) := \"00001\";\n" +
                        "  -- Illegal instruction\n" +
                        "  constant EXCEPTION_InstrIllegal    : std_logic_vector(4 downto 0) := \"00010\";\n" +
                        "  -- Breakpoint\n" +
                        "  constant EXCEPTION_Breakpoint      : std_logic_vector(4 downto 0) := \"00011\";\n" +
                        "  -- Load address misaligned\n" +
                        "  constant EXCEPTION_LoadMisalign    : std_logic_vector(4 downto 0) := \"00100\";\n" +
                        "  -- Load access fault\n" +
                        "  constant EXCEPTION_LoadFault       : std_logic_vector(4 downto 0) := \"00101\";\n" +
                        "  -- Store/AMO address misaligned\n" +
                        "  constant EXCEPTION_StoreMisalign   : std_logic_vector(4 downto 0) := \"00110\";\n" +
                        "  -- Store/AMO access fault\n" +
                        "  constant EXCEPTION_StoreFault      : std_logic_vector(4 downto 0) := \"00111\";\n" +
                        "  -- Environment call from U-mode\n" +
                        "  constant EXCEPTION_CallFromUmode   : std_logic_vector(4 downto 0) := \"01000\";\n" +
                        "  -- Environment call from S-mode\n" +
                        "  constant EXCEPTION_CallFromSmode   : std_logic_vector(4 downto 0) := \"01001\";\n" +
                        "  -- Environment call from H-mode\n" +
                        "  constant EXCEPTION_CallFromHmode   : std_logic_vector(4 downto 0) := \"01010\";\n" +
                        "  -- Environment call from M-mode\n" +
                        "  constant EXCEPTION_CallFromMmode   : std_logic_vector(4 downto 0) := \"01011\";\n" +
                        "  -- Instruction page fault\n" +
                        "  constant EXCEPTION_InstrPageFault  : std_logic_vector(4 downto 0) := \"01100\";\n" +
                        "  -- Load page fault\n" +
                        "  constant EXCEPTION_LoadPageFault   : std_logic_vector(4 downto 0) := \"01101\";\n" +
                        "  -- reserved\n" +
                        "  constant EXCEPTION_rsrv14          : std_logic_vector(4 downto 0) := \"01110\";\n" +
                        "  -- Store/AMO page fault\n" +
                        "  constant EXCEPTION_StorePageFault  : std_logic_vector(4 downto 0) := \"01111\";\n" +
                        "  -- Stack overflow\n" +
                        "  constant EXCEPTION_StackOverflow   : std_logic_vector(4 downto 0) := \"10000\";\n" +
                        "  -- Stack underflow\n" +
                        "  constant EXCEPTION_StackUnderflow  : std_logic_vector(4 downto 0) := \"10001\";\n" +
                        "  --! @}\n" +
                        "\n" +
                        "  --! @name   Interrupts\n" +
                        "  --! @{\n" +
                        "  -- User software interrupt\n" +
                        "  constant INTERRUPT_USoftware       : std_logic_vector(4 downto 0) := \"00000\";\n" +
                        "  -- Superuser software interrupt\n" +
                        "  constant INTERRUPT_SSoftware       : std_logic_vector(4 downto 0) := \"00001\";\n" +
                        "  -- Hypervisor software itnerrupt\n" +
                        "  constant INTERRUPT_HSoftware       : std_logic_vector(4 downto 0) := \"00010\";\n" +
                        "  -- Machine software interrupt\n" +
                        "  constant INTERRUPT_MSoftware       : std_logic_vector(4 downto 0) := \"00011\";\n" +
                        "  -- User timer interrupt\n" +
                        "  constant INTERRUPT_UTimer          : std_logic_vector(4 downto 0) := \"00100\";\n" +
                        "  -- Superuser timer interrupt\n" +
                        "  constant INTERRUPT_STimer          : std_logic_vector(4 downto 0) := \"00101\";\n" +
                        "  -- Hypervisor timer interrupt\n" +
                        "  constant INTERRUPT_HTimer          : std_logic_vector(4 downto 0) := \"00110\";\n" +
                        "  -- Machine timer interrupt\n" +
                        "  constant INTERRUPT_MTimer          : std_logic_vector(4 downto 0) := \"00111\";\n" +
                        "  -- User external interrupt\n" +
                        "  constant INTERRUPT_UExternal       : std_logic_vector(4 downto 0) := \"01000\";\n" +
                        "  -- Superuser external interrupt\n" +
                        "  constant INTERRUPT_SExternal       : std_logic_vector(4 downto 0) := \"01001\";\n" +
                        "  -- Hypervisor external interrupt\n" +
                        "  constant INTERRUPT_HExternal       : std_logic_vector(4 downto 0) := \"01010\";\n" +
                        "  -- Machine external interrupt (from PLIC)\n" +
                        "  constant INTERRUPT_MExternal       : std_logic_vector(4 downto 0) := \"01011\";\n" +
                        "  --! @}\n" +
                        "\n" +
                        "\n" +
                        "  --! @param[in] i_clk             CPU clock\n" +
                        "  --! @param[in] i_nrst            Reset. Active LOW.\n" +
                        "  --! @param[in] i_req_mem_fire    Memory request was accepted\n" +
                        "  --! @param[in] i_resp_mem_valid  Memory response from ICache is valid\n" +
                        "  --! @param[in] i_resp_mem_addr   Memory response address\n" +
                        "  --! @param[in] i_resp_mem_data   Memory response value\n" +
                        "  --! @param[in] i_e_npc           Valid instruction value awaited by 'Executor'\n" +
                        "  --! @param[in] i_ra              Return address register value\n" +
                        "  --! @param[out] o_npc_predic     Predicted next instruction address\n" +
                        "  --! @param[out] o_predict        Mark requested address as predicted\n" +
                        "  component BranchPredictor is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_req_mem_fire : in std_logic;\n" +
                        "    i_resp_mem_valid : in std_logic;\n" +
                        "    i_resp_mem_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_resp_mem_data : in std_logic_vector(31 downto 0);\n" +
                        "    i_e_npc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_ra : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_npc_predict : out std_logic_vector(31 downto 0)\n" +
                        "  );\n" +
                        "  end component; \n" +
                        "\n" +
                        "  --! @param[in] i_clk          CPU clock\n" +
                        "  --! @param[in] i_nrst         Reset. Active LOW.\n" +
                        "  --! @param[in] i_xret         XRet instruction signals mode switching\n" +
                        "  --! @param[in] i_addr         CSR address, if xret=1 switch mode accordingly\n" +
                        "  --! @param[in] i_wena         Write enable\n" +
                        "  --! @param[in] i_wdata        CSR writing value\n" +
                        "  --! @param[out] o_rdata       CSR read value\n" +
                        "  --! @param[in] i_trap_ready   Trap branch request was accepted\n" +
                        "  --! @param[in] i_ex_data_addr    Data path: address must be equal to the latest request address\n" +
                        "  --! @param[in] i_ex_data_load_fault Data path: Bus response with SLVERR or DECERR on read\n" +
                        "  --! @param[in] i_ex_data_store_fault Data path: Bus response with SLVERR or DECERR on write\n" +
                        "  --! @param[in] i_break_mode   Behaviour on EBREAK instruction: 0 = halt; 1 = generate trap\n" +
                        "  --! @param[out] o_break_event ebreak detected1 clock event\n" +
                        "  --! @param[in] i_dport_ena    Debug port request is enabled\n" +
                        "  --! @param[in] i_dport_write  Debug port Write enable\n" +
                        "  --! @param[in] i_dport_addr   Debug port CSR address\n" +
                        "  --! @param[in] i_dport_wdata  Debug port CSR writing value\n" +
                        "  --! @param[out] o_dport_rdata Debug port CSR read value\n" +
                        "  component CsrRegs is\n" +
                        "  generic (\n" +
                        "    hartid : integer;\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_mret : in std_logic;\n" +
                        "    i_uret : in std_logic;\n" +
                        "    i_sp : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    i_addr : in std_logic_vector(11 downto 0);\n" +
                        "    i_wena : in std_logic;\n" +
                        "    i_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_rdata : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    i_trap_ready : in std_logic;\n" +
                        "    i_ex_pc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_ex_npc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_ex_data_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_ex_data_load_fault : in std_logic;\n" +
                        "    i_ex_data_store_fault : in std_logic;\n" +
                        "    i_ex_data_store_fault_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_ex_ctrl_load_fault : in std_logic;\n" +
                        "    i_ex_illegal_instr : in std_logic;\n" +
                        "    i_ex_unalign_store : in std_logic;\n" +
                        "    i_ex_unalign_load : in std_logic;\n" +
                        "    i_ex_breakpoint : in std_logic;\n" +
                        "    i_ex_ecall : in std_logic;\n" +
                        "    i_ex_fpu_invalidop : in std_logic;\n" +
                        "    i_ex_fpu_divbyzero : in std_logic;\n" +
                        "    i_ex_fpu_overflow : in std_logic;\n" +
                        "    i_ex_fpu_underflow : in std_logic;\n" +
                        "    i_ex_fpu_inexact : in std_logic;\n" +
                        "    i_fpu_valid : in std_logic;\n" +
                        "    i_irq_external : in std_logic;\n" +
                        "    o_trap_valid : out std_logic;\n" +
                        "    o_trap_pc : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_break_mode : in std_logic;\n" +
                        "    o_break_event : out std_logic;\n" +
                        "    i_dport_ena : in std_logic;\n" +
                        "    i_dport_write : in std_logic;\n" +
                        "    i_dport_addr : in std_logic_vector(11 downto 0);\n" +
                        "    i_dport_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_dport_rdata : out std_logic_vector(RISCV_ARCH-1 downto 0)\n" +
                        "  );\n" +
                        "  end component; \n" +
                        "\n" +
                        "  --! @param[in] i_clk CPU clock\n" +
                        "  --! @param[in] i_nrst Reset. Active LOW.\n" +
                        "  --! @param[in] i_any_hold Hold pipeline by any reason\n" +
                        "  --! @param[in] i_f_valid Fetch input valid\n" +
                        "  --! @param[in] i_f_pc Fetched pc\n" +
                        "  --! @param[in] i_f_instr Fetched instruction value\n" +
                        "  --! @param[out] o_valid Current output values are valid\n" +
                        "  --! @param[out] o_pc Current instruction pointer value\n" +
                        "  --! @param[out] o_instr Current instruction value\n" +
                        "  --! @param[out] o_memop_store Store to memory operation\n" +
                        "  --! @param[out] o_memop_load Load from memoru operation\n" +
                        "  --! @param[out] o_memop_sign_ext Load memory value with sign extending\n" +
                        "  --! @param[out] o_memop_size Memory transaction size\n" +
                        "  --! @param[out] o_rv32 32-bits instruction\n" +
                        "  --! @param[out] o_f64  64-bits FPU (D-extension)\n" +
                        "  --! @param[out] o_compressed 16-bits instruction (C-extension)\n" +
                        "  --! @param[out] o_insigned_op Unsigned operands\n" +
                        "  --! @param[out] o_isa_type Instruction format accordingly with ISA\n" +
                        "  --! @param[out] o_instr_vec One bit per decoded instruction bus\n" +
                        "  --! @param[out] o_exception Unimplemented instruction\n" +
                        "  component InstrDecoder is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk  : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_any_hold : in std_logic;\n" +
                        "    i_f_valid : in std_logic;\n" +
                        "    i_f_pc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_f_instr : in std_logic_vector(31 downto 0);\n" +
                        "    o_valid : out std_logic;\n" +
                        "    o_pc : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_instr : out std_logic_vector(31 downto 0);\n" +
                        "    o_memop_store : out std_logic;\n" +
                        "    o_memop_load : out std_logic;\n" +
                        "    o_memop_sign_ext : out std_logic;\n" +
                        "    o_memop_size : out std_logic_vector(1 downto 0);\n" +
                        "    o_rv32 : out std_logic;\n" +
                        "    o_f64 : out std_logic;\n" +
                        "    o_compressed : out std_logic;\n" +
                        "    o_unsigned_op : out std_logic;\n" +
                        "    o_isa_type : out std_logic_vector(ISA_Total-1 downto 0);\n" +
                        "    o_instr_vec : out std_logic_vector(Instr_Total-1 downto 0);\n" +
                        "    o_exception : out std_logic\n" +
                        "  );\n" +
                        "  end component; \n" +
                        "\n" +
                        "\n" +
                        "  --! @param[in] i_clk  \n" +
                        "  --! @param[in] i_nrst Reset active LOW\n" +
                        "  --! @param[in] i_pipeline_hold Hold execution by any reason\n" +
                        "  --! @param[in] i_d_valid Decoded instruction is valid\n" +
                        "  --! @param[in] i_d_pc Instruction pointer on decoded instruction\n" +
                        "  --! @param[in] i_d_instr Decoded instruction value\n" +
                        "  --! @param[in] i_wb_done write back done (Used to clear hazardness)\n" +
                        "  --! @param[in] i_memop_store Store to memory operation\n" +
                        "  --! @param[in] i_memop_load Load from memoru operation\n" +
                        "  --! @param[in] i_memop_sign_ext Load memory value with sign extending\n" +
                        "  --! @param[in] i_memop_size Memory transaction size\n" +
                        "  --! @param[in] i_unsigned_op Unsigned operands\n" +
                        "  --! @param[in] i_rv32 32-bits instruction\n" +
                        "  --! @param[in] i_compressed 16-bits instruction (C-extension)\n" +
                        "  --! @param[in] i_f64        D-extension (FPU)\n" +
                        "  --! @param[in] i_isa_type   Type of the instruction's structure (ISA spec.)\n" +
                        "  --! @param[in] i_break_mode        Behaviour on EBREAK instruction: 0 = halt; 1 = generate trap\n" +
                        "  --! @param[in] i_unsup_exception   Unsupported instruction exception\n" +
                        "  --! @param[in] i_ext_irq           External interrupt from PLIC (todo: timer & software interrupts)\n" +
                        "  --! @param[in] i_dport_npc_write   Write npc value from debug port\n" +
                        "  --! @param[in] i_dport_npc         Debug port npc value to write\n" +
                        "  --! @param[out] o_radr1 Integer/float register index 1\n" +
                        "  --! @param[in] i_rdata1 Integer register value 1\n" +
                        "  --! @param[out] o_radr2 Integer/float register index 2\n" +
                        "  --! @param[in] i_rdata2 Integer register value 2\n" +
                        "  --! @param[in] i_rfdata1   Float register value 1\n" +
                        "  --! @param[in] i_rfdata2   Float register value 2\n" +
                        "  --! @param[out] o_res_addr Address to store result of the instruction (0=do not store)\n" +
                        "  --! @param[out] o_res_data Value to store\n" +
                        "  --! @param[out] o_pipeline_hold Hold pipeline while 'writeback' not done or multi-clock instruction.\n" +
                        "  --! @param[out] o_csr_addr CSR address. 0 if not a CSR instruction with xret signals mode switching\n" +
                        "  --! @param[out] o_csr_wena Write new CSR value\n" +
                        "  --! @param[in] i_csr_rdata CSR current value\n" +
                        "  --! @param[out] o_csr_wdata CSR new value\n" +
                        "  --! @param[out] o_ex_npc    exception npc\n" +
                        "  --! @param[out] o_ex_illegal_instr Exception: illegal instruction\n" +
                        "  --! @param[out] o_ex_unalign_store Exception: Unaligned store\n" +
                        "  --! @param[out] o_ex_unalign_load  Exception: Unaligned load\n" +
                        "  --! @param[out] o_ex_breakpoint    Exception: BREAK\n" +
                        "  --! @param[out] o_ex_ecall         Exception: ECALL\n" +
                        "  --! @param[out] o_ex_fpu_invalidop FPU Exception: invalid operation\n" +
                        "  --! @param[out] o_ex_fpu_divbyzero FPU Exception: divide by zero\n" +
                        "  --! @param[out] o_ex_fpu_overflow  FPU Exception: overflow\n" +
                        "  --! @param[out] o_ex_fpu_underflow FPU Exception: underflow\n" +
                        "  --! @param[out] o_ex_fpu_inexact   FPU Exception: inexact\n" +
                        "  --! @param[out] o_fpu_valid        FPU output is valid\n" +
                        "  --! @param[out] o_memop_sign_ext Load data with sign extending\n" +
                        "  --! @param[out] o_memop_load Load data instruction\n" +
                        "  --! @param[out] o_memop_store Store data instruction\n" +
                        "  --! @param[out] o_memop_size 0=1bytes; 1=2bytes; 2=4bytes; 3=8bytes\n" +
                        "  --! @param[out] o_memop_addr  Memory access address\n" +
                        "  --! @param[out] o_trap_ready  Trap branch request was accepted\n" +
                        "  --! @param[out] o_valid       Output is valid\n" +
                        "  --! @param[out] o_pc          Valid instruction pointer\n" +
                        "  --! @param[out] o_npc         Next instruction pointer. Next decoded pc must match to this value or will be ignored.\n" +
                        "  --! @param[out] o_instr       Valid instruction value\n" +
                        "  --! @param[out] o_call        CALL pseudo instruction detected\n" +
                        "  --! @param[out] o_ret         RET pseudoinstruction detected\n" +
                        "  --! @param[out] o_mret        MRET detected\n" +
                        "  --! @param[out] o_uret        URET detected\n" +
                        "  component InstrExecute is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk  : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_pipeline_hold : in std_logic;\n" +
                        "    i_d_valid : in std_logic;\n" +
                        "    i_d_pc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_d_instr : in std_logic_vector(31 downto 0);\n" +
                        "    i_wb_ready : in std_logic;\n" +
                        "    i_memop_store : in std_logic;\n" +
                        "    i_memop_load : in std_logic;\n" +
                        "    i_memop_sign_ext : in std_logic;\n" +
                        "    i_memop_size : in std_logic_vector(1 downto 0);\n" +
                        "    i_unsigned_op : in std_logic;\n" +
                        "    i_rv32 : in std_logic;\n" +
                        "    i_compressed : in std_logic;\n" +
                        "    i_f64 : in std_logic;\n" +
                        "    i_isa_type : in std_logic_vector(ISA_Total-1 downto 0);\n" +
                        "    i_ivec : in std_logic_vector(Instr_Total-1 downto 0);\n" +
                        "    i_unsup_exception : in std_logic;\n" +
                        "    i_dport_npc_write : in std_logic;\n" +
                        "    i_dport_npc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_radr1 : out std_logic_vector(5 downto 0);\n" +
                        "    i_rdata1 : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_radr2 : out std_logic_vector(5 downto 0);\n" +
                        "    i_rdata2 : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    i_rfdata1 : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    i_rfdata2 : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_res_addr : out std_logic_vector(5 downto 0);\n" +
                        "    o_res_data : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_pipeline_hold : out std_logic;\n" +
                        "    o_csr_addr : out std_logic_vector(11 downto 0);\n" +
                        "    o_csr_wena : out std_logic;\n" +
                        "    i_csr_rdata : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_csr_wdata : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    i_trap_valid : in std_logic;\n" +
                        "    i_trap_pc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_ex_npc : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_ex_illegal_instr : out std_logic;\n" +
                        "    o_ex_unalign_store : out std_logic;\n" +
                        "    o_ex_unalign_load : out std_logic;\n" +
                        "    o_ex_breakpoint : out std_logic;\n" +
                        "    o_ex_ecall : out std_logic;\n" +
                        "    o_ex_fpu_invalidop : out std_logic;\n" +
                        "    o_ex_fpu_divbyzero : out std_logic;\n" +
                        "    o_ex_fpu_overflow : out std_logic;\n" +
                        "    o_ex_fpu_underflow : out std_logic;\n" +
                        "    o_ex_fpu_inexact : out std_logic;\n" +
                        "    o_fpu_valid : out std_logic;\n" +
                        "    o_memop_sign_ext : out std_logic;\n" +
                        "    o_memop_load : out std_logic;\n" +
                        "    o_memop_store : out std_logic;\n" +
                        "    o_memop_size : out std_logic_vector(1 downto 0);\n" +
                        "    o_memop_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_trap_ready : out std_logic;\n" +
                        "    o_valid : out std_logic;\n" +
                        "    o_pc : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_npc : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_instr : out std_logic_vector(31 downto 0);\n" +
                        "    o_call : out std_logic;\n" +
                        "    o_ret : out std_logic;\n" +
                        "    o_mret : out std_logic;\n" +
                        "    o_uret : out std_logic\n" +
                        "  );\n" +
                        "  end component; \n" +
                        "\n" +
                        "  --! @param[in] i_clk\n" +
                        "  --! @param[in] i_nrst\n" +
                        "  --! @param[in] i_pipeline_hold\n" +
                        "  --! @param[in] i_mem_ready\n" +
                        "  --! @param[out] o_mem_addr_valid\n" +
                        "  --! @param[out] o_mem_addr\n" +
                        "  --! @param[in] i_mem_data_valid\n" +
                        "  --! @param[in] i_mem_data_addr\n" +
                        "  --! @param[in] i_mem_data\n" +
                        "  --! @param[out] o_mem_ready\n" +
                        "  --! @param[in] i_predict_npc\n" +
                        "  --! @param[out] o_mem_req_fire    Used by branch predictor to form new npc value\n" +
                        "  --! @param[out] o_valid\n" +
                        "  --! @param[out] o_pc\n" +
                        "  --! @param[out] o_instr\n" +
                        "  --! @param[out] o_hold            Hold due no response from icache yet\n" +
                        "  --! @param[in] i_br_fetch_valid   Fetch injection address/instr are valid\n" +
                        "  --! @param[in] i_br_address_fetch Fetch injection address to skip ebreak instruciton only once\n" +
                        "  --! @param[in] i_br_instr_fetch   Real instruction value that was replaced by ebreak\n" +
                        "  --! @param[out] o_instr_buf\n" +
                        "  component InstrFetch is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk  : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_pipeline_hold : in std_logic;\n" +
                        "    i_mem_req_ready : in std_logic;\n" +
                        "    o_mem_addr_valid : out std_logic;\n" +
                        "    o_mem_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_mem_data_valid : in std_logic;\n" +
                        "    i_mem_data_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_mem_data : in std_logic_vector(31 downto 0);\n" +
                        "    i_mem_load_fault : in std_logic;\n" +
                        "    o_mem_resp_ready : out std_logic;\n" +
                        "    i_predict_npc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "\n" +
                        "    o_mem_req_fire : out std_logic;\n" +
                        "    o_ex_load_fault : out std_logic;\n" +
                        "    o_valid : out std_logic;\n" +
                        "    o_pc : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_instr : out std_logic_vector(31 downto 0);\n" +
                        "    o_hold : out std_logic;\n" +
                        "    i_br_fetch_valid : in std_logic;\n" +
                        "    i_br_address_fetch : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_br_instr_fetch : in std_logic_vector(31 downto 0);\n" +
                        "    o_instr_buf : out std_logic_vector(DBG_FETCH_TRACE_SIZE*64-1 downto 0)\n" +
                        "  );\n" +
                        "  end component; \n" +
                        "\n" +
                        "  --! @param[in] i_clk\n" +
                        "  --! @param[in] i_nrst\n" +
                        "  --! @param[in] i_e_valid Execution stage outputs are valid\n" +
                        "  --! @param[in] i_e_pc Execution stage instruction pointer\n" +
                        "  --! @param[in] i_e_instr Execution stage instruction value\n" +
                        "  --! @param[in] i_res_addr Register address to be written (0=no writing)\n" +
                        "  --! @param[in] i_res_data Register value to be written\n" +
                        "  --! @param[in] i_memop_sign_ext Load data with sign extending (if less than 8 Bytes)\n" +
                        "  --! @param[in] i_memop_load Load data from memory and write to i_res_addr\n" +
                        "  --! @param[in] i_memop_store Store i_res_data value into memory\n" +
                        "  --! @param[in] i_memop_size Encoded memory transaction size in bytes:\n" +
                        "  --!                         0=1B; 1=2B; 2=4B; 3=8B\n" +
                        "  --! @param[in] i_memop_addr Memory access address\n" +
                        "  --! @param[out] o_wena Write enable signal\n" +
                        "  --! @param[out] o_waddr Output register address (0 = x0 = no write)\n" +
                        "  --! @param[out] o_wdata Register value\n" +
                        "  --! @param[in] i_mem_req_read Memory request is acceptable\n" +
                        "  --! @param[out] o_mem_valid Memory request is valid\n" +
                        "  --! @param[out] o_mem_write Memory write request\n" +
                        "  --! @param[out] o_mem_sz Encoded data size in bytes: 0=1B; 1=2B; 2=4B; 3=8B\n" +
                        "  --! @param[out] o_mem_addr Data path requested address\n" +
                        "  --! @param[out] o_mem_data Data path requested data (write transaction)\n" +
                        "  --! @param[in] i_mem_data_valid Data path memory response is valid\n" +
                        "  --! @param[in] i_mem_data_addr Data path memory response address\n" +
                        "  --! @param[in] i_mem_data Data path memory response value\n" +
                        "  --! @param[out] o_mem_resp_ready Data from DCache was accepted\n" +
                        "  --! @param[out] o_hold Hold-on pipeline while memory operation not finished\n" +
                        "  --! @param[out] o_valid Output is valid\n" +
                        "  --! @param[out] o_pc Valid instruction pointer\n" +
                        "  --! @param[out] o_instr Valid instruction value\n" +
                        "  component MemAccess is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk  : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_e_valid : in std_logic;\n" +
                        "    i_e_pc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_e_instr : in std_logic_vector(31 downto 0);\n" +
                        "    i_res_addr : in std_logic_vector(5 downto 0);\n" +
                        "    i_res_data : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    i_memop_sign_ext : in std_logic;\n" +
                        "    i_memop_load : in std_logic;\n" +
                        "    i_memop_store : in std_logic;\n" +
                        "    i_memop_size : in std_logic_vector(1 downto 0);\n" +
                        "    i_memop_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_wena : out std_logic;\n" +
                        "    o_waddr : out std_logic_vector(5 downto 0);\n" +
                        "    o_wdata : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    i_mem_req_ready : in std_logic;\n" +
                        "    o_mem_valid : out std_logic;\n" +
                        "    o_mem_write : out std_logic;\n" +
                        "    o_mem_sz : out std_logic_vector(1 downto 0);\n" +
                        "    o_mem_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_mem_data : out std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    i_mem_data_valid : in std_logic;\n" +
                        "    i_mem_data_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_mem_data : in std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    o_mem_resp_ready : out std_logic;\n" +
                        "    o_hold : out std_logic;\n" +
                        "    o_valid : out std_logic;\n" +
                        "    o_pc : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_instr : out std_logic_vector(31 downto 0)\n" +
                        "  );\n" +
                        "  end component; \n" +
                        "\n" +
                        "  --! @param[in] i_clk CPU clock\n" +
                        "  --! @param[in] i_nrst Reset. Active LOW.\n" +
                        "  --! @param[in] i_radr1 Port 1 read address\n" +
                        "  --! @param[out] o_rdata1 Port 1 read value\n" +
                        "  --! @param[in] i_radr2 Port 2 read address\n" +
                        "  --! @param[out] o_rdata2 Port 2 read value\n" +
                        "  --! @param[in] i_waddr Writing value\n" +
                        "  --! @param[in] i_wena Writing is enabled\n" +
                        "  --! @param[in] i_wdata Writing value\n" +
                        "  --! @param[in] i_dport_addr    Debug port address\n" +
                        "  --! @param[in] i_dport_ena     Debug port is enabled\n" +
                        "  --! @param[in] i_dport_write   Debug port write is enabled\n" +
                        "  --! @param[in] i_dport_wdata   Debug port write value\n" +
                        "  --! @param[out] o_dport_rdata  Debug port read value\n" +
                        "  --! @param[out] o_ra           Return address for branch predictor\n" +
                        "  --! @param[out] o_sp           Stack Pointer for the borders control\n" +
                        "  component RegIntBank is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_radr1 : in std_logic_vector(5 downto 0);\n" +
                        "    o_rdata1 : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    i_radr2 : in std_logic_vector(5 downto 0);\n" +
                        "    o_rdata2 : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    i_waddr : in std_logic_vector(5 downto 0);\n" +
                        "    i_wena : in std_logic;\n" +
                        "    i_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    i_dport_addr : in std_logic_vector(4 downto 0);\n" +
                        "    i_dport_ena : in std_logic;\n" +
                        "    i_dport_write : in std_logic;\n" +
                        "    i_dport_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_dport_rdata : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_ra : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_sp : out std_logic_vector(RISCV_ARCH-1 downto 0)\n" +
                        "  );\n" +
                        "  end component; \n" +
                        "\n" +
                        "  component RegFloatBank is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;                                   -- CPU clock\n" +
                        "    i_nrst : in std_logic;                                  -- Reset. Active LOW.\n" +
                        "\n" +
                        "    i_radr1 : in std_logic_vector(5 downto 0);              -- Port 1 read address\n" +
                        "    o_rdata1 : out std_logic_vector(RISCV_ARCH-1 downto 0); -- Port 1 read value\n" +
                        "\n" +
                        "    i_radr2 : in std_logic_vector(5 downto 0);              -- Port 2 read address\n" +
                        "    o_rdata2 : out std_logic_vector(RISCV_ARCH-1 downto 0); -- Port 2 read value\n" +
                        "\n" +
                        "    i_waddr : in std_logic_vector(5 downto 0);              -- Writing value\n" +
                        "    i_wena : in std_logic;                                  -- Writing is enabled\n" +
                        "    i_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0);   -- Writing value\n" +
                        "\n" +
                        "    i_dport_addr : in std_logic_vector(4 downto 0);         -- Debug port address\n" +
                        "    i_dport_ena : in std_logic;                             -- Debug port is enabled\n" +
                        "    i_dport_write : in std_logic;                           -- Debug port write is enabled\n" +
                        "    i_dport_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0); -- Debug port write value\n" +
                        "    o_dport_rdata : out std_logic_vector(RISCV_ARCH-1 downto 0)-- Debug port read value\n" +
                        "  );\n" +
                        "  end component; \n" +
                        "\n" +
                        "  --! @param[in] i_clk            CPU clock\n" +
                        "  --! @param[in] i_nrst           Reset. Active LOW.\n" +
                        "  --! @param[in] i_dport_valid    Debug access from DSU is valid\n" +
                        "  --! @param[in] i_dport_write    Write command flag\n" +
                        "  --! @param[in] i_dport_region   Registers region ID: 0=CSR; 1=IREGS; 2=Control\n" +
                        "  --! @param[in] i_dport_addr     Register idx\n" +
                        "  --! @param[in] i_dport_wdata    Write value\n" +
                        "  --! @param[out] o_dport_ready   Response is ready\n" +
                        "  --! @param[out] o_dport_rdata   Response value\n" +
                        "  --! @param[out] o_core_addr     Address of the sub-region register\n" +
                        "  --! @param[out] o_core_wdata    Write data\n" +
                        "  --! @param[out] o_csr_ena       Region 0: Access to CSR bank is enabled.\n" +
                        "  --! @param[out] o_csr_write     Region 0: CSR write enable\n" +
                        "  --! @param[in] i_csr_rdata      Region 0: CSR read value\n" +
                        "  --! @param[out] o_ireg_ena      Region 1: Access to integer register bank is enabled\n" +
                        "  --! @param[out] o_ireg_write    Region 1: Integer registers bank write pulse\n" +
                        "  --! @param[out] o_freg_ena      Region 1: Access to float register bank is enabled\n" +
                        "  --! @param[out] o_freg_write    Region 1: Float registers bank write pulse\n" +
                        "  --! @param[out] o_npc_write     Region 1: npc write enable\n" +
                        "  --! @param[in] i_ireg_rdata     Region 1: Integer register read value\n" +
                        "  --! @param[in] i_freg_rdata  Region 1: Float register read value\n" +
                        "  --! @param[in] i_pc             Region 1: Instruction pointer\n" +
                        "  --! @param[in] i_npc            Region 1: Next Instruction pointer\n" +
                        "  --! @param[in] i_e_valid        Stepping control signal\n" +
                        "  --! @param[in] i_e_call         Pseudo-instruction CALL\n" +
                        "  --! @param[in] i_e_ret          Pseudo-instruction RET\n" +
                        "  --! @param[in] i_m_valid        To compute number of valid executed instruction\n" +
                        "  --! @param[out] o_clock_cnt     Number of clocks excluding halt state\n" +
                        "  --! @param[out] o_executed_cnt  Number of executed instructions\n" +
                        "  --! @param[out] o_halt          Halt signal is equal to hold pipeline\n" +
                        "  --! @param[in] i_ebreak            ebreak instruction decoded\n" +
                        "  --! @param[out] o_break_mode       Behaviour on EBREAK instruction: 0 = halt; 1 = generate trap\n" +
                        "  --! @param[out] o_br_fetch_valid   Fetch injection address/instr are valid\n" +
                        "  --! @param[out] o_br_address_fetch Fetch injection address to skip ebreak instruciton only once\n" +
                        "  --! @param[out] o_br_instr_fetch   Real instruction value that was replaced by ebreak\n" +
                        "  --! @param[out] o_flush_address    Address of instruction to remove from ICache\n" +
                        "  --! @param[out] o_flush_valid      Remove address from ICache is valid\n" +
                        "  --! @param[in] i_istate            ICache state machine value\n" +
                        "  --! @param[in] i_dstate            DCache state machine value\n" +
                        "  --! @param[in] i_instr_buf\n" +
                        "  component DbgPort is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_dport_valid : in std_logic;\n" +
                        "    i_dport_write : in std_logic;\n" +
                        "    i_dport_region : in std_logic_vector(1 downto 0);\n" +
                        "    i_dport_addr : in std_logic_vector(11 downto 0);\n" +
                        "    i_dport_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_dport_ready : out std_logic;\n" +
                        "    o_dport_rdata : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_core_addr : out std_logic_vector(11 downto 0);\n" +
                        "    o_core_wdata : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_csr_ena : out std_logic;\n" +
                        "    o_csr_write : out std_logic;\n" +
                        "    i_csr_rdata : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_ireg_ena : out std_logic;\n" +
                        "    o_ireg_write : out std_logic;\n" +
                        "    o_freg_ena : out std_logic;\n" +
                        "    o_freg_write : out std_logic;\n" +
                        "    o_npc_write : out std_logic;\n" +
                        "    i_ireg_rdata : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    i_freg_rdata : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    i_pc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_npc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_e_valid : in std_logic;\n" +
                        "    i_e_call : in std_logic;\n" +
                        "    i_e_ret : in std_logic;\n" +
                        "    i_m_valid : in std_logic;\n" +
                        "    o_clock_cnt : out std_logic_vector(63 downto 0);\n" +
                        "    o_executed_cnt : out std_logic_vector(63 downto 0);\n" +
                        "    o_halt : out std_logic;\n" +
                        "    i_ebreak : in std_logic;\n" +
                        "    o_break_mode : out std_logic;\n" +
                        "    o_br_fetch_valid : out std_logic;\n" +
                        "    o_br_address_fetch : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_br_instr_fetch : out std_logic_vector(31 downto 0);\n" +
                        "    o_flush_address : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_flush_valid : out std_logic;\n" +
                        "    i_istate : in std_logic_vector(1 downto 0);\n" +
                        "    i_dstate : in std_logic_vector(1 downto 0);\n" +
                        "    i_cstate : in std_logic_vector(1 downto 0);\n" +
                        "    i_instr_buf : in std_logic_vector(DBG_FETCH_TRACE_SIZE*64-1 downto 0)\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "\n" +
                        "  --! @brief CPU 5-stages pipeline top-level\n" +
                        "  --! @param[in] i_clk             CPU clock\n" +
                        "  --! @param[in] i_nrst            Reset. Active LOW.\n" +
                        "  --! @param[in] i_req_ctrl_ready  ICache is ready to accept request\n" +
                        "  --! @param[out] o_req_ctrl_valid Request to ICache is valid\n" +
                        "  --! @param[out] o_req_ctrl_addr  Requesting address to ICache\n" +
                        "  --! @param[in] i_resp_ctrl_valid ICache response is valid\n" +
                        "  --! @param[in] i_resp_ctrl_addr  Response address must be equal to the latest request address\n" +
                        "  --! @param[in] i_resp_ctrl_data  Read value\n" +
                        "  --! @param[out] o_resp_ctrl_ready Response from ICache is accepted\n" +
                        "  --! @param[in] i_req_data_ready  DCache is ready to accept request\n" +
                        "  --! @param[out] o_req_data_valid Request to DCache is valid\n" +
                        "  --! @param[out] o_req_data_write Read/Write transaction\n" +
                        "  --! @param[out] o_req_data_size  Size [Bytes]: 0=1B; 1=2B; 2=4B; 3=8B\n" +
                        "  --! @param[out] o_req_data_addr  Requesting address to DCache\n" +
                        "  --! @param[out] o_req_data_data  Writing value\n" +
                        "  --! @param[in] i_resp_data_valid DCache response is valid\n" +
                        "  --! @param[in] i_resp_data_addr  DCache response address must be equal to the latest request address\n" +
                        "  --! @param[in] i_resp_data_data  Read value\n" +
                        "  --! @param[in] i_resp_data_load_fault Bus response SLVERR or DECERR on read\n" +
                        "  --! @param[in] i_resp_data_store_fault Bus response SLVERR or DECERR on write\n" +
                        "  --! @param[out] o_resp_data_ready Response drom DCache is accepted\n" +
                        "  --! @param[in] i_ext_irq         PLIC interrupt accordingly with spec\n" +
                        "  --! @param[out] o_time           Timer in clock except halt state\n" +
                        "  --! @param[in] i_dport_valid     Debug access from DSU is valid\n" +
                        "  --! @param[in] i_dport_write     Write command flag\n" +
                        "  --! @param[in] i_dport_region    Registers region ID: 0=CSR; 1=IREGS; 2=Control\n" +
                        "  --! @param[in] i_dport_addr      Register idx\n" +
                        "  --! @param[in] i_dport_wdata     Write value\n" +
                        "  --! @param[out] o_dport_ready    Response is ready\n" +
                        "  --! @param[out] o_dport_rdata    Response value\n" +
                        "  --! @param[out] o_flush_address  Address of instruction to remove from ICache\n" +
                        "  --! @param[out] o_flush_valid    Remove address from ICache is valid\n" +
                        "  --! @param[in] i_istate          ICache state machine value\n" +
                        "  --! @param[in] i_dstate          DCache state machine value\n" +
                        "  --! @param[in] i_cstate          cachetop state machine value\n" +
                        "  component Processor is\n" +
                        "  generic (\n" +
                        "    hartid : integer;\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_req_ctrl_ready : in std_logic;\n" +
                        "    o_req_ctrl_valid : out std_logic;\n" +
                        "    o_req_ctrl_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_resp_ctrl_valid : in std_logic;\n" +
                        "    i_resp_ctrl_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_resp_ctrl_data : in std_logic_vector(31 downto 0);\n" +
                        "    i_resp_ctrl_load_fault : in std_logic;\n" +
                        "    o_resp_ctrl_ready : out std_logic;\n" +
                        "    i_req_data_ready : in std_logic;\n" +
                        "    o_req_data_valid : out std_logic;\n" +
                        "    o_req_data_write : out std_logic;\n" +
                        "    o_req_data_size : out std_logic_vector(1 downto 0);\n" +
                        "    o_req_data_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_req_data_data : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    i_resp_data_valid : in std_logic;\n" +
                        "    i_resp_data_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_resp_data_data : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    i_resp_data_load_fault : in std_logic;\n" +
                        "    i_resp_data_store_fault : in std_logic;\n" +
                        "    i_resp_data_store_fault_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_resp_data_ready : out std_logic;\n" +
                        "    i_ext_irq : in std_logic;\n" +
                        "    o_time : out std_logic_vector(63 downto 0);\n" +
                        "    i_dport_valid : in std_logic;\n" +
                        "    i_dport_write : in std_logic;\n" +
                        "    i_dport_region : in std_logic_vector(1 downto 0);\n" +
                        "    i_dport_addr : in std_logic_vector(11 downto 0);\n" +
                        "    i_dport_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_dport_ready : out std_logic;\n" +
                        "    o_dport_rdata : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_halted : out std_logic;\n" +
                        "    o_flush_address : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_flush_valid : out std_logic;\n" +
                        "    i_istate : in std_logic_vector(1 downto 0);\n" +
                        "    i_dstate : in std_logic_vector(1 downto 0);\n" +
                        "    i_cstate : in std_logic_vector(1 downto 0)\n" +
                        "  );\n" +
                        "  end component; \n" +
                        "\n" +
                        "  --! @brief CPU cache top level\n" +
                        "  --! @param[in] i_clk\n" +
                        "  --! @param[in] i_nrst\n" +
                        "  --! @param[in] i_req_ctrl_valid\n" +
                        "  --! @param[in] i_req_ctrl_addr\n" +
                        "  --! @param[out] o_req_ctrl_ready\n" +
                        "  --! @param[out] o_resp_ctrl_valid\n" +
                        "  --! @param[out] o_resp_ctrl_addr\n" +
                        "  --! @param[out] o_resp_ctrl_data\n" +
                        "  --! @param[in] i_resp_ctrl_ready\n" +
                        "  --! @param[out] o_req_data_ready\n" +
                        "  --! @param[in] i_req_data_valid\n" +
                        "  --! @param[in] i_req_data_write\n" +
                        "  --! @param[in] i_req_data_sz\n" +
                        "  --! @param[in] i_req_data_addr\n" +
                        "  --! @param[in] i_req_data_data\n" +
                        "  --! @param[out] o_resp_data_valid\n" +
                        "  --! @param[out] o_resp_data_addr\n" +
                        "  --! @param[out] o_resp_data_data\n" +
                        "  --! @param[out] o_resp_data_load_fault\n" +
                        "  --! @param[out] o_resp_data_store_fault\n" +
                        "  --! @param[in] i_resp_data_ready\n" +
                        "  --! @param[in] i_req_mem_ready      AXI request was accepted\n" +
                        "  --! @param[out] o_req_mem_valid\n" +
                        "  --! @param[out] o_req_mem_write\n" +
                        "  --! @param[out] o_req_mem_addr\n" +
                        "  --! @param[out] o_req_mem_strob\n" +
                        "  --! @param[out] o_req_mem_data\n" +
                        "  --! @param[out] o_req_mem_len        burst length\n" +
                        "  --! @param[out] o_req_mem_burst      burst type: \"00\" FIX; \"01\" INCR; \"10\" WRAP\n" +
                        "  --! @param[in] i_resp_mem_data_valid\n" +
                        "  --! @param[in] i_resp_mem_data\n" +
                        "  --! @param[in] i_resp_mem_load_store\n" +
                        "  --! @param[in] i_resp_mem_store_store\n" +
                        "  --! @param[in] i_flush_address   clear ICache address from debug interface\n" +
                        "  --! @param[in] i_flush_valid     address to clear icache is valid\n" +
                        "  --! @param[out] o_istate        ICache state machine value\n" +
                        "  --! @param[out] o_dstate        DCache state machine value\n" +
                        "  --! @param[out] o_cstate        cachetop state machine value\n" +
                        "  component CacheTop is generic (\n" +
                        "    memtech : integer;\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_req_ctrl_valid : in std_logic;\n" +
                        "    i_req_ctrl_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_req_ctrl_ready : out std_logic;\n" +
                        "    o_resp_ctrl_valid : out std_logic;\n" +
                        "    o_resp_ctrl_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_resp_ctrl_data : out std_logic_vector(31 downto 0);\n" +
                        "    o_resp_ctrl_load_fault : out std_logic;\n" +
                        "    i_resp_ctrl_ready : in std_logic;\n" +
                        "    o_req_data_ready : out std_logic;\n" +
                        "    i_req_data_valid : in std_logic;\n" +
                        "    i_req_data_write : in std_logic;\n" +
                        "    i_req_data_size : in std_logic_vector(1 downto 0);\n" +
                        "    i_req_data_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_req_data_data : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_resp_data_valid : out std_logic;\n" +
                        "    o_resp_data_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_resp_data_data : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_resp_data_load_fault : out std_logic;\n" +
                        "    o_resp_data_store_fault : out std_logic;\n" +
                        "    o_resp_data_store_fault_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_resp_data_ready : in std_logic;\n" +
                        "    i_req_mem_ready : in std_logic;\n" +
                        "    o_req_mem_valid : out std_logic;\n" +
                        "    o_req_mem_write : out std_logic;\n" +
                        "    o_req_mem_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_req_mem_strob : out std_logic_vector(BUS_DATA_BYTES-1 downto 0);\n" +
                        "    o_req_mem_data : out std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    o_req_mem_len : out std_logic_vector(7 downto 0);\n" +
                        "    o_req_mem_burst : out std_logic_vector(1 downto 0);\n" +
                        "    i_resp_mem_data_valid : in std_logic;\n" +
                        "    i_resp_mem_data : in std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    i_resp_mem_load_fault : in std_logic;\n" +
                        "    i_resp_mem_store_fault : in std_logic;\n" +
                        "    i_resp_mem_store_fault_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_flush_address : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_flush_valid : in std_logic;\n" +
                        "    o_istate : out std_logic_vector(1 downto 0);\n" +
                        "    o_dstate : out std_logic_vector(1 downto 0);\n" +
                        "    o_cstate : out std_logic_vector(1 downto 0)\n" +
                        "  );\n" +
                        "  end component; \n" +
                        "\n" +
                        "\n" +
                        "  --! @brief \"River\" CPU Top level.\n" +
                        "  --! @param[in] i_clk                 CPU clock\n" +
                        "  --! @param[in] i_nrst                Reset. Active LOW.\n" +
                        "  --! @param[in] i_req_mem_ready       AXI request was accepted\n" +
                        "  --! @param[out] o_req_mem_valid      AXI memory request is valid\n" +
                        "  --! @param[out] o_req_mem_write      AXI memory request is write type\n" +
                        "  --! @param[out] o_req_mem_addr       AXI memory request address\n" +
                        "  --! @param[out] o_req_mem_strob      Writing strob. 1 bit per Byte\n" +
                        "  --! @param[out] o_req_mem_data       Writing data\n" +
                        "  --! @param[out] o_req_mem_len        burst length\n" +
                        "  --! @param[out] o_req_mem_burst      burst type: \"00\" FIX; \"01\" INCR; \"10\" WRAP\n" +
                        "  --! @param[in] i_resp_mem_data_valid AXI response is valid\n" +
                        "  --! @param[in] i_resp_mem_data       Read data\n" +
                        "  --! @param[in] i_resp_mem_load_fault Bus response with SLVERR or DECERR on read\n" +
                        "  --! @param[in] i_resp_mem_store_fault Bus response with SLVERR or DECERR on write\n" +
                        "  --! @param[in] i_ext_irq             Interrupt line from external interrupts controller (PLIC).\n" +
                        "  --! @param[out] o_time               Timer. Clock counter except halt state.\n" +
                        "  --! @param[in] i_dport_valid         Debug access from DSU is valid\n" +
                        "  --! @param[in] i_dport_write         Write command flag\n" +
                        "  --! @param[in] i_dport_region        Registers region ID: 0=CSR; 1=IREGS; 2=Control\n" +
                        "  --! @param[in] i_dport_addr          Register idx\n" +
                        "  --! @param[in] i_dport_wdata         Write value\n" +
                        "  --! @param[out] o_dport_ready        Response is ready\n" +
                        "  --! @param[out] o_dport_rdata        Response value\n" +
                        "  component RiverTop is\n" +
                        "  generic (\n" +
                        "    memtech : integer := 0;\n" +
                        "    hartid : integer := 0;\n" +
                        "    async_reset : boolean := false\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_req_mem_ready : in std_logic;\n" +
                        "    o_req_mem_valid : out std_logic;\n" +
                        "    o_req_mem_write : out std_logic;\n" +
                        "    o_req_mem_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_req_mem_strob : out std_logic_vector(BUS_DATA_BYTES-1 downto 0);\n" +
                        "    o_req_mem_data : out std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    o_req_mem_len : out std_logic_vector(7 downto 0);\n" +
                        "    o_req_mem_burst : out std_logic_vector(1 downto 0);\n" +
                        "    i_resp_mem_data_valid : in std_logic;\n" +
                        "    i_resp_mem_data : in std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    i_resp_mem_load_fault : in std_logic;\n" +
                        "    i_resp_mem_store_fault : in std_logic;\n" +
                        "    i_resp_mem_store_fault_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_ext_irq : in std_logic;\n" +
                        "    o_time : out std_logic_vector(63 downto 0);\n" +
                        "    i_dport_valid : in std_logic;\n" +
                        "    i_dport_write : in std_logic;\n" +
                        "    i_dport_region : in std_logic_vector(1 downto 0);\n" +
                        "    i_dport_addr : in std_logic_vector(11 downto 0);\n" +
                        "    i_dport_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_dport_ready : out std_logic;\n" +
                        "    o_dport_rdata : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_halted : out std_logic\n" +
                        "  );\n" +
                        "  end component; \n" +
                        "\n" +
                        "end; -- package body";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_river_amba_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2018 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "--! @brief     \"River\" CPU Top level with AXI4 interface.\n" +
                        "------------------------------------------------------------------------------\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--! AMBA system bus specific library.\n" +
                        "--library ambalib;\n" +
                        "--! AXI4 configuration constants.\n" +
                        "use work.types_amba4.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "--library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use work.river_cfg.all;\n" +
                        "--! River top level with AMBA interface module declaration\n" +
                        "use work.types_river.all;\n" +
                        "--! Technology definition library.\n" +
                        "\n" +
                        "entity river_amba is \n" +
                        "  generic (\n" +
                        "    memtech : integer;\n" +
                        "    hartid : integer;\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port ( \n" +
                        "    i_nrst   : in std_logic;\n" +
                        "    i_clk    : in std_logic;\n" +
                        "    i_msti   : in axi4_master_in_type;\n" +
                        "    o_msto   : out axi4_master_out_type;\n" +
                        "    o_mstcfg : out axi4_master_config_type;\n" +
                        "    i_dport  : in dport_in_type;\n" +
                        "    o_dport  : out dport_out_type;\n" +
                        "    i_ext_irq : in std_logic\n" +
                        ");\n" +
                        "end;\n" +
                        " \n" +
                        "architecture arch_river_amba of river_amba is\n" +
                        "\n" +
                        "  component river_top is\n" +
                        "	  generic (\n" +
                        "		 memtech : integer := 0;\n" +
                        "		 hartid : integer := 0;\n" +
                        "		 async_reset : boolean := false\n" +
                        "	  );\n" +
                        "	  port (\n" +
                        "		 i_clk : in std_logic;                                             -- CPU clock\n" +
                        "		 i_nrst : in std_logic;                                            -- Reset. Active LOW.\n" +
                        "		 -- Memory interface:\n" +
                        "		 i_req_mem_ready : in std_logic;                                   -- AXI request was accepted\n" +
                        "		 o_req_mem_valid : out std_logic;                                  -- AXI memory request is valid\n" +
                        "		 o_req_mem_write : out std_logic;                                  -- AXI memory request is write type\n" +
                        "		 o_req_mem_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0); -- AXI memory request address\n" +
                        "		 o_req_mem_strob : out std_logic_vector(BUS_DATA_BYTES-1 downto 0);-- Writing strob. 1 bit per Byte\n" +
                        "		 o_req_mem_data : out std_logic_vector(BUS_DATA_WIDTH-1 downto 0); -- Writing data\n" +
                        "		 o_req_mem_len : out std_logic_vector(7 downto 0);                 -- burst length\n" +
                        "		 o_req_mem_burst : out std_logic_vector(1 downto 0);               -- burst type: \"00\" FIX; \"01\" INCR; \"10\" WRAP\n" +
                        "		 i_resp_mem_data_valid : in std_logic;                             -- AXI response is valid\n" +
                        "		 i_resp_mem_data : in std_logic_vector(BUS_DATA_WIDTH-1 downto 0); -- Read data\n" +
                        "		 i_resp_mem_load_fault : in std_logic;                             -- Bus response with SLVERR or DECERR on read\n" +
                        "		 i_resp_mem_store_fault : in std_logic;                            -- Bus response with SLVERR or DECERR on write\n" +
                        "		 i_resp_mem_store_fault_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "		 -- Interrupt line from external interrupts controller (PLIC).\n" +
                        "		 i_ext_irq : in std_logic;\n" +
                        "		 o_time : out std_logic_vector(63 downto 0);                       -- Timer. Clock counter except halt state.\n" +
                        "		 -- Debug interface:\n" +
                        "		 i_dport_valid : in std_logic;                                     -- Debug access from DSU is valid\n" +
                        "		 i_dport_write : in std_logic;                                     -- Write command flag\n" +
                        "		 i_dport_region : in std_logic_vector(1 downto 0);                 -- Registers region ID: 0=CSR; 1=IREGS; 2=Control\n" +
                        "		 i_dport_addr : in std_logic_vector(11 downto 0);                  -- Register idx\n" +
                        "		 i_dport_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0);       -- Write value\n" +
                        "		 o_dport_ready : out std_logic;                                    -- Response is ready\n" +
                        "		 o_dport_rdata : out std_logic_vector(RISCV_ARCH-1 downto 0);      -- Response value\n" +
                        "		 o_halted : out std_logic\n" +
                        "	  );\n" +
                        "  end component;\n" +
                        "  \n" +
                        "  constant xconfig : axi4_master_config_type := (\n" +
                        "     descrsize => PNP_CFG_MASTER_DESCR_BYTES,\n" +
                        "     descrtype => PNP_CFG_TYPE_MASTER,\n" +
                        "     vid => VENDOR_GNSSSENSOR,\n" +
                        "     did => RISCV_RIVER_CPU\n" +
                        "  );\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "      reading : std_logic;\n" +
                        "      w_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      w_valid : std_logic;\n" +
                        "      w_last : std_logic;\n" +
                        "      b_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      b_ready : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "      '0', (others => '0'), '0', '0', (others => '0'), '0'\n" +
                        "  );\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "\n" +
                        "  signal w_req_mem_ready : std_logic;\n" +
                        "  signal w_req_mem_valid : std_logic;\n" +
                        "  signal w_req_mem_write : std_logic;\n" +
                        "  signal wb_req_mem_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "  signal wb_req_mem_strob : std_logic_vector(BUS_DATA_BYTES-1 downto 0);\n" +
                        "  signal wb_req_mem_data : std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "  signal wb_req_mem_len : std_logic_vector(7 downto 0);\n" +
                        "  signal wb_req_mem_burst : std_logic_vector(1 downto 0);\n" +
                        "  signal w_resp_mem_data_valid : std_logic;\n" +
                        "  signal w_resp_mem_load_fault : std_logic;\n" +
                        "  signal w_resp_mem_store_fault : std_logic;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  o_mstcfg <= xconfig;\n" +
                        "  w_resp_mem_data_valid <= i_msti.r_valid or (r.w_valid and i_msti.w_ready);\n" +
                        "  -- Slave response resp = SLVERR (2'b10)\n" +
                        "  -- Interconnect response resp = DECERR (2'b11):\n" +
                        "  w_resp_mem_load_fault <= r.reading and i_msti.r_valid and i_msti.r_resp(1);\n" +
                        "  w_resp_mem_store_fault <= r.b_ready and i_msti.b_valid and i_msti.b_resp(1);\n" +
                        "  \n" +
                        "  river0 : river_top  generic map (\n" +
                        "      memtech => memtech,\n" +
                        "      hartid => hartid,\n" +
                        "      async_reset => async_reset\n" +
                        "    ) port map (\n" +
                        "      i_clk => i_clk,\n" +
                        "      i_nrst => i_nrst,\n" +
                        "      i_req_mem_ready => w_req_mem_ready,\n" +
                        "      o_req_mem_valid => w_req_mem_valid,\n" +
                        "      o_req_mem_write => w_req_mem_write,\n" +
                        "      o_req_mem_addr => wb_req_mem_addr,\n" +
                        "      o_req_mem_strob => wb_req_mem_strob,\n" +
                        "      o_req_mem_data => wb_req_mem_data,\n" +
                        "      o_req_mem_len => wb_req_mem_len,\n" +
                        "      o_req_mem_burst => wb_req_mem_burst,\n" +
                        "      i_resp_mem_data_valid => w_resp_mem_data_valid,\n" +
                        "      i_resp_mem_data => i_msti.r_data,\n" +
                        "      i_resp_mem_load_fault => w_resp_mem_load_fault,\n" +
                        "      i_resp_mem_store_fault => w_resp_mem_store_fault,\n" +
                        "      i_resp_mem_store_fault_addr => r.b_addr,\n" +
                        "      i_ext_irq => i_ext_irq,\n" +
                        "      o_time => open,\n" +
                        "      i_dport_valid => i_dport.valid,\n" +
                        "      i_dport_write => i_dport.write,\n" +
                        "      i_dport_region => i_dport.region,\n" +
                        "      i_dport_addr => i_dport.addr,\n" +
                        "      i_dport_wdata => i_dport.wdata,\n" +
                        "      o_dport_ready => o_dport.ready,\n" +
                        "      o_dport_rdata => o_dport.rdata,\n" +
                        "      o_halted => o_dport.halted\n" +
                        ");\n" +
                        "\n" +
                        "  comb : process(i_nrst, w_req_mem_valid, w_req_mem_write, wb_req_mem_addr,\n" +
                        "                 wb_req_mem_strob, wb_req_mem_data, wb_req_mem_len,\n" +
                        "                 wb_req_mem_burst, i_msti, r)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable vmsto : axi4_master_out_type;\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    vmsto := axi4_master_out_none;\n" +
                        "    vmsto.ar_valid      := w_req_mem_valid and not w_req_mem_write;\n" +
                        "    vmsto.ar_bits.addr  := wb_req_mem_addr;\n" +
                        "    vmsto.ar_bits.len   := wb_req_mem_len;\n" +
                        "    vmsto.ar_user       := '0';\n" +
                        "    vmsto.ar_id         := conv_std_logic_vector(0, CFG_ROCKET_ID_BITS);\n" +
                        "    vmsto.ar_bits.size  := \"011\"; -- 8 bytes\n" +
                        "    vmsto.ar_bits.burst := wb_req_mem_burst;\n" +
                        "\n" +
                        "    vmsto.aw_valid      := w_req_mem_valid and w_req_mem_write;\n" +
                        "    vmsto.aw_bits.addr  := wb_req_mem_addr;\n" +
                        "    vmsto.aw_bits.len   := wb_req_mem_len;\n" +
                        "    vmsto.aw_user       := '0';\n" +
                        "    vmsto.aw_id         := conv_std_logic_vector(0, CFG_ROCKET_ID_BITS);\n" +
                        "    vmsto.aw_bits.size  := \"011\"; -- 8 bytes\n" +
                        "    vmsto.aw_bits.burst := wb_req_mem_burst;\n" +
                        "\n" +
                        "    vmsto.w_valid := r.w_valid;\n" +
                        "    vmsto.w_last := r.w_last;\n" +
                        "    vmsto.w_strb := wb_req_mem_strob;\n" +
                        "    vmsto.w_data := wb_req_mem_data;\n" +
                        "\n" +
                        "    vmsto.b_ready := r.b_ready;\n" +
                        "    vmsto.r_ready := '1';\n" +
                        "\n" +
                        "    if (w_req_mem_valid and not w_req_mem_write and i_msti.ar_ready) = '1' then\n" +
                        "        v.reading := '1';\n" +
                        "    elsif i_msti.r_valid = '1' and i_msti.r_last = '1' then\n" +
                        "        v.reading := '0';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if (w_req_mem_valid and w_req_mem_write and i_msti.aw_ready) = '1' then\n" +
                        "        v.w_addr := wb_req_mem_addr;\n" +
                        "        v.w_valid := '1';\n" +
                        "        v.w_last := '1';\n" +
                        "    elsif i_msti.w_ready = '1' then\n" +
                        "        v.w_valid := '0';\n" +
                        "        v.w_last := '0';\n" +
                        "    end if;\n" +
                        "    \n" +
                        "    if (r.w_valid and i_msti.w_ready) = '1' then\n" +
                        "        v.b_addr := r.w_addr;\n" +
                        "        v.b_ready := '1';\n" +
                        "    elsif i_msti.b_valid = '1' then\n" +
                        "        v.b_ready := '0';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    rin <= v;\n" +
                        "    o_msto <= vmsto;\n" +
                        "    w_req_mem_ready <= (w_req_mem_write and i_msti.aw_ready)\n" +
                        "                    or (not w_req_mem_write and i_msti.ar_ready);\n" +
                        "  end process;\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(i_clk, i_nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_types_cache_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "--! Standard library\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--library riverlib;\n" +
                        "use work.river_cfg.all;\n" +
                        "\n" +
                        "package types_cache is\n" +
                        "\n" +
                        "  --! ICacheLru config\n" +
                        "  constant CFG_IOFFSET_WIDTH   : integer := 5;    -- [4:0]  log2(ICACHE_LINE_BYTES)\n" +
                        "  constant CFG_IODDEVEN_WIDTH  : integer := 1;    -- [5]    0=even; 1=odd\n" +
                        "  constant CFG_ICACHE_WAYS     : integer := 4;    -- 4 odds, 4 even\n" +
                        "\n" +
                        "  constant CFG_ILINES_PER_WAY : integer := 2**CFG_IINDEX_WIDTH;\n" +
                        "  -- [31:14] tag when 64 KB\n" +
                        "  -- [31:13] tag when 32 KB\n" +
                        "  -- [31:12] tag when 16 KB\n" +
                        "  constant CFG_ITAG_WIDTH : integer := BUS_ADDR_WIDTH\n" +
                        "    - (CFG_IOFFSET_WIDTH + CFG_IODDEVEN_WIDTH + CFG_IINDEX_WIDTH);\n" +
                        "\n" +
                        "  --! Store tag data as:\n" +
                        "  --!     [3:0]            qword is valid flag\n" +
                        "  --!     [4]              load_fault\n" +
                        "  --!     [ITAG_WIDTH+5:5] tag value\n" +
                        "  constant CFG_ITAG_WIDTH_TOTAL : integer := CFG_ITAG_WIDTH + 5;\n" +
                        "\n" +
                        "\n" +
                        "  constant IINDEX_START : integer := CFG_IOFFSET_WIDTH + CFG_IODDEVEN_WIDTH;\n" +
                        "  constant IINDEX_END : integer := IINDEX_START + CFG_IINDEX_WIDTH - 1;\n" +
                        "\n" +
                        "  constant ITAG_START : integer := IINDEX_START + CFG_IINDEX_WIDTH;\n" +
                        "  constant ITAG_END : integer := BUS_ADDR_WIDTH-1;\n" +
                        "\n" +
                        "  component IWayMem is generic (\n" +
                        "    memtech : integer := 0;\n" +
                        "    async_reset : boolean;\n" +
                        "    wayidx : integer\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_radr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_wadr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_wena : in std_logic;\n" +
                        "    i_wstrb : in std_logic_vector(3 downto 0);\n" +
                        "    i_wvalid : in std_logic_vector(3 downto 0);\n" +
                        "    i_wdata : in std_logic_vector(63 downto 0);\n" +
                        "    i_load_fault : in std_logic;\n" +
                        "    o_rtag : out std_logic_vector(CFG_ITAG_WIDTH-1 downto 0);\n" +
                        "    o_rdata : out std_logic_vector(31 downto 0);\n" +
                        "    o_valid : out std_logic;\n" +
                        "    o_load_fault : out std_logic\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "  component ILru is port (\n" +
                        "    i_clk : in std_logic;\n" +
                        "    i_init : in std_logic;\n" +
                        "    i_radr : in std_logic_vector(CFG_IINDEX_WIDTH-1 downto 0);\n" +
                        "    i_wadr : in std_logic_vector(CFG_IINDEX_WIDTH-1 downto 0);\n" +
                        "    i_we : in std_logic;\n" +
                        "    i_lru : in std_logic_vector(1 downto 0);\n" +
                        "    o_lru : out std_logic_vector(1 downto 0)\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_iwaymem_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--library techmap;\n" +
                        "use work.types_mem.all;\n" +
                        "--library riverlib;\n" +
                        "use work.river_cfg.all;\n" +
                        "use work.types_cache.all;\n" +
                        "\n" +
                        "entity IWayMem is generic (\n" +
                        "    memtech : integer := 0;\n" +
                        "    async_reset : boolean;\n" +
                        "    wayidx : integer\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_radr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_wadr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_wena : in std_logic;\n" +
                        "    i_wstrb : in std_logic_vector(3 downto 0);\n" +
                        "    i_wvalid : in std_logic_vector(3 downto 0);\n" +
                        "    i_wdata : in std_logic_vector(63 downto 0);\n" +
                        "    i_load_fault : in std_logic;\n" +
                        "    o_rtag : out std_logic_vector(CFG_ITAG_WIDTH-1 downto 0);\n" +
                        "    o_rdata : out std_logic_vector(31 downto 0);\n" +
                        "    o_valid : out std_logic;\n" +
                        "    o_load_fault : out std_logic\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_IWayMem of IWayMem is\n" +
                        "\n" +
                        "  constant RAM64_BLOCK_TOTAL : integer := (2**CFG_IOFFSET_WIDTH) / 8;\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "      roffset : std_logic_vector(CFG_IOFFSET_WIDTH-2 downto 0);  -- 2-bytes alignment\n" +
                        "  end record;\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "\n" +
                        "  signal datan : std_logic_vector(64*RAM64_BLOCK_TOTAL-1 downto 0);\n" +
                        "  signal wb_radr : std_logic_vector(CFG_IINDEX_WIDTH-1 downto 0);\n" +
                        "  signal wb_wadr : std_logic_vector(CFG_IINDEX_WIDTH-1 downto 0);\n" +
                        "\n" +
                        "  signal wb_tag_rdata : std_logic_vector(CFG_ITAG_WIDTH_TOTAL-1 downto 0);\n" +
                        "  signal w_tag_wena : std_logic;\n" +
                        "  signal wb_tag_wdata : std_logic_vector(CFG_ITAG_WIDTH_TOTAL-1 downto 0);\n" +
                        "\n" +
                        "  signal wb_data_rdata : std_logic_vector(64*RAM64_BLOCK_TOTAL-1 downto 0);\n" +
                        "  signal w_data_wena : std_logic_vector(RAM64_BLOCK_TOTAL-1 downto 0);\n" +
                        "\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  sp : if CFG_SINGLEPORT_CACHE generate\n" +
                        "    tag0 : ram_tech generic map (\n" +
                        "      memtech => memtech,\n" +
                        "      abits => CFG_IINDEX_WIDTH,\n" +
                        "      dbits => CFG_ITAG_WIDTH_TOTAL\n" +
                        "    ) port map (\n" +
                        "      i_clk => i_clk,\n" +
                        "      i_addr => wb_radr,\n" +
                        "      o_rdata => wb_tag_rdata,\n" +
                        "      i_wena => w_tag_wena,\n" +
                        "      i_wdata => wb_tag_wdata\n" +
                        "    );\n" +
                        "\n" +
                        "    dx : for n in 0 to RAM64_BLOCK_TOTAL-1 generate\n" +
                        "      data0 : ram_tech generic map (\n" +
                        "        memtech => memtech,\n" +
                        "        abits => CFG_IINDEX_WIDTH,\n" +
                        "        dbits => 64\n" +
                        "      ) port map (\n" +
                        "        i_clk => i_clk,\n" +
                        "        i_addr => wb_radr,\n" +
                        "        o_rdata => wb_data_rdata(64*(n+1)-1 downto 64*n),\n" +
                        "        i_wena => w_data_wena(n),\n" +
                        "        i_wdata => i_wdata\n" +
                        "      );\n" +
                        "    end generate;\n" +
                        "  end generate;\n" +
                        "\n" +
                        "  dp : if not CFG_SINGLEPORT_CACHE generate\n" +
                        "    tag0 : dpram_tech generic map (\n" +
                        "      memtech => memtech,\n" +
                        "      abits => CFG_IINDEX_WIDTH,\n" +
                        "      dbits => CFG_ITAG_WIDTH_TOTAL\n" +
                        "    ) port map (\n" +
                        "      i_clk => i_clk,\n" +
                        "      i_raddr => wb_radr,\n" +
                        "      o_rdata => wb_tag_rdata,\n" +
                        "      i_waddr => wb_wadr,\n" +
                        "      i_wena => w_tag_wena,\n" +
                        "      i_wdata => wb_tag_wdata\n" +
                        "    );\n" +
                        "\n" +
                        "    dx : for n in 0 to RAM64_BLOCK_TOTAL-1 generate\n" +
                        "      data0 : dpram_tech generic map (\n" +
                        "        memtech => memtech,\n" +
                        "        abits => CFG_IINDEX_WIDTH,\n" +
                        "        dbits => 64\n" +
                        "      ) port map (\n" +
                        "        i_clk => i_clk,\n" +
                        "        i_raddr => wb_radr,\n" +
                        "        o_rdata => wb_data_rdata(64*(n+1)-1 downto 64*n),\n" +
                        "        i_waddr => wb_wadr,\n" +
                        "        i_wena => w_data_wena(n),\n" +
                        "        i_wdata => i_wdata\n" +
                        "      );\n" +
                        "    end generate;\n" +
                        "  end generate;\n" +
                        "\n" +
                        "  comb : process(i_nrst, i_radr, i_wadr, i_wena, i_wstrb, i_wvalid,\n" +
                        "                 i_wdata, i_load_fault, wb_tag_rdata, wb_data_rdata, r)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable vb_rdata : std_logic_vector(31 downto 0);\n" +
                        "    variable v_valid : std_logic;\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    wb_radr <= i_radr(IINDEX_END downto IINDEX_START);\n" +
                        "    wb_wadr <= i_wadr(IINDEX_END downto IINDEX_START);\n" +
                        "\n" +
                        "    w_tag_wena <= i_wena;\n" +
                        "    wb_tag_wdata <= i_wadr(ITAG_END downto ITAG_START) &\n" +
                        "                   i_load_fault &     -- [4]\n" +
                        "                   i_wvalid;          -- [3:0]\n" +
                        "\n" +
                        "    w_data_wena <= (i_wena & i_wena & i_wena & i_wena) and i_wstrb;\n" +
                        "\n" +
                        "    v_valid := '0';\n" +
                        "    v.roffset := i_radr(CFG_IOFFSET_WIDTH-1 downto 1);\n" +
                        "    case r.roffset is\n" +
                        "    when X\"0\" =>\n" +
                        "        vb_rdata := wb_data_rdata(31 downto 0);\n" +
                        "        v_valid := wb_tag_rdata(0);\n" +
                        "    when X\"1\" =>\n" +
                        "        vb_rdata := wb_data_rdata(47 downto 16);\n" +
                        "        v_valid := wb_tag_rdata(0);\n" +
                        "    when X\"2\" =>\n" +
                        "        vb_rdata := wb_data_rdata(63 downto 32);\n" +
                        "        v_valid := wb_tag_rdata(0);\n" +
                        "    when X\"3\" =>\n" +
                        "        vb_rdata := wb_data_rdata(79 downto 48);\n" +
                        "        v_valid := wb_tag_rdata(0) and wb_tag_rdata(1);\n" +
                        "    when X\"4\" =>\n" +
                        "        vb_rdata := wb_data_rdata(95 downto 64);\n" +
                        "        v_valid := wb_tag_rdata(1);\n" +
                        "    when X\"5\" =>\n" +
                        "        vb_rdata := wb_data_rdata(111 downto 80);\n" +
                        "        v_valid := wb_tag_rdata(1);\n" +
                        "    when X\"6\" =>\n" +
                        "        vb_rdata := wb_data_rdata(127 downto 96);\n" +
                        "        v_valid := wb_tag_rdata(1);\n" +
                        "    when X\"7\" =>\n" +
                        "        vb_rdata := wb_data_rdata(143 downto 112);\n" +
                        "        v_valid := wb_tag_rdata(1) and wb_tag_rdata(2);\n" +
                        "    when X\"8\" =>\n" +
                        "        vb_rdata := wb_data_rdata(159 downto 128);\n" +
                        "        v_valid := wb_tag_rdata(2);\n" +
                        "    when X\"9\" =>\n" +
                        "        vb_rdata := wb_data_rdata(175 downto 144);\n" +
                        "        v_valid := wb_tag_rdata(2);\n" +
                        "    when X\"A\" =>\n" +
                        "        vb_rdata := wb_data_rdata(191 downto 160);\n" +
                        "        v_valid := wb_tag_rdata(2);\n" +
                        "    when X\"B\" =>\n" +
                        "        vb_rdata := wb_data_rdata(207 downto 176);\n" +
                        "        v_valid := wb_tag_rdata(2) and wb_tag_rdata(3);\n" +
                        "    when X\"C\" =>\n" +
                        "        vb_rdata := wb_data_rdata(223 downto 192);\n" +
                        "        v_valid := wb_tag_rdata(3);\n" +
                        "    when X\"D\" =>\n" +
                        "        vb_rdata := wb_data_rdata(239 downto 208);\n" +
                        "        v_valid := wb_tag_rdata(3);\n" +
                        "    when X\"E\" =>\n" +
                        "        vb_rdata := wb_data_rdata(255 downto 224);\n" +
                        "        v_valid := wb_tag_rdata(3);\n" +
                        "    when X\"F\" =>\n" +
                        "        vb_rdata(15 downto 0) := wb_data_rdata(255 downto 240);\n" +
                        "        vb_rdata(31 downto 16) := (others => '0');\n" +
                        "        v_valid := wb_tag_rdata(3);\n" +
                        "    when others =>\n" +
                        "    end case;\n" +
                        "\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v.roffset := (others => '0');\n" +
                        "    end if;\n" +
                        "\n" +
                        "    o_rdata <= vb_rdata;\n" +
                        "    o_rtag <= wb_tag_rdata(CFG_ITAG_WIDTH_TOTAL-1 downto 5);\n" +
                        "    o_valid <= v_valid;\n" +
                        "    o_load_fault <= wb_tag_rdata(4);\n" +
                        "   \n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(i_clk, i_nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r.roffset <= (others => '0');\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_ilru_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--library riverlib;\n" +
                        "use work.river_cfg.all;\n" +
                        "use work.types_cache.all;\n" +
                        "\n" +
                        "entity ILru is port (\n" +
                        "    i_clk : in std_logic;\n" +
                        "    i_init : in std_logic;\n" +
                        "    i_radr : in std_logic_vector(CFG_IINDEX_WIDTH-1 downto 0);\n" +
                        "    i_wadr : in std_logic_vector(CFG_IINDEX_WIDTH-1 downto 0);\n" +
                        "    i_we : in std_logic;\n" +
                        "    i_lru : in std_logic_vector(1 downto 0);\n" +
                        "    o_lru : out std_logic_vector(1 downto 0)\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_ILru of ILru is\n" +
                        "\n" +
                        "  constant LINES_TOTAL : integer := 2**CFG_IINDEX_WIDTH;\n" +
                        "  type array_type is array (0 to LINES_TOTAL-1) of std_logic_vector(7 downto 0);\n" +
                        "\n" +
                        "  signal radr : std_logic_vector(CFG_IINDEX_WIDTH-1 downto 0);\n" +
                        "  signal tbl : array_type;\n" +
                        "  signal wb_tbl_rdata : std_logic_vector(7 downto 0);\n" +
                        "  signal wb_tbl_wdata : std_logic_vector(7 downto 0);\n" +
                        "  signal w_we : std_logic;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  comb : process(i_init, i_radr, i_wadr, i_we, i_lru, wb_tbl_rdata)\n" +
                        "    variable vb_tbl_wdata : std_logic_vector(7 downto 0);\n" +
                        "    variable v_we : std_logic;\n" +
                        "  begin\n" +
                        "\n" +
                        "    v_we := i_we;\n" +
                        "    if i_init = '1' then\n" +
                        "        v_we := '1';\n" +
                        "        vb_tbl_wdata := X\"E4\";  -- 0x3, 0x2, 0x1, 00\n" +
                        "    elsif i_we = '1' then\n" +
                        "        if wb_tbl_rdata(7 downto 6) = i_lru then\n" +
                        "            vb_tbl_wdata := wb_tbl_rdata;\n" +
                        "        elsif wb_tbl_rdata(5 downto 4) = i_lru then\n" +
                        "            vb_tbl_wdata := i_lru & wb_tbl_rdata(7 downto 6)\n" +
                        "                                  & wb_tbl_rdata(3 downto 0);\n" +
                        "        elsif wb_tbl_rdata(3 downto 2) = i_lru then\n" +
                        "            vb_tbl_wdata := i_lru & wb_tbl_rdata(7 downto 4)\n" +
                        "                                  & wb_tbl_rdata(1 downto 0);\n" +
                        "        else\n" +
                        "            vb_tbl_wdata := i_lru & wb_tbl_rdata(7 downto 2);\n" +
                        "        end if;\n" +
                        "    else\n" +
                        "        vb_tbl_wdata := wb_tbl_rdata;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_we <= v_we;\n" +
                        "    wb_tbl_wdata <= vb_tbl_wdata;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  reg : process (i_clk) begin\n" +
                        "    if rising_edge(i_clk) then \n" +
                        "      radr <= i_radr;\n" +
                        "      if w_we = '1' then\n" +
                        "        tbl(conv_integer(i_wadr)) <= wb_tbl_wdata;\n" +
                        "      end if;\n" +
                        "    end if;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  wb_tbl_rdata <= tbl(conv_integer(radr));\n" +
                        "  o_lru <= wb_tbl_rdata(1 downto 0);\n" +
                        " \n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_icache_lru_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--library riverlib;\n" +
                        "use work.river_cfg.all;\n" +
                        "use work.types_cache.all;\n" +
                        "\n" +
                        "entity ICacheLru is generic (\n" +
                        "    memtech : integer;\n" +
                        "    async_reset : boolean;\n" +
                        "    index_width : integer\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    -- Control path:\n" +
                        "    i_req_ctrl_valid : in std_logic;\n" +
                        "    i_req_ctrl_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_req_ctrl_ready : out std_logic;\n" +
                        "    o_resp_ctrl_valid : out std_logic;\n" +
                        "    o_resp_ctrl_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_resp_ctrl_data : out std_logic_vector(31 downto 0);\n" +
                        "    o_resp_ctrl_load_fault : out std_logic;\n" +
                        "    i_resp_ctrl_ready : in std_logic;\n" +
                        "    -- Memory interface:\n" +
                        "    i_req_mem_ready : in std_logic;\n" +
                        "    o_req_mem_valid : out std_logic;\n" +
                        "    o_req_mem_write : out std_logic;\n" +
                        "    o_req_mem_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_req_mem_strob : out std_logic_vector(BUS_DATA_BYTES-1 downto 0);\n" +
                        "    o_req_mem_data : out std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    o_req_mem_len : out std_logic_vector(7 downto 0);\n" +
                        "    o_req_mem_burst : out std_logic_vector(1 downto 0);\n" +
                        "    o_req_mem_last : out std_logic;\n" +
                        "    i_resp_mem_data_valid : in std_logic;\n" +
                        "    i_resp_mem_data : in std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    i_resp_mem_load_fault : in std_logic;\n" +
                        "    -- Debug Signals:\n" +
                        "    i_flush_address : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);  -- clear ICache address from debug interface\n" +
                        "    i_flush_valid : in std_logic;                                      -- address to clear icache is valid\n" +
                        "    o_istate : out std_logic_vector(1 downto 0)\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_ICacheLru of ICacheLru is\n" +
                        "\n" +
                        "  constant FLUSH_ALL_ADDR : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0) := X\"FFFF0000\";\n" +
                        "  constant flush_cnt_zero : std_logic_vector(CFG_IINDEX_WIDTH downto 0) := (others => '0');\n" +
                        "\n" +
                        "  constant MISS : integer := CFG_ICACHE_WAYS;\n" +
                        "\n" +
                        "  constant WAY_EVEN : integer := 0;\n" +
                        "  constant WAY_ODD : integer := 1;\n" +
                        "\n" +
                        "  constant State_Idle : std_logic_vector(2 downto 0) := \"000\";\n" +
                        "  constant State_CheckHit : std_logic_vector(2 downto 0) := \"001\";\n" +
                        "  constant State_WaitGrant : std_logic_vector(2 downto 0) := \"010\";\n" +
                        "  constant State_WaitResp : std_logic_vector(2 downto 0) := \"011\";\n" +
                        "  constant State_CheckResp : std_logic_vector(2 downto 0) := \"100\";\n" +
                        "  constant State_SetupReadAdr : std_logic_vector(2 downto 0) := \"101\";\n" +
                        "  constant State_Flush : std_logic_vector(2 downto 0) := \"110\";\n" +
                        "\n" +
                        "  constant offset_ones : std_logic_vector(CFG_IOFFSET_WIDTH-1 downto 1) := (others => '1');\n" +
                        "\n" +
                        "  type TagMemInType is record\n" +
                        "      radr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      wadr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      wstrb : std_logic_vector(3 downto 0);\n" +
                        "      wvalid : std_logic_vector(3 downto 0);\n" +
                        "      wdata : std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "      load_fault : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  type TagMemInVector is array (0 to 1) of TagMemInType;\n" +
                        " \n" +
                        "\n" +
                        "  type TagMemOutType is record\n" +
                        "      rtag : std_logic_vector(CFG_ITAG_WIDTH-1 downto 0);\n" +
                        "      rdata : std_logic_vector(31 downto 0);\n" +
                        "      valid : std_logic;\n" +
                        "      load_fault : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  type TagMemOutVector is array (0 to CFG_ICACHE_WAYS-1) of TagMemOutType;\n" +
                        "\n" +
                        "\n" +
                        "  type WayMuxType is record\n" +
                        "      hit : integer range 0 to CFG_ICACHE_WAYS;\n" +
                        "      rdata : std_logic_vector(31 downto 0);\n" +
                        "      valid : std_logic;\n" +
                        "      load_fault : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  type WayMuxVector is array (0 to 1) of WayMuxType;\n" +
                        "\n" +
                        "\n" +
                        "  type LruInType is record\n" +
                        "      init : std_logic;\n" +
                        "      radr : std_logic_vector(CFG_IINDEX_WIDTH-1 downto 0);\n" +
                        "      wadr : std_logic_vector(CFG_IINDEX_WIDTH-1 downto 0);\n" +
                        "      we : std_logic;\n" +
                        "      lru : std_logic_vector(1 downto 0);\n" +
                        "  end record;\n" +
                        "\n" +
                        "  type LruInVector is array (0 to 1) of LruInType;\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "      requested : std_logic;\n" +
                        "      req_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      req_addr_overlay : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      use_overlay : std_logic;\n" +
                        "      state : std_logic_vector(2 downto 0);\n" +
                        "      req_mem_valid : std_logic;\n" +
                        "      mem_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      burst_cnt : integer range 0 to 3;\n" +
                        "      burst_wstrb : std_logic_vector(3 downto 0);\n" +
                        "      burst_valid : std_logic_vector(3 downto 0);\n" +
                        "      lru_even_wr : std_logic_vector(1 downto 0);\n" +
                        "      lru_odd_wr : std_logic_vector(1 downto 0);\n" +
                        "      req_flush : std_logic;\n" +
                        "      req_flush_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      req_flush_cnt : std_logic_vector(CFG_IINDEX_WIDTH downto 0);\n" +
                        "      flush_cnt : std_logic_vector(CFG_IINDEX_WIDTH downto 0);\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "    '0', (others => '0'), (others => '0'),  -- requested, req_addr, req_addr_overlay\n" +
                        "    '0', State_Idle,                        -- use_overlay, state\n" +
                        "    '0', (others => '0'),                   -- req_mem_valid, mem_addr,\n" +
                        "    0, \"0000\", \"0000\",                      -- burst_cnt, burst_wstrb, burst_valid\n" +
                        "    \"00\", \"00\", '1',                        -- lru_even_wr, lru_odd_wr, req_flush\n" +
                        "    (others => '1'), (others => '0'),       -- req_flush_addr, req_flush_cnt\n" +
                        "    (others => '0')                         -- flush_cnt\n" +
                        "  );\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "  signal swapin : TagMemInVector;\n" +
                        "  signal memeven : TagMemOutVector;\n" +
                        "  signal memodd : TagMemOutVector;\n" +
                        "  signal wb_ena_even : std_logic_vector(CFG_ICACHE_WAYS-1 downto 0);\n" +
                        "  signal wb_ena_odd : std_logic_vector(CFG_ICACHE_WAYS-1 downto 0);\n" +
                        "\n" +
                        "  signal lrui : LruInVector;\n" +
                        "  signal wb_lru_even : std_logic_vector(1 downto 0);\n" +
                        "  signal wb_lru_odd : std_logic_vector(1 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  wayx : for n in 0 to CFG_ICACHE_WAYS-1 generate\n" +
                        "      wayevenx : IWayMem generic map (\n" +
                        "          memtech => memtech,\n" +
                        "          async_reset => async_reset,\n" +
                        "          wayidx => 2*n\n" +
                        "      ) port map (\n" +
                        "          i_clk => i_clk,\n" +
                        "          i_nrst => i_nrst,\n" +
                        "          i_radr => swapin(WAY_EVEN).radr,\n" +
                        "          i_wadr => swapin(WAY_EVEN).wadr,\n" +
                        "          i_wena => wb_ena_even(n),\n" +
                        "          i_wstrb => swapin(WAY_EVEN).wstrb,\n" +
                        "          i_wvalid => swapin(WAY_EVEN).wvalid,\n" +
                        "          i_wdata => swapin(WAY_EVEN).wdata,\n" +
                        "          i_load_fault => swapin(WAY_EVEN).load_fault,\n" +
                        "          o_rtag => memeven(n).rtag,\n" +
                        "          o_rdata => memeven(n).rdata,\n" +
                        "          o_valid => memeven(n).valid,\n" +
                        "          o_load_fault => memeven(n).load_fault\n" +
                        "      );\n" +
                        "\n" +
                        "      wayoddx : IWayMem generic map (\n" +
                        "          async_reset => async_reset,\n" +
                        "          wayidx => 2*n + 1\n" +
                        "      ) port map (\n" +
                        "          i_clk => i_clk,\n" +
                        "          i_nrst => i_nrst,\n" +
                        "          i_radr => swapin(WAY_ODD).radr,\n" +
                        "          i_wadr => swapin(WAY_ODD).wadr,\n" +
                        "          i_wena => wb_ena_odd(n),\n" +
                        "          i_wstrb => swapin(WAY_ODD).wstrb,\n" +
                        "          i_wvalid => swapin(WAY_ODD).wvalid,\n" +
                        "          i_wdata => swapin(WAY_ODD).wdata,\n" +
                        "          i_load_fault => swapin(WAY_ODD).load_fault,\n" +
                        "          o_rtag => memodd(n).rtag,\n" +
                        "          o_rdata => memodd(n).rdata,\n" +
                        "          o_valid => memodd(n).valid,\n" +
                        "          o_load_fault => memodd(n).load_fault\n" +
                        "      );\n" +
                        "  end generate;\n" +
                        "\n" +
                        "  lrueven0 : ILru port map (\n" +
                        "      i_clk => i_clk,\n" +
                        "      i_init => lrui(WAY_EVEN).init,\n" +
                        "      i_radr => lrui(WAY_EVEN).radr,\n" +
                        "      i_wadr => lrui(WAY_EVEN).wadr,\n" +
                        "      i_we => lrui(WAY_EVEN).we,\n" +
                        "      i_lru => lrui(WAY_EVEN).lru,\n" +
                        "      o_lru => wb_lru_even\n" +
                        "  );\n" +
                        "\n" +
                        "  lruodd0 : ILru port map (\n" +
                        "      i_clk => i_clk,\n" +
                        "      i_init => lrui(WAY_ODD).init,\n" +
                        "      i_radr => lrui(WAY_ODD).radr,\n" +
                        "      i_wadr => lrui(WAY_ODD).wadr,\n" +
                        "      i_we => lrui(WAY_ODD).we,\n" +
                        "      i_lru => lrui(WAY_ODD).lru,\n" +
                        "      o_lru => wb_lru_odd\n" +
                        "  );\n" +
                        "\n" +
                        "  comb : process(i_nrst, i_req_ctrl_valid, i_req_ctrl_addr,\n" +
                        "                i_resp_ctrl_ready, i_req_mem_ready, \n" +
                        "                i_resp_mem_data_valid, i_resp_mem_data, i_resp_mem_load_fault, \n" +
                        "                i_flush_address, i_flush_valid,\n" +
                        "                memeven, memodd, wb_lru_even, wb_lru_odd, r)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable waysel : WayMuxVector;\n" +
                        "    variable w_raddr5 : std_logic;\n" +
                        "    variable w_raddr5_r : std_logic;\n" +
                        "    variable w_use_overlay : std_logic;\n" +
                        "    variable wb_req_adr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable wb_radr_overlay : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable wb_rtag : std_logic_vector(CFG_ITAG_WIDTH-1 downto 0);\n" +
                        "    variable wb_rtag_overlay : std_logic_vector(CFG_ITAG_WIDTH-1 downto 0);\n" +
                        "    variable wb_rtag_even : std_logic_vector(CFG_ITAG_WIDTH-1 downto 0);\n" +
                        "    variable wb_rtag_odd : std_logic_vector(CFG_ITAG_WIDTH-1 downto 0);\n" +
                        "    variable wb_hit0 : integer range 0 to CFG_ICACHE_WAYS;\n" +
                        "    variable wb_hit1 : integer range 0 to CFG_ICACHE_WAYS;\n" +
                        "    variable w_hit0_valid : std_logic;\n" +
                        "    variable w_hit1_valid : std_logic;\n" +
                        "    variable wb_mem_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable wb_o_resp_data : std_logic_vector(31 downto 0);\n" +
                        "    variable v_init : std_logic;\n" +
                        "    variable w_ena : std_logic;\n" +
                        "    variable w_last : std_logic;\n" +
                        "    variable w_o_resp_valid : std_logic;\n" +
                        "    variable w_o_resp_load_fault : std_logic;\n" +
                        "    variable w_o_req_ctrl_ready : std_logic;\n" +
                        "    variable wb_wstrb_next : std_logic_vector(3 downto 0);\n" +
                        "    variable v_swapin : TagMemInVector;\n" +
                        "    variable v_lrui : LruInVector;\n" +
                        "    variable vb_ena_even : std_logic_vector(CFG_ICACHE_WAYS-1 downto 0);\n" +
                        "    variable vb_ena_odd : std_logic_vector(CFG_ICACHE_WAYS-1 downto 0);\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    if i_req_ctrl_valid = '1' then\n" +
                        "        wb_req_adr := i_req_ctrl_addr;\n" +
                        "    else\n" +
                        "        wb_req_adr := r.req_addr;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_raddr5 := wb_req_adr(CFG_IOFFSET_WIDTH);\n" +
                        "    w_raddr5_r := r.req_addr(CFG_IOFFSET_WIDTH);\n" +
                        "\n" +
                        "    w_use_overlay := '0';\n" +
                        "    if wb_req_adr(CFG_IOFFSET_WIDTH-1 downto 1) = offset_ones then\n" +
                        "        w_use_overlay := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    wb_radr_overlay(BUS_ADDR_WIDTH-1 downto CFG_IOFFSET_WIDTH) := \n" +
                        "        wb_req_adr(BUS_ADDR_WIDTH-1 downto CFG_IOFFSET_WIDTH) + 1;\n" +
                        "    wb_radr_overlay(CFG_IOFFSET_WIDTH-1 downto 0) := (others => '0');\n" +
                        "\n" +
                        "    -- flush request via debug interface\n" +
                        "    if i_flush_valid = '1' then\n" +
                        "        v.req_flush := '1';\n" +
                        "        if i_flush_address(0) = '1' then\n" +
                        "            v.req_flush_cnt := (others => '1');\n" +
                        "            v.req_flush_addr := FLUSH_ALL_ADDR;\n" +
                        "        elsif i_flush_address(CFG_IOFFSET_WIDTH-1 downto 1) = offset_ones then\n" +
                        "            v.req_flush_cnt := conv_std_logic_vector(1, CFG_IINDEX_WIDTH+1);\n" +
                        "            v.req_flush_addr := i_flush_address;\n" +
                        "        else\n" +
                        "            v.req_flush_cnt := (others => '0');\n" +
                        "            v.req_flush_addr := i_flush_address;\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Check read tag and select hit way\n" +
                        "    wb_rtag := r.req_addr(ITAG_END downto ITAG_START);\n" +
                        "    wb_rtag_overlay := r.req_addr_overlay(ITAG_END downto ITAG_START);\n" +
                        "    waysel(WAY_EVEN).hit := MISS;\n" +
                        "    waysel(WAY_EVEN).rdata := (others => '0');\n" +
                        "    waysel(WAY_EVEN).valid := '0';\n" +
                        "    waysel(WAY_EVEN).load_fault := '0';\n" +
                        "    waysel(WAY_ODD).hit := MISS;\n" +
                        "    waysel(WAY_ODD).rdata := (others => '0');\n" +
                        "    waysel(WAY_ODD).valid := '0';\n" +
                        "    waysel(WAY_ODD).load_fault := '0';\n" +
                        "    if r.use_overlay = '0' then\n" +
                        "        wb_rtag_even := wb_rtag;\n" +
                        "        wb_rtag_odd := wb_rtag;\n" +
                        "    elsif w_raddr5_r = '0' then\n" +
                        "        wb_rtag_even := wb_rtag;\n" +
                        "        wb_rtag_odd := wb_rtag_overlay;\n" +
                        "    else\n" +
                        "        wb_rtag_even := wb_rtag_overlay;\n" +
                        "        wb_rtag_odd := wb_rtag;\n" +
                        "    end if;\n" +
                        "    for n in 0 to CFG_ICACHE_WAYS-1 loop\n" +
                        "        if waysel(WAY_EVEN).hit = MISS and memeven(n).rtag = wb_rtag_even then\n" +
                        "            waysel(WAY_EVEN).hit := n;\n" +
                        "            waysel(WAY_EVEN).rdata := memeven(n).rdata;\n" +
                        "            waysel(WAY_EVEN).valid := memeven(n).valid;\n" +
                        "            waysel(WAY_EVEN).load_fault := memeven(n).load_fault;\n" +
                        "        end if;\n" +
                        "\n" +
                        "        if waysel(WAY_ODD).hit = MISS and memodd(n).rtag = wb_rtag_odd then\n" +
                        "            waysel(WAY_ODD).hit := n;\n" +
                        "            waysel(WAY_ODD).rdata := memodd(n).rdata;\n" +
                        "            waysel(WAY_ODD).valid := memodd(n).valid;\n" +
                        "            waysel(WAY_ODD).load_fault := memodd(n).load_fault;\n" +
                        "        end if;\n" +
                        "    end loop;\n" +
                        "\n" +
                        "    -- swap back rdata\n" +
                        "    w_o_resp_load_fault := '0';\n" +
                        "    if w_raddr5_r = '0' then\n" +
                        "        if r.use_overlay = '0' then\n" +
                        "            wb_hit0 := waysel(WAY_EVEN).hit;\n" +
                        "            wb_hit1 := waysel(WAY_EVEN).hit;\n" +
                        "            w_hit0_valid := waysel(WAY_EVEN).valid;\n" +
                        "            w_hit1_valid := waysel(WAY_EVEN).valid;\n" +
                        "            wb_o_resp_data := waysel(WAY_EVEN).rdata;\n" +
                        "            w_o_resp_load_fault := waysel(WAY_EVEN).load_fault;\n" +
                        "        else\n" +
                        "            wb_hit0 := waysel(WAY_EVEN).hit;\n" +
                        "            wb_hit1 := waysel(WAY_ODD).hit;\n" +
                        "            w_hit0_valid := waysel(WAY_EVEN).valid;\n" +
                        "            w_hit1_valid := waysel(WAY_ODD).valid;\n" +
                        "            wb_o_resp_data(15 downto 0) := waysel(WAY_EVEN).rdata(15 downto 0);\n" +
                        "            wb_o_resp_data(31 downto 16) := waysel(WAY_ODD).rdata(15 downto 0);\n" +
                        "            w_o_resp_load_fault :=\n" +
                        "                waysel(WAY_EVEN).load_fault or waysel(WAY_ODD).load_fault;\n" +
                        "        end if;\n" +
                        "    else\n" +
                        "        if r.use_overlay = '0' then\n" +
                        "            wb_hit0 := waysel(WAY_ODD).hit;\n" +
                        "            wb_hit1 := waysel(WAY_ODD).hit;\n" +
                        "            w_hit0_valid := waysel(WAY_ODD).valid;\n" +
                        "            w_hit1_valid := waysel(WAY_ODD).valid;\n" +
                        "            wb_o_resp_data := waysel(WAY_ODD).rdata;\n" +
                        "            w_o_resp_load_fault := waysel(WAY_ODD).load_fault;\n" +
                        "        else\n" +
                        "            wb_hit0 := waysel(WAY_ODD).hit;\n" +
                        "            wb_hit1 := waysel(WAY_EVEN).hit;\n" +
                        "            w_hit0_valid := waysel(WAY_ODD).valid;\n" +
                        "            w_hit1_valid := waysel(WAY_EVEN).valid;\n" +
                        "            wb_o_resp_data(15 downto 0) := waysel(WAY_ODD).rdata(15 downto 0);\n" +
                        "            wb_o_resp_data(31 downto 16) := waysel(WAY_EVEN).rdata(15 downto 0);\n" +
                        "            w_o_resp_load_fault :=\n" +
                        "                waysel(WAY_ODD).load_fault or waysel(WAY_EVEN).load_fault;\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    v_lrui(WAY_EVEN).init := '0';\n" +
                        "    v_lrui(WAY_EVEN).radr := (others => '0');\n" +
                        "    v_lrui(WAY_EVEN).wadr := (others => '0');\n" +
                        "    v_lrui(WAY_EVEN).we := '0';\n" +
                        "    v_lrui(WAY_EVEN).lru := (others => '0');\n" +
                        "    v_lrui(WAY_ODD).init := '0';\n" +
                        "    v_lrui(WAY_ODD).radr := (others => '0');\n" +
                        "    v_lrui(WAY_ODD).wadr := (others => '0');\n" +
                        "    v_lrui(WAY_ODD).we := '0';\n" +
                        "    v_lrui(WAY_ODD).lru := (others => '0');\n" +
                        "    w_o_resp_valid := '0';\n" +
                        "    if r.state = State_Flush then\n" +
                        "        v_lrui(WAY_EVEN).init := not r.mem_addr(CFG_IOFFSET_WIDTH);\n" +
                        "        v_lrui(WAY_EVEN).wadr := r.mem_addr(IINDEX_END downto IINDEX_START);\n" +
                        "        v_lrui(WAY_ODD).init := r.mem_addr(CFG_IOFFSET_WIDTH);\n" +
                        "        v_lrui(WAY_ODD).wadr := r.mem_addr(IINDEX_END downto IINDEX_START);\n" +
                        "    elsif CFG_SINGLEPORT_CACHE and (r.state = State_WaitGrant\n" +
                        "            or r.state = State_WaitResp or r.state = State_CheckResp\n" +
                        "            or r.state = State_SetupReadAdr) then\n" +
                        "            -- Do nothing while memory writing\n" +
                        "    elsif w_hit0_valid = '1' and w_hit1_valid = '1'\n" +
                        "        and wb_hit0 /= MISS and wb_hit1 /= MISS and r.requested = '1' then\n" +
                        "        w_o_resp_valid := '1';\n" +
                        "\n" +
                        "        -- Update LRU table\n" +
                        "        if w_raddr5_r = '0' then\n" +
                        "            v_lrui(WAY_EVEN).we := '1';\n" +
                        "            v_lrui(WAY_EVEN).lru := conv_std_logic_vector(wb_hit0, 2)(1 downto 0);\n" +
                        "            v_lrui(WAY_EVEN).wadr :=\n" +
                        "                r.req_addr(IINDEX_END downto IINDEX_START);\n" +
                        "            if r.use_overlay = '1' then\n" +
                        "                v_lrui(WAY_ODD).we := '1';\n" +
                        "                v_lrui(WAY_ODD).lru := conv_std_logic_vector(wb_hit1, 2)(1 downto 0);\n" +
                        "                v_lrui(WAY_ODD).wadr :=\n" +
                        "                    r.req_addr_overlay(IINDEX_END downto IINDEX_START);\n" +
                        "            end if;\n" +
                        "        else\n" +
                        "            v_lrui(WAY_ODD).we := '1';\n" +
                        "            v_lrui(WAY_ODD).lru := conv_std_logic_vector(wb_hit0, 2)(1 downto 0);\n" +
                        "            v_lrui(WAY_ODD).wadr :=\n" +
                        "                r.req_addr(IINDEX_END downto IINDEX_START);\n" +
                        "            if r.use_overlay = '1' then\n" +
                        "                v_lrui(WAY_EVEN).we := '1';\n" +
                        "                v_lrui(WAY_EVEN).lru := conv_std_logic_vector(wb_hit1, 2)(1 downto 0);\n" +
                        "                v_lrui(WAY_EVEN).wadr :=\n" +
                        "                    r.req_addr_overlay(IINDEX_END downto IINDEX_START);\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_o_req_ctrl_ready := not r.req_flush\n" +
                        "                       and (not r.requested or w_o_resp_valid);\n" +
                        "    if i_req_ctrl_valid = '1' and w_o_req_ctrl_ready = '1' then\n" +
                        "        v.req_addr := i_req_ctrl_addr;\n" +
                        "        v.req_addr_overlay := wb_radr_overlay;\n" +
                        "        v.use_overlay := w_use_overlay;\n" +
                        "        v.requested := '1';\n" +
                        "    elsif w_o_resp_valid = '1' and i_resp_ctrl_ready = '1' then\n" +
                        "        v.requested := '0';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- System Bus access state machine\n" +
                        "    w_last := '0';\n" +
                        "    w_ena := '0';\n" +
                        "    v_init := '0';\n" +
                        "    wb_wstrb_next := r.burst_wstrb(2 downto 0) & r.burst_wstrb(3);\n" +
                        "    case r.state is\n" +
                        "    when State_Idle =>\n" +
                        "        if r.req_flush = '1' then\n" +
                        "            v.state := State_Flush;\n" +
                        "            if r.req_flush_addr(0) = '1' then\n" +
                        "                v.mem_addr := FLUSH_ALL_ADDR;\n" +
                        "                v.flush_cnt := (others => '1');\n" +
                        "            else\n" +
                        "                v.mem_addr := r.req_flush_addr;\n" +
                        "                v.flush_cnt := r.req_flush_cnt;\n" +
                        "            end if;\n" +
                        "            v.burst_wstrb := (others => '1');    -- All qwords in line\n" +
                        "            v.burst_valid := (others => '0');    -- All qwords in line\n" +
                        "        elsif (i_req_ctrl_valid = '1' and w_o_req_ctrl_ready = '1')\n" +
                        "              or r.requested = '1' then\n" +
                        "            --! Check hit even there's no new request only the previous one.\n" +
                        "            --! This must be done in a case of CPU is halted and cache was flushed\n" +
                        "            --!\n" +
                        "            v.state := State_CheckHit;\n" +
                        "        end if;\n" +
                        "    when State_CheckHit =>\n" +
                        "        if w_o_resp_valid = '1' then\n" +
                        "            -- Hit\n" +
                        "            if i_req_ctrl_valid = '1' and w_o_req_ctrl_ready = '1' then\n" +
                        "                v.state := State_CheckHit;\n" +
                        "            else\n" +
                        "                v.state := State_Idle;\n" +
                        "            end if;\n" +
                        "\n" +
                        "        else\n" +
                        "            -- Miss\n" +
                        "            v.req_mem_valid := '1';\n" +
                        "            if w_hit0_valid = '0' or wb_hit0 = MISS then\n" +
                        "                wb_mem_addr := r.req_addr;\n" +
                        "            else\n" +
                        "                wb_mem_addr := r.req_addr_overlay;\n" +
                        "            end if;\n" +
                        "            if i_req_mem_ready = '1' then\n" +
                        "                v.state := State_WaitResp;\n" +
                        "            else\n" +
                        "                v.state := State_WaitGrant;\n" +
                        "            end if;\n" +
                        "\n" +
                        "            v.mem_addr := wb_mem_addr(BUS_ADDR_WIDTH-1 downto 3) & \"000\";\n" +
                        "            v.burst_cnt := 3;\n" +
                        "            case wb_mem_addr(CFG_IOFFSET_WIDTH-1 downto 3) is\n" +
                        "            when \"00\" =>\n" +
                        "                wb_wstrb_next := X\"1\";\n" +
                        "            when \"01\" =>\n" +
                        "                wb_wstrb_next := X\"2\";\n" +
                        "            when \"10\" =>\n" +
                        "                wb_wstrb_next := X\"4\";\n" +
                        "            when \"11\" =>\n" +
                        "                wb_wstrb_next := X\"8\";\n" +
                        "            when others =>\n" +
                        "            end case;\n" +
                        "            v.burst_wstrb := wb_wstrb_next;\n" +
                        "            v.burst_valid := wb_wstrb_next;\n" +
                        "            v.lru_even_wr := wb_lru_even;\n" +
                        "            v.lru_odd_wr := wb_lru_odd;\n" +
                        "        end if;\n" +
                        "    when State_WaitGrant =>\n" +
                        "        if i_req_mem_ready = '1' then\n" +
                        "            v.req_mem_valid := '0';\n" +
                        "            v.state := State_WaitResp;\n" +
                        "        end if;\n" +
                        "    when State_WaitResp =>\n" +
                        "        if r.burst_cnt = 0 then\n" +
                        "            w_last := '1';\n" +
                        "        end if;\n" +
                        "        if i_resp_mem_data_valid = '1' then\n" +
                        "            w_ena := '1';\n" +
                        "            if r.burst_cnt = 0 then\n" +
                        "                v.state := State_CheckResp;\n" +
                        "            else\n" +
                        "                v.burst_cnt := r.burst_cnt - 1;\n" +
                        "            end if;\n" +
                        "            -- Suppose using WRAP burst transaction\n" +
                        "            v.burst_wstrb := wb_wstrb_next;\n" +
                        "            v.burst_valid := r.burst_valid or wb_wstrb_next;\n" +
                        "        end if;\n" +
                        "    when State_CheckResp =>\n" +
                        "        if CFG_SINGLEPORT_CACHE then\n" +
                        "            v.state := State_SetupReadAdr;\n" +
                        "        elsif (w_o_req_ctrl_ready = '1' and i_req_ctrl_valid = '1')\n" +
                        "            or (r.requested = '1' and w_o_resp_valid = '0') then\n" +
                        "            v.state := State_CheckHit;\n" +
                        "        else\n" +
                        "            v.state := State_Idle;\n" +
                        "        end if;\n" +
                        "    when State_SetupReadAdr =>\n" +
                        "        v.state := State_CheckHit;\n" +
                        "    when State_Flush =>\n" +
                        "        v_init := '1';\n" +
                        "        if r.flush_cnt = flush_cnt_zero then\n" +
                        "            v.req_flush := '0';\n" +
                        "            v.state := State_Idle;\n" +
                        "        else\n" +
                        "            v.flush_cnt := r.flush_cnt - 1;\n" +
                        "            v.mem_addr(BUS_ADDR_WIDTH-1 downto CFG_IOFFSET_WIDTH) := \n" +
                        "                   r.mem_addr(BUS_ADDR_WIDTH-1 downto CFG_IOFFSET_WIDTH) + 1;\n" +
                        "        end if;\n" +
                        "    when others =>\n" +
                        "    end case;\n" +
                        "\n" +
                        "    -- Write signals:\n" +
                        "    vb_ena_even := (others => '0');\n" +
                        "    vb_ena_odd := (others => '0');\n" +
                        "    if r.mem_addr(CFG_IOFFSET_WIDTH) = '0' then\n" +
                        "        vb_ena_even := (others => v_init);\n" +
                        "        vb_ena_even(conv_integer(r.lru_even_wr)) := w_ena or v_init;\n" +
                        "    else\n" +
                        "        vb_ena_odd := (others => v_init);\n" +
                        "        vb_ena_odd(conv_integer(r.lru_odd_wr)) := w_ena or v_init;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    v_swapin(WAY_EVEN).wadr := r.mem_addr;\n" +
                        "    v_swapin(WAY_EVEN).wstrb := r.burst_wstrb;\n" +
                        "    v_swapin(WAY_EVEN).wvalid := r.burst_valid;\n" +
                        "    v_swapin(WAY_EVEN).wdata := i_resp_mem_data;\n" +
                        "    v_swapin(WAY_EVEN).load_fault := i_resp_mem_load_fault;\n" +
                        "    v_swapin(WAY_ODD).wadr := r.mem_addr;\n" +
                        "    v_swapin(WAY_ODD).wstrb := r.burst_wstrb;\n" +
                        "    v_swapin(WAY_ODD).wvalid := r.burst_valid;\n" +
                        "    v_swapin(WAY_ODD).wdata := i_resp_mem_data;\n" +
                        "    v_swapin(WAY_ODD).load_fault := i_resp_mem_load_fault;\n" +
                        "\n" +
                        "    if CFG_SINGLEPORT_CACHE and (r.state = State_WaitResp\n" +
                        "        or r.state = State_CheckResp\n" +
                        "        or r.state = State_Flush) then\n" +
                        "        v_swapin(WAY_EVEN).radr := r.mem_addr;\n" +
                        "        v_swapin(WAY_ODD).radr := r.mem_addr;\n" +
                        "    elsif r.state = State_Idle or w_o_resp_valid = '1' then\n" +
                        "        if w_raddr5 = '0' then\n" +
                        "            v_swapin(WAY_EVEN).radr := wb_req_adr;\n" +
                        "            v_swapin(WAY_ODD).radr := wb_radr_overlay;\n" +
                        "            v_lrui(WAY_EVEN).radr := wb_req_adr(IINDEX_END downto IINDEX_START);\n" +
                        "            v_lrui(WAY_ODD).radr := wb_radr_overlay(IINDEX_END downto IINDEX_START);\n" +
                        "        else\n" +
                        "            v_swapin(WAY_EVEN).radr := wb_radr_overlay;\n" +
                        "            v_swapin(WAY_ODD).radr := wb_req_adr;\n" +
                        "            v_lrui(WAY_EVEN).radr := wb_radr_overlay(IINDEX_END downto IINDEX_START);\n" +
                        "            v_lrui(WAY_ODD).radr := wb_req_adr(IINDEX_END downto IINDEX_START);\n" +
                        "        end if;\n" +
                        "    else\n" +
                        "        if w_raddr5_r = '0' then\n" +
                        "            v_swapin(WAY_EVEN).radr := r.req_addr;\n" +
                        "            v_swapin(WAY_ODD).radr := r.req_addr_overlay;\n" +
                        "            v_lrui(WAY_EVEN).radr :=\n" +
                        "                r.req_addr(IINDEX_END downto IINDEX_START);\n" +
                        "            v_lrui(WAY_ODD).radr :=\n" +
                        "                r.req_addr_overlay(IINDEX_END downto IINDEX_START);\n" +
                        "        else\n" +
                        "            v_swapin(WAY_EVEN).radr := r.req_addr_overlay;\n" +
                        "            v_swapin(WAY_ODD).radr := r.req_addr;\n" +
                        "            v_lrui(WAY_EVEN).radr :=\n" +
                        "                r.req_addr_overlay(IINDEX_END downto IINDEX_START);\n" +
                        "            v_lrui(WAY_ODD).radr :=\n" +
                        "                r.req_addr(IINDEX_END downto IINDEX_START);\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    lrui(WAY_EVEN) <= v_lrui(WAY_EVEN);\n" +
                        "    lrui(WAY_ODD) <= v_lrui(WAY_ODD);\n" +
                        "\n" +
                        "    swapin(WAY_EVEN) <= v_swapin(WAY_EVEN);\n" +
                        "    swapin(WAY_ODD) <= v_swapin(WAY_ODD);\n" +
                        "\n" +
                        "    wb_ena_even <= vb_ena_even;\n" +
                        "    wb_ena_odd <= vb_ena_odd;\n" +
                        "\n" +
                        "    o_req_ctrl_ready <= w_o_req_ctrl_ready;\n" +
                        "\n" +
                        "    o_req_mem_valid <= r.req_mem_valid;\n" +
                        "    o_req_mem_addr <= r.mem_addr;\n" +
                        "    o_req_mem_write <= '0';\n" +
                        "    o_req_mem_strob <= (others => '0');\n" +
                        "    o_req_mem_data <= (others => '0');\n" +
                        "    o_req_mem_len <= conv_std_logic_vector(3, 8);\n" +
                        "    o_req_mem_burst <= \"10\";  -- WRAP burst transaction\n" +
                        "    o_req_mem_last <= w_last;\n" +
                        "\n" +
                        "    o_resp_ctrl_valid <= w_o_resp_valid;\n" +
                        "    o_resp_ctrl_data <= wb_o_resp_data;\n" +
                        "    o_resp_ctrl_addr <= r.req_addr;\n" +
                        "    o_resp_ctrl_load_fault <= w_o_resp_load_fault;\n" +
                        "    o_istate <= r.state(1 downto 0);\n" +
                        "    \n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(i_clk, i_nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_icache_vhd_file(String Project_Folder_File) {
        String data =   "-----------------------------------------------------------------------------\n" +
                        "--! @file\n" +
                        "--! @copyright Copyright 2016 GNSS Sensor Ltd. All right reserved.\n" +
                        "--! @author    Sergey Khabarov - sergeykhbr@gmail.com\n" +
                        "--! @brief     Instruction Cache.\n" +
                        "------------------------------------------------------------------------------\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "--library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use work.river_cfg.all;\n" +
                        "\n" +
                        "entity ICache is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;                              -- CPU clock\n" +
                        "    i_nrst : in std_logic;                             -- Reset. Active LOW.\n" +
                        "    -- Control path:\n" +
                        "    i_req_ctrl_valid : in std_logic;\n" +
                        "    i_req_ctrl_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_req_ctrl_ready : out std_logic;\n" +
                        "    o_resp_ctrl_valid : out std_logic;\n" +
                        "    o_resp_ctrl_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_resp_ctrl_data : out std_logic_vector(31 downto 0);\n" +
                        "    o_resp_ctrl_load_fault : out std_logic;\n" +
                        "    i_resp_ctrl_ready : in std_logic;\n" +
                        "    -- Memory interface:\n" +
                        "    i_req_mem_ready : in std_logic;\n" +
                        "    o_req_mem_valid : out std_logic;\n" +
                        "    o_req_mem_write : out std_logic;\n" +
                        "    o_req_mem_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_req_mem_strob : out std_logic_vector(BUS_DATA_BYTES-1 downto 0);\n" +
                        "    o_req_mem_data : out std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    o_req_mem_len : out std_logic_vector(7 downto 0);\n" +
                        "    o_req_mem_burst : out std_logic_vector(1 downto 0);\n" +
                        "    o_req_mem_last : out std_logic;\n" +
                        "    i_resp_mem_data_valid : in std_logic;\n" +
                        "    i_resp_mem_data : in std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    i_resp_mem_load_fault : in std_logic;\n" +
                        "    -- Debug Signals:\n" +
                        "    i_flush_address : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);  -- clear ICache address from debug interface\n" +
                        "    i_flush_valid : in std_logic;                                      -- address to clear icache is valid\n" +
                        "    o_istate : out std_logic_vector(1 downto 0)\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_ICache of ICache is\n" +
                        "\n" +
                        "  constant State_Idle : std_logic_vector(1 downto 0) := \"00\";\n" +
                        "  constant State_WaitGrant : std_logic_vector(1 downto 0) := \"01\";\n" +
                        "  constant State_WaitResp : std_logic_vector(1 downto 0) := \"10\";\n" +
                        "  constant State_WaitAccept : std_logic_vector(1 downto 0) := \"11\";\n" +
                        "\n" +
                        "  constant Hit_Line1 : integer := 0;\n" +
                        "  constant Hit_Line2 : integer := 1;\n" +
                        "  constant Hit_Response : integer := 2;\n" +
                        "  constant Hit_Total : integer := 3;\n" +
                        "\n" +
                        "  constant ILINE_TOTAL : integer := 2;\n" +
                        "\n" +
                        "  type line_type is record\n" +
                        "      addr : std_logic_vector(BUS_ADDR_WIDTH-4 downto 0);\n" +
                        "      data : std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "      load_fault : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant LINE_RESET : line_type := (\n" +
                        "    (others => '1'), (others => '0'), '0'\n" +
                        "  );\n" +
                        "\n" +
                        "  type iline_vector is array (0 to ILINE_TOTAL-1) of line_type;\n" +
                        "\n" +
                        "  type line_signal_type is record\n" +
                        "       hit : std_logic_vector(ILINE_TOTAL downto 0);     -- Hit_Total = ILINE_TOTAL + 1\n" +
                        "       hit_hold : std_logic_vector(ILINE_TOTAL-1 downto 0);\n" +
                        "       hit_load_fault : std_logic;\n" +
                        "       hold_load_fault : std_logic;\n" +
                        "       hit_data : std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "       hold_data : std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "  end record;\n" +
                        " \n" +
                        "  type line_signal_vector is array (0 to ILINE_TOTAL-1) of line_signal_type;\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "      iline_addr_req : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      addr_processing : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      state : std_logic_vector(1 downto 0);\n" +
                        "      double_req : std_logic;\n" +
                        "      delay_valid : std_logic;\n" +
                        "      delay_data : std_logic_vector(31 downto 0);\n" +
                        "      delay_load_fault : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "    (others => '0'), (others => '0'), State_Idle,\n" +
                        "    '0', '0', (others => '0'), '0'\n" +
                        "  );\n" +
                        "\n" +
                        "  type adr_type is array (0 to 1) of std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "  signal r_iline, rin_iline : iline_vector;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  comb : process(i_nrst, i_req_ctrl_valid, i_req_ctrl_addr,\n" +
                        "                i_resp_ctrl_ready, i_req_mem_ready, \n" +
                        "                i_resp_mem_data_valid, i_resp_mem_data, i_resp_mem_load_fault, \n" +
                        "                i_flush_address, i_flush_valid, r, r_iline)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable v_iline : iline_vector;\n" +
                        "    variable w_need_mem_req : std_logic;\n" +
                        "    variable wb_hit_word : std_logic_vector(31 downto 0);\n" +
                        "    variable w_hit_load_fault : std_logic;\n" +
                        "    variable wb_l : line_signal_vector;\n" +
                        "    variable w_reuse_lastline : std_logic;\n" +
                        "    variable w_wait_response : std_logic;\n" +
                        "\n" +
                        "    variable w_o_req_ctrl_ready : std_logic;\n" +
                        "    variable w_o_req_mem_valid : std_logic;\n" +
                        "    variable wb_o_req_mem_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable w_req_ctrl_valid : std_logic;\n" +
                        "    variable w_req_fire : std_logic;\n" +
                        "    variable w_o_resp_valid : std_logic;\n" +
                        "    variable wb_o_resp_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable wb_o_resp_data : std_logic_vector(31 downto 0);\n" +
                        "    variable w_o_resp_load_fault : std_logic;\n" +
                        "    variable wb_req_addr : adr_type;\n" +
                        "    variable wb_hold_addr : adr_type;\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "    v_iline := r_iline;\n" +
                        "\n" +
                        "    w_wait_response := '0';\n" +
                        "    if r.state = State_WaitResp and i_resp_mem_data_valid = '0' then\n" +
                        "        w_wait_response := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_req_ctrl_valid := not w_wait_response\n" +
                        "                        and (i_req_ctrl_valid or r.double_req);\n" +
                        "    if r.double_req = '1' then\n" +
                        "        wb_req_addr(0) := r.addr_processing;\n" +
                        "        wb_req_addr(1) := r.addr_processing + 2;\n" +
                        "    else\n" +
                        "        wb_req_addr(0) := i_req_ctrl_addr;\n" +
                        "        wb_req_addr(1) := i_req_ctrl_addr + 2;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    wb_hold_addr(0) := r.addr_processing;\n" +
                        "    wb_hold_addr(1) := r.addr_processing + 2;\n" +
                        "\n" +
                        "    for i in 0 to ILINE_TOTAL-1 loop\n" +
                        "        wb_l(i).hit := (others => '0');\n" +
                        "        wb_l(i).hit_data := (others => '0');\n" +
                        "        wb_l(i).hit_load_fault := '0';\n" +
                        "        if wb_req_addr(i)(BUS_ADDR_WIDTH-1 downto 3) = r_iline(0).addr then\n" +
                        "            wb_l(i).hit(Hit_Line1) := w_req_ctrl_valid;\n" +
                        "            wb_l(i).hit_data := r_iline(0).data;\n" +
                        "            wb_l(i).hit_load_fault := r_iline(0).load_fault;\n" +
                        "        elsif wb_req_addr(i)(BUS_ADDR_WIDTH-1 downto 3) = r_iline(1).addr then\n" +
                        "            wb_l(i).hit(Hit_Line2) := w_req_ctrl_valid;\n" +
                        "            wb_l(i).hit_data := r_iline(1).data;\n" +
                        "            wb_l(i).hit_load_fault := r_iline(1).load_fault;\n" +
                        "        elsif wb_req_addr(i)(BUS_ADDR_WIDTH-1 downto 3) =\n" +
                        "            r.iline_addr_req(BUS_ADDR_WIDTH-1 downto 3) then\n" +
                        "            wb_l(i).hit(Hit_Response) := i_resp_mem_data_valid;\n" +
                        "            wb_l(i).hit_data := i_resp_mem_data;\n" +
                        "            wb_l(i).hit_load_fault := i_resp_mem_load_fault;\n" +
                        "        end if;\n" +
                        "\n" +
                        "        wb_l(i).hit_hold := (others => '0');\n" +
                        "        wb_l(i).hold_data := (others => '0');\n" +
                        "        wb_l(i).hold_load_fault := '0';\n" +
                        "        if wb_hold_addr(i)(BUS_ADDR_WIDTH-1 downto 3) = r_iline(0).addr then\n" +
                        "            wb_l(i).hit_hold(Hit_Line1) := '1';\n" +
                        "            wb_l(i).hold_data := r_iline(0).data;\n" +
                        "            wb_l(i).hold_load_fault := r_iline(0).load_fault;\n" +
                        "        elsif wb_hold_addr(i)(BUS_ADDR_WIDTH-1 downto 3) = r_iline(1).addr then\n" +
                        "            wb_l(i).hit_hold(Hit_Line2) := '1';\n" +
                        "            wb_l(i).hold_data := r_iline(1).data;\n" +
                        "            wb_l(i).hold_load_fault := r_iline(1).load_fault;\n" +
                        "        elsif wb_hold_addr(i)(BUS_ADDR_WIDTH-1 downto 3) =\n" +
                        "            r.iline_addr_req(BUS_ADDR_WIDTH-1 downto 3) then\n" +
                        "            wb_l(i).hold_data := i_resp_mem_data;\n" +
                        "            wb_l(i).hold_load_fault := i_resp_mem_load_fault;\n" +
                        "        end if;\n" +
                        "    end loop;\n" +
                        "\n" +
                        "    wb_hit_word := (others => '0');\n" +
                        "    w_hit_load_fault := '0';\n" +
                        "    w_need_mem_req := '1';\n" +
                        "    if wb_l(0).hit /= \"000\" and wb_l(1).hit /= \"000\" then\n" +
                        "        w_need_mem_req := '0';\n" +
                        "    end if;\n" +
                        "    case r.addr_processing(2 downto 1) is\n" +
                        "    when \"00\" =>\n" +
                        "        wb_hit_word := wb_l(0).hold_data(31 downto 0);\n" +
                        "        w_hit_load_fault := wb_l(0).hold_load_fault;\n" +
                        "    when \"01\" =>\n" +
                        "        wb_hit_word := wb_l(0).hold_data(47 downto 16);\n" +
                        "        w_hit_load_fault := wb_l(0).hold_load_fault;\n" +
                        "    when \"10\" =>\n" +
                        "        wb_hit_word := wb_l(0).hold_data(63 downto 32);\n" +
                        "        w_hit_load_fault := wb_l(0).hold_load_fault;\n" +
                        "    when others =>\n" +
                        "        wb_hit_word := wb_l(1).hold_data(15 downto 0) &\n" +
                        "                       wb_l(0).hold_data(63 downto 48);\n" +
                        "        w_hit_load_fault := wb_l(0).hold_load_fault\n" +
                        "                         or wb_l(1).hold_load_fault;\n" +
                        "    end case;\n" +
                        "\n" +
                        "    if w_req_ctrl_valid = '1' and w_need_mem_req = '0' then\n" +
                        "        v.delay_valid := '1';\n" +
                        "        case i_req_ctrl_addr(2 downto 1) is\n" +
                        "        when \"00\" =>\n" +
                        "            v.delay_data := wb_l(0).hit_data(31 downto 0);\n" +
                        "            v.delay_load_fault := wb_l(0).hit_load_fault;\n" +
                        "        when \"01\" =>\n" +
                        "            v.delay_data := wb_l(0).hit_data(47 downto 16);\n" +
                        "            v.delay_load_fault := wb_l(0).hit_load_fault;\n" +
                        "        when \"10\" =>\n" +
                        "            v.delay_data := wb_l(0).hit_data(63 downto 32);\n" +
                        "            v.delay_load_fault := wb_l(0).hit_load_fault;\n" +
                        "        when others =>\n" +
                        "            v.delay_data := wb_l(1).hit_data(15 downto 0) &\n" +
                        "                            wb_l(0).hit_data(63 downto 48);\n" +
                        "            v.delay_load_fault := wb_l(0).hit_load_fault \n" +
                        "                               or wb_l(1).hit_load_fault;\n" +
                        "        end case;\n" +
                        "    elsif i_resp_ctrl_ready = '1' then\n" +
                        "        v.delay_valid := '0';\n" +
                        "        v.delay_data := (others => '0');\n" +
                        "        v.delay_load_fault := '0';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_o_req_mem_valid := w_need_mem_req and w_req_ctrl_valid;\n" +
                        "    if r.double_req = '1' then\n" +
                        "        if (r.addr_processing(BUS_ADDR_WIDTH-1 downto 3) =\n" +
                        "            r.iline_addr_req(BUS_ADDR_WIDTH-1 downto 3))\n" +
                        "            or (r.addr_processing(BUS_ADDR_WIDTH-1 downto 3) =\n" +
                        "                wb_hold_addr(0)(BUS_ADDR_WIDTH-1 downto 3)) then\n" +
                        "            wb_o_req_mem_addr := wb_hold_addr(1)(BUS_ADDR_WIDTH-1 downto 3) & \"000\";\n" +
                        "        else\n" +
                        "            wb_o_req_mem_addr := wb_hold_addr(0)(BUS_ADDR_WIDTH-1 downto 3) & \"000\";\n" +
                        "        end if;\n" +
                        "    elsif wb_l(0).hit = \"000\" then\n" +
                        "        wb_o_req_mem_addr := wb_req_addr(0)(BUS_ADDR_WIDTH-1 downto 3)  & \"000\";\n" +
                        "    else\n" +
                        "        wb_o_req_mem_addr := wb_req_addr(1)(BUS_ADDR_WIDTH-1 downto 3)  & \"000\";\n" +
                        "    end if;\n" +
                        "    w_o_req_ctrl_ready := not w_need_mem_req or (i_req_mem_ready and not w_wait_response);\n" +
                        "    w_req_fire := w_req_ctrl_valid and w_o_req_ctrl_ready;\n" +
                        "\n" +
                        "    if (w_o_req_mem_valid and i_req_mem_ready and not w_wait_response) = '1'\n" +
                        "       or (r.double_req and not w_wait_response) = '1' then\n" +
                        "        v.iline_addr_req := wb_o_req_mem_addr;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    case r.state is\n" +
                        "    when State_Idle =>\n" +
                        "        if i_req_ctrl_valid = '1' then\n" +
                        "            if w_need_mem_req = '0' then\n" +
                        "                v.state := State_WaitAccept;\n" +
                        "            elsif i_req_mem_ready = '1' then\n" +
                        "                v.state := State_WaitResp;\n" +
                        "            else\n" +
                        "                v.state := State_WaitGrant;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    when State_WaitGrant =>\n" +
                        "        if i_req_mem_ready = '1' then\n" +
                        "            v.state := State_WaitResp;\n" +
                        "        elsif w_need_mem_req = '0' then\n" +
                        "            --! Fetcher can change request address while request wasn't\n" +
                        "            --! accepteed.\n" +
                        "            v.state := State_WaitAccept;\n" +
                        "        end if;\n" +
                        "    when State_WaitResp =>\n" +
                        "        if i_resp_mem_data_valid = '1' then\n" +
                        "            if i_resp_ctrl_ready = '0' then\n" +
                        "                v.state := State_WaitAccept;\n" +
                        "            elsif w_req_ctrl_valid = '0' then\n" +
                        "                v.state := State_Idle;\n" +
                        "            else\n" +
                        "                -- New request\n" +
                        "                if w_need_mem_req = '0' then\n" +
                        "                    v.state := State_WaitAccept;\n" +
                        "                elsif i_req_mem_ready = '1' then\n" +
                        "                    v.state := State_WaitResp;\n" +
                        "                else\n" +
                        "                    v.state := State_WaitGrant;\n" +
                        "                end if;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    when State_WaitAccept =>\n" +
                        "        if i_resp_ctrl_ready = '1' then\n" +
                        "            if w_req_ctrl_valid = '0' then\n" +
                        "                v.state := State_Idle;\n" +
                        "            else\n" +
                        "                if w_need_mem_req = '0' then\n" +
                        "                    v.state := State_WaitAccept;\n" +
                        "                elsif i_req_mem_ready = '1' then\n" +
                        "                    v.state := State_WaitResp;\n" +
                        "                else\n" +
                        "                    v.state := State_WaitGrant;\n" +
                        "                end if;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    when others =>\n" +
                        "    end case;\n" +
                        "\n" +
                        "\n" +
                        "    if w_req_fire = '1' then\n" +
                        "        v.double_req := '0';\n" +
                        "        if i_req_ctrl_addr(2 downto 1) = \"11\"\n" +
                        "            and wb_l(0).hit = \"000\" and wb_l(1).hit = \"000\"\n" +
                        "            and r.double_req = '0' then\n" +
                        "            v.double_req := '1';\n" +
                        "        end if;\n" +
                        "        if r.double_req = '0' then\n" +
                        "            v.addr_processing := i_req_ctrl_addr;\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_reuse_lastline := '0';\n" +
                        "\n" +
                        "    if i_resp_mem_data_valid = '1' then\n" +
                        "        --! Condition to avoid removing the last line:\n" +
                        "        if i_resp_ctrl_ready = '1' then\n" +
                        "            if (wb_l(0).hit(Hit_Line2) or wb_l(1).hit(Hit_Line2)) = '1'\n" +
                        "                and r_iline(1).addr /= wb_o_req_mem_addr(BUS_ADDR_WIDTH-1 downto 3) then\n" +
                        "                w_reuse_lastline := w_need_mem_req;\n" +
                        "            end if;\n" +
                        "        else\n" +
                        "            if (wb_l(0).hit_hold(Hit_Line2) or wb_l(1).hit_hold(Hit_Line2)) = '1'\n" +
                        "                and (wb_l(0).hit_hold(Hit_Line1) or wb_l(1).hit_hold(Hit_Line1)) = '0'\n" +
                        "                and r_iline(1).addr /= r.iline_addr_req(BUS_ADDR_WIDTH-1 downto 3) then\n" +
                        "                w_reuse_lastline := '1';\n" +
                        "            end if;\n" +
                        "		  end if;\n" +
                        "        if w_reuse_lastline = '0' then\n" +
                        "            v_iline(1).addr := r_iline(0).addr;\n" +
                        "            v_iline(1).data := r_iline(0).data;\n" +
                        "            v_iline(1).load_fault := r_iline(0).load_fault;\n" +
                        "        end if;\n" +
                        "        \n" +
                        "        v_iline(0).addr := r.iline_addr_req(BUS_ADDR_WIDTH-1 downto 3);\n" +
                        "        v_iline(0).data := i_resp_mem_data;\n" +
                        "        v_iline(0).load_fault := i_resp_mem_load_fault;\n" +
                        "    end if;\n" +
                        "    if i_flush_valid = '1' then\n" +
                        "        v_iline(0).addr := (others => '1');\n" +
                        "        v_iline(1).addr := (others => '1');\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if r.state = State_WaitAccept then\n" +
                        "        w_o_resp_valid := not r.double_req;\n" +
                        "    else\n" +
                        "        w_o_resp_valid := i_resp_mem_data_valid and not r.double_req;\n" +
                        "    end if;\n" +
                        "    if r.delay_valid = '1' then\n" +
                        "        wb_o_resp_data := r.delay_data;\n" +
                        "        w_o_resp_load_fault := r.delay_load_fault;\n" +
                        "    else\n" +
                        "        wb_o_resp_data := wb_hit_word;\n" +
                        "        w_o_resp_load_fault := w_hit_load_fault;\n" +
                        "    end if;\n" +
                        "    wb_o_resp_addr := r.addr_processing;\n" +
                        "\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "        for i in 0 to ILINE_TOTAL-1 loop\n" +
                        "            v_iline(i) := LINE_RESET;\n" +
                        "        end loop;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    o_req_ctrl_ready <= w_o_req_ctrl_ready;\n" +
                        "    \n" +
                        "    o_req_mem_valid <= w_o_req_mem_valid;\n" +
                        "    o_req_mem_addr <= wb_o_req_mem_addr;\n" +
                        "    o_req_mem_write <= '0';\n" +
                        "    o_req_mem_strob <= (others => '0');\n" +
                        "    o_req_mem_data <= (others => '0');\n" +
                        "    o_req_mem_len <= X\"00\";\n" +
                        "    o_req_mem_burst <= \"00\";\n" +
                        "    o_req_mem_last <= '1';\n" +
                        "\n" +
                        "    o_resp_ctrl_valid <= w_o_resp_valid;\n" +
                        "    o_resp_ctrl_data <= wb_o_resp_data;\n" +
                        "    o_resp_ctrl_addr <= wb_o_resp_addr;\n" +
                        "    o_resp_ctrl_load_fault <= w_o_resp_load_fault;\n" +
                        "    o_istate <= r.state;\n" +
                        "    \n" +
                        "    rin <= v;\n" +
                        "    rin_iline <= v_iline;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(i_clk, i_nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "        for i in 0 to ILINE_TOTAL-1 loop\n" +
                        "            r_iline(i) <= LINE_RESET;\n" +
                        "        end loop;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "        r_iline <= rin_iline;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_dcache_vhd_file(String Project_Folder_File) {
        String data =   "-----------------------------------------------------------------------------\n" +
                        "--! @file\n" +
                        "--! @copyright Copyright 2016 GNSS Sensor Ltd. All right reserved.\n" +
                        "--! @author    Sergey Khabarov - sergeykhbr@gmail.com\n" +
                        "--! @brief     Data Cache.\n" +
                        "------------------------------------------------------------------------------\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "--library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use work.river_cfg.all;\n" +
                        "\n" +
                        "\n" +
                        "entity DCache is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;                              -- CPU clock\n" +
                        "    i_nrst : in std_logic;                             -- Reset. Active LOW.\n" +
                        "    -- Data path:\n" +
                        "    i_req_data_valid : in std_logic;\n" +
                        "    i_req_data_write : in std_logic;\n" +
                        "    i_req_data_sz : in std_logic_vector(1 downto 0);\n" +
                        "    i_req_data_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_req_data_data : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_req_data_ready : out std_logic;\n" +
                        "    o_resp_data_valid : out std_logic;\n" +
                        "    o_resp_data_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_resp_data_data : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_resp_data_load_fault : out std_logic;\n" +
                        "    o_resp_data_store_fault : out std_logic;\n" +
                        "    o_resp_data_store_fault_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_resp_data_ready : in std_logic;\n" +
                        "    -- Memory interface:\n" +
                        "    i_req_mem_ready : in std_logic;\n" +
                        "    o_req_mem_valid : out std_logic;\n" +
                        "    o_req_mem_write : out std_logic;\n" +
                        "    o_req_mem_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_req_mem_strob : out std_logic_vector(BUS_DATA_BYTES-1 downto 0);\n" +
                        "    o_req_mem_data : out std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    o_req_mem_len : out std_logic_vector(7 downto 0);\n" +
                        "    o_req_mem_burst : out std_logic_vector(1 downto 0);\n" +
                        "    o_req_mem_last : out std_logic;\n" +
                        "    i_resp_mem_data_valid : in std_logic;\n" +
                        "    i_resp_mem_data : in std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    i_resp_mem_load_fault : in std_logic;\n" +
                        "    i_resp_mem_store_fault : in std_logic;\n" +
                        "    i_resp_mem_store_fault_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    -- Debug Signals:\n" +
                        "    o_dstate : out std_logic_vector(1 downto 0)\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_DCache of DCache is\n" +
                        "\n" +
                        "  constant State_Idle : std_logic_vector(1 downto 0) := \"00\";\n" +
                        "  constant State_WaitGrant : std_logic_vector(1 downto 0) := \"01\";\n" +
                        "  constant State_WaitResp : std_logic_vector(1 downto 0) := \"10\";\n" +
                        "  constant State_WaitAccept : std_logic_vector(1 downto 0) := \"11\";\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "      req_strob : std_logic_vector(BUS_DATA_BYTES-1 downto 0);\n" +
                        "      req_wdata : std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "      dline_data : std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "      dline_addr_req : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      dline_size_req : std_logic_vector(1 downto 0);\n" +
                        "      dline_load_fault : std_logic;\n" +
                        "      state : std_logic_vector(1 downto 0);\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "      (others => '0'), (others => '0'),\n" +
                        "      (others => '0'), (others => '0'), (others => '0'),\n" +
                        "      '0', State_Idle);\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  comb : process(i_nrst, i_req_data_valid, i_req_data_write, i_req_data_sz, \n" +
                        "                i_req_data_addr, i_req_data_data, i_resp_mem_data_valid, \n" +
                        "                i_resp_mem_data, i_resp_mem_load_fault, i_resp_mem_store_fault,\n" +
                        "                i_resp_mem_store_fault_addr, i_req_mem_ready, i_resp_data_ready, r)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable w_wait_response : std_logic;\n" +
                        "    variable w_o_req_data_ready : std_logic;\n" +
                        "    variable w_o_req_mem_valid : std_logic;\n" +
                        "    variable wb_o_req_mem_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable wb_o_req_strob : std_logic_vector(BUS_DATA_BYTES-1 downto 0);\n" +
                        "    variable wb_o_req_wdata : std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    variable w_req_fire : std_logic;\n" +
                        "    variable w_o_resp_valid : std_logic;\n" +
                        "    variable wb_o_resp_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable wb_resp_data_mux : std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    variable wb_o_resp_data : std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    variable w_o_resp_load_fault : std_logic;\n" +
                        "    variable wb_rtmp : std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "    wb_o_req_strob := (others => '0');\n" +
                        "    wb_o_req_wdata := (others => '0');\n" +
                        "    wb_o_resp_data := (others => '0');\n" +
                        "    wb_rtmp := (others => '0');\n" +
                        "\n" +
                        "    w_wait_response := '0';\n" +
                        "    if r.state = State_WaitResp and i_resp_mem_data_valid = '0' then\n" +
                        "        w_wait_response := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    case i_req_data_sz is\n" +
                        "    when \"00\" =>\n" +
                        "        wb_o_req_wdata := i_req_data_data(7 downto 0) &\n" +
                        "            i_req_data_data(7 downto 0) & i_req_data_data(7 downto 0) &\n" +
                        "            i_req_data_data(7 downto 0) & i_req_data_data(7 downto 0) &\n" +
                        "            i_req_data_data(7 downto 0) & i_req_data_data(7 downto 0) &\n" +
                        "            i_req_data_data(7 downto 0);\n" +
                        "        if i_req_data_addr(2 downto 0) = \"000\" then\n" +
                        "            wb_o_req_strob := X\"01\";\n" +
                        "        elsif i_req_data_addr(2 downto 0) = \"001\" then\n" +
                        "            wb_o_req_strob := X\"02\";\n" +
                        "        elsif i_req_data_addr(2 downto 0) = \"010\" then\n" +
                        "            wb_o_req_strob := X\"04\";\n" +
                        "        elsif i_req_data_addr(2 downto 0) = \"011\" then\n" +
                        "            wb_o_req_strob := X\"08\";\n" +
                        "        elsif i_req_data_addr(2 downto 0) = \"100\" then\n" +
                        "            wb_o_req_strob := X\"10\";\n" +
                        "        elsif i_req_data_addr(2 downto 0) = \"101\" then\n" +
                        "            wb_o_req_strob := X\"20\";\n" +
                        "        elsif i_req_data_addr(2 downto 0) = \"110\" then\n" +
                        "            wb_o_req_strob := X\"40\";\n" +
                        "        elsif i_req_data_addr(2 downto 0) = \"111\" then\n" +
                        "            wb_o_req_strob := X\"80\";\n" +
                        "        end if;\n" +
                        "    when \"01\" =>\n" +
                        "        wb_o_req_wdata := i_req_data_data(15 downto 0) &\n" +
                        "            i_req_data_data(15 downto 0) & i_req_data_data(15 downto 0) &\n" +
                        "            i_req_data_data(15 downto 0);\n" +
                        "        if i_req_data_addr(2 downto 1) = \"00\" then\n" +
                        "            wb_o_req_strob := X\"03\";\n" +
                        "        elsif i_req_data_addr(2 downto 1) = \"01\" then\n" +
                        "            wb_o_req_strob := X\"0C\";\n" +
                        "        elsif i_req_data_addr(2 downto 1) = \"10\" then\n" +
                        "            wb_o_req_strob := X\"30\";\n" +
                        "        else\n" +
                        "            wb_o_req_strob := X\"C0\";\n" +
                        "        end if;\n" +
                        "    when \"10\" =>\n" +
                        "        wb_o_req_wdata := i_req_data_data(31 downto 0) &\n" +
                        "                          i_req_data_data(31 downto 0);\n" +
                        "        if i_req_data_addr(2) = '1' then\n" +
                        "            wb_o_req_strob := X\"F0\";\n" +
                        "        else\n" +
                        "            wb_o_req_strob := X\"0F\";\n" +
                        "        end if;\n" +
                        "    when \"11\" =>\n" +
                        "        wb_o_req_wdata := i_req_data_data;\n" +
                        "        wb_o_req_strob := X\"FF\";\n" +
                        "    when others =>\n" +
                        "    end case;\n" +
                        "\n" +
                        "\n" +
                        "    w_o_req_mem_valid := i_req_data_valid and not w_wait_response;\n" +
                        "    wb_o_req_mem_addr := i_req_data_addr(BUS_ADDR_WIDTH-1 downto 3) & \"000\";\n" +
                        "    w_o_req_data_ready := i_req_mem_ready;\n" +
                        "    w_req_fire := w_o_req_mem_valid and w_o_req_data_ready;\n" +
                        "    case r.state is\n" +
                        "    when State_Idle =>\n" +
                        "        if i_req_data_valid = '1' then\n" +
                        "            if i_req_mem_ready = '1' then\n" +
                        "                v.state := State_WaitResp;\n" +
                        "            else\n" +
                        "                v.state := State_WaitGrant;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    when State_WaitGrant =>\n" +
                        "        if i_req_mem_ready = '1' then\n" +
                        "            v.state := State_WaitResp;\n" +
                        "        end if;\n" +
                        "    when State_WaitResp =>\n" +
                        "        if i_resp_mem_data_valid = '1' then\n" +
                        "            if i_resp_data_ready = '0' then\n" +
                        "                v.state := State_WaitAccept;\n" +
                        "            elsif i_req_data_valid = '0' then\n" +
                        "                v.state := State_Idle;\n" +
                        "            else\n" +
                        "                -- New request\n" +
                        "                if i_req_mem_ready = '1' then\n" +
                        "                    v.state := State_WaitResp;\n" +
                        "                else\n" +
                        "                    v.state := State_WaitGrant;\n" +
                        "                end if;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    when State_WaitAccept =>\n" +
                        "        if i_resp_data_ready = '1' then\n" +
                        "            if i_req_data_valid = '0' then\n" +
                        "                v.state := State_Idle;\n" +
                        "            else\n" +
                        "                if i_req_mem_ready = '1' then\n" +
                        "                    v.state := State_WaitResp;\n" +
                        "                else\n" +
                        "                    v.state := State_WaitGrant;\n" +
                        "                end if;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    when others =>\n" +
                        "    end case;\n" +
                        "\n" +
                        "    if w_req_fire = '1' then\n" +
                        "        v.dline_addr_req := i_req_data_addr;\n" +
                        "        v.dline_size_req := i_req_data_sz;\n" +
                        "        v.req_strob := wb_o_req_strob;\n" +
                        "        v.req_wdata := wb_o_req_wdata;\n" +
                        "    end if;\n" +
                        "    if i_resp_mem_data_valid = '1' then\n" +
                        "        v.dline_data := i_resp_mem_data;\n" +
                        "        v.dline_load_fault := i_resp_mem_load_fault;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    wb_o_resp_addr := r.dline_addr_req;\n" +
                        "    if r.state = State_WaitAccept then\n" +
                        "        w_o_resp_valid := '1';\n" +
                        "        wb_resp_data_mux := r.dline_data;\n" +
                        "        w_o_resp_load_fault := r.dline_load_fault;\n" +
                        "    else\n" +
                        "        w_o_resp_valid := i_resp_mem_data_valid;\n" +
                        "        wb_resp_data_mux := i_resp_mem_data;\n" +
                        "        w_o_resp_load_fault := i_resp_mem_load_fault;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    case r.dline_addr_req(2 downto 0) is\n" +
                        "    when \"001\" =>\n" +
                        "        wb_rtmp := X\"00\" & wb_resp_data_mux(63 downto 8);\n" +
                        "    when \"010\" =>\n" +
                        "        wb_rtmp := X\"0000\" & wb_resp_data_mux(63 downto 16);\n" +
                        "    when \"011\" =>\n" +
                        "        wb_rtmp := X\"000000\" & wb_resp_data_mux(63 downto 24);\n" +
                        "    when \"100\" =>\n" +
                        "        wb_rtmp := X\"00000000\" & wb_resp_data_mux(63 downto 32);\n" +
                        "    when \"101\" =>\n" +
                        "        wb_rtmp := X\"0000000000\" & wb_resp_data_mux(63 downto 40);\n" +
                        "    when \"110\" =>\n" +
                        "        wb_rtmp := X\"000000000000\" & wb_resp_data_mux(63 downto 48);\n" +
                        "    when \"111\" =>\n" +
                        "        wb_rtmp := X\"00000000000000\" & wb_resp_data_mux(63 downto 56);\n" +
                        "    when others =>\n" +
                        "        wb_rtmp := wb_resp_data_mux;\n" +
                        "    end case;\n" +
                        "\n" +
                        "    case r.dline_size_req is\n" +
                        "    when \"00\" =>\n" +
                        "        wb_o_resp_data(7 downto 0) := wb_rtmp(7 downto 0);\n" +
                        "    when \"01\" =>\n" +
                        "        wb_o_resp_data(15 downto 0) := wb_rtmp(15 downto 0);\n" +
                        "    when \"10\" =>\n" +
                        "        wb_o_resp_data(31 downto 0) := wb_rtmp(31 downto 0);\n" +
                        "    when others =>\n" +
                        "        wb_o_resp_data := wb_rtmp;\n" +
                        "    end case;\n" +
                        "    \n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    o_req_data_ready <= w_o_req_data_ready;\n" +
                        "\n" +
                        "    o_req_mem_valid <= w_o_req_mem_valid;\n" +
                        "    o_req_mem_addr <= wb_o_req_mem_addr;\n" +
                        "    o_req_mem_write <= i_req_data_write;\n" +
                        "    o_req_mem_strob <= r.req_strob;\n" +
                        "    o_req_mem_data <= r.req_wdata;\n" +
                        "    o_req_mem_len <= X\"00\";\n" +
                        "    o_req_mem_burst <= \"00\";\n" +
                        "    o_req_mem_last <= '1';\n" +
                        "\n" +
                        "    o_resp_data_valid <= w_o_resp_valid;\n" +
                        "    o_resp_data_data <= wb_o_resp_data;\n" +
                        "    o_resp_data_addr <= wb_o_resp_addr;\n" +
                        "    o_resp_data_load_fault <= w_o_resp_load_fault;\n" +
                        "    -- AXI b channel\n" +
                        "    o_resp_data_store_fault <= i_resp_mem_store_fault;\n" +
                        "    o_resp_data_store_fault_addr <= i_resp_mem_store_fault_addr;\n" +
                        "    o_dstate <= r.state;\n" +
                        "    \n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(i_clk, i_nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_cache_top_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "--library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use work.river_cfg.all;\n" +
                        "\n" +
                        "\n" +
                        "entity CacheTop is generic (\n" +
                        "    memtech : integer;\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;                              -- CPU clock\n" +
                        "    i_nrst : in std_logic;                             -- Reset. Active LOW.\n" +
                        "    -- Control path:\n" +
                        "    i_req_ctrl_valid : in std_logic;\n" +
                        "    i_req_ctrl_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_req_ctrl_ready : out std_logic;\n" +
                        "    o_resp_ctrl_valid : out std_logic;\n" +
                        "    o_resp_ctrl_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_resp_ctrl_data : out std_logic_vector(31 downto 0);\n" +
                        "    o_resp_ctrl_load_fault : out std_logic;\n" +
                        "    i_resp_ctrl_ready : in std_logic;\n" +
                        "    -- Data path:\n" +
                        "    i_req_data_valid : in std_logic;\n" +
                        "    i_req_data_write : in std_logic;\n" +
                        "    i_req_data_size : in std_logic_vector(1 downto 0);\n" +
                        "    i_req_data_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_req_data_data : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_req_data_ready : out std_logic;\n" +
                        "    o_resp_data_valid : out std_logic;\n" +
                        "    o_resp_data_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_resp_data_data : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_resp_data_load_fault : out std_logic;\n" +
                        "    o_resp_data_store_fault : out std_logic;\n" +
                        "    o_resp_data_store_fault_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_resp_data_ready : in std_logic;\n" +
                        "    -- Memory interface:\n" +
                        "    i_req_mem_ready : in std_logic;                                    -- AXI request was accepted\n" +
                        "    o_req_mem_valid : out std_logic;\n" +
                        "    o_req_mem_write : out std_logic;\n" +
                        "    o_req_mem_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_req_mem_strob : out std_logic_vector(BUS_DATA_BYTES-1 downto 0);\n" +
                        "    o_req_mem_data : out std_logic_vector(BUS_DATA_WIDTH-1 downto 0);  -- burst transaction length\n" +
                        "    o_req_mem_len : out std_logic_vector(7 downto 0);                  -- burst length\n" +
                        "    o_req_mem_burst : out std_logic_vector(1 downto 0);                -- burst type: \"00\" FIX; \"01\" INCR; \"10\" WRAP\n" +
                        "    i_resp_mem_data_valid : in std_logic;\n" +
                        "    i_resp_mem_data : in std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    i_resp_mem_load_fault : in std_logic;                             -- Bus response with SLVERR or DECERR on read\n" +
                        "    i_resp_mem_store_fault : in std_logic;                            -- Bus response with SLVERR or DECERR on write\n" +
                        "    i_resp_mem_store_fault_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    -- Debug signals:\n" +
                        "    i_flush_address : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);  -- clear ICache address from debug interface\n" +
                        "    i_flush_valid : in std_logic;                                      -- address to clear icache is valid\n" +
                        "    o_istate : out std_logic_vector(1 downto 0);                      -- ICache state machine value\n" +
                        "    o_dstate : out std_logic_vector(1 downto 0);                      -- DCache state machine value\n" +
                        "    o_cstate : out std_logic_vector(1 downto 0)                       -- cachetop state machine value\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_CacheTop of CacheTop is\n" +
                        "  constant State_Idle : std_logic_vector(1 downto 0) := \"00\";\n" +
                        "  constant State_IMem : std_logic_vector(1 downto 0) := \"01\";\n" +
                        "  constant State_DMem : std_logic_vector(1 downto 0) := \"10\";\n" +
                        "\n" +
                        "  type CacheOutputType is record\n" +
                        "      req_mem_valid : std_logic;\n" +
                        "      req_mem_write : std_logic;\n" +
                        "      req_mem_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      req_mem_strob : std_logic_vector(BUS_DATA_BYTES-1 downto 0);\n" +
                        "      req_mem_wdata : std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "      req_mem_len : std_logic_vector(7 downto 0);\n" +
                        "      req_mem_burst : std_logic_vector(1 downto 0);\n" +
                        "      req_mem_last : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "      state : std_logic_vector(1 downto 0);\n" +
                        "  end record;\n" +
                        "\n" +
                        "  signal i :  CacheOutputType;\n" +
                        "  signal d :  CacheOutputType;\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "  -- Memory Control interface:\n" +
                        "  signal w_ctrl_resp_mem_data_valid : std_logic;\n" +
                        "  signal wb_ctrl_resp_mem_data : std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "  signal w_ctrl_resp_mem_load_fault : std_logic;\n" +
                        "  signal w_ctrl_req_ready : std_logic;\n" +
                        "  -- Memory Data interface:\n" +
                        "  signal w_data_resp_mem_data_valid : std_logic;\n" +
                        "  signal wb_data_resp_mem_data : std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "  signal w_data_resp_mem_load_fault : std_logic;\n" +
                        "  signal w_data_req_ready : std_logic;\n" +
                        "\n" +
                        "  component ICacheLru is generic (\n" +
                        "    memtech : integer;\n" +
                        "    async_reset : boolean;\n" +
                        "    index_width : integer\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_req_ctrl_valid : in std_logic;\n" +
                        "    i_req_ctrl_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_req_ctrl_ready : out std_logic;\n" +
                        "    o_resp_ctrl_valid : out std_logic;\n" +
                        "    o_resp_ctrl_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_resp_ctrl_data : out std_logic_vector(31 downto 0);\n" +
                        "    o_resp_ctrl_load_fault : out std_logic;\n" +
                        "    i_resp_ctrl_ready : in std_logic;\n" +
                        "    i_req_mem_ready : in std_logic;\n" +
                        "    o_req_mem_valid : out std_logic;\n" +
                        "    o_req_mem_write : out std_logic;\n" +
                        "    o_req_mem_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_req_mem_strob : out std_logic_vector(BUS_DATA_BYTES-1 downto 0);\n" +
                        "    o_req_mem_data : out std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    o_req_mem_len : out std_logic_vector(7 downto 0);\n" +
                        "    o_req_mem_burst : out std_logic_vector(1 downto 0);\n" +
                        "    o_req_mem_last : out std_logic;\n" +
                        "    i_resp_mem_data_valid : in std_logic;\n" +
                        "    i_resp_mem_data : in std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    i_resp_mem_load_fault : in std_logic;\n" +
                        "    i_flush_address : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_flush_valid : in std_logic;\n" +
                        "    o_istate : out std_logic_vector(1 downto 0)\n" +
                        "  );\n" +
                        "  end component; \n" +
                        "\n" +
                        "  component DCache is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_req_data_valid : in std_logic;\n" +
                        "    i_req_data_write : in std_logic;\n" +
                        "    i_req_data_sz : in std_logic_vector(1 downto 0);\n" +
                        "    i_req_data_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_req_data_data : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_req_data_ready : out std_logic;\n" +
                        "    o_resp_data_valid : out std_logic;\n" +
                        "    o_resp_data_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_resp_data_data : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_resp_data_load_fault : out std_logic;\n" +
                        "    o_resp_data_store_fault : out std_logic;\n" +
                        "    o_resp_data_store_fault_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_resp_data_ready : in std_logic;\n" +
                        "    i_req_mem_ready : in std_logic;\n" +
                        "    o_req_mem_valid : out std_logic;\n" +
                        "    o_req_mem_write : out std_logic;\n" +
                        "    o_req_mem_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_req_mem_strob : out std_logic_vector(BUS_DATA_BYTES-1 downto 0);\n" +
                        "    o_req_mem_data : out std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    o_req_mem_len : out std_logic_vector(7 downto 0);\n" +
                        "    o_req_mem_burst : out std_logic_vector(1 downto 0);\n" +
                        "    o_req_mem_last : out std_logic;\n" +
                        "    i_resp_mem_data_valid : in std_logic;\n" +
                        "    i_resp_mem_data : in std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    i_resp_mem_load_fault : in std_logic;\n" +
                        "    i_resp_mem_store_fault : in std_logic;\n" +
                        "    i_resp_mem_store_fault_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_dstate : out std_logic_vector(1 downto 0)\n" +
                        "  );\n" +
                        "  end component; \n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "    i0 : ICacheLru generic map (\n" +
                        "        memtech => memtech,\n" +
                        "        async_reset => async_reset,\n" +
                        "        index_width => CFG_IINDEX_WIDTH\n" +
                        "      ) port map (\n" +
                        "        i_clk => i_clk,\n" +
                        "        i_nrst => i_nrst,\n" +
                        "        i_req_ctrl_valid => i_req_ctrl_valid,\n" +
                        "        i_req_ctrl_addr => i_req_ctrl_addr,\n" +
                        "        o_req_ctrl_ready => o_req_ctrl_ready,\n" +
                        "        o_resp_ctrl_valid => o_resp_ctrl_valid,\n" +
                        "        o_resp_ctrl_addr => o_resp_ctrl_addr,\n" +
                        "        o_resp_ctrl_data => o_resp_ctrl_data,\n" +
                        "        o_resp_ctrl_load_fault => o_resp_ctrl_load_fault,\n" +
                        "        i_resp_ctrl_ready => i_resp_ctrl_ready,\n" +
                        "        i_req_mem_ready => w_ctrl_req_ready,\n" +
                        "        o_req_mem_valid => i.req_mem_valid,\n" +
                        "        o_req_mem_write => i.req_mem_write,\n" +
                        "        o_req_mem_addr => i.req_mem_addr,\n" +
                        "        o_req_mem_strob => i.req_mem_strob,\n" +
                        "        o_req_mem_data => i.req_mem_wdata,\n" +
                        "        o_req_mem_len => i.req_mem_len,\n" +
                        "        o_req_mem_burst => i.req_mem_burst,\n" +
                        "        o_req_mem_last => i.req_mem_last,\n" +
                        "        i_resp_mem_data_valid => w_ctrl_resp_mem_data_valid,\n" +
                        "        i_resp_mem_data => wb_ctrl_resp_mem_data,\n" +
                        "        i_resp_mem_load_fault => w_ctrl_resp_mem_load_fault,\n" +
                        "        i_flush_address => i_flush_address,\n" +
                        "        i_flush_valid => i_flush_valid,\n" +
                        "        o_istate => o_istate);\n" +
                        "\n" +
                        "    d0 : DCache generic map (\n" +
                        "        async_reset => async_reset\n" +
                        "      ) port map (\n" +
                        "        i_clk => i_clk,\n" +
                        "        i_nrst => i_nrst,\n" +
                        "        i_req_data_valid => i_req_data_valid,\n" +
                        "        i_req_data_write => i_req_data_write,\n" +
                        "        i_req_data_sz => i_req_data_size,\n" +
                        "        i_req_data_addr => i_req_data_addr,\n" +
                        "        i_req_data_data => i_req_data_data,\n" +
                        "        o_req_data_ready => o_req_data_ready,\n" +
                        "        o_resp_data_valid => o_resp_data_valid,\n" +
                        "        o_resp_data_addr => o_resp_data_addr,\n" +
                        "        o_resp_data_data => o_resp_data_data,\n" +
                        "        o_resp_data_load_fault => o_resp_data_load_fault,\n" +
                        "        o_resp_data_store_fault => o_resp_data_store_fault,\n" +
                        "        o_resp_data_store_fault_addr => o_resp_data_store_fault_addr,\n" +
                        "        i_resp_data_ready => i_resp_data_ready,\n" +
                        "        i_req_mem_ready => w_data_req_ready,\n" +
                        "        o_req_mem_valid => d.req_mem_valid,\n" +
                        "        o_req_mem_write => d.req_mem_write,\n" +
                        "        o_req_mem_addr => d.req_mem_addr,\n" +
                        "        o_req_mem_strob => d.req_mem_strob,\n" +
                        "        o_req_mem_data => d.req_mem_wdata,\n" +
                        "        o_req_mem_len => d.req_mem_len,\n" +
                        "        o_req_mem_burst => d.req_mem_burst,\n" +
                        "        o_req_mem_last => d.req_mem_last,\n" +
                        "        i_resp_mem_data_valid => w_data_resp_mem_data_valid,\n" +
                        "        i_resp_mem_data => wb_data_resp_mem_data,\n" +
                        "        i_resp_mem_load_fault => w_data_resp_mem_load_fault,\n" +
                        "        i_resp_mem_store_fault => i_resp_mem_store_fault,\n" +
                        "        i_resp_mem_store_fault_addr => i_resp_mem_store_fault_addr,\n" +
                        "        o_dstate => o_dstate);\n" +
                        "\n" +
                        "  comb : process(i_nrst, i_req_mem_ready, i_resp_mem_data_valid, i_resp_mem_data,\n" +
                        "                 i_resp_mem_load_fault, i, d, r)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable w_req_mem_valid : std_logic;\n" +
                        "    variable wb_mem_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable wb_mem_len : std_logic_vector(7 downto 0);\n" +
                        "    variable wb_mem_burst : std_logic_vector(1 downto 0);\n" +
                        "    variable w_mem_write : std_logic;\n" +
                        "    variable v_data_req_ready : std_logic;\n" +
                        "    variable v_data_resp_mem_data_valid : std_logic;\n" +
                        "    variable v_ctrl_req_ready : std_logic;\n" +
                        "    variable v_ctrl_resp_mem_data_valid : std_logic;\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    -- default is data path\n" +
                        "    w_req_mem_valid := '0';\n" +
                        "    wb_mem_addr := d.req_mem_addr;\n" +
                        "    w_mem_write := d.req_mem_write;\n" +
                        "    wb_mem_len := d.req_mem_len;\n" +
                        "    wb_mem_burst := d.req_mem_burst;\n" +
                        "    v_data_req_ready := '0';\n" +
                        "    v_data_resp_mem_data_valid := '0';\n" +
                        "    v_ctrl_req_ready := '0';\n" +
                        "    v_ctrl_resp_mem_data_valid := '0';\n" +
                        "   \n" +
                        "    case r.state is\n" +
                        "    when State_Idle =>\n" +
                        "        w_req_mem_valid := i.req_mem_valid or d.req_mem_valid;\n" +
                        "        if d.req_mem_valid = '1' then\n" +
                        "            v_data_req_ready := i_req_mem_ready;\n" +
                        "            if i_req_mem_ready = '1' then\n" +
                        "                v.state := State_DMem;\n" +
                        "            end if;\n" +
                        "        elsif i.req_mem_valid = '1' then\n" +
                        "            v_ctrl_req_ready := i_req_mem_ready;\n" +
                        "            wb_mem_addr := i.req_mem_addr;\n" +
                        "            wb_mem_len := i.req_mem_len;\n" +
                        "            wb_mem_burst := i.req_mem_burst;\n" +
                        "            w_mem_write := i.req_mem_write;\n" +
                        "            if i_req_mem_ready = '1' then\n" +
                        "                v.state := State_IMem;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "\n" +
                        "    when State_DMem =>\n" +
                        "        w_req_mem_valid := d.req_mem_last and (i.req_mem_valid or d.req_mem_valid);\n" +
                        "        if i_resp_mem_data_valid = '1' and d.req_mem_last = '1' then\n" +
                        "            if d.req_mem_valid = '1' then\n" +
                        "                v_data_req_ready := i_req_mem_ready;\n" +
                        "                if i_req_mem_ready = '1' then\n" +
                        "                     v.state := State_DMem;\n" +
                        "                else\n" +
                        "                    v.state := State_Idle;\n" +
                        "                end if;\n" +
                        "            elsif i.req_mem_valid = '1' then\n" +
                        "                v_ctrl_req_ready := i_req_mem_ready;\n" +
                        "                wb_mem_addr := i.req_mem_addr;\n" +
                        "                wb_mem_len := i.req_mem_len;\n" +
                        "                wb_mem_burst := i.req_mem_burst;\n" +
                        "                w_mem_write := i.req_mem_write;\n" +
                        "                if i_req_mem_ready = '1' then\n" +
                        "                    v.state := State_IMem;\n" +
                        "                else\n" +
                        "                    v.state := State_Idle;\n" +
                        "                end if;\n" +
                        "            else\n" +
                        "                v.state := State_Idle;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "        v_data_resp_mem_data_valid := i_resp_mem_data_valid;\n" +
                        "        \n" +
                        "    when State_IMem =>\n" +
                        "        w_req_mem_valid := i.req_mem_last and (i.req_mem_valid or d.req_mem_valid);\n" +
                        "        if i_resp_mem_data_valid = '1' and i.req_mem_last = '1' then\n" +
                        "            if d.req_mem_valid = '1' then\n" +
                        "                v_data_req_ready := i_req_mem_ready;\n" +
                        "                if i_req_mem_ready = '1' then\n" +
                        "                    v.state := State_DMem;\n" +
                        "                else\n" +
                        "                    v.state := State_Idle;\n" +
                        "                end if;\n" +
                        "            elsif i.req_mem_valid = '1' then\n" +
                        "                v_ctrl_req_ready := i_req_mem_ready;\n" +
                        "                wb_mem_addr := i.req_mem_addr;\n" +
                        "                wb_mem_len := i.req_mem_len;\n" +
                        "                wb_mem_burst := i.req_mem_burst;\n" +
                        "                w_mem_write := i.req_mem_write;\n" +
                        "                if i_req_mem_ready = '1' then\n" +
                        "                    v.state := State_IMem;\n" +
                        "                else\n" +
                        "                    v.state := State_Idle;\n" +
                        "                end if;\n" +
                        "            else\n" +
                        "                v.state := State_Idle;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "        v_ctrl_resp_mem_data_valid := i_resp_mem_data_valid;\n" +
                        "        \n" +
                        "    when others =>\n" +
                        "    end case;\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v.state := State_Idle;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_data_req_ready <= v_data_req_ready;\n" +
                        "    w_data_resp_mem_data_valid <= v_data_resp_mem_data_valid;\n" +
                        "    wb_data_resp_mem_data <= i_resp_mem_data;\n" +
                        "    w_data_resp_mem_load_fault <= i_resp_mem_load_fault;\n" +
                        "\n" +
                        "    w_ctrl_req_ready <= v_ctrl_req_ready;\n" +
                        "    w_ctrl_resp_mem_data_valid <= v_ctrl_resp_mem_data_valid;\n" +
                        "    wb_ctrl_resp_mem_data <= i_resp_mem_data;\n" +
                        "    w_ctrl_resp_mem_load_fault <= i_resp_mem_load_fault;\n" +
                        "\n" +
                        "    o_req_mem_valid <= w_req_mem_valid;\n" +
                        "    o_req_mem_addr <= wb_mem_addr;\n" +
                        "    o_req_mem_len <= wb_mem_len;\n" +
                        "    o_req_mem_burst <= wb_mem_burst;\n" +
                        "    o_req_mem_write <= w_mem_write;\n" +
                        "    o_req_mem_strob <= d.req_mem_strob;\n" +
                        "    o_req_mem_data <= d.req_mem_wdata;\n" +
                        "    o_cstate <= r.state;\n" +
                        "    \n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(i_clk, i_nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r.state <= State_Idle;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_axi_dsu_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2018 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "--! @brief     Debug Support Unit (DSU) with AXI4 interface.\n" +
                        "--! @details   DSU provides access to the internal CPU registers via\n" +
                        "--!            'Debug port' bus interface available only on <b>RIVER</b> CPU.\n" +
                        "--!            It is also implements a set of registers collecting bus\n" +
                        "--!            utilization statistic and additional debug information.\n" +
                        "-----------------------------------------------------------------------------\n" +
                        "\n" +
                        "--! VHDL base library.\n" +
                        "library ieee;\n" +
                        "--! VHDL base types import\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--! VHDL base numeric import\n" +
                        "use ieee.numeric_std.all;\n" +
                        "--! SoC common functionality library.\n" +
                        "--library commonlib;\n" +
                        "--! SoC common types import\n" +
                        "use work.types_common.all;\n" +
                        "--! AMBA system bus specific library.\n" +
                        "--library ambalib;\n" +
                        "--! AXI4 configuration constants.\n" +
                        "use work.types_amba4.all;\n" +
                        "use work.types_bus0.all; -- TODO: REMOVE ME when update dsu\n" +
                        "--! RIVER CPU specific library.\n" +
                        "--library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use work.river_cfg.all;\n" +
                        "--! River top level with AMBA interface module declaration\n" +
                        "use work.types_river.all;\n" +
                        "\n" +
                        "entity axi_dsu is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr    : integer := 0;\n" +
                        "    xmask    : integer := 16#fffff#\n" +
                        "  );\n" +
                        "  port \n" +
                        "  (\n" +
                        "    clk    : in std_logic;\n" +
                        "    nrst   : in std_logic;\n" +
                        "    o_cfg  : out axi4_slave_config_type;\n" +
                        "    i_axi  : in axi4_slave_in_type;\n" +
                        "    o_axi  : out axi4_slave_out_type;\n" +
                        "    o_dporti : out dport_in_vector;\n" +
                        "    i_dporto : in dport_out_vector;\n" +
                        "    --! reset CPU and interrupt controller\n" +
                        "    o_soft_rst : out std_logic;\n" +
                        "    -- Platfrom run-time statistic\n" +
                        "    i_bus_util_w : in std_logic_vector(CFG_BUS0_XMST_TOTAL-1 downto 0);\n" +
                        "    i_bus_util_r : in std_logic_vector(CFG_BUS0_XMST_TOTAL-1 downto 0)\n" +
                        "  );\n" +
                        "end;\n" +
                        "\n" +
                        "architecture arch_axi_dsu of axi_dsu is\n" +
                        "\n" +
                        "  constant xconfig : axi4_slave_config_type := (\n" +
                        "     descrtype => PNP_CFG_TYPE_SLAVE,\n" +
                        "     descrsize => PNP_CFG_SLAVE_DESCR_BYTES,\n" +
                        "     irq_idx => conv_std_logic_vector(0, 8),\n" +
                        "     xaddr => conv_std_logic_vector(xaddr, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     xmask => conv_std_logic_vector(xmask, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     vid => VENDOR_GNSSSENSOR,\n" +
                        "     did => GNSSSENSOR_DSU\n" +
                        "  );\n" +
                        "  \n" +
                        "  constant zero64 : std_logic_vector(63 downto 0) := (others => '0');\n" +
                        "\n" +
                        "  type state_type is (idle, read_internal, read_dport, dport_response, read_msw32);\n" +
                        "  \n" +
                        "  type mst_utilization_type is array (0 to CFG_BUS0_XMST_TOTAL-1) \n" +
                        "         of std_logic_vector(63 downto 0);\n" +
                        "\n" +
                        "  type mst_utilization_map_type is array (0 to 2*CFG_BUS0_XMST_TOTAL-1) \n" +
                        "         of std_logic_vector(63 downto 0);\n" +
                        "\n" +
                        "  type registers is record\n" +
                        "    state : state_type;\n" +
                        "    r32 : std_logic;\n" +
                        "    raddr : std_logic_vector(13 downto 0);\n" +
                        "    waddr : std_logic_vector(13 downto 0);\n" +
                        "    wdata : std_logic_vector(63 downto 0);\n" +
                        "    write_valid : std_logic;\n" +
                        "    soft_rst : std_logic;\n" +
                        "    dev_rdata : std_logic_vector(63 downto 0);\n" +
                        "    dev_ready : std_logic;\n" +
                        "    -- Platform statistic:\n" +
                        "    clk_cnt : std_logic_vector(63 downto 0);\n" +
                        "    cpu_context : std_logic_vector(log2x(CFG_CORES_PER_DSU_MAX)-1 downto 0);\n" +
                        "    util_w_cnt : mst_utilization_type;\n" +
                        "    util_r_cnt : mst_utilization_type;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : registers := (\n" +
                        "     idle, '0',                              -- state, r32\n" +
                        "     (others => '0'), (others => '0'),       -- raddr, waddr\n" +
                        "     (others => '0'), '0', '0',              -- wdata, write_valid, soft_rst\n" +
                        "     (others => '0'), '0',                   -- dev_rdata, dev_Ready\n" +
                        "     (others => '0'), (others => '0'),       -- clk_cnt, cpu_context\n" +
                        "     (others => zero64), (others => zero64)\n" +
                        "  );\n" +
                        "\n" +
                        "  signal r, rin: registers;\n" +
                        "  signal wb_bus_raddr : global_addr_array_type;\n" +
                        "  signal w_bus_re : std_logic;\n" +
                        "  signal w_bus_r32 : std_logic;\n" +
                        "  signal wb_bus_waddr : global_addr_array_type;\n" +
                        "  signal w_bus_we : std_logic;\n" +
                        "  signal wb_bus_wstrb : std_logic_vector(CFG_SYSBUS_DATA_BYTES-1 downto 0);\n" +
                        "  signal wb_bus_wdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  axi0 :  axi4_slave generic map (\n" +
                        "    async_reset => async_reset\n" +
                        "  ) port map (\n" +
                        "    i_clk => clk,\n" +
                        "    i_nrst => nrst,\n" +
                        "    i_xcfg => xconfig, \n" +
                        "    i_xslvi => i_axi,\n" +
                        "    o_xslvo => o_axi,\n" +
                        "    i_ready => r.dev_ready,\n" +
                        "    i_rdata => r.dev_rdata,\n" +
                        "    o_re => w_bus_re,\n" +
                        "    o_r32 => w_bus_r32,\n" +
                        "    o_radr => wb_bus_raddr,\n" +
                        "    o_wadr => wb_bus_waddr,\n" +
                        "    o_we => w_bus_we,\n" +
                        "    o_wstrb => wb_bus_wstrb,\n" +
                        "    o_wdata => wb_bus_wdata\n" +
                        "  );\n" +
                        "\n" +
                        "  comblogic : process(nrst, i_dporto, i_bus_util_w, i_bus_util_r, r, \n" +
                        "                      w_bus_re, w_bus_r32, wb_bus_raddr, wb_bus_waddr,\n" +
                        "                      w_bus_we, wb_bus_wstrb, wb_bus_wdata)\n" +
                        "    variable v : registers;\n" +
                        "    variable vrdata_internal : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "    variable vdporti : dport_in_vector;\n" +
                        "    variable iraddr : integer;\n" +
                        "    variable wb_bus_util_map : mst_utilization_map_type;\n" +
                        "    variable cpuidx : integer;\n" +
                        "  begin\n" +
                        "    v := r;\n" +
                        "    vdporti := (others => dport_in_none);\n" +
                        "    cpuidx := conv_integer(r.cpu_context);\n" +
                        "    \n" +
                        "    -- Update statistic:\n" +
                        "    v.clk_cnt := r.clk_cnt + 1;\n" +
                        "\n" +
                        "    -- TODO: move out these stuffs to bus-tracer\n" +
                        "    for n in 0 to CFG_BUS0_XMST_TOTAL-1 loop\n" +
                        "        if i_bus_util_w(n) = '1' then\n" +
                        "            v.util_w_cnt(n) := r.util_w_cnt(n) + 1;\n" +
                        "        end if;\n" +
                        "        if i_bus_util_r(n) = '1' then\n" +
                        "            v.util_r_cnt(n) := r.util_r_cnt(n) + 1;\n" +
                        "        end if;\n" +
                        "    end loop;\n" +
                        "\n" +
                        "    for n in 0 to CFG_BUS0_XMST_TOTAL-1 loop\n" +
                        "        wb_bus_util_map(2*n) := r.util_w_cnt(n);\n" +
                        "        wb_bus_util_map(2*n+1) := r.util_r_cnt(n);\n" +
                        "    end loop;\n" +
                        "\n" +
                        "\n" +
                        "    iraddr := conv_integer(r.raddr(11 downto 0));\n" +
                        "    vrdata_internal := (others => '0');\n" +
                        "    case iraddr is\n" +
                        "    when 0 =>\n" +
                        "        vrdata_internal(0) := r.soft_rst;\n" +
                        "    when 1 =>\n" +
                        "        vrdata_internal(log2x(CFG_CORES_PER_DSU_MAX)-1 downto 0) := r.cpu_context;\n" +
                        "    when others =>\n" +
                        "        if (iraddr >= 8) and (iraddr < (8 + 2*CFG_BUS0_XMST_TOTAL)) then\n" +
                        "             vrdata_internal := wb_bus_util_map(iraddr - 8);\n" +
                        "        end if;\n" +
                        "    end case;\n" +
                        "\n" +
                        "    v.write_valid := '0'; \n" +
                        "    if r.write_valid = '1' then\n" +
                        "        if r.waddr(13 downto 12) = \"11\" then\n" +
                        "            --! local region\n" +
                        "            case conv_integer(r.waddr(11 downto 0)) is\n" +
                        "            when 0 =>\n" +
                        "                v.soft_rst := r.wdata(0);\n" +
                        "            when 1 =>\n" +
                        "                v.cpu_context := r.wdata(log2x(CFG_CORES_PER_DSU_MAX)-1 downto 0);\n" +
                        "            when others =>\n" +
                        "            end case;\n" +
                        "        else\n" +
                        "            --! debug port regions: 0 to 2\n" +
                        "            vdporti(cpuidx).valid := '1';\n" +
                        "            vdporti(cpuidx).write := '1';\n" +
                        "            vdporti(cpuidx).region := r.waddr(13 downto 12);\n" +
                        "            vdporti(cpuidx).addr := r.waddr(11 downto 0);\n" +
                        "            vdporti(cpuidx).wdata := r.wdata;\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    case r.state is\n" +
                        "      when idle =>\n" +
                        "          v.dev_ready := '1';\n" +
                        "          if w_bus_we = '1' then\n" +
                        "              if wb_bus_waddr(0)(2) = '0' and wb_bus_wstrb = X\"FF\" then\n" +
                        "                  -- 64-bits access\n" +
                        "                  v.write_valid := '1'; \n" +
                        "                  v.waddr := wb_bus_waddr(0)(16 downto 3);\n" +
                        "                  v.wdata := wb_bus_wdata;\n" +
                        "              elsif wb_bus_wstrb(3 downto 0) = X\"F\" then\n" +
                        "                  -- 32-bits burst 1-st half, wait the second part\n" +
                        "                  v.waddr := wb_bus_waddr(0)(16 downto 3);\n" +
                        "                  v.wdata(31 downto 0) := wb_bus_wdata(31 downto 0);\n" +
                        "              else\n" +
                        "                  -- 32-bits burst 2-nd half\n" +
                        "                  v.write_valid := '1'; \n" +
                        "                  v.wdata(63 downto 32) := wb_bus_wdata(31 downto 0);\n" +
                        "              end if;\n" +
                        "          elsif w_bus_re = '1' then\n" +
                        "              v.dev_ready := '0';\n" +
                        "              v.raddr := wb_bus_raddr(0)(16 downto 3);\n" +
                        "              v.r32 := w_bus_r32;\n" +
                        "              if wb_bus_raddr(0)(16 downto 15) = \"11\" then\n" +
                        "                  v.state := read_internal;\n" +
                        "              else\n" +
                        "                  v.state := read_dport;\n" +
                        "              end if;\n" +
                        "          end if;\n" +
                        "\n" +
                        "      when read_internal =>\n" +
                        "          v.dev_ready := '1';\n" +
                        "          v.dev_rdata := vrdata_internal;\n" +
                        "          if r.r32 = '1' then\n" +
                        "              v.state := read_msw32;\n" +
                        "          else\n" +
                        "              v.state := idle;\n" +
                        "          end if;\n" +
                        "      when read_dport =>\n" +
                        "          --! debug port regions: 0 to 2\n" +
                        "          vdporti(cpuidx).valid := '1';\n" +
                        "          vdporti(cpuidx).write := '0';\n" +
                        "          vdporti(cpuidx).region := r.raddr(13 downto 12);\n" +
                        "          vdporti(cpuidx).addr := r.raddr(11 downto 0);\n" +
                        "          vdporti(cpuidx).wdata := (others => '0');\n" +
                        "          v.state := dport_response;\n" +
                        "      when dport_response =>\n" +
                        "          if r.r32 = '1' then\n" +
                        "              v.state := read_msw32;\n" +
                        "          else\n" +
                        "              v.state := idle;\n" +
                        "          end if;\n" +
                        "          v.dev_ready := '1';\n" +
                        "          v.dev_rdata := i_dporto(cpuidx).rdata;\n" +
                        "      when read_msw32 =>\n" +
                        "          v.r32 := '0';\n" +
                        "          v.state := idle;\n" +
                        "          v.dev_ready := '1';\n" +
                        "      when others =>\n" +
                        "    end case;\n" +
                        "\n" +
                        "    if not async_reset and nrst = '0' then \n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    rin <= v;\n" +
                        "\n" +
                        "    o_dporti <= vdporti;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  o_cfg  <= xconfig;\n" +
                        "  o_soft_rst <= r.soft_rst;\n" +
                        "\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(clk, nrst)\n" +
                        "  begin \n" +
                        "      if async_reset and nrst = '0' then\n" +
                        "          r <= R_RESET;\n" +
                        "      elsif rising_edge(clk) then \n" +
                        "          r <= rin;\n" +
                        "      end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_stacktrbuf_vhd_file(String Project_Folder_File) {
        String data =   "-----------------------------------------------------------------------------\n" +
                        "--! @file\n" +
                        "--! @copyright Copyright 2017 GNSS Sensor Ltd. All right reserved.\n" +
                        "--! @author    Sergey Khabarov - sergeykhbr@gmail.com\n" +
                        "--! @brief     Stack trace buffer on hardware level.\n" +
                        "------------------------------------------------------------------------------\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "\n" +
                        "entity StackTraceBuffer is \n" +
                        "  generic (\n" +
                        "    abits : integer := 5;\n" +
                        "    dbits : integer := 64\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk   : in std_logic;\n" +
                        "    i_raddr : in std_logic_vector(abits-1 downto 0);\n" +
                        "    o_rdata : out std_logic_vector(dbits-1 downto 0);\n" +
                        "    i_we    : in std_logic;\n" +
                        "    i_waddr : in std_logic_vector(abits-1 downto 0);\n" +
                        "    i_wdata : in std_logic_vector(dbits-1 downto 0)\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_StackTraceBuffer of StackTraceBuffer is\n" +
                        "\n" +
                        "  type ram_type is array ((2**abits)-1 downto 0) of std_logic_vector (dbits-1 downto 0);\n" +
                        "  signal stackbuf    : ram_type;\n" +
                        "  signal raddr       : std_logic_vector(abits-1 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(i_clk) begin \n" +
                        "    if rising_edge(i_clk) then \n" +
                        "      if i_we = '1' then\n" +
                        "        stackbuf(conv_integer(i_waddr)) <= i_wdata; \n" +
                        "      end if;\n" +
                        "      raddr <= i_raddr;\n" +
                        "    end if;\n" +
                        "  end process;\n" +
                        "  \n" +
                        "  o_rdata <= stackbuf(conv_integer(raddr));\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_regibank_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "--library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use work.river_cfg.all;\n" +
                        "\n" +
                        "\n" +
                        "entity RegIntBank is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;                                   -- CPU clock\n" +
                        "    i_nrst : in std_logic;                                  -- Reset. Active LOW.\n" +
                        "\n" +
                        "    i_radr1 : in std_logic_vector(5 downto 0);              -- Port 1 read address\n" +
                        "    o_rdata1 : out std_logic_vector(RISCV_ARCH-1 downto 0); -- Port 1 read value\n" +
                        "\n" +
                        "    i_radr2 : in std_logic_vector(5 downto 0);              -- Port 2 read address\n" +
                        "    o_rdata2 : out std_logic_vector(RISCV_ARCH-1 downto 0); -- Port 2 read value\n" +
                        "\n" +
                        "    i_waddr : in std_logic_vector(5 downto 0);              -- Writing value\n" +
                        "    i_wena : in std_logic;                                  -- Writing is enabled\n" +
                        "    i_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0);   -- Writing value\n" +
                        "\n" +
                        "    i_dport_addr : in std_logic_vector(4 downto 0);         -- Debug port address\n" +
                        "    i_dport_ena : in std_logic;                             -- Debug port is enabled\n" +
                        "    i_dport_write : in std_logic;                           -- Debug port write is enabled\n" +
                        "    i_dport_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0); -- Debug port write value\n" +
                        "    o_dport_rdata : out std_logic_vector(RISCV_ARCH-1 downto 0);-- Debug port read value\n" +
                        "\n" +
                        "    o_ra : out std_logic_vector(RISCV_ARCH-1 downto 0);     -- Return address for branch predictor\n" +
                        "    o_sp : out std_logic_vector(RISCV_ARCH-1 downto 0)      -- Stack Pointer for the borders control\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_RegIntBank of RegIntBank is\n" +
                        "\n" +
                        "  type MemoryType is array (0 to Reg_Total-1) \n" +
                        "         of std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "      mem : MemoryType;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  comb : process(i_nrst, i_radr1, i_radr2, i_waddr, i_wena, i_wdata,\n" +
                        "                 i_dport_ena, i_dport_write, i_dport_addr, i_dport_wdata, r)\n" +
                        "    variable v : RegistersType;\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "    --! Debug port has higher priority. Collision must be controlled by SW\n" +
                        "    if (i_dport_ena and i_dport_write) = '1' then\n" +
                        "        if i_dport_addr /= \"00000\" then\n" +
                        "            v.mem(conv_integer(i_dport_addr)) := i_dport_wdata;\n" +
                        "        end if;\n" +
                        "    elsif i_waddr(5) = '0' and i_wena = '1'  then\n" +
                        "        if i_waddr(4 downto 0) /= \"00000\" then\n" +
                        "            v.mem(conv_integer(i_waddr(4 downto 0))) := i_wdata;\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v.mem(Reg_Zero) := (others => '0');\n" +
                        "        for i in 1 to Reg_Total-1 loop\n" +
                        "            v.mem(i) := X\"00000000FEEDFACE\";\n" +
                        "        end loop;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  o_rdata1 <= r.mem(conv_integer(i_radr1(4 downto 0)));\n" +
                        "  o_rdata2 <= r.mem(conv_integer(i_radr2(4 downto 0)));\n" +
                        "  o_dport_rdata <= r.mem(conv_integer(i_dport_addr));\n" +
                        "  o_ra <= r.mem(Reg_ra);\n" +
                        "  o_sp <= r.mem(Reg_sp);\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(i_nrst, i_clk)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r.mem(Reg_Zero) <= (others => '0');\n" +
                        "        for i in 1 to Reg_Total-1 loop\n" +
                        "            r.mem(i) <= X\"00000000FEEDFACE\";\n" +
                        "        end loop;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_regfbank_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "--library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use work.river_cfg.all;\n" +
                        "\n" +
                        "\n" +
                        "entity RegFloatBank is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;                                   -- CPU clock\n" +
                        "    i_nrst : in std_logic;                                  -- Reset. Active LOW.\n" +
                        "\n" +
                        "    i_radr1 : in std_logic_vector(5 downto 0);              -- Port 1 read address\n" +
                        "    o_rdata1 : out std_logic_vector(RISCV_ARCH-1 downto 0); -- Port 1 read value\n" +
                        "\n" +
                        "    i_radr2 : in std_logic_vector(5 downto 0);              -- Port 2 read address\n" +
                        "    o_rdata2 : out std_logic_vector(RISCV_ARCH-1 downto 0); -- Port 2 read value\n" +
                        "\n" +
                        "    i_waddr : in std_logic_vector(5 downto 0);              -- Writing value\n" +
                        "    i_wena : in std_logic;                                  -- Writing is enabled\n" +
                        "    i_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0);   -- Writing value\n" +
                        "\n" +
                        "    i_dport_addr : in std_logic_vector(4 downto 0);         -- Debug port address\n" +
                        "    i_dport_ena : in std_logic;                             -- Debug port is enabled\n" +
                        "    i_dport_write : in std_logic;                           -- Debug port write is enabled\n" +
                        "    i_dport_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0); -- Debug port write value\n" +
                        "    o_dport_rdata : out std_logic_vector(RISCV_ARCH-1 downto 0)-- Debug port read value\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_RegFloatBank of RegFloatBank is\n" +
                        "\n" +
                        "  type MemoryType is array (0 to RegFpu_Total-1) \n" +
                        "         of std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "      mem : MemoryType;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  comb : process(i_nrst, i_radr1, i_radr2, i_waddr, i_wena, i_wdata,\n" +
                        "                 i_dport_ena, i_dport_write, i_dport_addr, i_dport_wdata, r)\n" +
                        "    variable v : RegistersType;\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "    --! Debug port has higher priority. Collision must be controlled by SW\n" +
                        "    if (i_dport_ena and i_dport_write) = '1' then\n" +
                        "        if i_dport_addr /= \"00000\" then\n" +
                        "            v.mem(conv_integer(i_dport_addr)) := i_dport_wdata;\n" +
                        "        end if;\n" +
                        "    elsif i_wena = '1' and i_waddr(5) = '1' then\n" +
                        "        v.mem(conv_integer(i_waddr(4 downto 0))) := i_wdata;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        for i in 0 to RegFpu_Total-1 loop\n" +
                        "            v.mem(i) := X\"00000000FEEDFACE\";\n" +
                        "        end loop;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  o_rdata1 <= r.mem(conv_integer(i_radr1(4 downto 0)));\n" +
                        "  o_rdata2 <= r.mem(conv_integer(i_radr2(4 downto 0)));\n" +
                        "  o_dport_rdata <= r.mem(conv_integer(i_dport_addr));\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(i_nrst, i_clk)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        for i in 0 to RegFpu_Total-1 loop\n" +
                        "            r.mem(i) <= X\"00000000FEEDFACE\";\n" +
                        "        end loop;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_proc_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "--library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use work.river_cfg.all;\n" +
                        "\n" +
                        "\n" +
                        "entity Processor is\n" +
                        "  generic (\n" +
                        "    hartid : integer;\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;                                             -- CPU clock\n" +
                        "    i_nrst : in std_logic;                                            -- Reset. Active LOW.\n" +
                        "    -- Control path:\n" +
                        "    i_req_ctrl_ready : in std_logic;                                  -- ICache is ready to accept request\n" +
                        "    o_req_ctrl_valid : out std_logic;                                 -- Request to ICache is valid\n" +
                        "    o_req_ctrl_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);-- Requesting address to ICache\n" +
                        "    i_resp_ctrl_valid : in std_logic;                                 -- ICache response is valid\n" +
                        "    i_resp_ctrl_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);-- Response address must be equal to the latest request address\n" +
                        "    i_resp_ctrl_data : in std_logic_vector(31 downto 0);              -- Read value\n" +
                        "    i_resp_ctrl_load_fault : in std_logic;                            -- bus response with error\n" +
                        "    o_resp_ctrl_ready : out std_logic;\n" +
                        "    -- Data path:\n" +
                        "    i_req_data_ready : in std_logic;                                  -- DCache is ready to accept request\n" +
                        "    o_req_data_valid : out std_logic;                                 -- Request to DCache is valid\n" +
                        "    o_req_data_write : out std_logic;                                 -- Read/Write transaction\n" +
                        "    o_req_data_size : out std_logic_vector(1 downto 0);               -- Size [Bytes]: 0=1B; 1=2B; 2=4B; 3=8B\n" +
                        "    o_req_data_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);-- Requesting address to DCache\n" +
                        "    o_req_data_data : out std_logic_vector(RISCV_ARCH-1 downto 0);    -- Writing value\n" +
                        "    i_resp_data_valid : in std_logic;                                 -- DCache response is valid\n" +
                        "    i_resp_data_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);-- DCache response address must be equal to the latest request address\n" +
                        "    i_resp_data_data : in std_logic_vector(RISCV_ARCH-1 downto 0);    -- Read value\n" +
                        "    i_resp_data_load_fault : in std_logic;                            -- Bus response with SLVERR or DECERR on read\n" +
                        "    i_resp_data_store_fault : in std_logic;                           -- Bus response with SLVERR or DECERR on write\n" +
                        "    i_resp_data_store_fault_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_resp_data_ready : out std_logic;\n" +
                        "    -- External interrupt pin\n" +
                        "    i_ext_irq : in std_logic;                                         -- PLIC interrupt accordingly with spec\n" +
                        "    o_time : out std_logic_vector(63 downto 0);                       -- Timer in clock except halt state\n" +
                        "    -- Debug interface:\n" +
                        "    i_dport_valid : in std_logic;                                     -- Debug access from DSU is valid\n" +
                        "    i_dport_write : in std_logic;                                     -- Write command flag\n" +
                        "    i_dport_region : in std_logic_vector(1 downto 0);                 -- Registers region ID: 0=CSR; 1=IREGS; 2=Control\n" +
                        "    i_dport_addr : in std_logic_vector(11 downto 0);                  -- Register idx\n" +
                        "    i_dport_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0);       -- Write value\n" +
                        "    o_dport_ready : out std_logic;                                    -- Response is ready\n" +
                        "    o_dport_rdata : out std_logic_vector(RISCV_ARCH-1 downto 0);      -- Response value\n" +
                        "    o_halted : out std_logic;\n" +
                        "    -- Debug signals:\n" +
                        "    o_flush_address : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);-- Address of instruction to remove from ICache\n" +
                        "    o_flush_valid : out std_logic;                                    -- Remove address from ICache is valid\n" +
                        "    i_istate : in std_logic_vector(1 downto 0);                       -- ICache state machine value\n" +
                        "    i_dstate : in std_logic_vector(1 downto 0);                       -- DCache state machine value\n" +
                        "    i_cstate : in std_logic_vector(1 downto 0)                        -- CacheTop state machine value\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_Processor of Processor is\n" +
                        "\n" +
                        "    type FetchType is record\n" +
                        "        req_fire : std_logic;\n" +
                        "        load_fault : std_logic;\n" +
                        "        valid : std_logic;\n" +
                        "        pc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "        instr : std_logic_vector(31 downto 0);\n" +
                        "        imem_req_valid : std_logic;\n" +
                        "        imem_req_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "        pipeline_hold : std_logic;\n" +
                        "        instr_buf : std_logic_vector(DBG_FETCH_TRACE_SIZE*64-1 downto 0);\n" +
                        "    end record;\n" +
                        "\n" +
                        "    type InstructionDecodeType is record\n" +
                        "        pc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "        instr : std_logic_vector(31 downto 0);\n" +
                        "        instr_valid : std_logic;\n" +
                        "        memop_store : std_logic;\n" +
                        "        memop_load : std_logic;\n" +
                        "        memop_sign_ext : std_logic;\n" +
                        "        memop_size : std_logic_vector(1 downto 0);\n" +
                        "        rv32 : std_logic;                                    -- 32-bits instruction\n" +
                        "        compressed : std_logic;                              -- C-extension\n" +
                        "        f64 : std_logic;                                     -- D-extension (FPU)\n" +
                        "        unsigned_op : std_logic;                             -- Unsigned operands\n" +
                        "        isa_type : std_logic_vector(ISA_Total-1 downto 0);\n" +
                        "        instr_vec : std_logic_vector(Instr_Total-1 downto 0);\n" +
                        "        exception : std_logic;\n" +
                        "    end record;\n" +
                        "\n" +
                        "    type ExecuteType is record\n" +
                        "        trap_ready : std_logic;\n" +
                        "        valid : std_logic;\n" +
                        "        instr : std_logic_vector(31 downto 0);\n" +
                        "        pc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "        npc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "        ex_npc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "\n" +
                        "        radr1 : std_logic_vector(5 downto 0);\n" +
                        "        radr2 : std_logic_vector(5 downto 0);\n" +
                        "        res_addr : std_logic_vector(5 downto 0);\n" +
                        "        res_data : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "        mret : std_logic;\n" +
                        "        uret : std_logic;\n" +
                        "        csr_addr : std_logic_vector(11 downto 0);\n" +
                        "        csr_wena : std_logic;\n" +
                        "        csr_wdata : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "        ex_illegal_instr : std_logic;\n" +
                        "        ex_unalign_load : std_logic;\n" +
                        "        ex_unalign_store : std_logic;\n" +
                        "        ex_breakpoint : std_logic;\n" +
                        "        ex_ecall : std_logic;\n" +
                        "        ex_fpu_invalidop : std_logic;            -- FPU Exception: invalid operation\n" +
                        "        ex_fpu_divbyzero : std_logic;            -- FPU Exception: divide by zero\n" +
                        "        ex_fpu_overflow : std_logic;             -- FPU Exception: overflow\n" +
                        "        ex_fpu_underflow : std_logic;            -- FPU Exception: underflow\n" +
                        "        ex_fpu_inexact : std_logic;              -- FPU Exception: inexact\n" +
                        "        fpu_valid : std_logic;\n" +
                        "\n" +
                        "        memop_sign_ext : std_logic;\n" +
                        "        memop_load : std_logic;\n" +
                        "        memop_store : std_logic;\n" +
                        "        memop_size : std_logic_vector(1 downto 0);\n" +
                        "        memop_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "        pipeline_hold : std_logic;                            -- Hold pipeline from Execution stage\n" +
                        "        call : std_logic;\n" +
                        "        ret : std_logic;\n" +
                        "    end record;\n" +
                        "\n" +
                        "    type MemoryType is record\n" +
                        "        valid : std_logic;\n" +
                        "        instr : std_logic_vector(31 downto 0);\n" +
                        "        pc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "        pipeline_hold : std_logic;\n" +
                        "    end record;\n" +
                        "\n" +
                        "    type WriteBackType is record\n" +
                        "        pc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "        wena : std_logic;\n" +
                        "        waddr : std_logic_vector(5 downto 0);\n" +
                        "        wdata : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    end record;\n" +
                        "\n" +
                        "    type IntRegsType is record\n" +
                        "        rdata1 : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "        rdata2 : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "        dport_rdata : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "        ra : std_logic_vector(RISCV_ARCH-1 downto 0);       -- Return address\n" +
                        "        sp : std_logic_vector(RISCV_ARCH-1 downto 0);       -- Stack pointer\n" +
                        "    end record;\n" +
                        "\n" +
                        "    type FloatRegsType is record\n" +
                        "        rdata1 : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "        rdata2 : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "        dport_rdata : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    end record;\n" +
                        "\n" +
                        "    type CsrType is record\n" +
                        "        rdata : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "        dport_rdata : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "        trap_valid : std_logic;\n" +
                        "        trap_pc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "        break_event : std_logic;\n" +
                        "    end record;\n" +
                        "\n" +
                        "    --! 5-stages CPU pipeline\n" +
                        "    type PipelineType is record\n" +
                        "        f : FetchType;                            -- Fetch instruction stage\n" +
                        "        d : InstructionDecodeType;                -- Decode instruction stage\n" +
                        "        e : ExecuteType;                          -- Execute instruction\n" +
                        "        m : MemoryType;                           -- Memory load/store\n" +
                        "        w : WriteBackType;                        -- Write back registers value\n" +
                        "    end record;\n" +
                        "\n" +
                        "    type DebugType is record\n" +
                        "        core_addr : std_logic_vector(11 downto 0);           -- Address of the sub-region register\n" +
                        "        core_wdata : std_logic_vector(RISCV_ARCH-1 downto 0);-- Write data\n" +
                        "        csr_ena : std_logic;                                 -- Region 0: Access to CSR bank is enabled.\n" +
                        "        csr_write : std_logic;                               -- Region 0: CSR write enable\n" +
                        "        ireg_ena : std_logic;                                -- Region 1: Access to integer register bank is enabled\n" +
                        "        ireg_write : std_logic;                              -- Region 1: Integer registers bank write pulse\n" +
                        "        freg_ena : std_logic;                                -- Region 1: Access to float register bank is enabled\n" +
                        "        freg_write : std_logic;                              -- Region 1: Float registers bank write pulse\n" +
                        "        npc_write : std_logic;                               -- Region 1: npc write enable\n" +
                        "        halt : std_logic;                                    -- Halt signal is equal to hold pipeline\n" +
                        "        clock_cnt : std_logic_vector(63 downto 0);           -- Number of clocks excluding halt state\n" +
                        "        executed_cnt : std_logic_vector(63 downto 0);        -- Number of executed instruction\n" +
                        "        break_mode : std_logic;                              -- Behaviour on EBREAK instruction: 0 = halt; 1 = generate trap\n" +
                        "        br_fetch_valid : std_logic;                          -- Fetch injection address/instr are valid\n" +
                        "        br_address_fetch : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0); -- Fetch injection address to skip ebreak instruciton only once\n" +
                        "        br_instr_fetch : std_logic_vector(31 downto 0);      -- Real instruction value that was replaced by ebreak\n" +
                        "        flush_address : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);-- Address of instruction to remove from ICache\n" +
                        "        flush_valid : std_logic;                                    -- Remove address from ICache is valid\n" +
                        "    end record;\n" +
                        "\n" +
                        "    type BranchPredictorType is record\n" +
                        "       npc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    end record;\n" +
                        "\n" +
                        "    signal ireg : IntRegsType;\n" +
                        "    signal freg : FloatRegsType;\n" +
                        "    signal csr : CsrType;\n" +
                        "    signal w : PipelineType;\n" +
                        "    signal dbg : DebugType;\n" +
                        "    signal bp : BranchPredictorType;\n" +
                        "\n" +
                        "    signal wb_ireg_dport_addr : std_logic_vector(4 downto 0);\n" +
                        "    signal wb_freg_dport_addr : std_logic_vector(4 downto 0);\n" +
                        "    signal wb_exec_dport_npc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    \n" +
                        "    signal w_fetch_pipeline_hold : std_logic;\n" +
                        "    signal w_any_pipeline_hold : std_logic;\n" +
                        "    signal w_exec_pipeline_hold : std_logic;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "    w_fetch_pipeline_hold <= w.e.pipeline_hold or w.m.pipeline_hold or dbg.halt;\n" +
                        "    w_any_pipeline_hold <= w.f.pipeline_hold or w.e.pipeline_hold \n" +
                        "                          or w.m.pipeline_hold  or dbg.halt;\n" +
                        "    w_exec_pipeline_hold <= w.f.pipeline_hold or w.m.pipeline_hold or dbg.halt;\n" +
                        "\n" +
                        "    wb_ireg_dport_addr <= dbg.core_addr(4 downto 0);\n" +
                        "    wb_freg_dport_addr <= dbg.core_addr(4 downto 0);\n" +
                        "    wb_exec_dport_npc <= dbg.core_wdata(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    \n" +
                        "    fetch0 : InstrFetch generic map (\n" +
                        "        async_reset => async_reset\n" +
                        "      ) port map (\n" +
                        "        i_clk => i_clk,\n" +
                        "        i_nrst => i_nrst,\n" +
                        "        i_pipeline_hold => w_fetch_pipeline_hold,\n" +
                        "        i_mem_req_ready => i_req_ctrl_ready,\n" +
                        "        o_mem_addr_valid => w.f.imem_req_valid,\n" +
                        "        o_mem_addr => w.f.imem_req_addr,\n" +
                        "        i_mem_data_valid => i_resp_ctrl_valid,\n" +
                        "        i_mem_data_addr => i_resp_ctrl_addr,\n" +
                        "        i_mem_data => i_resp_ctrl_data,\n" +
                        "        i_mem_load_fault => i_resp_ctrl_load_fault,\n" +
                        "        o_mem_resp_ready => o_resp_ctrl_ready,\n" +
                        "        i_predict_npc => bp.npc,\n" +
                        "        o_mem_req_fire => w.f.req_fire,\n" +
                        "        o_ex_load_fault => w.f.load_fault,\n" +
                        "        o_valid => w.f.valid,\n" +
                        "        o_pc => w.f.pc,\n" +
                        "        o_instr => w.f.instr,\n" +
                        "        o_hold => w.f.pipeline_hold,\n" +
                        "        i_br_fetch_valid => dbg.br_fetch_valid,\n" +
                        "        i_br_address_fetch => dbg.br_address_fetch,\n" +
                        "        i_br_instr_fetch => dbg.br_instr_fetch,\n" +
                        "        o_instr_buf => w.f.instr_buf);\n" +
                        "        \n" +
                        "    dec0 : InstrDecoder generic map (\n" +
                        "        async_reset => async_reset\n" +
                        "      ) port map (\n" +
                        "        i_clk => i_clk,\n" +
                        "        i_nrst => i_nrst,\n" +
                        "        i_any_hold => w_any_pipeline_hold,\n" +
                        "        i_f_valid => w.f.valid,\n" +
                        "        i_f_pc => w.f.pc,\n" +
                        "        i_f_instr => w.f.instr,\n" +
                        "        o_valid => w.d.instr_valid,\n" +
                        "        o_pc => w.d.pc,\n" +
                        "        o_instr => w.d.instr,\n" +
                        "        o_memop_store => w.d.memop_store,\n" +
                        "        o_memop_load => w.d.memop_load,\n" +
                        "        o_memop_sign_ext => w.d.memop_sign_ext,\n" +
                        "        o_memop_size => w.d.memop_size,\n" +
                        "        o_unsigned_op => w.d.unsigned_op,\n" +
                        "        o_rv32 => w.d.rv32,\n" +
                        "        o_compressed => w.d.compressed,\n" +
                        "        o_f64 => w.d.f64,\n" +
                        "        o_isa_type => w.d.isa_type,\n" +
                        "        o_instr_vec => w.d.instr_vec,\n" +
                        "        o_exception => w.d.exception);\n" +
                        "\n" +
                        "    exec0 : InstrExecute generic map (\n" +
                        "        async_reset => async_reset\n" +
                        "      ) port map (\n" +
                        "        i_clk => i_clk,\n" +
                        "        i_nrst => i_nrst,\n" +
                        "        i_pipeline_hold => w_exec_pipeline_hold,\n" +
                        "        i_d_valid => w.d.instr_valid,\n" +
                        "        i_d_pc => w.d.pc,\n" +
                        "        i_d_instr => w.d.instr,\n" +
                        "        i_wb_ready => w.m.valid,\n" +
                        "        i_memop_store => w.d.memop_store,\n" +
                        "        i_memop_load => w.d.memop_load,\n" +
                        "        i_memop_sign_ext => w.d.memop_sign_ext,\n" +
                        "        i_memop_size => w.d.memop_size,\n" +
                        "        i_unsigned_op => w.d.unsigned_op,\n" +
                        "        i_rv32 => w.d.rv32,\n" +
                        "        i_compressed => w.d.compressed,\n" +
                        "        i_f64 => w.d.f64,\n" +
                        "        i_isa_type => w.d.isa_type,\n" +
                        "        i_ivec => w.d.instr_vec,\n" +
                        "        i_unsup_exception => w.d.exception,\n" +
                        "        i_dport_npc_write => dbg.npc_write,\n" +
                        "        i_dport_npc => wb_exec_dport_npc,\n" +
                        "        o_radr1 => w.e.radr1,\n" +
                        "        i_rdata1 => ireg.rdata1,\n" +
                        "        o_radr2 => w.e.radr2,\n" +
                        "        i_rdata2 => ireg.rdata2,\n" +
                        "        i_rfdata1 => freg.rdata1,\n" +
                        "        i_rfdata2 => freg.rdata2,\n" +
                        "        o_res_addr => w.e.res_addr,\n" +
                        "        o_res_data => w.e.res_data,\n" +
                        "        o_pipeline_hold => w.e.pipeline_hold,\n" +
                        "        o_csr_addr => w.e.csr_addr,\n" +
                        "        o_csr_wena => w.e.csr_wena,\n" +
                        "        i_csr_rdata => csr.rdata,\n" +
                        "        o_csr_wdata => w.e.csr_wdata,\n" +
                        "        i_trap_valid => csr.trap_valid,\n" +
                        "        i_trap_pc => csr.trap_pc,\n" +
                        "        o_ex_npc => w.e.ex_npc,\n" +
                        "        o_ex_illegal_instr => w.e.ex_illegal_instr,\n" +
                        "        o_ex_unalign_store => w.e.ex_unalign_store,\n" +
                        "        o_ex_unalign_load => w.e.ex_unalign_load,\n" +
                        "        o_ex_breakpoint => w.e.ex_breakpoint,\n" +
                        "        o_ex_ecall => w.e.ex_ecall,\n" +
                        "        o_ex_fpu_invalidop => w.e.ex_fpu_invalidop,\n" +
                        "        o_ex_fpu_divbyzero => w.e.ex_fpu_divbyzero,\n" +
                        "        o_ex_fpu_overflow => w.e.ex_fpu_overflow,\n" +
                        "        o_ex_fpu_underflow => w.e.ex_fpu_underflow,\n" +
                        "        o_ex_fpu_inexact => w.e.ex_fpu_inexact,\n" +
                        "        o_fpu_valid => w.e.fpu_valid,\n" +
                        "        o_memop_sign_ext => w.e.memop_sign_ext,\n" +
                        "        o_memop_load => w.e.memop_load,\n" +
                        "        o_memop_store => w.e.memop_store,\n" +
                        "        o_memop_size => w.e.memop_size,\n" +
                        "        o_memop_addr => w.e.memop_addr,\n" +
                        "        o_trap_ready => w.e.trap_ready,\n" +
                        "        o_valid => w.e.valid,\n" +
                        "        o_pc => w.e.pc,\n" +
                        "        o_npc => w.e.npc,\n" +
                        "        o_instr => w.e.instr,\n" +
                        "        o_call => w.e.call,\n" +
                        "        o_ret => w.e.ret,\n" +
                        "        o_mret => w.e.mret,\n" +
                        "        o_uret => w.e.uret);\n" +
                        "\n" +
                        "    mem0 : MemAccess generic map (\n" +
                        "        async_reset => async_reset\n" +
                        "      ) port map (\n" +
                        "        i_clk => i_clk,\n" +
                        "        i_nrst => i_nrst,\n" +
                        "        i_e_valid => w.e.valid,\n" +
                        "        i_e_pc => w.e.pc,\n" +
                        "        i_e_instr => w.e.instr,\n" +
                        "        i_res_addr => w.e.res_addr,\n" +
                        "        i_res_data => w.e.res_data,\n" +
                        "        i_memop_sign_ext => w.e.memop_sign_ext,\n" +
                        "        i_memop_load => w.e.memop_load,\n" +
                        "        i_memop_store => w.e.memop_store,\n" +
                        "        i_memop_size => w.e.memop_size,\n" +
                        "        i_memop_addr => w.e.memop_addr,\n" +
                        "        o_waddr => w.w.waddr,\n" +
                        "        o_wena => w.w.wena,\n" +
                        "        o_wdata => w.w.wdata,\n" +
                        "        i_mem_req_ready => i_req_data_ready,\n" +
                        "        o_mem_valid => o_req_data_valid,\n" +
                        "        o_mem_write => o_req_data_write,\n" +
                        "        o_mem_sz => o_req_data_size,\n" +
                        "        o_mem_addr => o_req_data_addr,\n" +
                        "        o_mem_data => o_req_data_data,\n" +
                        "        i_mem_data_valid => i_resp_data_valid,\n" +
                        "        i_mem_data_addr => i_resp_data_addr,\n" +
                        "        i_mem_data => i_resp_data_data,\n" +
                        "        o_mem_resp_ready => o_resp_data_ready,\n" +
                        "        o_hold => w.m.pipeline_hold,\n" +
                        "        o_valid => w.m.valid,\n" +
                        "        o_pc => w.m.pc,\n" +
                        "        o_instr => w.m.instr);\n" +
                        "\n" +
                        "    predic0 : BranchPredictor generic map (\n" +
                        "        async_reset => async_reset\n" +
                        "      ) port map (\n" +
                        "        i_clk => i_clk,\n" +
                        "        i_nrst => i_nrst,\n" +
                        "        i_req_mem_fire => w.f.req_fire,\n" +
                        "        i_resp_mem_valid => i_resp_ctrl_valid,\n" +
                        "        i_resp_mem_addr => i_resp_ctrl_addr,\n" +
                        "        i_resp_mem_data => i_resp_ctrl_data,\n" +
                        "        i_e_npc => w.e.npc,\n" +
                        "        i_ra => ireg.ra,\n" +
                        "        o_npc_predict => bp.npc);\n" +
                        "\n" +
                        "\n" +
                        "    iregs0 : RegIntBank generic map (\n" +
                        "        async_reset => async_reset\n" +
                        "      ) port map ( \n" +
                        "        i_clk => i_clk,\n" +
                        "        i_nrst => i_nrst,\n" +
                        "        i_radr1 => w.e.radr1,\n" +
                        "        o_rdata1 => ireg.rdata1,\n" +
                        "        i_radr2 => w.e.radr2,\n" +
                        "        o_rdata2 => ireg.rdata2,\n" +
                        "        i_waddr => w.w.waddr,\n" +
                        "        i_wena => w.w.wena,\n" +
                        "        i_wdata => w.w.wdata,\n" +
                        "        i_dport_addr => wb_ireg_dport_addr,\n" +
                        "        i_dport_ena => dbg.ireg_ena,\n" +
                        "        i_dport_write => dbg.ireg_write,\n" +
                        "        i_dport_wdata => dbg.core_wdata,\n" +
                        "        o_dport_rdata => ireg.dport_rdata,\n" +
                        "        o_ra => ireg.ra,   -- Return address\n" +
                        "        o_sp => ireg.sp);\n" +
                        "\n" +
                        "    fpuena : if CFG_HW_FPU_ENABLE generate\n" +
                        "      fregs0 : RegFloatBank generic map (\n" +
                        "        async_reset => async_reset\n" +
                        "      ) port map (\n" +
                        "        i_clk => i_clk,\n" +
                        "        i_nrst => i_nrst,\n" +
                        "        i_radr1 => w.e.radr1,\n" +
                        "        o_rdata1 => freg.rdata1,\n" +
                        "        i_radr2 => w.e.radr2,\n" +
                        "        o_rdata2 => freg.rdata2,\n" +
                        "        i_waddr => w.w.waddr,\n" +
                        "        i_wena => w.w.wena,\n" +
                        "        i_wdata => w.w.wdata,\n" +
                        "        i_dport_addr => wb_freg_dport_addr,\n" +
                        "        i_dport_ena => dbg.freg_ena,\n" +
                        "        i_dport_write => dbg.freg_write,\n" +
                        "        i_dport_wdata => dbg.core_wdata,\n" +
                        "        o_dport_rdata => freg.dport_rdata);\n" +
                        "    end generate;\n" +
                        "\n" +
                        "    fpudis : if not CFG_HW_FPU_ENABLE generate\n" +
                        "        freg.rdata1 <= (others => '0');\n" +
                        "        freg.rdata2 <= (others => '0');\n" +
                        "        freg.dport_rdata <= (others => '0');\n" +
                        "    end generate;\n" +
                        "\n" +
                        "    csr0 : CsrRegs generic map (\n" +
                        "        hartid => hartid,\n" +
                        "        async_reset => async_reset\n" +
                        "      ) port map (\n" +
                        "        i_clk => i_clk,\n" +
                        "        i_nrst => i_nrst,\n" +
                        "        i_mret => w.e.mret,\n" +
                        "        i_uret => w.e.uret,\n" +
                        "        i_sp => ireg.sp,\n" +
                        "        i_addr => w.e.csr_addr,\n" +
                        "        i_wena => w.e.csr_wena,\n" +
                        "        i_wdata => w.e.csr_wdata,\n" +
                        "        o_rdata => csr.rdata,\n" +
                        "        i_trap_ready => w.e.trap_ready,\n" +
                        "        i_ex_pc => w.e.npc,\n" +
                        "        i_ex_npc => w.e.ex_npc,\n" +
                        "        i_ex_data_addr => i_resp_data_addr,\n" +
                        "        i_ex_data_load_fault => i_resp_data_load_fault,\n" +
                        "        i_ex_data_store_fault => i_resp_data_store_fault,\n" +
                        "        i_ex_data_store_fault_addr => i_resp_data_store_fault_addr,\n" +
                        "        i_ex_ctrl_load_fault => w.f.load_fault,\n" +
                        "        i_ex_illegal_instr => w.e.ex_illegal_instr,\n" +
                        "        i_ex_unalign_store => w.e.ex_unalign_store,\n" +
                        "        i_ex_unalign_load => w.e.ex_unalign_load,\n" +
                        "        i_ex_breakpoint => w.e.ex_breakpoint,\n" +
                        "        i_ex_ecall => w.e.ex_ecall,\n" +
                        "        i_ex_fpu_invalidop => w.e.ex_fpu_invalidop,\n" +
                        "        i_ex_fpu_divbyzero => w.e.ex_fpu_divbyzero,\n" +
                        "        i_ex_fpu_overflow => w.e.ex_fpu_overflow,\n" +
                        "        i_ex_fpu_underflow => w.e.ex_fpu_underflow,\n" +
                        "        i_ex_fpu_inexact => w.e.ex_fpu_inexact,\n" +
                        "        i_fpu_valid => w.e.fpu_valid,\n" +
                        "        i_irq_external => i_ext_irq,\n" +
                        "        o_trap_valid => csr.trap_valid,\n" +
                        "        o_trap_pc => csr.trap_pc,\n" +
                        "        i_break_mode => dbg.break_mode,\n" +
                        "        o_break_event => csr.break_event,\n" +
                        "        i_dport_ena => dbg.csr_ena,\n" +
                        "        i_dport_write => dbg.csr_write,\n" +
                        "        i_dport_addr => dbg.core_addr,\n" +
                        "        i_dport_wdata => dbg.core_wdata,\n" +
                        "        o_dport_rdata => csr.dport_rdata);\n" +
                        "\n" +
                        "\n" +
                        "    dbg0 : DbgPort generic map (\n" +
                        "        async_reset => async_reset\n" +
                        "    ) port map (\n" +
                        "        i_clk => i_clk,\n" +
                        "        i_nrst => i_nrst,\n" +
                        "        i_dport_valid => i_dport_valid,\n" +
                        "        i_dport_write => i_dport_write,\n" +
                        "        i_dport_region => i_dport_region,\n" +
                        "        i_dport_addr => i_dport_addr,\n" +
                        "        i_dport_wdata => i_dport_wdata,\n" +
                        "        o_dport_ready => o_dport_ready,\n" +
                        "        o_dport_rdata => o_dport_rdata,\n" +
                        "        o_core_addr => dbg.core_addr,\n" +
                        "        o_core_wdata => dbg.core_wdata,\n" +
                        "        o_csr_ena => dbg.csr_ena,\n" +
                        "        o_csr_write => dbg.csr_write,\n" +
                        "        i_csr_rdata => csr.dport_rdata,\n" +
                        "        o_ireg_ena => dbg.ireg_ena,\n" +
                        "        o_ireg_write => dbg.ireg_write,\n" +
                        "        o_freg_ena => dbg.freg_ena,\n" +
                        "        o_freg_write => dbg.freg_write,\n" +
                        "        o_npc_write => dbg.npc_write,\n" +
                        "        i_ireg_rdata => ireg.dport_rdata,\n" +
                        "        i_freg_rdata => freg.dport_rdata,\n" +
                        "        i_pc => w.e.pc,\n" +
                        "        i_npc => w.e.npc,\n" +
                        "        i_e_valid => w.e.valid,\n" +
                        "        i_e_call => w.e.call,\n" +
                        "        i_e_ret => w.e.ret,\n" +
                        "        i_m_valid => w.m.valid,\n" +
                        "        o_clock_cnt => dbg.clock_cnt,\n" +
                        "        o_executed_cnt => dbg.executed_cnt,\n" +
                        "        o_halt => dbg.halt,\n" +
                        "        i_ebreak => csr.break_event,\n" +
                        "        o_break_mode => dbg.break_mode,\n" +
                        "        o_br_fetch_valid => dbg.br_fetch_valid,\n" +
                        "        o_br_address_fetch => dbg.br_address_fetch,\n" +
                        "        o_br_instr_fetch => dbg.br_instr_fetch,\n" +
                        "        o_flush_address => dbg.flush_address,\n" +
                        "        o_flush_valid => dbg.flush_valid,\n" +
                        "        i_istate => i_istate,\n" +
                        "        i_dstate => i_dstate,\n" +
                        "        i_cstate => i_cstate,\n" +
                        "        i_instr_buf => w.f.instr_buf);\n" +
                        "\n" +
                        "    o_flush_valid <= dbg.flush_valid or csr.break_event;\n" +
                        "    o_flush_address <= w.e.npc when csr.break_event = '1' else dbg.flush_address;\n" +
                        "    o_req_ctrl_valid <= w.f.imem_req_valid;\n" +
                        "    o_req_ctrl_addr <= w.f.imem_req_addr;\n" +
                        "    o_time <= dbg.clock_cnt;\n" +
                        "    o_halted <= dbg.halt;\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_memaccess_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "--library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use work.river_cfg.all;\n" +
                        "\n" +
                        "\n" +
                        "entity MemAccess is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk  : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_e_valid : in std_logic;                                         -- Execution stage outputs are valid\n" +
                        "    i_e_pc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);          -- Execution stage instruction pointer\n" +
                        "    i_e_instr : in std_logic_vector(31 downto 0);                     -- Execution stage instruction value\n" +
                        "\n" +
                        "    i_res_addr : in std_logic_vector(5 downto 0);                     -- Register address to be written (0=no writing)\n" +
                        "    i_res_data : in std_logic_vector(RISCV_ARCH-1 downto 0);          -- Register value to be written\n" +
                        "    i_memop_sign_ext : in std_logic;                                  -- Load data with sign extending (if less than 8 Bytes)\n" +
                        "    i_memop_load : in std_logic;                                      -- Load data from memory and write to i_res_addr\n" +
                        "    i_memop_store : in std_logic;                                     -- Store i_res_data value into memory\n" +
                        "    i_memop_size : in std_logic_vector(1 downto 0);                   -- Encoded memory transaction size in bytes: 0=1B; 1=2B; 2=4B; 3=8B\n" +
                        "    i_memop_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);    -- Memory access address\n" +
                        "    o_wena : out std_logic;                                           -- Write enable signal\n" +
                        "    o_waddr : out std_logic_vector(5 downto 0);                       -- Output register address (0 = x0 = no write)\n" +
                        "    o_wdata : out std_logic_vector(RISCV_ARCH-1 downto 0);            -- Register value\n" +
                        "\n" +
                        "    -- Memory interface:\n" +
                        "    i_mem_req_ready : in std_logic;\n" +
                        "    o_mem_valid : out std_logic;                                      -- Memory request is valid\n" +
                        "    o_mem_write : out std_logic;                                      -- Memory write request\n" +
                        "    o_mem_sz : out std_logic_vector(1 downto 0);                      -- Encoded data size in bytes: 0=1B; 1=2B; 2=4B; 3=8B\n" +
                        "    o_mem_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);     -- Data path requested address\n" +
                        "    o_mem_data : out std_logic_vector(BUS_DATA_WIDTH-1 downto 0);     -- Data path requested data (write transaction)\n" +
                        "    i_mem_data_valid : in std_logic;                                  -- Data path memory response is valid\n" +
                        "    i_mem_data_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0); -- Data path memory response address\n" +
                        "    i_mem_data : in std_logic_vector(BUS_DATA_WIDTH-1 downto 0);      -- Data path memory response value\n" +
                        "    o_mem_resp_ready : out std_logic;\n" +
                        "\n" +
                        "    o_hold : out std_logic;                                           -- Memory operation is more than 1 clock\n" +
                        "    o_valid : out std_logic;                                          -- Output is valid\n" +
                        "    o_pc : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);           -- Valid instruction pointer\n" +
                        "    o_instr : out std_logic_vector(31 downto 0)                       -- Valid instruction value\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_MemAccess of MemAccess is\n" +
                        "\n" +
                        "  constant State_Idle : std_logic_vector(1 downto 0) := \"00\";\n" +
                        "  constant State_WaitReqAccept : std_logic_vector(1 downto 0) := \"01\";\n" +
                        "  constant State_WaitResponse : std_logic_vector(1 downto 0) := \"10\";\n" +
                        "  constant State_RegForward : std_logic_vector(1 downto 0) := \"11\";\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "      state : std_logic_vector(1 downto 0);\n" +
                        "      memop_r : std_logic;\n" +
                        "      memop_rw : std_logic;\n" +
                        "      memop_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      pc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      instr : std_logic_vector(31 downto 0);\n" +
                        "\n" +
                        "      res_addr : std_logic_vector(5 downto 0);\n" +
                        "      res_data : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "      memop_sign_ext : std_logic;\n" +
                        "      memop_size : std_logic_vector(1 downto 0);\n" +
                        "      wena : std_logic;\n" +
                        "  end record;\n" +
                        " \n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "    State_Idle,                              -- state\n" +
                        "    '0', '0', (others => '0'),               -- memop_r, memop_rw, memop_addr\n" +
                        "    (others => '0'), (others => '0'),        -- pc, instr\n" +
                        "    (others => '0'),                         -- res_addr\n" +
                        "    (others => '0'), '0',                    -- res_data, memop_sign_ext\n" +
                        "    (others => '0'), '0'                     -- memop_size, wena\n" +
                        "  );\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "\n" +
                        "  comb : process(i_nrst, i_mem_req_ready, i_e_valid, i_e_pc, i_e_instr, i_res_addr, i_res_data,\n" +
                        "                i_memop_sign_ext, i_memop_load, i_memop_store, i_memop_size,\n" +
                        "                i_memop_addr, i_mem_data_valid, i_mem_data_addr, i_mem_data, r)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable w_mem_valid : std_logic;\n" +
                        "    variable w_mem_write : std_logic;\n" +
                        "    variable wb_mem_sz : std_logic_vector(1 downto 0);\n" +
                        "    variable wb_mem_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable wb_mem_data : std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    variable w_hold : std_logic;\n" +
                        "    variable w_valid : std_logic;\n" +
                        "    variable wb_mem_data_signext : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable wb_res_data : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    w_mem_valid := '0';\n" +
                        "    w_hold := '0';\n" +
                        "    w_valid := '0';\n" +
                        "\n" +
                        "    w_mem_write := i_memop_store;\n" +
                        "    wb_mem_sz := i_memop_size;\n" +
                        "    wb_mem_addr := i_memop_addr;\n" +
                        "    wb_mem_data := i_res_data;\n" +
                        "\n" +
                        "    case r.state is\n" +
                        "    when State_Idle =>\n" +
                        "        if i_e_valid = '1' then\n" +
                        "            if i_memop_load = '1' or i_memop_store = '1' then\n" +
                        "                w_mem_valid := '1';\n" +
                        "                if i_mem_req_ready = '1' then\n" +
                        "                    v.state := State_WaitResponse;\n" +
                        "                else\n" +
                        "                    w_hold := '1';\n" +
                        "                    v.state := State_WaitReqAccept;\n" +
                        "                end if;\n" +
                        "            else\n" +
                        "                v.state := State_RegForward;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    when State_WaitReqAccept =>\n" +
                        "        w_mem_valid := '1';\n" +
                        "        w_mem_write := not r.memop_r;\n" +
                        "        wb_mem_sz := r.memop_size;\n" +
                        "        wb_mem_addr := r.memop_addr;\n" +
                        "        wb_mem_data := r.res_data;\n" +
                        "        w_hold := '1';\n" +
                        "        if i_mem_req_ready = '1' then\n" +
                        "            v.state := State_WaitResponse;\n" +
                        "        end if;\n" +
                        "    when State_WaitResponse =>\n" +
                        "        w_valid := '1';\n" +
                        "        if i_mem_data_valid = '0' then\n" +
                        "            w_valid := '0';\n" +
                        "            w_hold := '1';\n" +
                        "        elsif i_e_valid = '1' then\n" +
                        "            if i_memop_load = '1' or i_memop_store = '1' then\n" +
                        "                w_mem_valid := '1';\n" +
                        "                if i_mem_req_ready = '1' then\n" +
                        "                    v.state := State_WaitResponse;\n" +
                        "                else\n" +
                        "                    w_hold := '1';\n" +
                        "                    v.state := State_WaitReqAccept;\n" +
                        "                end if;\n" +
                        "            else\n" +
                        "                v.state := State_RegForward;\n" +
                        "            end if;\n" +
                        "        else\n" +
                        "            v.state := State_Idle;\n" +
                        "        end if;\n" +
                        "    when State_RegForward =>\n" +
                        "        w_valid := '1';\n" +
                        "        if i_e_valid = '1' then\n" +
                        "            if i_memop_load = '1' or i_memop_store = '1' then\n" +
                        "                w_mem_valid := '1';\n" +
                        "                if i_mem_req_ready = '1' then\n" +
                        "                    v.state := State_WaitResponse;\n" +
                        "                else\n" +
                        "                    w_hold := '1';\n" +
                        "                    v.state := State_WaitReqAccept;\n" +
                        "                end if;\n" +
                        "            else\n" +
                        "                v.state := State_RegForward;\n" +
                        "            end if;\n" +
                        "        else\n" +
                        "            v.state := State_Idle;\n" +
                        "        end if;\n" +
                        "    when others =>\n" +
                        "    end case;\n" +
                        "\n" +
                        "    if i_e_valid = '1' then\n" +
                        "        v.memop_r := i_memop_load;\n" +
                        "        v.memop_rw := i_memop_load or i_memop_store;\n" +
                        "        v.memop_addr := i_memop_addr;\n" +
                        "        v.memop_sign_ext := i_memop_sign_ext;\n" +
                        "        v.memop_size := i_memop_size;\n" +
                        "        v.pc := i_e_pc;\n" +
                        "        v.instr := i_e_instr;\n" +
                        "        v.res_addr := i_res_addr;\n" +
                        "        v.res_data := i_res_data;\n" +
                        "        if i_res_addr = \"000000\" then\n" +
                        "            v.wena := '0';\n" +
                        "        else\n" +
                        "            v.wena := '1';\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "    \n" +
                        "    case r.memop_size is\n" +
                        "    when MEMOP_1B =>\n" +
                        "        wb_mem_data_signext := i_mem_data;\n" +
                        "        if i_mem_data(7) = '1' then\n" +
                        "            wb_mem_data_signext(63 downto 8) := (others => '1');\n" +
                        "        end if;\n" +
                        "    when MEMOP_2B =>\n" +
                        "        wb_mem_data_signext := i_mem_data;\n" +
                        "        if i_mem_data(15) = '1' then\n" +
                        "            wb_mem_data_signext(63 downto 16) := (others => '1');\n" +
                        "        end if;\n" +
                        "    when MEMOP_4B =>\n" +
                        "        wb_mem_data_signext := i_mem_data;\n" +
                        "        if i_mem_data(31) = '1' then\n" +
                        "            wb_mem_data_signext(63 downto 32) := (others => '1');\n" +
                        "        end if;\n" +
                        "    when others =>\n" +
                        "        wb_mem_data_signext := i_mem_data;\n" +
                        "    end case;\n" +
                        "\n" +
                        "    if r.memop_r = '1' then\n" +
                        "        if r.memop_sign_ext = '1' then\n" +
                        "            wb_res_data := wb_mem_data_signext;\n" +
                        "        else\n" +
                        "            wb_res_data := i_mem_data;\n" +
                        "        end if;\n" +
                        "    else\n" +
                        "        wb_res_data := r.res_data;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    o_mem_resp_ready <= '1';\n" +
                        "\n" +
                        "    o_mem_valid <= w_mem_valid;\n" +
                        "    o_mem_write <= w_mem_write;\n" +
                        "    o_mem_sz <= wb_mem_sz;\n" +
                        "    o_mem_addr <= wb_mem_addr;\n" +
                        "    o_mem_data <= wb_mem_data;\n" +
                        "\n" +
                        "    o_wena <= r.wena and w_valid;\n" +
                        "    o_waddr <= r.res_addr;\n" +
                        "    o_wdata <= wb_res_data;\n" +
                        "    o_hold <= w_hold;\n" +
                        "    o_valid <= w_valid;\n" +
                        "    o_pc <= r.pc;\n" +
                        "    o_instr <= r.instr;\n" +
                        "    \n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(i_clk, i_nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_fetch_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "--library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use work.river_cfg.all;\n" +
                        "\n" +
                        "\n" +
                        "entity InstrFetch is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk  : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_pipeline_hold : in std_logic;\n" +
                        "    i_mem_req_ready : in std_logic;\n" +
                        "    o_mem_addr_valid : out std_logic;\n" +
                        "    o_mem_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_mem_data_valid : in std_logic;\n" +
                        "    i_mem_data_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_mem_data : in std_logic_vector(31 downto 0);\n" +
                        "    i_mem_load_fault : in std_logic;\n" +
                        "    o_mem_resp_ready : out std_logic;\n" +
                        "\n" +
                        "    i_predict_npc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "\n" +
                        "    o_mem_req_fire : out std_logic;                    -- used by branch predictor to form new npc value\n" +
                        "    o_ex_load_fault : out std_logic;\n" +
                        "    o_valid : out std_logic;\n" +
                        "    o_pc : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_instr : out std_logic_vector(31 downto 0);\n" +
                        "    o_hold : out std_logic;                                -- Hold due no response from icache yet\n" +
                        "    i_br_fetch_valid : in std_logic;                       -- Fetch injection address/instr are valid\n" +
                        "    i_br_address_fetch : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0); -- Fetch injection address to skip ebreak instruciton only once\n" +
                        "    i_br_instr_fetch : in std_logic_vector(31 downto 0);   -- Real instruction value that was replaced by ebreak\n" +
                        "    o_instr_buf : out std_logic_vector(DBG_FETCH_TRACE_SIZE*64-1 downto 0)    -- trace last fetched instructions\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_InstrFetch of InstrFetch is\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "      wait_resp : std_logic;\n" +
                        "      pipeline_init : std_logic_vector(4 downto 0);\n" +
                        "      br_address : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      br_instr : std_logic_vector(31 downto 0);\n" +
                        "      instr_buf : std_logic_vector(DBG_FETCH_TRACE_SIZE*64-1 downto 0);\n" +
                        "\n" +
                        "      resp_address : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      resp_data : std_logic_vector(31 downto 0);\n" +
                        "      resp_valid : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "    '0', (others => '0'),\n" +
                        "    (others => '1'),  -- br_address\n" +
                        "    (others =>'0'), (others =>'0'),\n" +
                        "    (others =>'0'), (others =>'0'), '0'\n" +
                        "  );\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  comb : process(i_nrst, i_pipeline_hold, i_mem_req_ready, i_mem_data_valid,\n" +
                        "                i_mem_data_addr, i_mem_data, i_mem_load_fault, i_predict_npc, \n" +
                        "                i_br_fetch_valid, i_br_address_fetch, i_br_instr_fetch, r)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable w_o_req_valid : std_logic;\n" +
                        "    variable w_o_req_fire : std_logic;\n" +
                        "    variable w_o_hold : std_logic;\n" +
                        "    variable wb_o_pc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable wb_o_instr : std_logic_vector(31 downto 0);\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    w_o_req_valid := i_nrst and not i_pipeline_hold\n" +
                        "        and not (r.wait_resp and not i_mem_data_valid);\n" +
                        "    w_o_req_fire := i_mem_req_ready and w_o_req_valid;\n" +
                        "\n" +
                        "    w_o_hold := not (r.wait_resp and i_mem_data_valid);\n" +
                        "\n" +
                        "    if w_o_req_fire = '1' then\n" +
                        "        v.wait_resp := '1';\n" +
                        "    elsif i_mem_data_valid = '1' and i_pipeline_hold = '0' then\n" +
                        "        v.wait_resp := '0';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if i_mem_data_valid = '1' and r.wait_resp = '1' and i_pipeline_hold = '0' then\n" +
                        "        v.resp_valid := '1';\n" +
                        "        v.resp_address := i_mem_data_addr;\n" +
                        "        v.resp_data := i_mem_data;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    wb_o_pc := r.resp_address;\n" +
                        "    wb_o_instr := r.resp_data;\n" +
                        "\n" +
                        "\n" +
                        "    if i_br_fetch_valid = '1' then\n" +
                        "        v.br_address := i_br_address_fetch;\n" +
                        "        v.br_instr := i_br_instr_fetch;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Breakpoint skip logic that allows to continue execution\n" +
                        "    -- without actual breakpoint remove only once \n" +
                        "    if wb_o_pc = r.br_address then\n" +
                        "        wb_o_instr := r.br_instr;\n" +
                        "        if i_mem_data_valid = '1' and r.wait_resp = '1' and i_pipeline_hold = '0' then\n" +
                        "            v.br_address := (others => '1');\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    \n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    o_mem_addr_valid <= w_o_req_valid;\n" +
                        "    o_mem_addr <= i_predict_npc;\n" +
                        "    o_mem_req_fire <= w_o_req_fire;\n" +
                        "    o_ex_load_fault <= '0';    -- TODO\n" +
                        "    o_valid <= r.resp_valid and not (i_pipeline_hold or w_o_hold);\n" +
                        "    o_pc <= wb_o_pc;\n" +
                        "    o_instr <= wb_o_instr;\n" +
                        "    o_mem_resp_ready <= r.wait_resp and not i_pipeline_hold;\n" +
                        "    o_hold <= w_o_hold;\n" +
                        "    o_instr_buf <= r.instr_buf;\n" +
                        "    \n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(i_clk, i_nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_execute_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use IEEE.std_logic_arith.all;  -- UNSIGNED function\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "--library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use work.river_cfg.all;\n" +
                        "\n" +
                        "library work;\n" +
                        "--! Target dependable configuration: RTL, FPGA or ASIC.\n" +
                        "use work.config_target.all;\n" +
                        "\n" +
                        "entity InstrExecute is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk  : in std_logic;\n" +
                        "    i_nrst : in std_logic;                                      -- Reset active LOW\n" +
                        "    i_pipeline_hold : in std_logic;                             -- Hold execution by any reason\n" +
                        "    i_d_valid : in std_logic;                                   -- Decoded instruction is valid\n" +
                        "    i_d_pc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);    -- Instruction pointer on decoded instruction\n" +
                        "    i_d_instr : in std_logic_vector(31 downto 0);               -- Decoded instruction value\n" +
                        "    i_wb_ready : in std_logic;                                  -- End of write back operation\n" +
                        "    i_memop_store : in std_logic;                               -- Store to memory operation\n" +
                        "    i_memop_load : in std_logic;                                -- Load from memoru operation\n" +
                        "    i_memop_sign_ext : in std_logic;                            -- Load memory value with sign extending\n" +
                        "    i_memop_size : in std_logic_vector(1 downto 0);             -- Memory transaction size\n" +
                        "    i_unsigned_op : in std_logic;                               -- Unsigned operands\n" +
                        "    i_rv32 : in std_logic;                                      -- 32-bits instruction\n" +
                        "    i_compressed : in std_logic;                                -- C-extension (2-bytes length)\n" +
                        "    i_f64 : in std_logic;                                       -- D-extension (FPU)\n" +
                        "    i_isa_type : in std_logic_vector(ISA_Total-1 downto 0);     -- Type of the instruction's structure (ISA spec.)\n" +
                        "    i_ivec : in std_logic_vector(Instr_Total-1 downto 0);       -- One pulse per supported instruction.\n" +
                        "    i_unsup_exception : in std_logic;                           -- Unsupported instruction exception\n" +
                        "    i_dport_npc_write : in std_logic;                           -- Write npc value from debug port\n" +
                        "    i_dport_npc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);-- Debug port npc value to write\n" +
                        "\n" +
                        "    o_radr1 : out std_logic_vector(5 downto 0);                 -- Integer/float register index 1\n" +
                        "    i_rdata1 : in std_logic_vector(RISCV_ARCH-1 downto 0);      -- Integer register value 1\n" +
                        "    o_radr2 : out std_logic_vector(5 downto 0);                 -- Integer/float register index 2\n" +
                        "    i_rdata2 : in std_logic_vector(RISCV_ARCH-1 downto 0);      -- Integer register value 2\n" +
                        "    i_rfdata1 : in std_logic_vector(RISCV_ARCH-1 downto 0);     -- Float register value 1\n" +
                        "    i_rfdata2 : in std_logic_vector(RISCV_ARCH-1 downto 0);     -- Float register value 2\n" +
                        "    o_res_addr : out std_logic_vector(5 downto 0);              -- Address to store result of the instruction (0=do not store)\n" +
                        "    o_res_data : out std_logic_vector(RISCV_ARCH-1 downto 0);   -- Value to store\n" +
                        "    o_pipeline_hold : out std_logic;                            -- Hold pipeline while 'writeback' not done or multi-clock instruction.\n" +
                        "    o_csr_addr : out std_logic_vector(11 downto 0);             -- CSR address. 0 if not a CSR instruction with xret signals mode switching\n" +
                        "    o_csr_wena : out std_logic;                                 -- Write new CSR value\n" +
                        "    i_csr_rdata : in std_logic_vector(RISCV_ARCH-1 downto 0);   -- CSR current value\n" +
                        "    o_csr_wdata : out std_logic_vector(RISCV_ARCH-1 downto 0);  -- CSR new value\n" +
                        "    i_trap_valid : in std_logic;\n" +
                        "    i_trap_pc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    -- exceptions:\n" +
                        "    o_ex_npc : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_ex_illegal_instr : out std_logic;\n" +
                        "    o_ex_unalign_store : out std_logic;\n" +
                        "    o_ex_unalign_load : out std_logic;\n" +
                        "    o_ex_breakpoint : out std_logic;\n" +
                        "    o_ex_ecall : out std_logic;\n" +
                        "    o_ex_fpu_invalidop : out std_logic;            -- FPU Exception: invalid operation\n" +
                        "    o_ex_fpu_divbyzero : out std_logic;            -- FPU Exception: divide by zero\n" +
                        "    o_ex_fpu_overflow : out std_logic;             -- FPU Exception: overflow\n" +
                        "    o_ex_fpu_underflow : out std_logic;            -- FPU Exception: underflow\n" +
                        "    o_ex_fpu_inexact : out std_logic;              -- FPU Exception: inexact\n" +
                        "    o_fpu_valid : out std_logic;                   -- FPU output is valid\n" +
                        "\n" +
                        "    o_memop_sign_ext : out std_logic;                           -- Load data with sign extending\n" +
                        "    o_memop_load : out std_logic;                               -- Load data instruction\n" +
                        "    o_memop_store : out std_logic;                              -- Store data instruction\n" +
                        "    o_memop_size : out std_logic_vector(1 downto 0);            -- 0=1bytes; 1=2bytes; 2=4bytes; 3=8bytes\n" +
                        "    o_memop_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);-- Memory access address\n" +
                        "\n" +
                        "    o_trap_ready : out std_logic;                               -- Trap branch request was accepted\n" +
                        "    o_valid : out std_logic;                                    -- Output is valid\n" +
                        "    o_pc : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);     -- Valid instruction pointer\n" +
                        "    o_npc : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);    -- Next instruction pointer. Next decoded pc must match to this value or will be ignored.\n" +
                        "    o_instr : out std_logic_vector(31 downto 0);                -- Valid instruction value\n" +
                        "    o_call : out std_logic;                                     -- CALL pseudo instruction detected\n" +
                        "    o_ret : out std_logic;                                      -- RET pseudoinstruction detected\n" +
                        "    o_mret : out std_logic;                                     -- MRET instruction\n" +
                        "    o_uret : out std_logic                                      -- URET instruction\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_InstrExecute of InstrExecute is\n" +
                        "\n" +
                        "  constant Multi_MUL : integer := 0;\n" +
                        "  constant Multi_DIV : integer := 1;\n" +
                        "  constant Multi_FPU : integer := 2;\n" +
                        "  constant Multi_Total : integer := 3;\n" +
                        "\n" +
                        "  constant State_WaitInstr : std_logic_vector(2 downto 0) := \"000\";\n" +
                        "  constant State_SingleCycle : std_logic_vector(2 downto 0) := \"001\";\n" +
                        "  constant State_MultiCycle : std_logic_vector(2 downto 0) := \"010\";\n" +
                        "  constant State_Hold : std_logic_vector(2 downto 0) := \"011\";\n" +
                        "  constant State_Hazard : std_logic_vector(2 downto 0) := \"100\";\n" +
                        "\n" +
                        "  constant zero64 : std_logic_vector(63 downto 0) := (others => '0');\n" +
                        "\n" +
                        "  type multi_arith_type is array (0 to Multi_Total-1) \n" +
                        "      of std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "        state : std_logic_vector(2 downto 0);\n" +
                        "        d_valid : std_logic;                                   -- Valid decoded instruction latch\n" +
                        "        pc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "        npc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "        instr : std_logic_vector(31 downto 0);\n" +
                        "        res_addr : std_logic_vector(5 downto 0);\n" +
                        "        res_val : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "        memop_load : std_logic;\n" +
                        "        memop_store : std_logic;\n" +
                        "        memop_sign_ext : std_logic;\n" +
                        "        memop_size : std_logic_vector(1 downto 0);\n" +
                        "        memop_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "\n" +
                        "        multi_res_addr : std_logic_vector(5 downto 0);         -- latched output reg. address while multi-cycle instruction\n" +
                        "        multi_pc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);-- latched pc-value while multi-cycle instruction\n" +
                        "        multi_npc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);-- latched npc-value while multi-cycle instruction\n" +
                        "        multi_instr : std_logic_vector(31 downto 0);           -- Multi-cycle instruction is under processing\n" +
                        "        multi_ena : std_logic_vector(Multi_Total-1 downto 0);  -- Enable pulse for Operation that takes more than 1 clock\n" +
                        "        multi_rv32 : std_logic;                                -- Long operation with 32-bits operands\n" +
                        "        multi_f64 : std_logic;                                 -- Long float operation\n" +
                        "        multi_unsigned : std_logic;                            -- Long operation with unsiged operands\n" +
                        "        multi_residual_high : std_logic;                       -- Flag for Divider module: 0=divsion output; 1=residual output\n" +
                        "                                                               -- Flag for multiplier: 0=usual; 1=get high bits\n" +
                        "        multiclock_ena : std_logic;\n" +
                        "        multi_ivec_fpu : std_logic_vector(Instr_FPU_Total-1 downto 0);\n" +
                        "        multi_a1 : std_logic_vector(RISCV_ARCH-1 downto 0);    -- Multi-cycle operand 1\n" +
                        "        multi_a2 : std_logic_vector(RISCV_ARCH-1 downto 0);    -- Multi-cycle operand 2\n" +
                        "\n" +
                        "        hazard_addr0 : std_logic_vector(5 downto 0);           -- Updated register address on previous step\n" +
                        "        hazard_depth : std_logic_vector(1 downto 0);           -- Number of modificated registers that wasn't done yet\n" +
                        "        hold_valid : std_logic;\n" +
                        "        hold_multi_ena : std_logic;\n" +
                        "\n" +
                        "        call : std_logic;\n" +
                        "        ret : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "    State_WaitInstr,                                   -- state\n" +
                        "    '0', (others => '0'), CFG_NMI_RESET_VECTOR,        -- d_valid, pc, npc\n" +
                        "    (others => '0'), (others => '0'), (others => '0'), -- instr, res_addr, res_val\n" +
                        "    '0', '0', '0', \"00\", (others => '0'),              -- memop_load, memop_store, memop_sign_ext, memop_size, memop_addr\n" +
                        "    (others => '0'), (others => '0'), (others => '0'), -- multi_res_addr, multi_pc, multi_npc\n" +
                        "    (others => '0'), (others => '0'), '0',             -- multi_instr, multi_ena, multi_rv32\n" +
                        "    '0', '0',  '0',                                    -- multi_f64, multi_unsigned, multi_residual_high\n" +
                        "    '0', (others => '0'),                              -- multiclock_ena, multi_ivec_fpu\n" +
                        "    (others => '0'), (others => '0'),                  -- multi_a1, multi_a2\n" +
                        "    (others => '0'), (others => '0'),                  -- hazard_add0, hazard_depth\n" +
                        "    '0', '0',                                          -- hold_valid, hold_multi_ena\n" +
                        "    '0', '0'                                           -- call, ret\n" +
                        "  );\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "\n" +
                        "  signal wb_arith_res : multi_arith_type;\n" +
                        "  signal w_arith_valid : std_logic_vector(Multi_Total-1 downto 0);\n" +
                        "  signal w_arith_busy : std_logic_vector(Multi_Total-1 downto 0);\n" +
                        "\n" +
                        "  signal wb_shifter_a1 : std_logic_vector(RISCV_ARCH-1 downto 0);  -- Shifters operand 1\n" +
                        "  signal wb_shifter_a2 : std_logic_vector(5 downto 0);             -- Shifters operand 2\n" +
                        "  signal wb_sll : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "  signal wb_sllw : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "  signal wb_srl : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "  signal wb_srlw : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "  signal wb_sra : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "  signal wb_sraw : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "\n" +
                        "  component IntMulCycloneV is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk  : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_ena : in std_logic;\n" +
                        "    i_unsigned : in std_logic;\n" +
                        "    i_high : in std_logic;\n" +
                        "    i_rv32 : in std_logic;\n" +
                        "    i_a1 : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    i_a2 : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_res : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_valid : out std_logic;\n" +
                        "    o_busy : out std_logic\n" +
                        "  );\n" +
                        "  end component; \n" +
                        "\n" +
                        "  --component IntDivCyclonev is generic (\n" +
                        "  component IntDiv is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk  : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_ena : in std_logic;\n" +
                        "    i_unsigned : in std_logic;\n" +
                        "    i_rv32 : in std_logic;\n" +
                        "    i_residual : in std_logic;\n" +
                        "    i_a1 : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    i_a2 : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_res : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_valid : out std_logic;\n" +
                        "    o_busy : out std_logic\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "  \n" +
                        "  component Shifter is port (\n" +
                        "    i_a1 : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    i_a2 : in std_logic_vector(5 downto 0);\n" +
                        "    o_sll : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_sllw : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_srl : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_sra : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_srlw : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_sraw : out std_logic_vector(RISCV_ARCH-1 downto 0)\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "  component FpuTop is \n" +
                        "  generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_nrst         : in std_logic;\n" +
                        "    i_clk          : in std_logic;\n" +
                        "    i_ena          : in std_logic;\n" +
                        "    i_ivec         : in std_logic_vector(Instr_FPU_Total-1 downto 0);\n" +
                        "    i_a            : in std_logic_vector(63 downto 0);\n" +
                        "    i_b            : in std_logic_vector(63 downto 0);\n" +
                        "    o_res          : out std_logic_vector(63 downto 0);\n" +
                        "    o_ex_invalidop : out std_logic;   -- Exception: invalid operation\n" +
                        "    o_ex_divbyzero : out std_logic;   -- Exception: divide by zero\n" +
                        "    o_ex_overflow  : out std_logic;   -- Exception: overflow\n" +
                        "    o_ex_underflow : out std_logic;   -- Exception: underflow\n" +
                        "    o_ex_inexact   : out std_logic;   -- Exception: inexact\n" +
                        "    o_valid        : out std_logic;\n" +
                        "    o_busy         : out std_logic\n" +
                        "  );\n" +
                        "  end component; \n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "	mul_ena : if CFG_MUL_ENABLE generate\n" +
                        "      mul0 : IntMulCycloneV generic map (\n" +
                        "			async_reset => async_reset\n" +
                        "		) port map (\n" +
                        "			i_clk  => i_clk,\n" +
                        "			i_nrst => i_nrst,\n" +
                        "			i_ena => r.multi_ena(Multi_MUL),\n" +
                        "			i_unsigned => r.multi_unsigned,\n" +
                        "			i_high => r.multi_residual_high,\n" +
                        "			i_rv32 => r.multi_rv32,\n" +
                        "			i_a1 => r.multi_a1,\n" +
                        "			i_a2 => r.multi_a2,\n" +
                        "			o_res => wb_arith_res(Multi_MUL),\n" +
                        "			o_valid => w_arith_valid(Multi_MUL),\n" +
                        "			o_busy => w_arith_busy(Multi_MUL)\n" +
                        "		);\n" +
                        "  end generate;\n" +
                        "\n" +
                        "  mul_dis : if not CFG_MUL_ENABLE generate\n" +
                        "      wb_arith_res(Multi_MUL)		<= (others => '0');\n" +
                        "		w_arith_valid(Multi_MUL)	<= '0';\n" +
                        "		w_arith_busy(Multi_MUL)		<= '0';\n" +
                        "  end generate;\n" +
                        "  \n" +
                        "  div_ena : if CFG_DIV_ENABLE generate\n" +
                        "      --div0 : IntDivCyclonev generic map (\n" +
                        "		div0 : IntDiv generic map (\n" +
                        "			async_reset => async_reset\n" +
                        "		) port map (\n" +
                        "			i_clk  => i_clk,\n" +
                        "			i_nrst => i_nrst,\n" +
                        "			i_ena => r.multi_ena(Multi_DIV),\n" +
                        "			i_unsigned => r.multi_unsigned,\n" +
                        "			i_residual => r.multi_residual_high,\n" +
                        "			i_rv32 => r.multi_rv32,\n" +
                        "			i_a1 => r.multi_a1,\n" +
                        "			i_a2 => r.multi_a2,\n" +
                        "			o_res => wb_arith_res(Multi_DIV),\n" +
                        "			o_valid => w_arith_valid(Multi_DIV),\n" +
                        "			o_busy => w_arith_busy(Multi_DIV)\n" +
                        "		);\n" +
                        "  end generate;\n" +
                        "\n" +
                        "  div_dis : if not CFG_DIV_ENABLE generate\n" +
                        "      wb_arith_res(Multi_DIV)		<= (others => '0');\n" +
                        "		w_arith_valid(Multi_DIV)	<= '0';\n" +
                        "		w_arith_busy(Multi_DIV)		<= '0';\n" +
                        "  end generate;\n" +
                        "      \n" +
                        "  sh0 : Shifter port map (\n" +
                        "      i_a1 => wb_shifter_a1,\n" +
                        "      i_a2 => wb_shifter_a2,\n" +
                        "      o_sll => wb_sll,\n" +
                        "      o_sllw => wb_sllw,\n" +
                        "      o_srl => wb_srl,\n" +
                        "      o_sra => wb_sra,\n" +
                        "      o_srlw => wb_srlw,\n" +
                        "      o_sraw => wb_sraw);\n" +
                        "\n" +
                        "  fpuena : if CFG_HW_FPU_ENABLE generate\n" +
                        "     fpu0 : FpuTop generic map (\n" +
                        "        async_reset => async_reset\n" +
                        "     ) port map (\n" +
                        "        i_clk => i_clk,\n" +
                        "        i_nrst => i_nrst,\n" +
                        "        i_ena => r.multi_ena(Multi_FPU),\n" +
                        "        i_ivec => r.multi_ivec_fpu,\n" +
                        "        i_a => r.multi_a1,\n" +
                        "        i_b => r.multi_a2,\n" +
                        "        o_res => wb_arith_res(Multi_FPU),\n" +
                        "        o_ex_invalidop => o_ex_fpu_invalidop,\n" +
                        "        o_ex_divbyzero => o_ex_fpu_divbyzero,\n" +
                        "        o_ex_overflow => o_ex_fpu_overflow,\n" +
                        "        o_ex_underflow => o_ex_fpu_underflow,\n" +
                        "        o_ex_inexact => o_ex_fpu_inexact,\n" +
                        "        o_valid => w_arith_valid(Multi_FPU),\n" +
                        "        o_busy => w_arith_busy(Multi_FPU)\n" +
                        "     );\n" +
                        "  end generate;\n" +
                        "\n" +
                        "  fpudis : if not CFG_HW_FPU_ENABLE generate\n" +
                        "        wb_arith_res(Multi_FPU) <= (others => '0');\n" +
                        "        w_arith_valid(Multi_FPU) <= '0';\n" +
                        "        w_arith_busy(Multi_FPU) <= '0';\n" +
                        "        o_fpu_valid <= '0';\n" +
                        "        o_ex_fpu_invalidop <= '0';\n" +
                        "        o_ex_fpu_divbyzero <= '0';\n" +
                        "        o_ex_fpu_overflow <= '0';\n" +
                        "        o_ex_fpu_underflow <= '0';\n" +
                        "        o_ex_fpu_inexact <= '0';\n" +
                        "  end generate;\n" +
                        "\n" +
                        "  comb : process(i_nrst, i_pipeline_hold, i_d_valid, i_d_pc, i_d_instr,\n" +
                        "                 i_wb_ready, i_memop_load, i_memop_store, i_memop_sign_ext,\n" +
                        "                 i_memop_size, i_unsigned_op, i_rv32, i_compressed, i_f64, i_isa_type, i_ivec,\n" +
                        "                 i_rdata1, i_rdata2, i_rfdata1, i_rfdata2, i_csr_rdata, \n" +
                        "                 i_trap_valid, i_trap_pc, i_dport_npc_write,\n" +
                        "                 i_dport_npc, i_unsup_exception,\n" +
                        "                 wb_arith_res, w_arith_valid, w_arith_busy,\n" +
                        "                 wb_sll, wb_sllw, wb_srl, wb_srlw, wb_sra, wb_sraw, r)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable w_exception_store : std_logic;\n" +
                        "    variable w_exception_load : std_logic;\n" +
                        "    variable wb_radr1 : std_logic_vector(5 downto 0);      -- [5] 0=Integer bank; 1=FPU bank\n" +
                        "    variable wb_rdata1 : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable wb_radr2 : std_logic_vector(5 downto 0);\n" +
                        "    variable wb_rdata2 : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable w_mret : std_logic;\n" +
                        "    variable w_uret : std_logic;\n" +
                        "    variable w_csr_wena : std_logic;\n" +
                        "    variable wb_res_addr : std_logic_vector(5 downto 0);\n" +
                        "    variable wb_csr_addr  : std_logic_vector(11 downto 0);\n" +
                        "    variable wb_csr_wdata : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable wb_res : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable wb_npc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable wb_ex_npc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable wb_off : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable wb_mask_i31 : std_logic_vector(RISCV_ARCH-1 downto 0);    -- Bits depending instr[31] bits\n" +
                        "    variable wb_sum64 : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable wb_sum32 : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable wb_sub64 : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable wb_sub32 : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable wb_and64 : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable wb_or64 : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable wb_xor64 : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable w_memop_load : std_logic;\n" +
                        "    variable w_memop_store : std_logic;\n" +
                        "    variable w_memop_sign_ext : std_logic;\n" +
                        "    variable wb_memop_size : std_logic_vector(1 downto 0);\n" +
                        "    variable wb_memop_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "\n" +
                        "    variable w_valid : std_logic;\n" +
                        "    variable w_pc_valid : std_logic;\n" +
                        "    variable w_next_ready : std_logic;\n" +
                        "    variable w_hold : std_logic;\n" +
                        "    variable w_multi_valid : std_logic;\n" +
                        "    variable w_multi_ena : std_logic;\n" +
                        "    variable w_fpu_ena : std_logic;\n" +
                        "    variable w_res_wena : std_logic;\n" +
                        "    variable w_pc_branch : std_logic;\n" +
                        "    variable w_hazard_lvl1 : std_logic;\n" +
                        "    variable w_hazard_lvl2 : std_logic;\n" +
                        "    variable w_less : std_logic;\n" +
                        "    variable w_gr_equal : std_logic;\n" +
                        "    variable wv : std_logic_vector(Instr_Total-1 downto 0);\n" +
                        "    variable opcode_len : integer;\n" +
                        "\n" +
                        "  begin\n" +
                        "\n" +
                        "    wb_radr1 := (others => '0');\n" +
                        "    wb_radr2 := (others => '0');\n" +
                        "    w_mret := '0';\n" +
                        "    w_uret := '0';\n" +
                        "    w_csr_wena := '0';\n" +
                        "    wb_res_addr := (others => '0');\n" +
                        "    wb_csr_addr := (others => '0');\n" +
                        "    wb_csr_wdata := (others => '0');\n" +
                        "    wb_res := (others => '0');\n" +
                        "    wb_off := (others => '0');\n" +
                        "    wb_rdata1 := (others => '0');\n" +
                        "    wb_rdata2 := (others => '0');\n" +
                        "    w_memop_load := '0';\n" +
                        "    w_memop_store := '0';\n" +
                        "    w_memop_sign_ext := '0';\n" +
                        "    wb_memop_size := (others => '0');\n" +
                        "    wb_memop_addr := (others => '0');\n" +
                        "    wv := i_ivec;\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    wb_mask_i31 := (others => i_d_instr(31));\n" +
                        "\n" +
                        "    w_pc_valid := '0';\n" +
                        "    if i_d_pc = r.npc then\n" +
                        "        w_pc_valid := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if i_isa_type(ISA_R_type) = '1' then\n" +
                        "        wb_radr1 := ('0' & i_d_instr(19 downto 15));\n" +
                        "        wb_rdata1 := i_rdata1;\n" +
                        "        wb_radr2 := ('0' & i_d_instr(24 downto 20));\n" +
                        "        wb_rdata2 := i_rdata2;\n" +
                        "        if CFG_HW_FPU_ENABLE and i_f64 = '1' then\n" +
                        "            if (wv(Instr_FMOV_D_X) or\n" +
                        "                wv(Instr_FCVT_D_L) or wv(Instr_FCVT_D_LU) or\n" +
                        "                wv(Instr_FCVT_D_W) or wv(Instr_FCVT_D_WU)) = '0' then\n" +
                        "                wb_radr1 := ('1' & i_d_instr(19 downto 15));\n" +
                        "                wb_rdata1 := i_rfdata1;\n" +
                        "            end if;\n" +
                        "            if wv(Instr_FMOV_X_D) = '0' then\n" +
                        "                wb_radr2 := ('1' & i_d_instr(24 downto 20));\n" +
                        "                wb_rdata2 := i_rfdata2;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    elsif i_isa_type(ISA_I_type) = '1' then\n" +
                        "        wb_radr1 := ('0' & i_d_instr(19 downto 15));\n" +
                        "        wb_rdata1 := i_rdata1;\n" +
                        "        wb_radr2 := (others => '0');\n" +
                        "        wb_rdata2 := wb_mask_i31(63 downto 12) & i_d_instr(31 downto 20);\n" +
                        "    elsif i_isa_type(ISA_SB_type) = '1' then\n" +
                        "        wb_radr1 := ('0' & i_d_instr(19 downto 15));\n" +
                        "        wb_rdata1 := i_rdata1;\n" +
                        "        wb_radr2 := ('0' & i_d_instr(24 downto 20));\n" +
                        "        wb_rdata2 := i_rdata2;\n" +
                        "        wb_off(RISCV_ARCH-1 downto 12) := wb_mask_i31(RISCV_ARCH-1 downto 12);\n" +
                        "        wb_off(12) := i_d_instr(31);\n" +
                        "        wb_off(11) := i_d_instr(7);\n" +
                        "        wb_off(10 downto 5) := i_d_instr(30 downto 25);\n" +
                        "        wb_off(4 downto 1) := i_d_instr(11 downto 8);\n" +
                        "        wb_off(0) := '0';\n" +
                        "    elsif i_isa_type(ISA_UJ_type) = '1' then\n" +
                        "        wb_radr1 := (others => '0');\n" +
                        "        wb_rdata1 := X\"00000000\" & i_d_pc;\n" +
                        "        wb_radr2 := (others => '0');\n" +
                        "        wb_off(RISCV_ARCH-1 downto 20) := wb_mask_i31(RISCV_ARCH-1 downto 20);\n" +
                        "        wb_off(19 downto 12) := i_d_instr(19 downto 12);\n" +
                        "        wb_off(11) := i_d_instr(20);\n" +
                        "        wb_off(10 downto 1) := i_d_instr(30 downto 21);\n" +
                        "        wb_off(0) := '0';\n" +
                        "    elsif i_isa_type(ISA_U_type) = '1'then\n" +
                        "        wb_radr1 := (others => '0');\n" +
                        "        wb_rdata1 := X\"00000000\" & i_d_pc;\n" +
                        "        wb_radr2 := (others => '0');\n" +
                        "        wb_rdata2(31 downto 0) := i_d_instr(31 downto 12) & X\"000\";\n" +
                        "        wb_rdata2(RISCV_ARCH-1 downto 32) := wb_mask_i31(RISCV_ARCH-1 downto 32);\n" +
                        "    elsif i_isa_type(ISA_S_type) = '1' then\n" +
                        "        wb_radr1 := ('0' & i_d_instr(19 downto 15));\n" +
                        "        wb_rdata1 := i_rdata1;\n" +
                        "        wb_radr2 := ('0' & i_d_instr(24 downto 20));\n" +
                        "        wb_rdata2 := i_rdata2;\n" +
                        "        wb_off(RISCV_ARCH-1 downto 12) := wb_mask_i31(RISCV_ARCH-1 downto 12);\n" +
                        "        wb_off(11 downto 5) := i_d_instr(31 downto 25);\n" +
                        "        wb_off(4 downto 0) := i_d_instr(11 downto 7);\n" +
                        "        if CFG_HW_FPU_ENABLE and wv(Instr_FSD) = '1' then\n" +
                        "            wb_radr2 := ('1' & i_d_instr(24 downto 20));\n" +
                        "            wb_rdata2 := i_rfdata2;\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    --! Default number of cycles per instruction = 0 (1 clock per instr)\n" +
                        "    --! If instruction is multicycle then modify this value.\n" +
                        "    --!\n" +
                        "    w_fpu_ena := '0';\n" +
                        "    if CFG_HW_FPU_ENABLE then\n" +
                        "        if i_f64 = '1' and (wv(Instr_FSD) or wv(Instr_FLD)) = '0' then\n" +
                        "            w_fpu_ena := '1';\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_multi_ena := wv(Instr_MUL) or wv(Instr_MULW) or wv(Instr_DIV)\n" +
                        "                    or wv(Instr_DIVU) or wv(Instr_DIVW) or wv(Instr_DIVUW)\n" +
                        "                    or wv(Instr_REM) or wv(Instr_REMU) or wv(Instr_REMW)\n" +
                        "                    or wv(Instr_REMUW) or w_fpu_ena;\n" +
                        "\n" +
                        "    w_multi_valid := w_arith_valid(Multi_MUL) or w_arith_valid(Multi_DIV)\n" +
                        "                   or w_arith_valid(Multi_FPU);\n" +
                        "\n" +
                        "    -- Don't modify registers on conditional jumps:\n" +
                        "    w_res_wena := not (wv(Instr_BEQ) or wv(Instr_BGE) or wv(Instr_BGEU)\n" +
                        "               or wv(Instr_BLT) or wv(Instr_BLTU) or wv(Instr_BNE)\n" +
                        "               or wv(Instr_SD) or wv(Instr_SW) or wv(Instr_SH) or wv(Instr_SB)\n" +
                        "               or wv(Instr_FSD)\n" +
                        "               or wv(Instr_MRET) or wv(Instr_URET)\n" +
                        "               or wv(Instr_ECALL) or wv(Instr_EBREAK));\n" +
                        "\n" +
                        "    if w_multi_valid = '1' then\n" +
                        "        wb_res_addr := r.multi_res_addr;\n" +
                        "        v.multiclock_ena := '0';\n" +
                        "    elsif w_res_wena = '1' then\n" +
                        "        wb_res_addr := ('0' & i_d_instr(11 downto 7));\n" +
                        "        if CFG_HW_FPU_ENABLE then\n" +
                        "            if i_f64 = '1' and wv(Instr_FLD) = '1' then\n" +
                        "                wb_res_addr(5) := '1';\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    else\n" +
                        "        wb_res_addr := (others => '0');\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    w_next_ready := '0';\n" +
                        "    w_hold := '0';\n" +
                        "\n" +
                        "    if i_d_valid = '1' and w_pc_valid = '1' then\n" +
                        "        w_next_ready := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    --! Valid values on the inputs radr1,radr2 will be 2 cycles after\n" +
                        "    --! signal o_valid = 1\n" +
                        "    --!\n" +
                        "    w_hazard_lvl1 := '0';\n" +
                        "    if r.res_addr /= \"000000\" and\n" +
                        "        (wb_radr1 = r.res_addr or wb_radr2 = r.res_addr) then\n" +
                        "        w_hazard_lvl1 := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_hazard_lvl2 := '0';\n" +
                        "    if r.hazard_addr0 /= \"000000\" and\n" +
                        "        (wb_radr1 = r.hazard_addr0 or wb_radr2 = r.hazard_addr0) then\n" +
                        "        w_hazard_lvl2 := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_valid := '0';\n" +
                        "    case r.state is\n" +
                        "    when State_WaitInstr =>\n" +
                        "        if r.hazard_depth /= \"00\" and w_hazard_lvl2 = '1' then\n" +
                        "            -- Hazard after missed predicted instruction 1 cycle\n" +
                        "            w_hold := '1';\n" +
                        "            w_next_ready := '0';\n" +
                        "        elsif i_pipeline_hold = '1' then\n" +
                        "            v.state := State_Hold;\n" +
                        "            v.hold_valid := w_next_ready;\n" +
                        "            v.hold_multi_ena := w_multi_ena;\n" +
                        "        elsif w_next_ready = '1' then\n" +
                        "            if w_multi_ena = '1' then\n" +
                        "                w_hold := '1';\n" +
                        "                v.state := State_MultiCycle;\n" +
                        "            else\n" +
                        "                v.state := State_SingleCycle;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    when State_SingleCycle =>\n" +
                        "        w_valid := '1';\n" +
                        "        if w_hazard_lvl1 = '1' then\n" +
                        "            -- 2-cycles wait state\n" +
                        "            w_hold := '1';\n" +
                        "            w_next_ready := '0';\n" +
                        "            v.state := State_Hazard;\n" +
                        "        elsif w_hazard_lvl2 = '1' then\n" +
                        "            -- 1-cycle wait state\n" +
                        "            w_hold := '1';\n" +
                        "            w_next_ready := '0';\n" +
                        "            v.state := State_WaitInstr;\n" +
                        "        elsif i_pipeline_hold = '1' then\n" +
                        "            v.state := State_Hold;\n" +
                        "            v.hold_valid := w_next_ready;\n" +
                        "            v.hold_multi_ena := w_multi_ena;\n" +
                        "        elsif w_next_ready = '1' then\n" +
                        "            if w_multi_ena = '1' then\n" +
                        "                w_hold := '1';\n" +
                        "                v.state := State_MultiCycle;\n" +
                        "            else\n" +
                        "                v.state := State_SingleCycle;\n" +
                        "            end if;\n" +
                        "        else\n" +
                        "            v.state := State_WaitInstr;\n" +
                        "        end if;\n" +
                        "    when State_MultiCycle =>\n" +
                        "        w_hold := '1';\n" +
                        "        w_next_ready := '0';\n" +
                        "        if w_multi_valid = '1' then\n" +
                        "            v.state := State_SingleCycle;\n" +
                        "        end if;\n" +
                        "    when State_Hold =>\n" +
                        "        --! No need to raise w_hold because it is already hold, but we have\n" +
                        "        --! to use previously latched values of instruction type because outputs\n" +
                        "        --! pc and npc switched for next instruction\n" +
                        "        w_next_ready := '0';\n" +
                        "        if i_pipeline_hold = '0' then\n" +
                        "            if r.hold_valid = '1' then\n" +
                        "                if r.hold_multi_ena = '1' and w_multi_valid = '0' then\n" +
                        "                    v.state := State_MultiCycle;\n" +
                        "                else\n" +
                        "                    v.state := State_SingleCycle;\n" +
                        "                end if;\n" +
                        "            else\n" +
                        "                v.state := State_WaitInstr;\n" +
                        "            end if;\n" +
                        "        elsif r.hold_multi_ena = '1' then\n" +
                        "            --! Track the end of multi-instruction while in Hold state\n" +
                        "            if w_multi_valid = '1' then\n" +
                        "                v.hold_multi_ena := '0';\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    when State_Hazard =>\n" +
                        "        w_next_ready := '0';\n" +
                        "        w_hold := '1';\n" +
                        "        if i_wb_ready = '1' then\n" +
                        "            v.state := State_WaitInstr;\n" +
                        "        end if;\n" +
                        "    when others =>\n" +
                        "    end case;\n" +
                        "\n" +
                        "    if w_valid = '1' then\n" +
                        "        v.hazard_addr0 := r.res_addr;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if w_valid = '1' and i_wb_ready = '0' then\n" +
                        "        v.hazard_depth := r.hazard_depth + 1;\n" +
                        "    elsif w_valid = '0' and i_wb_ready = '1' then\n" +
                        "        v.hazard_depth := r.hazard_depth - 1;\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    -- parallel ALU:\n" +
                        "    wb_sum64 := wb_rdata1 + wb_rdata2;\n" +
                        "    wb_sum32(31 downto 0) := wb_rdata1(31 downto 0) + wb_rdata2(31 downto 0);\n" +
                        "    wb_sum32(63 downto 32) := (others => wb_sum32(31));\n" +
                        "    wb_sub64 := wb_rdata1 - wb_rdata2;\n" +
                        "    wb_sub32(31 downto 0) := wb_rdata1(31 downto 0) - wb_rdata2(31 downto 0);\n" +
                        "    wb_sub32(63 downto 32) := (others => wb_sub32(31));\n" +
                        "    wb_and64 := wb_rdata1 and wb_rdata2;\n" +
                        "    wb_or64 := wb_rdata1 or wb_rdata2;\n" +
                        "    wb_xor64 := wb_rdata1 xor wb_rdata2;\n" +
                        "    \n" +
                        "    wb_shifter_a1 <= wb_rdata1;\n" +
                        "    wb_shifter_a2 <= wb_rdata2(5 downto 0);\n" +
                        "\n" +
                        "    w_less := '0';\n" +
                        "    w_gr_equal := '0';\n" +
                        "    if UNSIGNED(wb_rdata1) < UNSIGNED(wb_rdata2) then\n" +
                        "        w_less := '1';\n" +
                        "    end if;\n" +
                        "    if UNSIGNED(wb_rdata1) >= UNSIGNED(wb_rdata2) then\n" +
                        "        w_gr_equal := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Relative Branch on some condition:\n" +
                        "    w_pc_branch := '0';\n" +
                        "    if ((wv(Instr_BEQ) = '1' and (wb_sub64 = zero64))\n" +
                        "        or (wv(Instr_BGE) = '1' and (wb_sub64(63) = '0'))\n" +
                        "        or (wv(Instr_BGEU) = '1' and (w_gr_equal = '1'))\n" +
                        "        or (wv(Instr_BLT) = '1' and (wb_sub64(63) = '1'))\n" +
                        "        or (wv(Instr_BLTU) = '1' and (w_less = '1'))\n" +
                        "        or (wv(Instr_BNE) = '1' and (wb_sub64 /= zero64))) then\n" +
                        "        w_pc_branch := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    opcode_len := 4;\n" +
                        "    if i_compressed = '1' then\n" +
                        "        opcode_len := 2;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if w_pc_branch = '1' then\n" +
                        "        wb_npc := i_d_pc + wb_off(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    elsif wv(Instr_JAL) = '1' then\n" +
                        "        wb_res(63 downto 32) := (others => '0');\n" +
                        "        wb_res(31 downto 0) := i_d_pc + opcode_len;\n" +
                        "        wb_npc := wb_rdata1(BUS_ADDR_WIDTH-1 downto 0) + wb_off(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    elsif wv(Instr_JALR) = '1' then\n" +
                        "        wb_res(63 downto 32) := (others => '0');\n" +
                        "        wb_res(31 downto 0) := i_d_pc + opcode_len;\n" +
                        "        wb_npc := wb_rdata1(BUS_ADDR_WIDTH-1 downto 0) + wb_rdata2(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "        wb_npc(0) := '0';\n" +
                        "    elsif wv(Instr_MRET) = '1' then\n" +
                        "        wb_res(63 downto 32) := (others => '0');\n" +
                        "        wb_res(31 downto 0) := i_d_pc + opcode_len;\n" +
                        "        w_mret := '1';\n" +
                        "        w_csr_wena := '0';\n" +
                        "        wb_csr_addr := CSR_mepc;\n" +
                        "        wb_npc := i_csr_rdata(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    elsif wv(Instr_URET) = '1' then\n" +
                        "        wb_res(63 downto 32) := (others => '0');\n" +
                        "        wb_res(31 downto 0) := i_d_pc + opcode_len;\n" +
                        "        w_uret := '1';\n" +
                        "        w_csr_wena := '0';\n" +
                        "        wb_csr_addr := CSR_uepc;\n" +
                        "        wb_npc := i_csr_rdata(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    else\n" +
                        "        -- Instr_HRET, Instr_SRET, Instr_FENCE, Instr_FENCE_I:\n" +
                        "        wb_npc := i_d_pc + opcode_len;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if i_memop_load = '1' then\n" +
                        "        wb_memop_addr := wb_rdata1(BUS_ADDR_WIDTH-1 downto 0)\n" +
                        "                      + wb_rdata2(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    elsif i_memop_store = '1' then\n" +
                        "        wb_memop_addr := wb_rdata1(BUS_ADDR_WIDTH-1 downto 0)\n" +
                        "                       + wb_off(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_exception_store := '0';\n" +
                        "    w_exception_load := '0';\n" +
                        "\n" +
                        "    if ((wv(Instr_LD) = '1' and wb_memop_addr(2 downto 0) /= \"000\")\n" +
                        "        or ((wv(Instr_LW) or wv(Instr_LWU)) = '1' and wb_memop_addr(1 downto 0) /= \"00\")\n" +
                        "        or ((wv(Instr_LH) or wv(Instr_LHU)) = '1' and wb_memop_addr(0) /= '0'))  then\n" +
                        "        w_exception_load := '1';\n" +
                        "    end if;\n" +
                        "    if ((wv(Instr_SD) = '1' and wb_memop_addr(2 downto 0) /= \"000\")\n" +
                        "        or (wv(Instr_SW) = '1' and wb_memop_addr(1 downto 0) /= \"00\")\n" +
                        "        or (wv(Instr_SH) = '1' and wb_memop_addr(0) /= '0')) then\n" +
                        "        w_exception_store := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    v.multi_ena := (others => '0');\n" +
                        "    v.multi_rv32 := i_rv32;\n" +
                        "    v.multi_f64 := i_f64;\n" +
                        "    v.multi_unsigned := i_unsigned_op;\n" +
                        "    v.multi_residual_high := '0';\n" +
                        "    if w_fpu_ena = '1' then\n" +
                        "        v.multi_a1 := wb_rdata1;\n" +
                        "        v.multi_a2 := wb_rdata2;\n" +
                        "    else\n" +
                        "        v.multi_a1 := i_rdata1;\n" +
                        "        v.multi_a2 := i_rdata2;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if (w_multi_ena and w_next_ready) = '1' then\n" +
                        "        v.multiclock_ena := '1';\n" +
                        "        v.multi_res_addr := wb_res_addr;\n" +
                        "        if CFG_HW_FPU_ENABLE then\n" +
                        "            v.multi_ivec_fpu := wv(Instr_FSUB_D downto Instr_FADD_D);\n" +
                        "            if w_fpu_ena = '1' and (wv(Instr_FMOV_X_D) or wv(Instr_FEQ_D)\n" +
                        "                or wv(Instr_FLT_D) or wv(Instr_FLE_D)\n" +
                        "                or wv(Instr_FCVT_LU_D) or wv(Instr_FCVT_L_D)\n" +
                        "                or wv(Instr_FCVT_WU_D) or wv(Instr_FCVT_W_D)) = '0' then\n" +
                        "                v.multi_res_addr := '1' & wb_res_addr(4 downto 0);\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "        v.multi_pc := i_d_pc;\n" +
                        "        v.multi_instr := i_d_instr;\n" +
                        "        if i_trap_valid = '1' then\n" +
                        "            v.multi_npc := i_trap_pc;\n" +
                        "        else\n" +
                        "            v.multi_npc := wb_npc;\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    -- ALU block selector:\n" +
                        "    if w_arith_valid(Multi_MUL) = '1' then\n" +
                        "        wb_res := wb_arith_res(Multi_MUL);\n" +
                        "    elsif w_arith_valid(Multi_DIV) = '1' then\n" +
                        "        wb_res := wb_arith_res(Multi_DIV);\n" +
                        "    elsif w_arith_valid(Multi_FPU) = '1' then\n" +
                        "        wb_res := wb_arith_res(Multi_FPU);\n" +
                        "    elsif i_memop_load = '1' then\n" +
                        "        w_memop_load := '1';\n" +
                        "        w_memop_sign_ext := i_memop_sign_ext;\n" +
                        "        wb_memop_size := i_memop_size;\n" +
                        "    elsif i_memop_store = '1' then\n" +
                        "        w_memop_store := '1';\n" +
                        "        wb_memop_size := i_memop_size;\n" +
                        "        wb_res := wb_rdata2;\n" +
                        "    elsif (wv(Instr_ADD) or wv(Instr_ADDI) or wv(Instr_AUIPC)) = '1' then\n" +
                        "        wb_res := wb_sum64;\n" +
                        "    elsif (wv(Instr_ADDW) or wv(Instr_ADDIW)) = '1' then\n" +
                        "        wb_res := wb_sum32;\n" +
                        "    elsif wv(Instr_SUB) = '1' then\n" +
                        "        wb_res := wb_sub64;\n" +
                        "    elsif wv(Instr_SUBW) = '1' then\n" +
                        "        wb_res := wb_sub32;\n" +
                        "    elsif (wv(Instr_SLL) or wv(Instr_SLLI)) = '1' then\n" +
                        "        wb_res := wb_sll;\n" +
                        "    elsif (wv(Instr_SLLW) or wv(Instr_SLLIW)) = '1' then\n" +
                        "        wb_res := wb_sllw;\n" +
                        "    elsif (wv(Instr_SRL) or wv(Instr_SRLI)) = '1' then\n" +
                        "        wb_res := wb_srl;\n" +
                        "    elsif (wv(Instr_SRLW) or wv(Instr_SRLIW)) = '1' then\n" +
                        "        wb_res := wb_srlw;\n" +
                        "    elsif (wv(Instr_SRA) or wv(Instr_SRAI)) = '1' then\n" +
                        "        wb_res := wb_sra;\n" +
                        "    elsif (wv(Instr_SRAW) or wv(Instr_SRAW) or wv(Instr_SRAIW)) = '1' then\n" +
                        "        wb_res := wb_sraw;\n" +
                        "    elsif (wv(Instr_AND) or wv(Instr_ANDI)) = '1' then\n" +
                        "        wb_res := wb_and64;\n" +
                        "    elsif (wv(Instr_OR) or wv(Instr_ORI)) = '1' then\n" +
                        "        wb_res := wb_or64;\n" +
                        "    elsif (wv(Instr_XOR) or wv(Instr_XORI)) = '1' then\n" +
                        "        wb_res := wb_xor64;\n" +
                        "    elsif (wv(Instr_SLT) or wv(Instr_SLTI)) = '1' then\n" +
                        "        wb_res(RISCV_ARCH-1 downto 1) := (others => '0');\n" +
                        "        wb_res(0) := wb_sub64(63);\n" +
                        "    elsif (wv(Instr_SLTU) or wv(Instr_SLTIU)) = '1' then\n" +
                        "        wb_res(63 downto 1) := (others => '0');\n" +
                        "        wb_res(0) := w_less;\n" +
                        "    elsif wv(Instr_LUI) = '1' then\n" +
                        "        wb_res := wb_rdata2;\n" +
                        "    elsif (wv(Instr_MUL) or wv(Instr_MULW)) = '1' then\n" +
                        "        v.multi_ena(Multi_MUL) := w_next_ready;\n" +
                        "    elsif (wv(Instr_DIV) or wv(Instr_DIVU)\n" +
                        "            or wv(Instr_DIVW) or wv(Instr_DIVUW)) = '1' then\n" +
                        "        v.multi_ena(Multi_DIV) := w_next_ready;\n" +
                        "    elsif (wv(Instr_REM) or wv(Instr_REMU)\n" +
                        "            or wv(Instr_REMW) or wv(Instr_REMUW)) = '1' then\n" +
                        "        v.multi_ena(Multi_DIV) := w_next_ready;\n" +
                        "        v.multi_residual_high := '1';\n" +
                        "    elsif w_fpu_ena = '1' then\n" +
                        "        v.multi_ena(Multi_FPU) := w_next_ready;\n" +
                        "    elsif wv(Instr_CSRRC) = '1' then\n" +
                        "        wb_res := i_csr_rdata;\n" +
                        "        w_csr_wena := '1';\n" +
                        "        wb_csr_addr := wb_rdata2(11 downto 0);\n" +
                        "        wb_csr_wdata := i_csr_rdata and (not i_rdata1);\n" +
                        "    elsif wv(Instr_CSRRCI) = '1' then\n" +
                        "        wb_res := i_csr_rdata;\n" +
                        "        w_csr_wena := '1';\n" +
                        "        wb_csr_addr := wb_rdata2(11 downto 0);\n" +
                        "        wb_csr_wdata(RISCV_ARCH-1 downto 5) := i_csr_rdata(RISCV_ARCH-1 downto 5);\n" +
                        "        wb_csr_wdata(4 downto 0) := i_csr_rdata(4 downto 0) and not wb_radr1(4 downto 0);  -- zero-extending 5 to 64-bits\n" +
                        "    elsif wv(Instr_CSRRS) = '1' then\n" +
                        "        wb_res := i_csr_rdata;\n" +
                        "        w_csr_wena := '1';\n" +
                        "        wb_csr_addr := wb_rdata2(11 downto 0);\n" +
                        "        wb_csr_wdata := i_csr_rdata or i_rdata1;\n" +
                        "    elsif wv(Instr_CSRRSI) = '1' then\n" +
                        "        wb_res := i_csr_rdata;\n" +
                        "        w_csr_wena := '1';\n" +
                        "        wb_csr_addr := wb_rdata2(11 downto 0);\n" +
                        "        wb_csr_wdata(RISCV_ARCH-1 downto 5) := i_csr_rdata(RISCV_ARCH-1 downto 5);\n" +
                        "        wb_csr_wdata(4 downto 0) := i_csr_rdata(4 downto 0) or wb_radr1(4 downto 0);  -- zero-extending 5 to 64-bits\n" +
                        "    elsif wv(Instr_CSRRW) = '1' then\n" +
                        "        wb_res := i_csr_rdata;\n" +
                        "        w_csr_wena := '1';\n" +
                        "        wb_csr_addr := wb_rdata2(11 downto 0);\n" +
                        "        wb_csr_wdata := i_rdata1;\n" +
                        "    elsif wv(Instr_CSRRWI) = '1' then\n" +
                        "        wb_res := i_csr_rdata;\n" +
                        "        w_csr_wena := '1';\n" +
                        "        wb_csr_addr := wb_rdata2(11 downto 0);\n" +
                        "        wb_csr_wdata(RISCV_ARCH-1 downto 5) := (others => '0');\n" +
                        "        wb_csr_wdata(4 downto 0) := wb_radr1(4 downto 0);  -- zero-extending 5 to 64-bits\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    o_trap_ready <= w_next_ready;\n" +
                        "\n" +
                        "    o_ex_illegal_instr <= i_unsup_exception and w_next_ready;\n" +
                        "    o_ex_unalign_store <= w_exception_store and w_next_ready;\n" +
                        "    o_ex_unalign_load <= w_exception_load and w_next_ready;\n" +
                        "    o_ex_breakpoint <= wv(Instr_EBREAK) and w_next_ready;\n" +
                        "    o_ex_ecall <= wv(Instr_ECALL) and w_next_ready;\n" +
                        "\n" +
                        "    v.call := '0';\n" +
                        "    v.ret := '0';\n" +
                        "    wb_ex_npc := (others => '0');\n" +
                        "    if i_dport_npc_write = '1' then\n" +
                        "        v.npc := i_dport_npc;\n" +
                        "    elsif w_multi_valid = '1' then\n" +
                        "        -- multi-cycle instruction ending by single-cycle state\n" +
                        "        -- so no need to check jump opcodes\n" +
                        "        v.pc := r.multi_pc;\n" +
                        "        v.instr := r.multi_instr;\n" +
                        "        v.npc := r.multi_npc;\n" +
                        "        v.memop_load := '0';\n" +
                        "        v.memop_sign_ext := '0';\n" +
                        "        v.memop_store := '0';\n" +
                        "        v.memop_size := (others => '0');\n" +
                        "        v.memop_addr := (others => '0');\n" +
                        "\n" +
                        "        v.res_addr := wb_res_addr;\n" +
                        "        v.res_val := wb_res;\n" +
                        "    elsif w_next_ready = '1' then\n" +
                        "        v.pc := i_d_pc;\n" +
                        "        v.instr := i_d_instr;\n" +
                        "        if i_trap_valid = '1' then\n" +
                        "            v.npc := i_trap_pc;\n" +
                        "            wb_ex_npc := wb_npc;\n" +
                        "        else\n" +
                        "            v.npc := wb_npc;\n" +
                        "        end if;\n" +
                        "        v.memop_load := w_memop_load;\n" +
                        "        v.memop_sign_ext := w_memop_sign_ext;\n" +
                        "        v.memop_store := w_memop_store;\n" +
                        "        v.memop_size := wb_memop_size;\n" +
                        "        v.memop_addr := wb_memop_addr;\n" +
                        "\n" +
                        "        v.res_addr := wb_res_addr;\n" +
                        "        v.res_val := wb_res;\n" +
                        "\n" +
                        "        if wv(Instr_JAL) = '1' and conv_integer(wb_res_addr) = Reg_ra then\n" +
                        "            v.call := '1';\n" +
                        "        end if;\n" +
                        "        if wv(Instr_JALR) = '1' then\n" +
                        "            if conv_integer(wb_res_addr) = Reg_ra then\n" +
                        "                v.call := '1';\n" +
                        "            elsif wb_rdata2 = zero64 and conv_integer(wb_radr1) = Reg_ra then\n" +
                        "                v.ret := '1';\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    o_radr1 <= wb_radr1;\n" +
                        "    o_radr2 <= wb_radr2;\n" +
                        "    o_res_addr <= r.res_addr;\n" +
                        "    o_res_data <= r.res_val;\n" +
                        "    o_pipeline_hold <= w_hold;\n" +
                        "\n" +
                        "    o_csr_wena <= w_csr_wena and w_next_ready;\n" +
                        "    o_csr_addr <= wb_csr_addr;\n" +
                        "    o_csr_wdata <= wb_csr_wdata;\n" +
                        "    o_ex_npc <= wb_ex_npc;\n" +
                        "\n" +
                        "    o_memop_sign_ext <= r.memop_sign_ext;\n" +
                        "    o_memop_load <= r.memop_load;\n" +
                        "    o_memop_store <= r.memop_store;\n" +
                        "    o_memop_size <= r.memop_size;\n" +
                        "    o_memop_addr <= r.memop_addr;\n" +
                        "\n" +
                        "    o_valid <= w_valid;\n" +
                        "    o_pc <= r.pc;\n" +
                        "    o_npc <= r.npc;\n" +
                        "    o_instr <= r.instr;\n" +
                        "    o_call <= r.call;\n" +
                        "    o_ret <= r.ret;\n" +
                        "    o_mret <= w_mret;\n" +
                        "    o_uret <= w_uret;\n" +
                        "    o_fpu_valid <= w_arith_valid(Multi_FPU);\n" +
                        "    \n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(i_clk, i_nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_decoder_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "--library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use work.river_cfg.all;\n" +
                        "\n" +
                        "\n" +
                        "entity InstrDecoder is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk  : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_any_hold : in std_logic;                               -- Hold pipeline by any reason\n" +
                        "    i_f_valid : in std_logic;                                -- Fetch input valid\n" +
                        "    i_f_pc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0); -- Fetched pc\n" +
                        "    i_f_instr : in std_logic_vector(31 downto 0);            -- Fetched instruction value\n" +
                        "\n" +
                        "    o_valid : out std_logic;                                 -- Current output values are valid\n" +
                        "    o_pc : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);  -- Current instruction pointer value\n" +
                        "    o_instr : out std_logic_vector(31 downto 0);             -- Current instruction value\n" +
                        "    o_memop_store : out std_logic;                           -- Store to memory operation\n" +
                        "    o_memop_load : out std_logic;                            -- Load from memoru operation\n" +
                        "    o_memop_sign_ext : out std_logic;                        -- Load memory value with sign extending\n" +
                        "    o_memop_size : out std_logic_vector(1 downto 0);         -- Memory transaction size\n" +
                        "    o_rv32 : out std_logic;                                  -- 32-bits instruction\n" +
                        "    o_compressed : out std_logic;                            -- 16-bits opcode (C-extension)\n" +
                        "    o_f64 : out std_logic;                                   -- 64-bits FPU (D-extension)\n" +
                        "    o_unsigned_op : out std_logic;                           -- Unsigned operands\n" +
                        "    o_isa_type : out std_logic_vector(ISA_Total-1 downto 0); -- Instruction format accordingly with ISA\n" +
                        "    o_instr_vec : out std_logic_vector(Instr_Total-1 downto 0); -- One bit per decoded instruction bus\n" +
                        "    o_exception : out std_logic                              -- Unimplemented instruction\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_InstrDecoder of InstrDecoder is\n" +
                        "\n" +
                        "  -- LB, LH, LW, LD, LBU, LHU, LWU\n" +
                        "  constant OPCODE_LB     : std_logic_vector(4 downto 0) := \"00000\";\n" +
                        "  -- FLD\n" +
                        "  constant OPCODE_FPU_LD : std_logic_vector(4 downto 0) := \"00001\";\n" +
                        "  -- FENCE, FENCE_I\n" +
                        "  constant OPCODE_FENCE  : std_logic_vector(4 downto 0) := \"00011\";\n" +
                        "  --  ADDI, ANDI, ORI, SLLI, SLTI, SLTIU, SRAI, SRLI, XORI\n" +
                        "  constant OPCODE_ADDI   : std_logic_vector(4 downto 0) := \"00100\";\n" +
                        "  -- AUIPC\n" +
                        "  constant OPCODE_AUIPC  : std_logic_vector(4 downto 0) := \"00101\";\n" +
                        "  -- ADDIW, SLLIW, SRAIW, SRLIW\n" +
                        "  constant OPCODE_ADDIW  : std_logic_vector(4 downto 0) := \"00110\";\n" +
                        "  -- SB, SH, SW, SD\n" +
                        "  constant OPCODE_SB     : std_logic_vector(4 downto 0) := \"01000\";\n" +
                        "  -- FSD\n" +
                        "  constant OPCODE_FPU_SD : std_logic_vector(4 downto 0) := \"01001\";\n" +
                        "  -- ADD, AND, OR, SLT, SLTU, SLL, SRA, SRL, SUB, XOR, DIV, DIVU, MUL, REM, REMU\n" +
                        "  constant OPCODE_ADD    : std_logic_vector(4 downto 0) := \"01100\";\n" +
                        "  -- LUI\n" +
                        "  constant OPCODE_LUI    : std_logic_vector(4 downto 0) := \"01101\";\n" +
                        "  -- ADDW, SLLW, SRAW, SRLW, SUBW, DIVW, DIVUW, MULW, REMW, REMUW\n" +
                        "  constant OPCODE_ADDW   : std_logic_vector(4 downto 0) := \"01110\";\n" +
                        "  -- FPU operations\n" +
                        "  constant OPCODE_FPU_OP : std_logic_vector(4 downto 0) := \"10100\";\n" +
                        "  -- BEQ, BNE, BLT, BGE, BLTU, BGEU\n" +
                        "  constant OPCODE_BEQ    : std_logic_vector(4 downto 0) := \"11000\";\n" +
                        "  -- JALR\n" +
                        "  constant OPCODE_JALR   : std_logic_vector(4 downto 0) := \"11001\";\n" +
                        "  -- JAL\n" +
                        "  constant OPCODE_JAL    : std_logic_vector(4 downto 0) := \"11011\";\n" +
                        "  -- CSRRC, CSRRCI, CSRRS, CSRRSI, CSRRW, CSRRWI, URET, SRET, HRET, MRET\n" +
                        "  constant OPCODE_CSRR   : std_logic_vector(4 downto 0) := \"11100\"; \n" +
                        "  -- Compressed instruction set\n" +
                        "  constant OPCODE_C_ADDI4SPN : std_logic_vector(4 downto 0) := \"00000\";\n" +
                        "  constant OPCODE_C_NOP_ADDI : std_logic_vector(4 downto 0) := \"00001\";\n" +
                        "  constant OPCODE_C_SLLI     : std_logic_vector(4 downto 0) := \"00010\";\n" +
                        "  constant OPCODE_C_JAL_ADDIW : std_logic_vector(4 downto 0) := \"00101\";\n" +
                        "  constant OPCODE_C_LW       : std_logic_vector(4 downto 0) := \"01000\";\n" +
                        "  constant OPCODE_C_LI       : std_logic_vector(4 downto 0) := \"01001\";\n" +
                        "  constant OPCODE_C_LWSP     : std_logic_vector(4 downto 0) := \"01010\";\n" +
                        "  constant OPCODE_C_LD       : std_logic_vector(4 downto 0) := \"01100\";\n" +
                        "  constant OPCODE_C_ADDI16SP_LUI : std_logic_vector(4 downto 0) := \"01101\";\n" +
                        "  constant OPCODE_C_LDSP     : std_logic_vector(4 downto 0) := \"01110\";\n" +
                        "  constant OPCODE_C_MATH     : std_logic_vector(4 downto 0) := \"10001\";\n" +
                        "  constant OPCODE_C_JR_MV_EBREAK_JALR_ADD : std_logic_vector(4 downto 0) := \"10010\";\n" +
                        "  constant OPCODE_C_J        : std_logic_vector(4 downto 0) := \"10101\";\n" +
                        "  constant OPCODE_C_SW       : std_logic_vector(4 downto 0) := \"11000\";\n" +
                        "  constant OPCODE_C_BEQZ     : std_logic_vector(4 downto 0) := \"11001\";\n" +
                        "  constant OPCODE_C_SWSP     : std_logic_vector(4 downto 0) := \"11010\";\n" +
                        "  constant OPCODE_C_SD       : std_logic_vector(4 downto 0) := \"11100\";\n" +
                        "  constant OPCODE_C_BNEZ     : std_logic_vector(4 downto 0) := \"11101\";\n" +
                        "  constant OPCODE_C_SDSP     : std_logic_vector(4 downto 0) := \"11110\";\n" +
                        "\n" +
                        "\n" +
                        "  constant INSTR_NONE : std_logic_vector(Instr_Total-1 downto 0) := (others => '0');\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "      valid : std_logic;\n" +
                        "      pc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      isa_type : std_logic_vector(ISA_Total-1 downto 0);\n" +
                        "      instr_vec : std_logic_vector(Instr_Total-1 downto 0);\n" +
                        "      instr : std_logic_vector(31 downto 0);\n" +
                        "      memop_store : std_logic;\n" +
                        "      memop_load : std_logic;\n" +
                        "      memop_sign_ext : std_logic;\n" +
                        "      memop_size : std_logic_vector(1 downto 0);\n" +
                        "      unsigned_op : std_logic;\n" +
                        "      rv32 : std_logic;\n" +
                        "      f64 : std_logic;\n" +
                        "      compressed : std_logic;\n" +
                        "      instr_unimplemented : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "    '0', (others => '0'), (others => '0'),   -- valid, pc, isa_type\n" +
                        "    (others => '0'), (others => '0'), '0',   -- instr_vec, instr, memop_store\n" +
                        "    '0', '0', \"00\",                          -- memop_load, memop_sign_ext, memop_size\n" +
                        "    '0', '0', '0',                           -- unsigned_op, rv32, f64\n" +
                        "    '0', '0'                                 -- compressed, instr_unimpl\n" +
                        "  );\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "\n" +
                        "  comb : process(i_nrst, i_any_hold, i_f_valid, i_f_pc, i_f_instr, r)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable w_o_valid : std_logic;\n" +
                        "    variable w_error : std_logic;\n" +
                        "    variable w_compressed : std_logic;\n" +
                        "    variable wb_instr : std_logic_vector(31 downto 0);\n" +
                        "    variable wb_instr_out : std_logic_vector(31 downto 0);\n" +
                        "    variable wb_opcode1 : std_logic_vector(4 downto 0);\n" +
                        "    variable wb_opcode2 : std_logic_vector(2 downto 0);\n" +
                        "    variable wb_dec : std_logic_vector(Instr_Total-1 downto 0);\n" +
                        "    variable wb_isa_type : std_logic_vector(ISA_Total-1 downto 0);\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "    w_error := '0';\n" +
                        "    w_compressed := '0';\n" +
                        "    wb_instr := i_f_instr;\n" +
                        "    wb_opcode1 := wb_instr(6 downto 2);\n" +
                        "    wb_opcode2 := wb_instr(14 downto 12);\n" +
                        "    wb_dec := (others => '0');\n" +
                        "    wb_isa_type := (others => '0');\n" +
                        "\n" +
                        "    if wb_instr(1 downto 0) /= \"11\" then\n" +
                        "        w_compressed := '1';\n" +
                        "        wb_opcode1 := wb_instr(15 downto 13) & wb_instr(1 downto 0);\n" +
                        "        wb_instr_out := X\"00000003\";\n" +
                        "        case wb_opcode1 is\n" +
                        "        when OPCODE_C_ADDI4SPN =>\n" +
                        "            wb_isa_type(ISA_I_type) := '1';\n" +
                        "            wb_dec(Instr_ADDI) := '1';\n" +
                        "            wb_instr_out(11 downto 7) := \"01\" & wb_instr(4 downto 2);   -- rd\n" +
                        "            wb_instr_out(19 downto 15) := \"00010\";                     -- rs1 = sp\n" +
                        "            wb_instr_out(29 downto 22) :=\n" +
                        "                wb_instr(10 downto 7) & wb_instr(12 downto 11) & wb_instr(5) & wb_instr(6);\n" +
                        "        when OPCODE_C_NOP_ADDI =>\n" +
                        "            wb_isa_type(ISA_I_type) := '1';\n" +
                        "            wb_dec(Instr_ADDI) := '1';\n" +
                        "            wb_instr_out(11 downto 7) := wb_instr(11 downto 7);   -- rd\n" +
                        "            wb_instr_out(19 downto 15) := wb_instr(11 downto 7);  -- rs1\n" +
                        "            wb_instr_out(24 downto 20) := wb_instr(6 downto 2);   -- imm\n" +
                        "            if wb_instr(12) = '1' then\n" +
                        "                wb_instr_out(31 downto 25) := (others => '1');\n" +
                        "            end if;\n" +
                        "        when OPCODE_C_SLLI =>\n" +
                        "            wb_isa_type(ISA_I_type) := '1';\n" +
                        "            wb_dec(Instr_SLLI) := '1';\n" +
                        "            wb_instr_out(11 downto 7) := wb_instr(11 downto 7);      -- rd\n" +
                        "            wb_instr_out(19 downto 15) := wb_instr(11 downto 7);     -- rs1\n" +
                        "            wb_instr_out(25 downto 20) := wb_instr(12) & wb_instr(6 downto 2);  -- shamt\n" +
                        "        when OPCODE_C_JAL_ADDIW =>\n" +
                        "            -- JAL is the RV32C only instruction\n" +
                        "            wb_isa_type(ISA_I_type) := '1';\n" +
                        "            wb_dec(Instr_ADDIW) := '1';\n" +
                        "            wb_instr_out(11 downto 7) := wb_instr(11 downto 7);      -- rd\n" +
                        "            wb_instr_out(19 downto 15) := wb_instr(11 downto 7);     -- rs1\n" +
                        "            wb_instr_out(24 downto 20) := wb_instr(6 downto 2);      -- imm\n" +
                        "            if wb_instr(12) = '1' then\n" +
                        "                wb_instr_out(31 downto 25) := (others => '1');\n" +
                        "            end if;\n" +
                        "        when OPCODE_C_LW =>\n" +
                        "            wb_isa_type(ISA_I_type) := '1';\n" +
                        "            wb_dec(Instr_LW) := '1';\n" +
                        "            wb_instr_out(11 downto 7) := \"01\" & wb_instr(4 downto 2);   -- rd\n" +
                        "            wb_instr_out(19 downto 15) := \"01\" & wb_instr(9 downto 7);  -- rs1\n" +
                        "            wb_instr_out(26 downto 22) :=\n" +
                        "                wb_instr(5) & wb_instr(12 downto 10) & wb_instr(6);\n" +
                        "        when OPCODE_C_LI =>  -- ADDI rd = r0 + imm\n" +
                        "            wb_isa_type(ISA_I_type) := '1';\n" +
                        "            wb_dec(Instr_ADDI) := '1';\n" +
                        "            wb_instr_out(11 downto 7) := wb_instr(11 downto 7);      -- rd\n" +
                        "            wb_instr_out(24 downto 20) := wb_instr(6 downto 2);      -- imm\n" +
                        "            if wb_instr(12) = '1' then\n" +
                        "                wb_instr_out(31 downto 25) := (others => '1');\n" +
                        "            end if;\n" +
                        "        when OPCODE_C_LWSP =>\n" +
                        "            wb_isa_type(ISA_I_type) := '1';\n" +
                        "            wb_dec(Instr_LW) := '1';\n" +
                        "            wb_instr_out(11 downto 7) := wb_instr(11 downto 7);    -- rd\n" +
                        "            wb_instr_out(19 downto 15) := \"00010\";                 -- rs1 = sp\n" +
                        "            wb_instr_out(27 downto 22) :=\n" +
                        "                wb_instr(3 downto 2) & wb_instr(12) & wb_instr(6 downto 4);\n" +
                        "        when OPCODE_C_LD =>\n" +
                        "            wb_isa_type(ISA_I_type) := '1';\n" +
                        "            wb_dec(Instr_LD) := '1';\n" +
                        "            wb_instr_out(11 downto 7) := \"01\" & wb_instr(4 downto 2);   -- rd\n" +
                        "            wb_instr_out(19 downto 15) := \"01\" & wb_instr(9 downto 7);  -- rs1\n" +
                        "            wb_instr_out(27 downto 23) :=\n" +
                        "                wb_instr(6) & wb_instr(5) & wb_instr(12 downto 10);\n" +
                        "        when OPCODE_C_ADDI16SP_LUI =>\n" +
                        "            if wb_instr(11 downto 7) = \"00010\" then\n" +
                        "                wb_isa_type(ISA_I_type) := '1';\n" +
                        "                wb_dec(Instr_ADDI) := '1';\n" +
                        "                wb_instr_out(11 downto 7) := \"00010\";     -- rd = sp\n" +
                        "                wb_instr_out(19 downto 15) := \"00010\";    -- rs1 = sp\n" +
                        "                wb_instr_out(28 downto 24) :=\n" +
                        "                    wb_instr(4 downto 3) & wb_instr(5) & wb_instr(2) & wb_instr(6);\n" +
                        "                if wb_instr(12) = '1' then\n" +
                        "                    wb_instr_out(31 downto 29) := (others => '1');\n" +
                        "                end if;\n" +
                        "            else\n" +
                        "                wb_isa_type(ISA_U_type) := '1';\n" +
                        "                wb_dec(Instr_LUI) := '1';\n" +
                        "                wb_instr_out(11 downto 7) := wb_instr(11 downto 7);  -- rd\n" +
                        "                wb_instr_out(16 downto 12) := wb_instr(6 downto 2);\n" +
                        "                if wb_instr(12) = '1' then\n" +
                        "                    wb_instr_out(31 downto 17) := (others => '1');\n" +
                        "                end if;\n" +
                        "            end if;\n" +
                        "        when OPCODE_C_LDSP =>\n" +
                        "            wb_isa_type(ISA_I_type) := '1';\n" +
                        "            wb_dec(Instr_LD) := '1';\n" +
                        "            wb_instr_out(11 downto 7) := wb_instr(11 downto 7);  -- rd\n" +
                        "            wb_instr_out(19 downto 15) := \"00010\";               -- rs1 = sp\n" +
                        "            wb_instr_out(28 downto 23) :=\n" +
                        "                wb_instr(4 downto 2) & wb_instr(12) & wb_instr(6 downto 5);\n" +
                        "        when OPCODE_C_MATH =>\n" +
                        "            if wb_instr(11 downto 10) = \"00\" then\n" +
                        "                wb_isa_type(ISA_I_type) := '1';\n" +
                        "                wb_dec(Instr_SRLI) := '1';\n" +
                        "                wb_instr_out(11 downto 7) := \"01\" & wb_instr(9 downto 7);   -- rd\n" +
                        "                wb_instr_out(19 downto 15) := \"01\" & wb_instr(9 downto 7);  -- rs1\n" +
                        "                wb_instr_out(25 downto 20) := wb_instr(12) & wb_instr(6 downto 2);  -- shamt\n" +
                        "            elsif wb_instr(11 downto 10) = \"01\" then\n" +
                        "                wb_isa_type(ISA_I_type) := '1';\n" +
                        "                wb_dec(Instr_SRAI) := '1';\n" +
                        "                wb_instr_out(11 downto 7) := \"01\" & wb_instr(9 downto 7);   -- rd\n" +
                        "                wb_instr_out(19 downto 15) := \"01\" & wb_instr(9 downto 7);  -- rs1\n" +
                        "                wb_instr_out(25 downto 20) := wb_instr(12) & wb_instr(6 downto 2);  -- shamt\n" +
                        "            elsif wb_instr(11 downto 10) = \"10\" then\n" +
                        "                wb_isa_type(ISA_I_type) := '1';\n" +
                        "                wb_dec(Instr_ANDI) := '1';\n" +
                        "                wb_instr_out(11 downto 7) := \"01\" & wb_instr(9 downto 7);   -- rd\n" +
                        "                wb_instr_out(19 downto 15) := \"01\" & wb_instr(9 downto 7);  -- rs1\n" +
                        "                wb_instr_out(24 downto 20) := wb_instr(6 downto 2);        -- imm\n" +
                        "                if wb_instr(12) = '1' then\n" +
                        "                    wb_instr_out(31 downto 25) := (others => '1');\n" +
                        "                end if;\n" +
                        "            elsif wb_instr(12) = '0' then\n" +
                        "                wb_isa_type(ISA_R_type) := '1';\n" +
                        "                wb_instr_out(11 downto 7) := \"01\" & wb_instr(9 downto 7);   -- rd\n" +
                        "                wb_instr_out(19 downto 15) := \"01\" & wb_instr(9 downto 7);  -- rs1\n" +
                        "                wb_instr_out(24 downto 20) := \"01\" & wb_instr(4 downto 2);  -- rs2\n" +
                        "                case wb_instr(6 downto 5) is\n" +
                        "                when \"00\" =>\n" +
                        "                    wb_dec(Instr_SUB) := '1';\n" +
                        "                when \"01\" =>\n" +
                        "                    wb_dec(Instr_XOR) := '1';\n" +
                        "                when \"10\" =>\n" +
                        "                    wb_dec(Instr_OR) := '1';\n" +
                        "                when others =>\n" +
                        "                    wb_dec(Instr_AND) := '1';\n" +
                        "                end case;\n" +
                        "            else\n" +
                        "                wb_isa_type(ISA_R_type) := '1';\n" +
                        "                wb_instr_out(11 downto 7) := \"01\" & wb_instr(9 downto 7);   -- rd\n" +
                        "                wb_instr_out(19 downto 15) := \"01\" & wb_instr(9 downto 7);  -- rs1\n" +
                        "                wb_instr_out(24 downto 20) := \"01\" & wb_instr(4 downto 2);  -- rs2\n" +
                        "                case wb_instr(6 downto 5) is\n" +
                        "                when \"00\" =>\n" +
                        "                    wb_dec(Instr_SUBW) := '1';\n" +
                        "                when \"01\" =>\n" +
                        "                    wb_dec(Instr_ADDW) := '1';\n" +
                        "                when others =>\n" +
                        "                    w_error := '1';\n" +
                        "                end case;\n" +
                        "            end if;\n" +
                        "        when OPCODE_C_JR_MV_EBREAK_JALR_ADD =>\n" +
                        "            wb_isa_type(ISA_I_type) := '1';\n" +
                        "            if wb_instr(12) = '0' then\n" +
                        "                if wb_instr(6 downto 2) = \"00000\" then\n" +
                        "                    wb_dec(Instr_JALR) := '1';\n" +
                        "                    wb_instr_out(19 downto 15) := wb_instr(11 downto 7);  -- rs1\n" +
                        "                else\n" +
                        "                    wb_dec(Instr_ADDI) := '1';\n" +
                        "                    wb_instr_out(11 downto 7) := wb_instr(11 downto 7);   -- rd\n" +
                        "                    wb_instr_out(19 downto 15) := wb_instr(6 downto 2);   -- rs1\n" +
                        "                end if;\n" +
                        "            else\n" +
                        "                if wb_instr(11 downto 7) = \"00000\" and wb_instr(6 downto 2) = \"00000\" then\n" +
                        "                    wb_dec(Instr_EBREAK) := '1';\n" +
                        "                elsif wb_instr(6 downto 2) = \"00000\" then\n" +
                        "                    wb_dec(Instr_JALR) := '1';\n" +
                        "                    wb_instr_out(11 downto 7) := \"00001\";                 -- rd = ra\n" +
                        "                    wb_instr_out(19 downto 15) := wb_instr(11 downto 7);  -- rs1\n" +
                        "                else\n" +
                        "                    wb_dec(Instr_ADD) := '1';\n" +
                        "                    wb_isa_type(ISA_R_type) := '1';\n" +
                        "                    wb_instr_out(11 downto 7) := wb_instr(11 downto 7);   -- rd\n" +
                        "                    wb_instr_out(19 downto 15) := wb_instr(11 downto 7);  -- rs1\n" +
                        "                    wb_instr_out(24 downto 20) := wb_instr(6 downto 2);   -- rs2\n" +
                        "                end if;\n" +
                        "            end if;\n" +
                        "        when OPCODE_C_J =>   -- JAL with rd = 0\n" +
                        "            wb_isa_type(ISA_UJ_type) := '1';\n" +
                        "            wb_dec(Instr_JAL) := '1';\n" +
                        "            wb_instr_out(20) := wb_instr(12);            -- imm11\n" +
                        "            wb_instr_out(23 downto 21) := wb_instr(5 downto 3);      -- imm10_1(3:1)\n" +
                        "            wb_instr_out(24) := wb_instr(11);            -- imm10_1(4)\n" +
                        "            wb_instr_out(25) := wb_instr(2);             -- imm10_1(5)\n" +
                        "            wb_instr_out(26) := wb_instr(7);             -- imm10_1(6)\n" +
                        "            wb_instr_out(27) := wb_instr(6);             -- imm10_1(7)\n" +
                        "            wb_instr_out(29 downto 28) := wb_instr(10 downto 9);     -- imm10_1(9:8)\n" +
                        "            wb_instr_out(30) := wb_instr(8);             -- imm10_1(10)\n" +
                        "            if wb_instr(12) = '1' then\n" +
                        "                wb_instr_out(19 downto 12) := (others => '1'); -- imm19_12\n" +
                        "                wb_instr_out(31) := '1';                 -- imm20\n" +
                        "            end if;\n" +
                        "        when OPCODE_C_SW =>\n" +
                        "            wb_isa_type(ISA_S_type) := '1';\n" +
                        "            wb_dec(Instr_SW) := '1';\n" +
                        "            wb_instr_out(24 downto 20) := \"01\" & wb_instr(4 downto 2);    -- rs2\n" +
                        "            wb_instr_out(19 downto 15) := \"01\" & wb_instr(9 downto 7);    -- rs1\n" +
                        "            wb_instr_out(11 downto 9) := wb_instr(11 downto 10) & wb_instr(6);\n" +
                        "            wb_instr_out(26 downto 25) := wb_instr(5) & wb_instr(12);\n" +
                        "        when OPCODE_C_BEQZ =>\n" +
                        "            wb_isa_type(ISA_SB_type) := '1';\n" +
                        "            wb_dec(Instr_BEQ) := '1';\n" +
                        "            wb_instr_out(19 downto 15) := \"01\" & wb_instr(9 downto 7);    -- rs1\n" +
                        "            wb_instr_out(11 downto 8) := wb_instr(11 downto 10) & wb_instr(4 downto 3);\n" +
                        "            wb_instr_out(27 downto 25) := wb_instr(6 downto 5) & wb_instr(2);\n" +
                        "            if wb_instr(12) = '1' then\n" +
                        "                wb_instr_out(30 downto 28) := (others => '1');\n" +
                        "                wb_instr_out(7) := '1';\n" +
                        "                wb_instr_out(31) := '1';\n" +
                        "            end if;\n" +
                        "        when OPCODE_C_SWSP =>\n" +
                        "            wb_isa_type(ISA_S_type) := '1';\n" +
                        "            wb_dec(Instr_SW) := '1';\n" +
                        "            wb_instr_out(24 downto 20) := wb_instr(6 downto 2);  -- rs2\n" +
                        "            wb_instr_out(19 downto 15) := \"00010\";             -- rs1 = sp\n" +
                        "            wb_instr_out(11 downto 9) := wb_instr(11 downto 9);\n" +
                        "            wb_instr_out(27 downto 25) := wb_instr(8 downto 7) & wb_instr(12);\n" +
                        "        when OPCODE_C_SD =>\n" +
                        "            wb_isa_type(ISA_S_type) := '1';\n" +
                        "            wb_dec(Instr_SD) := '1';\n" +
                        "            wb_instr_out(24 downto 20) := \"01\" & wb_instr(4 downto 2);  -- rs2\n" +
                        "            wb_instr_out(19 downto 15) := \"01\" & wb_instr(9 downto 7);  -- rs1\n" +
                        "            wb_instr_out(11 downto 10) := wb_instr(11 downto 10);\n" +
                        "            wb_instr_out(27 downto 25) := wb_instr(6 downto 5) & wb_instr(12);\n" +
                        "        when OPCODE_C_BNEZ =>\n" +
                        "            wb_isa_type(ISA_SB_type) := '1';\n" +
                        "            wb_dec(Instr_BNE) := '1';\n" +
                        "            wb_instr_out(19 downto 15) := \"01\" & wb_instr(9 downto 7);    -- rs1\n" +
                        "            wb_instr_out(11 downto 8) := wb_instr(11 downto 10) & wb_instr(4 downto 3);\n" +
                        "            wb_instr_out(27 downto 25) := wb_instr(6 downto 5) & wb_instr(2);\n" +
                        "            if wb_instr(12) = '1' then\n" +
                        "                wb_instr_out(30 downto 28) := (others => '1');\n" +
                        "                wb_instr_out(7) := '1';\n" +
                        "                wb_instr_out(31) := '1';\n" +
                        "            end if;\n" +
                        "        when OPCODE_C_SDSP =>\n" +
                        "            wb_isa_type(ISA_S_type) := '1';\n" +
                        "            wb_dec(Instr_SD) := '1';\n" +
                        "            wb_instr_out(24 downto 20) := wb_instr(6 downto 2);  -- rs2\n" +
                        "            wb_instr_out(19 downto 15) := \"00010\";               -- rs1 = sp\n" +
                        "            wb_instr_out(11 downto 10) := wb_instr(11 downto 10);\n" +
                        "            wb_instr_out(28 downto 25) := wb_instr(9 downto 7) & wb_instr(12);\n" +
                        "        when others =>\n" +
                        "            w_error := '1';\n" +
                        "        end case;\n" +
                        "    else -- compressed/!not compressed\n" +
                        "        case wb_opcode1 is\n" +
                        "        when OPCODE_ADD =>\n" +
                        "            wb_isa_type(ISA_R_type) := '1';\n" +
                        "            case wb_opcode2 is\n" +
                        "            when \"000\" =>\n" +
                        "                if wb_instr(31 downto 25) = \"0000000\" then\n" +
                        "                    wb_dec(Instr_ADD) := '1';\n" +
                        "                elsif wb_instr(31 downto 25) = \"0000001\" then\n" +
                        "                    wb_dec(Instr_MUL) := '1';\n" +
                        "                elsif wb_instr(31 downto 25) = \"0100000\" then\n" +
                        "                    wb_dec(Instr_SUB) := '1';\n" +
                        "                else\n" +
                        "                    w_error := '1';\n" +
                        "                end if;\n" +
                        "            when \"001\" =>\n" +
                        "                wb_dec(Instr_SLL) := '1';\n" +
                        "            when \"010\" =>\n" +
                        "                wb_dec(Instr_SLT) := '1';\n" +
                        "            when \"011\" =>\n" +
                        "                wb_dec(Instr_SLTU) := '1';\n" +
                        "            when \"100\" =>\n" +
                        "                if wb_instr(31 downto 25) = \"0000000\" then\n" +
                        "                    wb_dec(Instr_XOR) := '1';\n" +
                        "                elsif wb_instr(31 downto 25) = \"0000001\" then\n" +
                        "                    wb_dec(Instr_DIV) := '1';\n" +
                        "                else \n" +
                        "                    w_error := '1';\n" +
                        "                end if;\n" +
                        "            when \"101\" =>\n" +
                        "                if wb_instr(31 downto 25) = \"0000000\" then\n" +
                        "                    wb_dec(Instr_SRL) := '1';\n" +
                        "                elsif wb_instr(31 downto 25) = \"0000001\" then\n" +
                        "                    wb_dec(Instr_DIVU) := '1';\n" +
                        "                elsif wb_instr(31 downto 25) = \"0100000\" then\n" +
                        "                    wb_dec(Instr_SRA) := '1';\n" +
                        "                else\n" +
                        "                    w_error := '1';\n" +
                        "                end if;\n" +
                        "            when \"110\" =>\n" +
                        "                if wb_instr(31 downto 25) = \"0000000\" then\n" +
                        "                    wb_dec(Instr_OR) := '1';\n" +
                        "                elsif wb_instr(31 downto 25) = \"0000001\" then\n" +
                        "                    wb_dec(Instr_REM) := '1';\n" +
                        "                else\n" +
                        "                    w_error := '1';\n" +
                        "                end if;\n" +
                        "            when \"111\" =>\n" +
                        "                if wb_instr(31 downto 25) = \"0000000\" then\n" +
                        "                    wb_dec(Instr_AND) := '1';\n" +
                        "                elsif wb_instr(31 downto 25) = \"0000001\" then\n" +
                        "                    wb_dec(Instr_REMU) := '1';\n" +
                        "                else\n" +
                        "                    w_error := '1';\n" +
                        "                end if;\n" +
                        "            when others =>\n" +
                        "                w_error := '1';\n" +
                        "            end case;\n" +
                        "        when OPCODE_ADDI =>\n" +
                        "            wb_isa_type(ISA_I_type) := '1';\n" +
                        "            case wb_opcode2 is\n" +
                        "            when \"000\" =>\n" +
                        "                wb_dec(Instr_ADDI) := '1';\n" +
                        "            when \"001\" =>\n" +
                        "                wb_dec(Instr_SLLI) := '1';\n" +
                        "            when \"010\" =>\n" +
                        "                wb_dec(Instr_SLTI) := '1';\n" +
                        "            when \"011\" =>\n" +
                        "                wb_dec(Instr_SLTIU) := '1';\n" +
                        "            when \"100\" =>\n" +
                        "                wb_dec(Instr_XORI) := '1';\n" +
                        "            when \"101\" =>\n" +
                        "                if wb_instr(31 downto 26) = \"000000\" then\n" +
                        "                    wb_dec(Instr_SRLI) := '1';\n" +
                        "                elsif wb_instr(31 downto 26) = \"010000\" then\n" +
                        "                    wb_dec(Instr_SRAI) := '1';\n" +
                        "                else\n" +
                        "                    w_error := '1';\n" +
                        "                end if;\n" +
                        "            when \"110\" =>\n" +
                        "                wb_dec(Instr_ORI) := '1';\n" +
                        "            when \"111\" =>\n" +
                        "                wb_dec(Instr_ANDI) := '1';\n" +
                        "            when others =>\n" +
                        "                w_error := '1';\n" +
                        "            end case;\n" +
                        "        when OPCODE_ADDIW =>\n" +
                        "            wb_isa_type(ISA_I_type) := '1';\n" +
                        "            case wb_opcode2 is\n" +
                        "            when \"000\" =>\n" +
                        "                wb_dec(Instr_ADDIW) := '1';\n" +
                        "            when \"001\" =>\n" +
                        "                wb_dec(Instr_SLLIW) := '1';\n" +
                        "            when \"101\" =>\n" +
                        "                if wb_instr(31 downto 25) = \"0000000\" then\n" +
                        "                    wb_dec(Instr_SRLIW) := '1';\n" +
                        "                elsif wb_instr(31 downto 25) = \"0100000\" then\n" +
                        "                    wb_dec(Instr_SRAIW) := '1';\n" +
                        "                else\n" +
                        "                    w_error := '1';\n" +
                        "                end if;\n" +
                        "            when others =>\n" +
                        "                w_error := '1';\n" +
                        "            end case;\n" +
                        "        when OPCODE_ADDW =>\n" +
                        "            wb_isa_type(ISA_R_type) := '1';\n" +
                        "            case wb_opcode2 is\n" +
                        "            when \"000\" =>\n" +
                        "                if wb_instr(31 downto 25) = \"0000000\" then\n" +
                        "                    wb_dec(Instr_ADDW) := '1';\n" +
                        "                elsif wb_instr(31 downto 25) = \"0000001\" then\n" +
                        "                    wb_dec(Instr_MULW) := '1';\n" +
                        "                elsif wb_instr(31 downto 25) = \"0100000\" then\n" +
                        "                    wb_dec(Instr_SUBW) := '1';\n" +
                        "                else\n" +
                        "                    w_error := '1';\n" +
                        "                end if;\n" +
                        "            when \"001\" =>\n" +
                        "                wb_dec(Instr_SLLW) := '1';\n" +
                        "            when \"100\" =>\n" +
                        "                if wb_instr(31 downto 25) = \"0000001\" then\n" +
                        "                    wb_dec(Instr_DIVW) := '1';\n" +
                        "                else\n" +
                        "                    w_error := '1';\n" +
                        "                end if;\n" +
                        "            when \"101\" =>\n" +
                        "                if wb_instr(31 downto 25) = \"0000000\" then\n" +
                        "                    wb_dec(Instr_SRLW) := '1';\n" +
                        "                elsif wb_instr(31 downto 25) = \"0000001\" then\n" +
                        "                    wb_dec(Instr_DIVUW) := '1';\n" +
                        "                elsif wb_instr(31 downto 25) = \"0100000\" then\n" +
                        "                    wb_dec(Instr_SRAW) := '1';\n" +
                        "                else\n" +
                        "                    w_error := '1';\n" +
                        "                end if;\n" +
                        "            when \"110\" =>\n" +
                        "                if wb_instr(31 downto 25) = \"0000001\" then\n" +
                        "                    wb_dec(Instr_REMW) := '1';\n" +
                        "                else\n" +
                        "                    w_error := '1';\n" +
                        "                end if;\n" +
                        "            when \"111\" =>\n" +
                        "                if wb_instr(31 downto 25) = \"0000001\" then\n" +
                        "                    wb_dec(Instr_REMUW) := '1';\n" +
                        "                else\n" +
                        "                    w_error := '1';\n" +
                        "                end if;\n" +
                        "            when others =>\n" +
                        "                w_error := '1';\n" +
                        "            end case;\n" +
                        "        when OPCODE_AUIPC =>\n" +
                        "            wb_isa_type(ISA_U_type) := '1';\n" +
                        "            wb_dec(Instr_AUIPC) := '1';\n" +
                        "        when OPCODE_BEQ =>\n" +
                        "            wb_isa_type(ISA_SB_type) := '1';\n" +
                        "            case wb_opcode2 is\n" +
                        "            when \"000\" =>\n" +
                        "                wb_dec(Instr_BEQ) := '1';\n" +
                        "            when \"001\" =>\n" +
                        "                wb_dec(Instr_BNE) := '1';\n" +
                        "            when \"100\" =>\n" +
                        "                wb_dec(Instr_BLT) := '1';\n" +
                        "            when \"101\" =>\n" +
                        "                wb_dec(Instr_BGE) := '1';\n" +
                        "            when \"110\" =>\n" +
                        "                wb_dec(Instr_BLTU) := '1';\n" +
                        "            when \"111\" =>\n" +
                        "                wb_dec(Instr_BGEU) := '1';\n" +
                        "            when others =>\n" +
                        "                w_error := '1';\n" +
                        "            end case;\n" +
                        "        when OPCODE_JAL =>\n" +
                        "            wb_isa_type(ISA_UJ_type) := '1';\n" +
                        "            wb_dec(Instr_JAL) := '1';\n" +
                        "        when OPCODE_JALR =>\n" +
                        "            wb_isa_type(ISA_I_type) := '1';\n" +
                        "            case wb_opcode2 is\n" +
                        "            when \"000\" =>\n" +
                        "                wb_dec(Instr_JALR) := '1';\n" +
                        "            when others =>\n" +
                        "                w_error := '1';\n" +
                        "            end case;\n" +
                        "        when OPCODE_LB =>\n" +
                        "            wb_isa_type(ISA_I_type) := '1';\n" +
                        "            case wb_opcode2 is\n" +
                        "            when \"000\" =>\n" +
                        "                wb_dec(Instr_LB) := '1';\n" +
                        "            when \"001\" =>\n" +
                        "                wb_dec(Instr_LH) := '1';\n" +
                        "            when \"010\" =>\n" +
                        "                wb_dec(Instr_LW) := '1';\n" +
                        "            when \"011\" =>\n" +
                        "                wb_dec(Instr_LD) := '1';\n" +
                        "            when \"100\" =>\n" +
                        "                wb_dec(Instr_LBU) := '1';\n" +
                        "            when \"101\" =>\n" +
                        "                wb_dec(Instr_LHU) := '1';\n" +
                        "            when \"110\" =>\n" +
                        "                wb_dec(Instr_LWU) := '1';\n" +
                        "            when others =>\n" +
                        "                w_error := '1';\n" +
                        "            end case;\n" +
                        "        when OPCODE_LUI =>\n" +
                        "            wb_isa_type(ISA_U_type) := '1';\n" +
                        "            wb_dec(Instr_LUI) := '1';\n" +
                        "        when OPCODE_SB =>\n" +
                        "            wb_isa_type(ISA_S_type) := '1';\n" +
                        "            case wb_opcode2 is\n" +
                        "            when \"000\" =>\n" +
                        "                wb_dec(Instr_SB) := '1';\n" +
                        "            when \"001\" =>\n" +
                        "                wb_dec(Instr_SH) := '1';\n" +
                        "            when \"010\" =>\n" +
                        "                wb_dec(Instr_SW) := '1';\n" +
                        "            when \"011\" =>\n" +
                        "                wb_dec(Instr_SD) := '1';\n" +
                        "            when others =>\n" +
                        "                w_error := '1';\n" +
                        "            end case;\n" +
                        "        when OPCODE_CSRR =>\n" +
                        "            wb_isa_type(ISA_I_type) := '1';\n" +
                        "            case wb_opcode2 is\n" +
                        "            when \"000\" =>\n" +
                        "                if wb_instr = X\"00000073\" then\n" +
                        "                    wb_dec(Instr_ECALL) := '1';\n" +
                        "                elsif wb_instr = X\"00100073\" then\n" +
                        "                    wb_dec(Instr_EBREAK) := '1';\n" +
                        "                elsif wb_instr = X\"00200073\" then\n" +
                        "                    wb_dec(Instr_URET) := '1';\n" +
                        "                elsif wb_instr = X\"10200073\" then\n" +
                        "                    wb_dec(Instr_SRET) := '1';\n" +
                        "                elsif wb_instr = X\"20200073\" then\n" +
                        "                    wb_dec(Instr_HRET) := '1';\n" +
                        "                elsif wb_instr = X\"30200073\" then\n" +
                        "                    wb_dec(Instr_MRET) := '1';\n" +
                        "                else\n" +
                        "                    w_error := '1';\n" +
                        "                end if;\n" +
                        "            when \"001\" =>\n" +
                        "                wb_dec(Instr_CSRRW) := '1';\n" +
                        "            when \"010\" =>\n" +
                        "                wb_dec(Instr_CSRRS) := '1';\n" +
                        "            when \"011\" =>\n" +
                        "                wb_dec(Instr_CSRRC) := '1';\n" +
                        "            when \"101\" =>\n" +
                        "                wb_dec(Instr_CSRRWI) := '1';\n" +
                        "            when \"110\" =>\n" +
                        "                wb_dec(Instr_CSRRSI) := '1';\n" +
                        "            when \"111\" =>\n" +
                        "                wb_dec(Instr_CSRRCI) := '1';\n" +
                        "            when others =>\n" +
                        "                w_error := '1';\n" +
                        "            end case;\n" +
                        "        when OPCODE_FENCE =>\n" +
                        "            case wb_opcode2 is\n" +
                        "            when \"000\" =>\n" +
                        "                wb_dec(Instr_FENCE) := '1';\n" +
                        "            when \"001\" =>\n" +
                        "                wb_dec(Instr_FENCE_I) := '1';\n" +
                        "            when others =>\n" +
                        "                w_error := '1';\n" +
                        "            end case;\n" +
                        "\n" +
                        "        when others =>\n" +
                        "            if CFG_HW_FPU_ENABLE then\n" +
                        "                case wb_opcode1 is\n" +
                        "                when OPCODE_FPU_LD =>\n" +
                        "                    wb_isa_type(ISA_I_type) := '1';\n" +
                        "                    if wb_opcode2 = \"011\" then\n" +
                        "                        wb_dec(Instr_FLD) := '1';\n" +
                        "                    else\n" +
                        "                        w_error := '1';\n" +
                        "                    end if;\n" +
                        "                when OPCODE_FPU_SD =>\n" +
                        "                    wb_isa_type(ISA_S_type) := '1';\n" +
                        "                    if wb_opcode2 = \"011\" then\n" +
                        "                        wb_dec(Instr_FSD) := '1';\n" +
                        "                    else\n" +
                        "                        w_error := '1';\n" +
                        "                    end if;\n" +
                        "                when OPCODE_FPU_OP =>\n" +
                        "                    wb_isa_type(ISA_R_type) := '1';\n" +
                        "                    case wb_instr(31 downto 25) is\n" +
                        "                    when \"0000001\" =>\n" +
                        "                        wb_dec(Instr_FADD_D) := '1';\n" +
                        "                    when \"0000101\" =>\n" +
                        "                        wb_dec(Instr_FSUB_D) := '1';\n" +
                        "                    when \"0001001\" =>\n" +
                        "                        wb_dec(Instr_FMUL_D) := '1';\n" +
                        "                    when \"0001101\" =>\n" +
                        "                        wb_dec(Instr_FDIV_D) := '1';\n" +
                        "                    when \"0010101\" =>\n" +
                        "                        if wb_opcode2 = \"000\" then\n" +
                        "                            wb_dec(Instr_FMIN_D) := '1';\n" +
                        "                        elsif wb_opcode2 = \"001\" then\n" +
                        "                            wb_dec(Instr_FMAX_D) := '1';\n" +
                        "                        else\n" +
                        "                            w_error := '1';\n" +
                        "                        end if;\n" +
                        "                    when \"1010001\" =>\n" +
                        "                        if wb_opcode2 = \"000\" then\n" +
                        "                            wb_dec(Instr_FLE_D) := '1';\n" +
                        "                        elsif wb_opcode2 = \"001\" then\n" +
                        "                            wb_dec(Instr_FLT_D) := '1';\n" +
                        "                        elsif wb_opcode2 = \"010\" then\n" +
                        "                            wb_dec(Instr_FEQ_D) := '1';\n" +
                        "                        else\n" +
                        "                            w_error := '1';\n" +
                        "                        end if;\n" +
                        "                    when \"1100001\" =>\n" +
                        "                        if wb_instr(24 downto 20) = \"00000\" then\n" +
                        "                            wb_dec(Instr_FCVT_W_D) := '1';\n" +
                        "                        elsif wb_instr(24 downto 20) = \"00001\" then\n" +
                        "                            wb_dec(Instr_FCVT_WU_D) := '1';\n" +
                        "                        elsif wb_instr(24 downto 20) = \"00010\" then\n" +
                        "                            wb_dec(Instr_FCVT_L_D) := '1';\n" +
                        "                        elsif wb_instr(24 downto 20) = \"00011\" then\n" +
                        "                            wb_dec(Instr_FCVT_LU_D) := '1';\n" +
                        "                        else\n" +
                        "                            w_error := '1';\n" +
                        "                        end if;\n" +
                        "                    when \"1101001\" =>\n" +
                        "                        if wb_instr(24 downto 20) = \"00000\" then\n" +
                        "                            wb_dec(Instr_FCVT_D_W) := '1';\n" +
                        "                        elsif wb_instr(24 downto 20) = \"00001\" then\n" +
                        "                            wb_dec(Instr_FCVT_D_WU) := '1';\n" +
                        "                        elsif wb_instr(24 downto 20) = \"00010\" then\n" +
                        "                            wb_dec(Instr_FCVT_D_L) := '1';\n" +
                        "                        elsif wb_instr(24 downto 20) = \"00011\" then\n" +
                        "                            wb_dec(Instr_FCVT_D_LU) := '1';\n" +
                        "                        else\n" +
                        "                            w_error := '1';\n" +
                        "                        end if;\n" +
                        "                    when \"1110001\" =>\n" +
                        "                        if wb_instr(24 downto 20) = \"00000\" and wb_opcode2 = \"000\" then\n" +
                        "                            wb_dec(Instr_FMOV_X_D) := '1';\n" +
                        "                        else\n" +
                        "                            w_error := '1';\n" +
                        "                        end if;\n" +
                        "                    when \"1111001\" =>\n" +
                        "                        if wb_instr(24 downto 20) = \"00000\" and wb_opcode2 = \"000\" then\n" +
                        "                            wb_dec(Instr_FMOV_D_X) := '1';\n" +
                        "                        else\n" +
                        "                            w_error := '1';\n" +
                        "                        end if;\n" +
                        "                    when others =>\n" +
                        "                        w_error := '1';\n" +
                        "                    end case;\n" +
                        "                when others =>\n" +
                        "                    w_error := '1';\n" +
                        "                end case;\n" +
                        "            else\n" +
                        "                w_error := '1';\n" +
                        "            end if;\n" +
                        "        end case;\n" +
                        "        wb_instr_out := wb_instr;\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    if i_f_valid = '1' then\n" +
                        "        v.valid := '1';\n" +
                        "        v.pc := i_f_pc;\n" +
                        "        v.instr := wb_instr_out;\n" +
                        "        v.compressed := w_compressed;\n" +
                        "\n" +
                        "        v.isa_type := wb_isa_type;\n" +
                        "        v.instr_vec := wb_dec;\n" +
                        "        v.memop_store := wb_dec(Instr_SD) or wb_dec(Instr_SW) \n" +
                        "                      or wb_dec(Instr_SH) or wb_dec(Instr_SB)\n" +
                        "                      or wb_dec(Instr_FSD);\n" +
                        "        v.memop_load := wb_dec(Instr_LD) or wb_dec(Instr_LW)\n" +
                        "                or wb_dec(Instr_LH) or wb_dec(Instr_LB)\n" +
                        "                or wb_dec(Instr_LWU) or wb_dec(Instr_LHU) \n" +
                        "                or wb_dec(Instr_LBU) or wb_dec(Instr_FLD);\n" +
                        "        v.memop_sign_ext := wb_dec(Instr_LD) or wb_dec(Instr_LW)\n" +
                        "                or wb_dec(Instr_LH) or wb_dec(Instr_LB);\n" +
                        "        if (wb_dec(Instr_LD) or wb_dec(Instr_SD) or\n" +
                        "            wb_dec(Instr_FLD) or wb_dec(Instr_FSD)) = '1' then\n" +
                        "            v.memop_size := MEMOP_8B;\n" +
                        "        elsif (wb_dec(Instr_LW) or wb_dec(Instr_LWU) or wb_dec(Instr_SW)) = '1' then\n" +
                        "            v.memop_size := MEMOP_4B;\n" +
                        "        elsif (wb_dec(Instr_LH) or wb_dec(Instr_LHU) or wb_dec(Instr_SH)) = '1' then\n" +
                        "            v.memop_size := MEMOP_2B;\n" +
                        "        else\n" +
                        "            v.memop_size := MEMOP_1B;\n" +
                        "        end if;\n" +
                        "        v.unsigned_op := wb_dec(Instr_DIVU) or wb_dec(Instr_REMU) or\n" +
                        "                         wb_dec(Instr_DIVUW) or wb_dec(Instr_REMUW) or\n" +
                        "                         wb_dec(Instr_FCVT_WU_D) or\n" +
                        "                         wb_dec(Instr_FCVT_LU_D);\n" +
                        "\n" +
                        "        v.rv32 := wb_dec(Instr_ADDW) or wb_dec(Instr_ADDIW) \n" +
                        "            or wb_dec(Instr_SLLW) or wb_dec(Instr_SLLIW) or wb_dec(Instr_SRAW)\n" +
                        "            or wb_dec(Instr_SRAIW)\n" +
                        "            or wb_dec(Instr_SRLW) or wb_dec(Instr_SRLIW) or wb_dec(Instr_SUBW) \n" +
                        "            or wb_dec(Instr_DIVW) or wb_dec(Instr_DIVUW) or wb_dec(Instr_MULW)\n" +
                        "            or wb_dec(Instr_REMW) or wb_dec(Instr_REMUW);\n" +
                        "\n" +
                        "        v.f64 := wb_dec(Instr_FADD_D) or wb_dec(Instr_FSUB_D)\n" +
                        "            or wb_dec(Instr_FMUL_D) or wb_dec(Instr_FDIV_D)\n" +
                        "            or wb_dec(Instr_FMIN_D) or wb_dec(Instr_FMAX_D)\n" +
                        "            or wb_dec(Instr_FLE_D) or wb_dec(Instr_FLT_D)\n" +
                        "            or wb_dec(Instr_FEQ_D) or wb_dec(Instr_FCVT_W_D)\n" +
                        "            or wb_dec(Instr_FCVT_WU_D) or wb_dec(Instr_FCVT_L_D)\n" +
                        "            or wb_dec(Instr_FCVT_LU_D) or wb_dec(Instr_FMOV_X_D)\n" +
                        "            or wb_dec(Instr_FCVT_D_W) or wb_dec(Instr_FCVT_D_WU)\n" +
                        "            or wb_dec(Instr_FCVT_D_L) or wb_dec(Instr_FCVT_D_LU)\n" +
                        "            or wb_dec(Instr_FMOV_D_X) or wb_dec(Instr_FLD)\n" +
                        "            or wb_dec(Instr_FSD);\n" +
                        "        \n" +
                        "        v.instr_unimplemented := w_error;\n" +
                        "    elsif i_any_hold = '0' then\n" +
                        "        v.valid := '0';\n" +
                        "    end if;\n" +
                        "    w_o_valid := r.valid;\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    o_valid <= w_o_valid;\n" +
                        "    o_pc <= r.pc;\n" +
                        "    o_instr <= r.instr;\n" +
                        "    o_memop_load <= r.memop_load;\n" +
                        "    o_memop_store <= r.memop_store;\n" +
                        "    o_memop_sign_ext <= r.memop_sign_ext;\n" +
                        "    o_memop_size <= r.memop_size;\n" +
                        "    o_unsigned_op <= r.unsigned_op;\n" +
                        "    o_rv32 <= r.rv32;\n" +
                        "    o_f64 <= r.f64;\n" +
                        "    o_compressed <= r.compressed;\n" +
                        "    o_isa_type <= r.isa_type;\n" +
                        "    o_instr_vec <= r.instr_vec;\n" +
                        "    o_exception <= r.instr_unimplemented;\n" +
                        "    \n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(i_clk, i_nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_dbg_port_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "--library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use work.river_cfg.all;\n" +
                        "\n" +
                        "\n" +
                        "entity DbgPort is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;                                     -- CPU clock\n" +
                        "    i_nrst : in std_logic;                                    -- Reset. Active LOW.\n" +
                        "    -- \"RIVER\" Debug interface\n" +
                        "    i_dport_valid : in std_logic;                             -- Debug access from DSU is valid\n" +
                        "    i_dport_write : in std_logic;                             -- Write command flag\n" +
                        "    i_dport_region : in std_logic_vector(1 downto 0);         -- Registers region ID: 0=CSR; 1=IREGS; 2=Control\n" +
                        "    i_dport_addr : in std_logic_vector(11 downto 0);          -- Register idx\n" +
                        "    i_dport_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0);-- Write value\n" +
                        "    o_dport_ready : out std_logic;                            -- Response is ready\n" +
                        "    o_dport_rdata : out std_logic_vector(RISCV_ARCH-1 downto 0);-- Response value\n" +
                        "    -- CPU debugging signals:\n" +
                        "    o_core_addr : out std_logic_vector(11 downto 0);          -- Address of the sub-region register\n" +
                        "    o_core_wdata : out std_logic_vector(RISCV_ARCH-1 downto 0);-- Write data\n" +
                        "    o_csr_ena : out std_logic;                                -- Region 0: Access to CSR bank is enabled.\n" +
                        "    o_csr_write : out std_logic;                              -- Region 0: CSR write enable\n" +
                        "    i_csr_rdata : in std_logic_vector(RISCV_ARCH-1 downto 0); -- Region 0: CSR read value\n" +
                        "    o_ireg_ena : out std_logic;                               -- Region 1: Access to integer register bank is enabled\n" +
                        "    o_ireg_write : out std_logic;                             -- Region 1: Integer registers bank write pulse\n" +
                        "    o_freg_ena : out std_logic;                               -- Region 1: Access to float register bank is enabled\n" +
                        "    o_freg_write : out std_logic;                             -- Region 1: Float registers bank write pulse\n" +
                        "    o_npc_write : out std_logic;                              -- Region 1: npc write enable\n" +
                        "    i_ireg_rdata : in std_logic_vector(RISCV_ARCH-1 downto 0);-- Region 1: Integer register read value\n" +
                        "    i_freg_rdata : in std_logic_vector(RISCV_ARCH-1 downto 0);-- Region 1: Float register read value\n" +
                        "    i_pc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);    -- Region 1: Instruction pointer\n" +
                        "    i_npc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);   -- Region 1: Next Instruction pointer\n" +
                        "    i_e_valid : in std_logic;                                 -- Stepping control signal\n" +
                        "    i_e_call : in std_logic;                                  -- pseudo-instruction CALL\n" +
                        "    i_e_ret : in std_logic;                                   -- pseudo-instruction RET\n" +
                        "    i_m_valid : in std_logic;                                 -- To compute number of valid executed instruction\n" +
                        "    o_clock_cnt : out std_logic_vector(63 downto 0);          -- Number of clocks excluding halt state\n" +
                        "    o_executed_cnt : out std_logic_vector(63 downto 0);       -- Number of executed instructions\n" +
                        "    o_halt : out std_logic;                                   -- Halt signal is equal to hold pipeline\n" +
                        "    i_ebreak : in std_logic;                                  -- ebreak instruction decoded\n" +
                        "    o_break_mode : out std_logic;                             -- Behaviour on EBREAK instruction: 0 = halt; 1 = generate trap\n" +
                        "    o_br_fetch_valid : out std_logic;                         -- Fetch injection address/instr are valid\n" +
                        "    o_br_address_fetch : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0); -- Fetch injection address to skip ebreak instruciton only once\n" +
                        "    o_br_instr_fetch : out std_logic_vector(31 downto 0);     -- Real instruction value that was replaced by ebreak\n" +
                        "    o_flush_address : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);  -- Address of instruction to remove from ICache\n" +
                        "    o_flush_valid : out std_logic;                            -- Remove address from ICache is valid\n" +
                        "    -- Debug signals:\n" +
                        "    i_istate : in std_logic_vector(1 downto 0);               -- ICache state machine value\n" +
                        "    i_dstate : in std_logic_vector(1 downto 0);               -- DCache state machine value\n" +
                        "    i_cstate : in std_logic_vector(1 downto 0);               -- CacheTop state machine value\n" +
                        "    i_instr_buf : in std_logic_vector(DBG_FETCH_TRACE_SIZE*64-1 downto 0) -- trace last fetched instructions\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_DbgPort of DbgPort is\n" +
                        "\n" +
                        "  constant zero64 : std_logic_vector(63 downto 0) := (others => '0');\n" +
                        "  constant one64 : std_logic_vector(63 downto 0) := X\"0000000000000001\";\n" +
                        "  constant STACKTR_ADRSZ : integer := log2(CFG_STACK_TRACE_BUF_SIZE);\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "      ready : std_logic;\n" +
                        "      halt : std_logic;\n" +
                        "      breakpoint : std_logic;\n" +
                        "      stepping_mode : std_logic;\n" +
                        "      stepping_mode_cnt : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "      trap_on_break : std_logic;\n" +
                        "      br_address_fetch : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      br_instr_fetch : std_logic_vector(31 downto 0);\n" +
                        "      br_fetch_valid : std_logic;\n" +
                        "      flush_address : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      flush_valid : std_logic;\n" +
                        "\n" +
                        "      rdata : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "      stepping_mode_steps : std_logic_vector(RISCV_ARCH-1 downto 0); -- Number of steps before halt in stepping mode\n" +
                        "      clock_cnt : std_logic_vector(63 downto 0);               -- Timer in clocks.\n" +
                        "      executed_cnt : std_logic_vector(63 downto 0);            -- Number of valid executed instructions\n" +
                        "      stack_trace_cnt : integer range 0 to CFG_STACK_TRACE_BUF_SIZE-1; -- Stack trace buffer counter\n" +
                        "      rd_trbuf_ena : std_logic;\n" +
                        "      rd_trbuf_addr0 : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "    '0', '0', '0',                          -- ready, halt, breakpoint\n" +
                        "    '0', (others => '0'), '0',              -- stepping_mode. stepping_mode_cnt, trap_on_break\n" +
                        "    (others => '0'), (others => '0'), '0',  -- br_address_fetch, br_instr_fetch, br_fetch_valid\n" +
                        "    (others => '0'), '0',                   -- flush_address, flush_valid\n" +
                        "    (others => '0'), (others => '0'),       -- rdata, stepping_mode_steps\n" +
                        "    (others => '0'), (others => '0'),       -- clock_cnt, executed_cnt\n" +
                        "    0, '0', '0'                             -- stack_trace_cnt, rd_trbuf_ena, rd_trbuf_addr0\n" +
                        "  );\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "  signal wb_stack_raddr : std_logic_vector(STACKTR_ADRSZ-1 downto 0);\n" +
                        "  signal wb_stack_rdata : std_logic_vector(2*BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "  signal w_stack_we : std_logic;\n" +
                        "  signal wb_stack_waddr : std_logic_vector(STACKTR_ADRSZ-1 downto 0);\n" +
                        "  signal wb_stack_wdata : std_logic_vector(2*BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "\n" +
                        "  component StackTraceBuffer is\n" +
                        "  generic (\n" +
                        "    abits : integer := 5;\n" +
                        "    dbits : integer := 64\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk   : in std_logic;\n" +
                        "    i_raddr : in std_logic_vector(abits-1 downto 0);\n" +
                        "    o_rdata : out std_logic_vector(dbits-1 downto 0);\n" +
                        "    i_we    : in std_logic;\n" +
                        "    i_waddr : in std_logic_vector(abits-1 downto 0);\n" +
                        "    i_wdata : in std_logic_vector(dbits-1 downto 0)\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "\n" +
                        "  stacktr_ena : if CFG_STACK_TRACE_BUF_SIZE /= 0 generate \n" +
                        "    stacktr0 : StackTraceBuffer generic map (\n" +
                        "      abits => STACKTR_ADRSZ,\n" +
                        "      dbits => 2*BUS_ADDR_WIDTH\n" +
                        "    ) port map (\n" +
                        "      i_clk   => i_clk,\n" +
                        "      i_raddr => wb_stack_raddr,\n" +
                        "      o_rdata => wb_stack_rdata,\n" +
                        "      i_we    => w_stack_we,\n" +
                        "      i_waddr => wb_stack_waddr,\n" +
                        "      i_wdata => wb_stack_wdata\n" +
                        "    );\n" +
                        "  end generate;\n" +
                        "\n" +
                        "  comb : process(i_nrst, i_dport_valid, i_dport_write, i_dport_region, \n" +
                        "                 i_dport_addr, i_dport_wdata, i_ireg_rdata, i_freg_rdata,\n" +
                        "                 i_csr_rdata, i_pc, i_npc, i_e_valid, i_m_valid, i_ebreak, r,\n" +
                        "                 wb_stack_rdata, i_e_call, i_e_ret, i_istate, i_dstate,\n" +
                        "                 i_cstate, i_instr_buf)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable wb_o_core_addr : std_logic_vector(11 downto 0);\n" +
                        "    variable wb_o_core_wdata : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable wb_rdata : std_logic_vector(63 downto 0);\n" +
                        "    variable wb_o_rdata : std_logic_vector(63 downto 0);\n" +
                        "    variable wb_idx : integer range 0 to 4095;\n" +
                        "    variable w_o_csr_ena : std_logic;\n" +
                        "    variable w_o_csr_write : std_logic;\n" +
                        "    variable w_o_ireg_ena : std_logic;\n" +
                        "    variable w_o_ireg_write : std_logic;\n" +
                        "    variable w_o_freg_ena : std_logic;\n" +
                        "    variable w_o_freg_write : std_logic;\n" +
                        "    variable w_o_npc_write : std_logic;\n" +
                        "    variable w_cur_halt : std_logic;\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    wb_o_core_addr := (others => '0');\n" +
                        "    wb_o_core_wdata := (others => '0');\n" +
                        "    wb_rdata := (others => '0');\n" +
                        "    wb_o_rdata := (others => '0');\n" +
                        "    wb_idx := conv_integer(i_dport_addr);\n" +
                        "    w_o_csr_ena := '0';\n" +
                        "    w_o_csr_write := '0';\n" +
                        "    w_o_ireg_ena := '0';\n" +
                        "    w_o_ireg_write := '0';\n" +
                        "    w_o_freg_ena := '0';\n" +
                        "    w_o_freg_write := '0';\n" +
                        "    w_o_npc_write := '0';\n" +
                        "    v.br_fetch_valid := '0';\n" +
                        "    v.flush_valid := '0';\n" +
                        "    v.rd_trbuf_ena := '0';\n" +
                        "    wb_stack_raddr <= (others => '0');\n" +
                        "    w_stack_we <= '0';\n" +
                        "    wb_stack_waddr <= (others => '0');\n" +
                        "    wb_stack_wdata <= (others => '0');\n" +
                        "\n" +
                        "    v.ready := i_dport_valid;\n" +
                        "\n" +
                        "    w_cur_halt := '0';\n" +
                        "    if i_e_valid = '1' then\n" +
                        "        if r.stepping_mode_cnt /= zero64(RISCV_ARCH-1 downto 0) then\n" +
                        "            v.stepping_mode_cnt := r.stepping_mode_cnt - 1;\n" +
                        "            if r.stepping_mode_cnt = one64 then\n" +
                        "                v.halt := '1';\n" +
                        "                w_cur_halt := '1';\n" +
                        "                v.stepping_mode := '0';\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if r.halt = '0' then\n" +
                        "        v.clock_cnt := r.clock_cnt + 1;\n" +
                        "    end if;\n" +
                        "    if i_m_valid = '1' then\n" +
                        "        v.executed_cnt := r.executed_cnt + 1;\n" +
                        "    end if;\n" +
                        "    if i_ebreak = '1' then\n" +
                        "        v.breakpoint := '1';\n" +
                        "        if r.trap_on_break = '0' then\n" +
                        "            v.halt := '1';\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if CFG_STACK_TRACE_BUF_SIZE /= 0 then\n" +
                        "        if i_e_call = '1' and r.stack_trace_cnt /= (CFG_STACK_TRACE_BUF_SIZE - 1) then\n" +
                        "            w_stack_we <= '1';\n" +
                        "            wb_stack_waddr <= conv_std_logic_vector(r.stack_trace_cnt, STACKTR_ADRSZ);\n" +
                        "            wb_stack_wdata <= i_npc & i_pc;\n" +
                        "            v.stack_trace_cnt := r.stack_trace_cnt + 1;\n" +
                        "        elsif i_e_ret = '1' and r.stack_trace_cnt /= 0 then\n" +
                        "            v.stack_trace_cnt := r.stack_trace_cnt - 1;\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if i_dport_valid = '1' then\n" +
                        "        case i_dport_region is\n" +
                        "        when \"00\" =>\n" +
                        "            w_o_csr_ena := '1';\n" +
                        "            wb_o_core_addr := i_dport_addr;\n" +
                        "            wb_rdata := i_csr_rdata;\n" +
                        "            if i_dport_write = '1' then\n" +
                        "                w_o_csr_write := '1';\n" +
                        "                wb_o_core_wdata := i_dport_wdata;\n" +
                        "            end if;\n" +
                        "        when \"01\" =>\n" +
                        "            if wb_idx < 32 then\n" +
                        "                w_o_ireg_ena := '1';\n" +
                        "                wb_o_core_addr := i_dport_addr;\n" +
                        "                wb_rdata := i_ireg_rdata;\n" +
                        "                if i_dport_write = '1' then\n" +
                        "                    w_o_ireg_write := '1';\n" +
                        "                    wb_o_core_wdata := i_dport_wdata;\n" +
                        "                end if;\n" +
                        "            elsif wb_idx = 32 then\n" +
                        "                --! Read only register\n" +
                        "                wb_rdata(BUS_ADDR_WIDTH-1 downto 0) := i_pc;\n" +
                        "            elsif wb_idx = 33 then\n" +
                        "                wb_rdata(BUS_ADDR_WIDTH-1 downto 0) := i_npc;\n" +
                        "                if i_dport_write = '1' then\n" +
                        "                    w_o_npc_write := '1';\n" +
                        "                    wb_o_core_wdata := i_dport_wdata;\n" +
                        "                end if;\n" +
                        "            elsif wb_idx = 34 then\n" +
                        "                wb_rdata(STACKTR_ADRSZ-1 downto 0) := \n" +
                        "							conv_std_logic_vector(r.stack_trace_cnt, STACKTR_ADRSZ);\n" +
                        "                if i_dport_write = '1' then\n" +
                        "                    v.stack_trace_cnt := conv_integer(i_dport_wdata);\n" +
                        "                end if;\n" +
                        "            elsif (wb_idx >= 64) and (wb_idx < 96) then\n" +
                        "                w_o_freg_ena := '1';\n" +
                        "                wb_o_core_addr := i_dport_addr;\n" +
                        "                wb_rdata := i_freg_rdata;\n" +
                        "                if i_dport_write = '1' then\n" +
                        "                    w_o_freg_write := '1';\n" +
                        "                    wb_o_core_wdata := i_dport_wdata;\n" +
                        "                end if;\n" +
                        "            elsif (wb_idx >= 128) and (wb_idx < (128 + 2 * CFG_STACK_TRACE_BUF_SIZE)) then\n" +
                        "                    v.rd_trbuf_ena := '1';\n" +
                        "                    v.rd_trbuf_addr0 := conv_std_logic_vector(wb_idx, 1)(0);\n" +
                        "                    wb_stack_raddr <= conv_std_logic_vector((wb_idx - 128) / 2, STACKTR_ADRSZ);\n" +
                        "            elsif wb_idx = 256 then\n" +
                        "                wb_rdata := i_instr_buf(63 downto 0);\n" +
                        "            elsif wb_idx = 257 then\n" +
                        "                wb_rdata := i_instr_buf(127 downto 64);\n" +
                        "            elsif wb_idx = 258 then\n" +
                        "                wb_rdata := i_instr_buf(191 downto 128);\n" +
                        "            elsif wb_idx = 259 then\n" +
                        "                wb_rdata := i_instr_buf(255 downto 192);\n" +
                        "            end if;\n" +
                        "        when \"10\" =>\n" +
                        "            case wb_idx is\n" +
                        "            when 0 =>\n" +
                        "                wb_rdata(0) := r.halt;\n" +
                        "                wb_rdata(2) := r.breakpoint;\n" +
                        "                wb_rdata(33 downto 32) := i_istate;\n" +
                        "                wb_rdata(37 downto 36) := i_dstate;\n" +
                        "                wb_rdata(41 downto 40) := i_cstate;\n" +
                        "                if i_dport_write = '1' then\n" +
                        "                    v.halt := i_dport_wdata(0);\n" +
                        "                    v.stepping_mode := i_dport_wdata(1);\n" +
                        "                    if i_dport_wdata(1) = '1' then\n" +
                        "                        v.stepping_mode_cnt := r.stepping_mode_steps;\n" +
                        "                    end if;\n" +
                        "                end if;\n" +
                        "            when 1 =>\n" +
                        "                wb_rdata := r.stepping_mode_steps;\n" +
                        "                if i_dport_write = '1' then\n" +
                        "                    v.stepping_mode_steps := i_dport_wdata;\n" +
                        "                end if;\n" +
                        "            when 2 =>\n" +
                        "                wb_rdata := r.clock_cnt;\n" +
                        "            when 3 =>\n" +
                        "                wb_rdata := r.executed_cnt;\n" +
                        "            when 4 =>\n" +
                        "                --! Trap on instruction:\n" +
                        "                --!      0 = Halt pipeline on ECALL instruction\n" +
                        "                --!      1 = Generate trap on ECALL instruction\n" +
                        "                wb_rdata(0) := r.trap_on_break;\n" +
                        "                if i_dport_write = '1' then\n" +
                        "                    v.trap_on_break := i_dport_wdata(0);\n" +
                        "                end if;\n" +
                        "            when 5 =>\n" +
                        "                -- todo: add hardware breakpoint\n" +
                        "            when 6 =>\n" +
                        "                -- todo: remove hardware breakpoint\n" +
                        "            when 7 =>\n" +
                        "                wb_rdata(BUS_ADDR_WIDTH-1 downto 0) := r.br_address_fetch;\n" +
                        "                if i_dport_write = '1' then\n" +
                        "                    v.br_address_fetch := i_dport_wdata(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "                end if;\n" +
                        "            when 8 =>\n" +
                        "                wb_rdata(31 downto 0) := r.br_instr_fetch;\n" +
                        "                if i_dport_write = '1' then\n" +
                        "                    v.br_fetch_valid := '1';\n" +
                        "                    v.breakpoint := '0';\n" +
                        "                    v.br_instr_fetch := i_dport_wdata(31 downto 0);\n" +
                        "                end if;\n" +
                        "            when 9 =>\n" +
                        "                wb_rdata(BUS_ADDR_WIDTH-1 downto 0) := r.flush_address;\n" +
                        "                if i_dport_write = '1' then\n" +
                        "                    v.flush_valid := '1';\n" +
                        "                    v.flush_address := i_dport_wdata(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "                end if;\n" +
                        "            when others =>\n" +
                        "            end case;\n" +
                        "        when others =>\n" +
                        "        end case;\n" +
                        "    end if;\n" +
                        "    v.rdata := wb_rdata;\n" +
                        "    if r.rd_trbuf_ena = '1' then\n" +
                        "        if r.rd_trbuf_addr0 = '0' then\n" +
                        "            wb_o_rdata(BUS_ADDR_WIDTH-1 downto 0) :=\n" +
                        "					wb_stack_rdata(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "        else\n" +
                        "            wb_o_rdata(BUS_ADDR_WIDTH-1 downto 0) :=\n" +
                        "					wb_stack_rdata(2*BUS_ADDR_WIDTH-1 downto BUS_ADDR_WIDTH);\n" +
                        "        end if;\n" +
                        "    else\n" +
                        "        wb_o_rdata := r.rdata;\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    rin <= v;\n" +
                        "\n" +
                        "    o_core_addr <= wb_o_core_addr;\n" +
                        "    o_core_wdata <= wb_o_core_wdata;\n" +
                        "    o_csr_ena <= w_o_csr_ena;\n" +
                        "    o_csr_write <= w_o_csr_write;\n" +
                        "    o_ireg_ena <= w_o_ireg_ena;\n" +
                        "    o_ireg_write <= w_o_ireg_write;\n" +
                        "    o_freg_ena <= w_o_freg_ena;\n" +
                        "    o_freg_write <= w_o_freg_write;\n" +
                        "    o_npc_write <= w_o_npc_write;\n" +
                        "    o_clock_cnt <= r.clock_cnt;\n" +
                        "    o_executed_cnt <= r.executed_cnt;\n" +
                        "    o_halt <= r.halt or w_cur_halt;\n" +
                        "    o_break_mode <= r.trap_on_break;\n" +
                        "    o_br_fetch_valid <= r.br_fetch_valid;\n" +
                        "    o_br_address_fetch <= r.br_address_fetch;\n" +
                        "    o_br_instr_fetch <= r.br_instr_fetch;\n" +
                        "    o_flush_address <= r.flush_address;\n" +
                        "    o_flush_valid <= r.flush_valid;\n" +
                        "\n" +
                        "    o_dport_ready <= r.ready;\n" +
                        "    o_dport_rdata <= wb_o_rdata;\n" +
                        "  end process;\n" +
                        "\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(i_clk, i_nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_csr_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.std_logic_misc.all;  -- or_reduce()\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "--library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use work.river_cfg.all;\n" +
                        "\n" +
                        "entity CsrRegs is \n" +
                        "  generic (\n" +
                        "    hartid : integer;\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;                                   -- CPU clock\n" +
                        "    i_nrst : in std_logic;                                  -- Reset. Active LOW.\n" +
                        "    i_mret : in std_logic;                                  -- mret instruction signals mode switching\n" +
                        "    i_uret : in std_logic;                                  -- uret instruction signals mode switching\n" +
                        "    i_sp : in std_logic_vector(RISCV_ARCH-1 downto 0);      -- Stack Pointer for the borders control\n" +
                        "    i_addr : in std_logic_vector(11 downto 0);              -- CSR address, if xret=1 switch mode accordingly\n" +
                        "    i_wena : in std_logic;                                  -- Write enable\n" +
                        "    i_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0);   -- CSR writing value\n" +
                        "    o_rdata : out std_logic_vector(RISCV_ARCH-1 downto 0);  -- CSR read value\n" +
                        "    i_trap_ready : in std_logic;                            -- Trap branch request was accepted\n" +
                        "    i_ex_pc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_ex_npc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_ex_data_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);-- Data path: address must be equal to the latest request address\n" +
                        "    i_ex_data_load_fault : in std_logic;                    -- Data path: Bus response with SLVERR or DECERR on read\n" +
                        "    i_ex_data_store_fault : in std_logic;                   -- Data path: Bus response with SLVERR or DECERR on write\n" +
                        "    i_ex_data_store_fault_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_ex_ctrl_load_fault : in std_logic;\n" +
                        "    i_ex_illegal_instr : in std_logic;\n" +
                        "    i_ex_unalign_store : in std_logic;\n" +
                        "    i_ex_unalign_load : in std_logic;\n" +
                        "    i_ex_breakpoint : in std_logic;\n" +
                        "    i_ex_ecall : in std_logic;\n" +
                        "    i_ex_fpu_invalidop : in std_logic;         -- FPU Exception: invalid operation\n" +
                        "    i_ex_fpu_divbyzero : in std_logic;         -- FPU Exception: divide by zero\n" +
                        "    i_ex_fpu_overflow : in std_logic;          -- FPU Exception: overflow\n" +
                        "    i_ex_fpu_underflow : in std_logic;         -- FPU Exception: underflow\n" +
                        "    i_ex_fpu_inexact : in std_logic;           -- FPU Exception: inexact\n" +
                        "    i_fpu_valid : in std_logic;                -- FPU output is valid\n" +
                        "    i_irq_external : in std_logic;\n" +
                        "    o_trap_valid : out std_logic;                              -- Trap pulse\n" +
                        "    o_trap_pc : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);-- trap on pc\n" +
                        "\n" +
                        "    i_break_mode : in std_logic;                            -- Behaviour on EBREAK instruction: 0 = halt; 1 = generate trap\n" +
                        "    o_break_event : out std_logic;                          -- 1 clock EBREAK detected\n" +
                        "\n" +
                        "    i_dport_ena : in std_logic;                              -- Debug port request is enabled\n" +
                        "    i_dport_write : in std_logic;                            -- Debug port Write enable\n" +
                        "    i_dport_addr : in std_logic_vector(11 downto 0);         -- Debug port CSR address\n" +
                        "    i_dport_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0);-- Debug port CSR writing value\n" +
                        "    o_dport_rdata : out std_logic_vector(RISCV_ARCH-1 downto 0)-- Debug port CSR read value\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_CsrRegs of CsrRegs is\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "      mtvec : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "      mscratch : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "      mstackovr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      mstackund : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      mbadaddr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      mode : std_logic_vector(1 downto 0);\n" +
                        "      uie : std_logic;                       -- User level interrupts ena for current priv. mode\n" +
                        "      mie : std_logic;                       -- Machine level interrupts ena for current priv. mode\n" +
                        "      mpie : std_logic;                      -- Previous MIE value\n" +
                        "      mstackovr_ena : std_logic;             -- Stack Overflow control enabled\n" +
                        "      mstackund_ena : std_logic;             -- Stack Underflow control enabled\n" +
                        "      mpp : std_logic_vector(1 downto 0);    -- Previous mode\n" +
                        "      mepc : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "      ext_irq : std_logic;\n" +
                        "\n" +
                        "      ex_fpu_invalidop : std_logic;          -- FPU Exception: invalid operation\n" +
                        "      ex_fpu_divbyzero : std_logic;          -- FPU Exception: divide by zero\n" +
                        "      ex_fpu_overflow : std_logic;           -- FPU Exception: overflow\n" +
                        "      ex_fpu_underflow : std_logic;          -- FPU Exception: underflow\n" +
                        "      ex_fpu_inexact : std_logic;            -- FPU Exception: inexact\n" +
                        "      trap_irq : std_logic;\n" +
                        "      trap_code : std_logic_vector(4 downto 0);\n" +
                        "      trap_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      break_event : std_logic;\n" +
                        "      hold_data_store_fault : std_logic;\n" +
                        "      hold_data_load_fault : std_logic;\n" +
                        "      hold_mbadaddr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "        (others => '0'), -- mtvec\n" +
                        "        (others => '0'), -- mscratch\n" +
                        "        (others => '0'), -- mstackovr\n" +
                        "        (others => '0'), -- mstackund\n" +
                        "        (others => '0'), -- mbadaddr\n" +
                        "        PRV_M,           -- mode\n" +
                        "        '0', '0', '0',\n" +
                        "        '0',             -- mstackovr_ena\n" +
                        "        '0',             -- mstackund_ena\n" +
                        "        (others => '0'), (others => '0'), '0',\n" +
                        "        '0', '0', '0', '0', '0', \n" +
                        "        '0', (others => '0'), (others => '0'), '0',\n" +
                        "        '0', '0', (others => '0'));\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "  \n" +
                        "  procedure procedure_RegAccess(\n" +
                        "     iaddr  : in std_logic_vector(11 downto 0);\n" +
                        "     iwena  : in std_logic;\n" +
                        "     iwdata : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "     ir : in RegistersType;\n" +
                        "     ov : out RegistersType;\n" +
                        "     ordata : out std_logic_vector(RISCV_ARCH-1 downto 0)) is\n" +
                        "  begin\n" +
                        "    ov := ir;\n" +
                        "    ordata := (others => '0');\n" +
                        "    case iaddr is\n" +
                        "    when CSR_fflags =>\n" +
                        "        ordata(0) := ir.ex_fpu_inexact;\n" +
                        "        ordata(1) := ir.ex_fpu_underflow;\n" +
                        "        ordata(2) := ir.ex_fpu_overflow;\n" +
                        "        ordata(3) := ir.ex_fpu_divbyzero;\n" +
                        "        ordata(4) := ir.ex_fpu_invalidop;\n" +
                        "        if CFG_HW_FPU_ENABLE then\n" +
                        "            if iwena = '1' then\n" +
                        "                ov.ex_fpu_inexact := iwdata(0);\n" +
                        "                ov.ex_fpu_underflow := iwdata(1);\n" +
                        "                ov.ex_fpu_overflow := iwdata(2);\n" +
                        "                ov.ex_fpu_divbyzero := iwdata(3);\n" +
                        "                ov.ex_fpu_invalidop := iwdata(4);\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    when CSR_frm =>\n" +
                        "        if CFG_HW_FPU_ENABLE then\n" +
                        "            ordata(2 downto 0) := \"100\";  -- Round mode: round to Nearest (RMM)\n" +
                        "        end if;\n" +
                        "    when CSR_fcsr =>\n" +
                        "        ordata(0) := ir.ex_fpu_inexact;\n" +
                        "        ordata(1) := ir.ex_fpu_underflow;\n" +
                        "        ordata(2) := ir.ex_fpu_overflow;\n" +
                        "        ordata(3) := ir.ex_fpu_divbyzero;\n" +
                        "        ordata(4) := ir.ex_fpu_invalidop;\n" +
                        "        if CFG_HW_FPU_ENABLE then\n" +
                        "            ordata(7 downto 5) := \"100\";  -- Round mode: round to Nearest (RMM)\n" +
                        "            if iwena = '1' then\n" +
                        "                ov.ex_fpu_inexact := iwdata(0);\n" +
                        "                ov.ex_fpu_underflow := iwdata(1);\n" +
                        "                ov.ex_fpu_overflow := iwdata(2);\n" +
                        "                ov.ex_fpu_divbyzero := iwdata(3);\n" +
                        "                ov.ex_fpu_invalidop := iwdata(4);\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    when CSR_misa =>\n" +
                        "        --! Base[XLEN-1:XLEN-2]\n" +
                        "        --!     1 = 32\n" +
                        "        --!     2 = 64\n" +
                        "        --!     3 = 128\n" +
                        "        --!\n" +
                        "        ordata(RISCV_ARCH-1 downto RISCV_ARCH-2) := \"10\";\n" +
                        "        --! BitCharacterDescription\n" +
                        "        --! 0  A Atomic extension\n" +
                        "        --! 1  B Tentatively reserved for Bit operations extension\n" +
                        "        --! 2  C Compressed extension\n" +
                        "        --! 3  D Double-precision Foating-point extension\n" +
                        "        --! 4  E RV32E base ISA (embedded)\n" +
                        "        --! 5  F Single-precision Foating-point extension\n" +
                        "        --! 6  G Additional standard extensions present\n" +
                        "        --! 7  H Hypervisor mode implemented\n" +
                        "        --! 8  I RV32I/64I/128I base ISA\n" +
                        "        --! 9  J Reserved\n" +
                        "        --! 10 K Reserved\n" +
                        "        --! 11 L Tentatively reserved for Decimal Floating-Point extension\n" +
                        "        --! 12 M Integer Multiply/Divide extension\n" +
                        "        --! 13 N User-level interrupts supported\n" +
                        "        --! 14 O Reserved\n" +
                        "        --! 15 P Tentatively reserved for Packed-SIMD extension\n" +
                        "        --! 16 Q Quad-precision Foating-point extension\n" +
                        "        --! 17 R Reserved\n" +
                        "        --! 18 S Supervisor mode implemented\n" +
                        "        --! 19 T Tentatively reserved for Transactional Memory extension\n" +
                        "        --! 20 U User mode implemented\n" +
                        "        --! 21 V Tentatively reserved for Vector extension\n" +
                        "        --! 22 W Reserved\n" +
                        "        --! 23 X Non-standard extensions present\n" +
                        "        --! 24 Y Reserved\n" +
                        "        --! 25 Z Reserve\n" +
                        "        --!\n" +
                        "        ordata(8) := '1';\n" +
                        "        ordata(12) := '1';\n" +
                        "        ordata(20) := '1';\n" +
                        "        ordata(2) := '1';\n" +
                        "        if CFG_HW_FPU_ENABLE then\n" +
                        "            ordata(3) := '1';\n" +
                        "        end if;\n" +
                        "    when CSR_mvendorid =>\n" +
                        "        ordata(31 downto 0) := CFG_VENDOR_ID;\n" +
                        "    when CSR_marchid =>\n" +
                        "    when CSR_mimplementationid =>\n" +
                        "        ordata(31 downto 0) := CFG_IMPLEMENTATION_ID;\n" +
                        "    when CSR_mhartid =>\n" +
                        "        ordata(31 downto 0) := conv_std_logic_vector(hartid, 32);\n" +
                        "    when CSR_uepc =>    -- User mode program counter\n" +
                        "    when CSR_mstatus => -- Machine mode status register\n" +
                        "        ordata(0) := ir.uie;\n" +
                        "        ordata(3) := ir.mie;\n" +
                        "        ordata(7) := ir.mpie;\n" +
                        "        ordata(12 downto 11) := ir.mpp;\n" +
                        "        if CFG_HW_FPU_ENABLE then\n" +
                        "            ordata(14 downto 13) := \"01\";  -- FS field: Initial state\n" +
                        "        end if;\n" +
                        "        ordata(33 downto 32) := \"10\";  -- UXL: User mode supported 64-bits\n" +
                        "        if iwena = '1' then\n" +
                        "            ov.uie := iwdata(0);\n" +
                        "            ov.mie := iwdata(3);\n" +
                        "            ov.mpie := iwdata(7);\n" +
                        "            ov.mpp := iwdata(12 downto 11);\n" +
                        "        end if;\n" +
                        "    when CSR_medeleg => -- Machine exception delegation\n" +
                        "    when CSR_mideleg => -- Machine interrupt delegation\n" +
                        "    when CSR_mie =>     -- Machine interrupt enable bit\n" +
                        "    when CSR_mtvec =>\n" +
                        "        ordata := ir.mtvec;\n" +
                        "        if iwena = '1' then\n" +
                        "            ov.mtvec := iwdata;\n" +
                        "        end if;\n" +
                        "    when CSR_mtimecmp => -- Machine wall-clock timer compare value\n" +
                        "    when CSR_mscratch => -- Machine scratch register\n" +
                        "        ordata := ir.mscratch;\n" +
                        "        if iwena = '1' then\n" +
                        "            ov.mscratch := iwdata;\n" +
                        "        end if;\n" +
                        "    when CSR_mepc => -- Machine program counter\n" +
                        "        ordata := ir.mepc;\n" +
                        "        if iwena = '1' then\n" +
                        "            ov.mepc := iwdata;\n" +
                        "        end if;\n" +
                        "    when CSR_mcause => -- Machine trap cause\n" +
                        "        ordata(63) := ir.trap_irq;\n" +
                        "        ordata(4 downto 0) := ir.trap_code;\n" +
                        "    when CSR_mbadaddr =>   -- Machine bad address\n" +
                        "        ordata(BUS_ADDR_WIDTH-1 downto 0) := ir.mbadaddr;\n" +
                        "    when CSR_mip =>        -- Machine interrupt pending\n" +
                        "    when CSR_mstackovr =>  -- Machine stack overflow\n" +
                        "        ordata(BUS_ADDR_WIDTH-1 downto 0) := ir.mstackovr;\n" +
                        "        if iwena = '1' then\n" +
                        "            ov.mstackovr := iwdata(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "            ov.mstackovr_ena := or_reduce(iwdata(BUS_ADDR_WIDTH-1 downto 0));\n" +
                        "        end if;\n" +
                        "    when CSR_mstackund =>  -- Machine stack underflow\n" +
                        "        ordata(BUS_ADDR_WIDTH-1 downto 0) := ir.mstackund;\n" +
                        "        if iwena = '1' then\n" +
                        "            ov.mstackund := iwdata(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "            ov.mstackund_ena := or_reduce(iwdata(BUS_ADDR_WIDTH-1 downto 0));\n" +
                        "        end if;\n" +
                        "    when others =>\n" +
                        "    end case;\n" +
                        "  end;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  comb : process(i_nrst, i_mret, i_uret, i_sp, i_addr, i_wena, i_wdata, i_trap_ready,\n" +
                        "                 i_ex_pc, i_ex_npc, i_ex_data_addr, i_ex_data_load_fault, i_ex_data_store_fault,\n" +
                        "                 i_ex_data_store_fault_addr,\n" +
                        "                 i_ex_ctrl_load_fault, i_ex_illegal_instr, i_ex_unalign_load, i_ex_unalign_store,\n" +
                        "                 i_ex_breakpoint, i_ex_ecall, \n" +
                        "                 i_ex_fpu_invalidop, i_ex_fpu_divbyzero, i_ex_fpu_overflow,\n" +
                        "                 i_ex_fpu_underflow, i_ex_fpu_inexact, i_fpu_valid, i_irq_external,\n" +
                        "                 i_break_mode, i_dport_ena, i_dport_write, i_dport_addr, i_dport_wdata,\n" +
                        "                 r)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable wb_rdata : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable wb_dport_rdata : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable w_ie : std_logic;\n" +
                        "    variable w_ext_irq : std_logic;\n" +
                        "    variable w_dport_wena : std_logic;\n" +
                        "    variable w_trap_valid : std_logic;\n" +
                        "    variable wb_trap_pc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable w_trap_irq : std_logic;\n" +
                        "    variable w_exception_xret : std_logic;\n" +
                        "    variable wb_trap_code : std_logic_vector(4 downto 0);\n" +
                        "    variable wb_mbadaddr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable w_mstackovr : std_logic;\n" +
                        "    variable w_mstackund : std_logic;\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    w_dport_wena := i_dport_ena and i_dport_write;\n" +
                        "\n" +
                        "    procedure_RegAccess(i_addr, i_wena, i_wdata,\n" +
                        "                        v, v, wb_rdata);\n" +
                        "\n" +
                        "    procedure_RegAccess(i_dport_addr, w_dport_wena,\n" +
                        "                        i_dport_wdata, v, v, wb_dport_rdata);\n" +
                        "\n" +
                        "    w_ie := '0';\n" +
                        "    if (r.mode /= PRV_M) or r.mie = '1' then\n" +
                        "        w_ie := '1';\n" +
                        "    end if;\n" +
                        "    w_ext_irq := i_irq_external and w_ie;\n" +
                        "    if i_trap_ready = '1' then\n" +
                        "        v.ext_irq := w_ext_irq;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_exception_xret := '0';\n" +
                        "    if (i_mret = '1' and r.mode /= PRV_M) or\n" +
                        "        (i_uret = '1' and r.mode /= PRV_U) then\n" +
                        "        w_exception_xret := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_mstackovr := '0';\n" +
                        "    if i_sp(BUS_ADDR_WIDTH-1 downto 0) < r.mstackovr then\n" +
                        "        w_mstackovr := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_mstackund := '0';\n" +
                        "    if i_sp(BUS_ADDR_WIDTH-1 downto 0) > r.mstackund then\n" +
                        "        w_mstackund := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if i_fpu_valid = '1' then\n" +
                        "        v.ex_fpu_invalidop := i_ex_fpu_invalidop;\n" +
                        "        v.ex_fpu_divbyzero := i_ex_fpu_divbyzero;\n" +
                        "        v.ex_fpu_overflow := i_ex_fpu_overflow;\n" +
                        "        v.ex_fpu_underflow := i_ex_fpu_underflow;\n" +
                        "        v.ex_fpu_inexact := i_ex_fpu_inexact;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_trap_valid := '0';\n" +
                        "    w_trap_irq := '0';\n" +
                        "    wb_trap_code := (others => '0');\n" +
                        "    v.break_event := '0';\n" +
                        "    wb_trap_pc := r.mtvec(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    wb_mbadaddr := i_ex_pc;\n" +
                        "\n" +
                        "    if i_ex_ctrl_load_fault = '1' then\n" +
                        "        w_trap_valid := '1';\n" +
                        "        wb_trap_pc := CFG_NMI_INSTR_FAULT_ADDR;\n" +
                        "        wb_trap_code := EXCEPTION_InstrFault;\n" +
                        "    elsif i_ex_illegal_instr = '1' or w_exception_xret = '1' then\n" +
                        "        w_trap_valid := '1';\n" +
                        "        wb_trap_pc := CFG_NMI_INSTR_ILLEGAL_ADDR;\n" +
                        "        wb_trap_code := EXCEPTION_InstrIllegal;\n" +
                        "    elsif i_ex_breakpoint = '1' then\n" +
                        "        v.break_event := '1';\n" +
                        "        w_trap_valid := '1';\n" +
                        "        wb_trap_code := EXCEPTION_Breakpoint;\n" +
                        "        if i_break_mode = '0' then\n" +
                        "            wb_trap_pc := i_ex_pc;\n" +
                        "        else\n" +
                        "            wb_trap_pc := CFG_NMI_BREAKPOINT_ADDR;\n" +
                        "        end if;\n" +
                        "    elsif i_ex_unalign_load = '1' then\n" +
                        "        w_trap_valid := '1';\n" +
                        "        wb_trap_pc := CFG_NMI_LOAD_UNALIGNED_ADDR;\n" +
                        "        wb_trap_code := EXCEPTION_LoadMisalign;\n" +
                        "    elsif i_ex_data_load_fault = '1' or r.hold_data_load_fault = '1' then\n" +
                        "        w_trap_valid := '1';\n" +
                        "        v.hold_data_load_fault := '0';\n" +
                        "        if i_trap_ready = '0' then\n" +
                        "            v.hold_data_load_fault := '1';\n" +
                        "        end if;\n" +
                        "        wb_trap_pc := CFG_NMI_LOAD_FAULT_ADDR;\n" +
                        "        if i_ex_data_load_fault = '1'  then\n" +
                        "            wb_mbadaddr := i_ex_data_addr;     -- miss-access read data address\n" +
                        "            v.hold_mbadaddr := i_ex_data_addr;\n" +
                        "        else\n" +
                        "            wb_mbadaddr := r.hold_mbadaddr;\n" +
                        "        end if;\n" +
                        "        wb_trap_code := EXCEPTION_LoadFault;\n" +
                        "    elsif i_ex_unalign_store = '1' then\n" +
                        "        w_trap_valid := '1';\n" +
                        "        wb_trap_pc := CFG_NMI_STORE_UNALIGNED_ADDR;\n" +
                        "        wb_trap_code := EXCEPTION_StoreMisalign;\n" +
                        "    elsif i_ex_data_store_fault = '1' or r.hold_data_store_fault = '1' then\n" +
                        "        w_trap_valid := '1';\n" +
                        "        v.hold_data_store_fault := '0';\n" +
                        "        if i_trap_ready = '0' then\n" +
                        "            v.hold_data_store_fault := '1';\n" +
                        "        end if;\n" +
                        "        wb_trap_pc := CFG_NMI_STORE_FAULT_ADDR;\n" +
                        "        if i_ex_data_store_fault = '1' then\n" +
                        "            wb_mbadaddr := i_ex_data_store_fault_addr;     -- miss-access write data address\n" +
                        "            v.hold_mbadaddr := i_ex_data_store_fault_addr;\n" +
                        "        else\n" +
                        "            wb_mbadaddr := r.hold_mbadaddr;\n" +
                        "        end if;\n" +
                        "        wb_trap_code := EXCEPTION_StoreFault;\n" +
                        "    elsif i_ex_ecall = '1' then\n" +
                        "        w_trap_valid := '1';\n" +
                        "        if r.mode = PRV_M then\n" +
                        "            wb_trap_pc := CFG_NMI_CALL_FROM_MMODE_ADDR;\n" +
                        "            wb_trap_code := EXCEPTION_CallFromMmode;\n" +
                        "        else\n" +
                        "            wb_trap_pc := CFG_NMI_CALL_FROM_UMODE_ADDR;\n" +
                        "            wb_trap_code := EXCEPTION_CallFromUmode;\n" +
                        "        end if;\n" +
                        "    elsif r.mstackovr_ena = '1' and w_mstackovr = '1' then\n" +
                        "        w_trap_valid := '1';\n" +
                        "        wb_trap_pc := CFG_NMI_STACK_OVERFLOW_ADDR;\n" +
                        "        wb_trap_code := EXCEPTION_StackOverflow;\n" +
                        "        if i_trap_ready = '1' then\n" +
                        "            v.mstackovr := (others => '0');\n" +
                        "            v.mstackovr_ena := '0';\n" +
                        "        end if;\n" +
                        "    elsif r.mstackund_ena = '1' and w_mstackund = '1' then\n" +
                        "        w_trap_valid := '1';\n" +
                        "        wb_trap_pc := CFG_NMI_STACK_UNDERFLOW_ADDR;\n" +
                        "        wb_trap_code := EXCEPTION_StackUnderflow;\n" +
                        "        if i_trap_ready = '1' then\n" +
                        "            v.mstackund := (others => '0');\n" +
                        "            v.mstackund_ena := '0';\n" +
                        "        end if;\n" +
                        "    elsif w_ext_irq = '1' and r.ext_irq = '0' then\n" +
                        "        w_trap_valid := '1';\n" +
                        "        wb_trap_pc := r.mtvec(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "        wb_trap_code := INTERRUPT_MExternal;\n" +
                        "        w_trap_irq := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if i_addr = CSR_mepc and (not w_exception_xret and (i_mret or i_uret)) = '1' then\n" +
                        "        -- Switch to previous mode\n" +
                        "        v.mie := r.mpie;\n" +
                        "        v.mpie := '1';\n" +
                        "        v.mode := r.mpp;\n" +
                        "        v.mpp := PRV_U;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Behaviour on EBREAK instruction defined by 'i_break_mode':\n" +
                        "    --     0 = halt;\n" +
                        "    --     1 = generate trap\n" +
                        "    if (w_trap_valid and i_trap_ready and (i_break_mode or not i_ex_breakpoint)) = '1' then\n" +
                        "        v.mie := '0';\n" +
                        "        v.mpp := r.mode;\n" +
                        "        v.mepc(RISCV_ARCH-1 downto BUS_ADDR_WIDTH) := (others => '0');\n" +
                        "        v.mepc(BUS_ADDR_WIDTH-1 downto 0) := i_ex_npc;\n" +
                        "        v.mbadaddr := wb_mbadaddr;\n" +
                        "        v.trap_code := wb_trap_code;\n" +
                        "        v.trap_irq := w_trap_irq;\n" +
                        "        v.mode := PRV_M;\n" +
                        "        case r.mode is\n" +
                        "        when PRV_U =>\n" +
                        "            v.mpie := r.uie;\n" +
                        "        when PRV_M =>\n" +
                        "            v.mpie := r.mie;\n" +
                        "        when others =>\n" +
                        "        end case;\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    o_trap_valid <= w_trap_valid;\n" +
                        "    o_trap_pc <= wb_trap_pc;\n" +
                        "    o_rdata <= wb_rdata;\n" +
                        "    o_dport_rdata <= wb_dport_rdata;\n" +
                        "    o_break_event <= r.break_event;\n" +
                        "    \n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(i_clk, i_nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_bp_predic_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "--library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use work.river_cfg.all;\n" +
                        "\n" +
                        "\n" +
                        "entity BranchPredictor is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;                              -- CPU clock\n" +
                        "    i_nrst : in std_logic;                             -- Reset. Active LOW.\n" +
                        "    i_req_mem_fire : in std_logic;                     -- Memory request was accepted\n" +
                        "    i_resp_mem_valid : in std_logic;                   -- Memory response from ICache is valid\n" +
                        "    i_resp_mem_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);-- Memory response address\n" +
                        "    i_resp_mem_data : in std_logic_vector(31 downto 0);-- Memory response value\n" +
                        "    i_e_npc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);  -- Valid instruction value awaited by 'Executor'\n" +
                        "    i_ra : in std_logic_vector(RISCV_ARCH-1 downto 0); -- Return address register value\n" +
                        "    o_npc_predict : out std_logic_vector(31 downto 0)  -- Predicted next instruction address\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_BranchPredictor of BranchPredictor is\n" +
                        "\n" +
                        "  type HistoryType is record\n" +
                        "      resp_pc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      resp_npc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "  end record;\n" +
                        "  constant history_none : HistoryType := (\n" +
                        "    (others => '1'), (others => '1')\n" +
                        "  );\n" +
                        "\n" +
                        "  type HistoryVector is array (0 to 2) of HistoryType;\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "      h : HistoryVector;\n" +
                        "      wait_resp : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "      (others => history_none), '0'\n" +
                        "  );\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  comb : process(i_nrst, i_req_mem_fire, i_resp_mem_valid, i_resp_mem_addr,\n" +
                        "                 i_resp_mem_data, i_e_npc, i_ra, r)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable vb_tmp : std_logic_vector(31 downto 0);\n" +
                        "    variable vb_npc_predicted : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable vb_pc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable vb_npc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable v_jal : std_logic;\n" +
                        "    variable vb_jal_off : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable vb_jal_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable v_branch : std_logic;\n" +
                        "    variable vb_branch_off : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable vb_branch_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable v_c_j : std_logic;\n" +
                        "    variable vb_c_j_off : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable vb_c_j_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable v_c_ret : std_logic;\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    vb_pc := r.h(0).resp_pc;\n" +
                        "    vb_tmp := i_resp_mem_data;\n" +
                        " \n" +
                        "    -- Unconditional jump \"J\"\n" +
                        "    vb_jal_off(BUS_ADDR_WIDTH-1 downto 20) := (others => vb_tmp(31));\n" +
                        "    vb_jal_off(19 downto 12) := vb_tmp(19 downto 12);\n" +
                        "    vb_jal_off(11) := vb_tmp(20);\n" +
                        "    vb_jal_off(10 downto 1) := vb_tmp(30 downto 21);\n" +
                        "    vb_jal_off(0) := '0';\n" +
                        "    vb_jal_addr := vb_pc + vb_jal_off;\n" +
                        "\n" +
                        "    v_jal := '0';\n" +
                        "    if vb_tmp(6 downto 0) = \"1101111\" then\n" +
                        "        if (vb_jal_addr /= r.h(1).resp_pc) and (vb_jal_addr /= r.h(2).resp_pc) then\n" +
                        "            v_jal := '1';\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Conditional branches \"BEQ\", \"BNE\", \"BLT\", \"BGE\", BLTU\", \"BGEU\"\n" +
                        "    -- Only negative offset leads to predicted jumps\n" +
                        "    if vb_tmp(31) = '1' then\n" +
                        "        vb_branch_off(BUS_ADDR_WIDTH-1 downto 12) := (others => '1');\n" +
                        "    else\n" +
                        "        vb_branch_off(BUS_ADDR_WIDTH-1 downto 12) := (others => '0');\n" +
                        "    end if;\n" +
                        "    vb_branch_off(11) := vb_tmp(7);\n" +
                        "    vb_branch_off(10 downto 5) := vb_tmp(30 downto 25);\n" +
                        "    vb_branch_off(4 downto 1) := vb_tmp(11 downto 8);\n" +
                        "    vb_branch_off(0) := '0';\n" +
                        "    vb_branch_addr := vb_pc + vb_branch_off;\n" +
                        "\n" +
                        "    v_branch := '0';\n" +
                        "    if (vb_tmp(6 downto 0) = \"1100011\") and (vb_tmp(31) = '1') then\n" +
                        "        if (vb_branch_addr /= r.h(1).resp_pc)\n" +
                        "            and (vb_branch_addr /= r.h(2).resp_pc) then\n" +
                        "            v_branch := '1';\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Check Compressed \"C_J\" unconditional jump\n" +
                        "    if vb_tmp(12) = '1' then\n" +
                        "        vb_c_j_off(BUS_ADDR_WIDTH-1 downto 11) := (others => '1');\n" +
                        "    else\n" +
                        "        vb_c_j_off(BUS_ADDR_WIDTH-1 downto 11) := (others => '0');\n" +
                        "    end if;\n" +
                        "    vb_c_j_off(10) := vb_tmp(8);\n" +
                        "    vb_c_j_off(9 downto 8) := vb_tmp(10 downto 9);\n" +
                        "    vb_c_j_off(7) := vb_tmp(6);\n" +
                        "    vb_c_j_off(6) := vb_tmp(7);\n" +
                        "    vb_c_j_off(5) := vb_tmp(2);\n" +
                        "    vb_c_j_off(4) := vb_tmp(11);\n" +
                        "    vb_c_j_off(3 downto 1) := vb_tmp(5 downto 3);\n" +
                        "    vb_c_j_off(0) := '0';\n" +
                        "    vb_c_j_addr := vb_pc + vb_c_j_off;\n" +
                        "\n" +
                        "    v_c_j := '0';\n" +
                        "    if (vb_tmp(15 downto 13) = \"101\") and (vb_tmp(1 downto 0) = \"01\") then\n" +
                        "        if (vb_c_j_addr /= r.h(1).resp_pc) and (vb_c_j_addr /= r.h(2).resp_pc) then\n" +
                        "            v_c_j := '1';\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Compressed RET pseudo-instruction\n" +
                        "    v_c_ret := '0';\n" +
                        "    if vb_tmp(15 downto 0) = X\"8082\" then\n" +
                        "        v_c_ret := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if v_jal = '1' then\n" +
                        "        vb_npc_predicted := vb_jal_addr;\n" +
                        "    elsif v_branch = '1' then\n" +
                        "        vb_npc_predicted := vb_branch_addr;\n" +
                        "    elsif v_c_j = '1' then\n" +
                        "        vb_npc_predicted := vb_c_j_addr;\n" +
                        "    elsif v_c_ret = '1' then\n" +
                        "        vb_npc_predicted := i_ra(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    elsif vb_tmp(1 downto 0) = \"11\" then\n" +
                        "        vb_npc_predicted := r.h(0).resp_pc + 4;\n" +
                        "    else\n" +
                        "        vb_npc_predicted := r.h(0).resp_pc + 2;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if i_e_npc = r.h(2).resp_pc then\n" +
                        "        if r.h(2).resp_npc = r.h(1).resp_pc then\n" +
                        "            if r.h(1).resp_npc = r.h(0).resp_pc then\n" +
                        "                vb_npc := vb_npc_predicted;\n" +
                        "            else\n" +
                        "                vb_npc := r.h(1).resp_npc;\n" +
                        "            end if;\n" +
                        "        elsif r.h(2).resp_npc = r.h(0).resp_pc then\n" +
                        "            vb_npc := vb_npc_predicted;\n" +
                        "        else\n" +
                        "            vb_npc := r.h(2).resp_npc;\n" +
                        "        end if;\n" +
                        "    elsif i_e_npc = r.h(1).resp_pc then\n" +
                        "        if r.h(1).resp_npc = r.h(0).resp_pc then\n" +
                        "            vb_npc := vb_npc_predicted;\n" +
                        "        else\n" +
                        "            vb_npc := r.h(1).resp_npc;\n" +
                        "        end if;\n" +
                        "    elsif i_e_npc = r.h(0).resp_pc then\n" +
                        "        vb_npc := vb_npc_predicted;\n" +
                        "    else\n" +
                        "        vb_npc := i_e_npc;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if i_req_mem_fire = '1' and r.wait_resp = '0' then\n" +
                        "        v.wait_resp := '1';\n" +
                        "        v.h(0).resp_pc := vb_npc;\n" +
                        "        v.h(0).resp_npc := (others => '1');\n" +
                        "        v.h(1) := r.h(0);\n" +
                        "        v.h(2) := r.h(1);\n" +
                        "    elsif i_req_mem_fire = '1' and i_resp_mem_valid = '1' then\n" +
                        "        v.wait_resp := '1';\n" +
                        "        v.h(0).resp_pc := vb_npc;\n" +
                        "        v.h(0).resp_npc := (others => '1');\n" +
                        "        v.h(1) := r.h(0);\n" +
                        "        v.h(1).resp_npc := vb_npc;\n" +
                        "        v.h(2) := r.h(1);\n" +
                        "    elsif i_resp_mem_valid = '1' and r.wait_resp = '1' then\n" +
                        "        v.wait_resp := '0';\n" +
                        "        v.h(0).resp_npc := vb_npc;\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    o_npc_predict <= vb_npc;\n" +
                        "    \n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(i_clk, i_nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_l2d_d_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "\n" +
                        "entity Long2Double is \n" +
                        "  generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_nrst       : in std_logic;\n" +
                        "    i_clk        : in std_logic;\n" +
                        "    i_ena        : in std_logic;\n" +
                        "    i_signed     : in std_logic;\n" +
                        "    i_w32        : in std_logic;\n" +
                        "    i_a          : in std_logic_vector(63 downto 0);\n" +
                        "    o_res        : out std_logic_vector(63 downto 0);\n" +
                        "    o_valid      : out std_logic;\n" +
                        "    o_busy       : out std_logic\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_Long2Double of Long2Double is\n" +
                        " \n" +
                        "  constant zero64 : std_logic_vector(63 downto 0) := (others => '0');\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "    busy : std_logic;\n" +
                        "    ena : std_logic_vector(2 downto 0);\n" +
                        "    signA : std_logic;\n" +
                        "    absA : std_logic_vector(63 downto 0);\n" +
                        "    result : std_logic_vector(63 downto 0);\n" +
                        "    op_signed : std_logic;\n" +
                        "    mantAlign : std_logic_vector(63 downto 0);\n" +
                        "    lshift : integer range 0 to 63;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "    '0', (others => '0'),                      -- busy, ena\n" +
                        "    '0', (others => '0'), (others => '0'),     -- signA, absA, result\n" +
                        "    '0', (others => '0'), 0                    -- op_signed, mantAlign, lshift\n" +
                        "  );\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  comb : process(i_nrst, i_ena, i_signed, i_w32, i_a, r)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable mantAlign : std_logic_vector(63 downto 0);\n" +
                        "    variable lshift : integer range 0 to 63;\n" +
                        "    variable expAlign : std_logic_vector(10 downto 0);\n" +
                        "    variable mantEven : std_logic;\n" +
                        "    variable mant05 : std_logic;\n" +
                        "    variable mantOnes : std_logic;\n" +
                        "    variable rndBit : std_logic;\n" +
                        "    variable v_signA : std_logic;\n" +
                        "    variable vb_A : std_logic_vector(63 downto 0);\n" +
                        "    variable res : std_logic_vector(63 downto 0);\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    v.ena := r.ena(1 downto 0) & (i_ena and not r.busy);\n" +
                        "    if i_w32 = '0' then\n" +
                        "        v_signA := i_a(63);\n" +
                        "        vb_A := i_a;\n" +
                        "    elsif i_signed = '1' and i_a(31) = '1' then\n" +
                        "        v_signA := '1';\n" +
                        "        vb_A(63 downto 32) := (others => '1');\n" +
                        "        vb_A(31 downto 0) := i_a(31 downto 0);\n" +
                        "    else\n" +
                        "        v_signA := '0';\n" +
                        "        vb_A(31 downto 0) := i_a(31 downto 0);\n" +
                        "        vb_A(63 downto 32) := (others => '0');\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if i_ena = '1' then\n" +
                        "        v.busy := '1';\n" +
                        "        if i_signed = '1' and v_signA = '1' then\n" +
                        "            v.signA := '1';\n" +
                        "            v.absA := not vb_A + 1;\n" +
                        "        else\n" +
                        "            v.signA := '0';\n" +
                        "            v.absA := vb_A;\n" +
                        "        end if;\n" +
                        "        v.op_signed := i_signed;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- multiplexer, probably if/elsif in rtl:\n" +
                        "    mantAlign := (others => '0');\n" +
                        "    lshift := 63;\n" +
                        "    if r.absA(63) = '1' then\n" +
                        "        mantAlign := r.absA;\n" +
                        "    else\n" +
                        "        for i in 1 to 63 loop\n" +
                        "            if lshift = 63 and r.absA(63 - i) = '1' then\n" +
                        "                mantAlign := r.absA(63-i downto 0) & zero64(i-1 downto 0);\n" +
                        "                lshift := i;\n" +
                        "            end if;\n" +
                        "        end loop;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if r.ena(0) = '1' then\n" +
                        "        v.mantAlign := mantAlign;\n" +
                        "        v.lshift := lshift;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if r.absA = zero64 then\n" +
                        "        expAlign := (others => '0');\n" +
                        "    else\n" +
                        "        expAlign := conv_std_logic_vector(1086 - r.lshift, 11);\n" +
                        "    end if;\n" +
                        "\n" +
                        "    mantEven := r.mantAlign(11);\n" +
                        "    mant05 := '0';\n" +
                        "    if r.mantAlign(10 downto 0) = \"11111111111\" then\n" +
                        "        mant05 := '1';\n" +
                        "    end if;\n" +
                        "    rndBit := r.mantAlign(10) and not(mant05 and mantEven);\n" +
                        "    mantOnes := '0';\n" +
                        "    if r.mantAlign(63) = '1' and r.mantAlign(62 downto 11) = X\"fffffffffffff\" then\n" +
                        "        mantOnes := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Result multiplexers:\n" +
                        "    res(63) := r.signA and r.op_signed;\n" +
                        "    res(62 downto 52) := expAlign + (\"0000000000\" & (mantOnes and rndBit));\n" +
                        "    res(51 downto 0) := r.mantAlign(62 downto 11) + rndBit;\n" +
                        "\n" +
                        "    if r.ena(1) = '1' then\n" +
                        "        v.result := res;\n" +
                        "        v.busy := '0';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  o_res <= r.result;\n" +
                        "  o_valid <= r.ena(2);\n" +
                        "  o_busy <= r.busy;\n" +
                        "  \n" +
                        "  -- registers:\n" +
                        "  regs : process(i_nrst, i_clk)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_imul53_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "\n" +
                        "entity imul53 is \n" +
                        "  generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_nrst     : in std_logic;\n" +
                        "    i_clk      : in std_logic;\n" +
                        "    i_ena      : in std_logic;\n" +
                        "    i_a        : in std_logic_vector(52 downto 0);\n" +
                        "    i_b        : in std_logic_vector(52 downto 0);\n" +
                        "    o_result   : out std_logic_vector(105 downto 0);\n" +
                        "    o_shift    : out std_logic_vector(6 downto 0);\n" +
                        "    o_rdy      : out std_logic;\n" +
                        "    o_overflow : out std_logic\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_imul53 of imul53 is\n" +
                        "\n" +
                        "  type mux_type is array (16 downto 0) of std_logic_vector(56 downto 0);\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "    delay : std_logic_vector(15 downto 0);\n" +
                        "    shift : std_logic_vector(6 downto 0);\n" +
                        "    accum_ena : std_logic;\n" +
                        "    b : std_logic_vector(55 downto 0);\n" +
                        "    sum : std_logic_vector(105 downto 0);\n" +
                        "    overflow : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "    (others => '0'), (others => '0'), '0',\n" +
                        "    (others => '0'), (others => '0'), '0');\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  comb : process(i_nrst, i_ena, i_a, i_b, r)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable vb_mux : mux_type;\n" +
                        "    variable vb_sel : std_logic_vector(56 downto 0);\n" +
                        "    variable vb_shift : std_logic_vector(6 downto 0);\n" +
                        "    variable vb_sumInv : std_logic_vector(104 downto 0);\n" +
                        "    variable vb_lshift_p1 : integer range 0 to 104;\n" +
                        "    variable vb_lshift_p2 : integer range 0 to 104;\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    vb_mux(0) := (others => '0');\n" +
                        "    vb_mux(1) := \"0000\" & i_a;                   -- 1*a\n" +
                        "    vb_mux(2) := \"000\" & i_a & '0';              -- 2*a\n" +
                        "    vb_mux(3) := vb_mux(2) + vb_mux(1);          -- 2*a + 1*a\n" +
                        "    vb_mux(4) := \"00\" & i_a & \"00\";              -- 4*a\n" +
                        "    vb_mux(5) := vb_mux(4) + vb_mux(1);          -- 4*a + 1*a\n" +
                        "    vb_mux(6) := vb_mux(4) + vb_mux(2);          -- 4*a + 2*a\n" +
                        "    vb_mux(8) := '0' & i_a & \"000\";              -- 8*a\n" +
                        "    vb_mux(7) := vb_mux(8) - vb_mux(1);          -- 8*a - 1*a\n" +
                        "    vb_mux(9) := vb_mux(8) + vb_mux(1);          -- 8*a + 1*a\n" +
                        "    vb_mux(10) := vb_mux(8) + vb_mux(2);         -- 8*a + 2*a\n" +
                        "    vb_mux(11) := vb_mux(10) + vb_mux(1);        -- (8*a + 2*a) + 1*a\n" +
                        "    vb_mux(12) := vb_mux(8) + vb_mux(4);         -- 8*a + 4*a\n" +
                        "    vb_mux(16) := i_a & \"0000\";                  -- unused\n" +
                        "    vb_mux(13) := vb_mux(16) - vb_mux(3);        -- 16*a - (2*a + 1*a)\n" +
                        "    vb_mux(14) := vb_mux(16) - vb_mux(2);        -- 16*a - 2*a\n" +
                        "    vb_mux(15) := vb_mux(16) - vb_mux(1);        -- 16*a - 1*a\n" +
                        "\n" +
                        "    v.delay := r.delay(14 downto 0) & i_ena;\n" +
                        "    if i_ena = '1' then\n" +
                        "        v.b := \"000\" & i_b;\n" +
                        "        v.overflow := '0';\n" +
                        "        v.accum_ena := '1';\n" +
                        "        v.sum := (others => '0');\n" +
                        "        v.shift := (others => '0');\n" +
                        "    elsif r.delay(13) = '1' then\n" +
                        "        v.accum_ena := '0';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    case r.b(55 downto 52) is\n" +
                        "    when X\"1\" => vb_sel := vb_mux(1);\n" +
                        "    when X\"2\" => vb_sel := vb_mux(2);\n" +
                        "    when X\"3\" => vb_sel := vb_mux(3);\n" +
                        "    when X\"4\" => vb_sel := vb_mux(4);\n" +
                        "    when X\"5\" => vb_sel := vb_mux(5);\n" +
                        "    when X\"6\" => vb_sel := vb_mux(6);\n" +
                        "    when X\"7\" => vb_sel := vb_mux(7);\n" +
                        "    when X\"8\" => vb_sel := vb_mux(8);\n" +
                        "    when X\"9\" => vb_sel := vb_mux(9);\n" +
                        "    when X\"A\" => vb_sel := vb_mux(10);\n" +
                        "    when X\"B\" => vb_sel := vb_mux(11);\n" +
                        "    when X\"C\" => vb_sel := vb_mux(12);\n" +
                        "    when X\"D\" => vb_sel := vb_mux(13);\n" +
                        "    when X\"E\" => vb_sel := vb_mux(14);\n" +
                        "    when X\"F\" => vb_sel := vb_mux(15);\n" +
                        "    when others =>\n" +
                        "        vb_sel := (others => '0');\n" +
                        "    end case;\n" +
                        "    if r.accum_ena = '1' then\n" +
                        "        v.sum := (r.sum(101 downto 0) & \"0000\") + vb_sel;\n" +
                        "        v.b := r.b(51 downto 0) & \"0000\";\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- To avoid timing constrains violation occured in Vivado Studio\n" +
                        "    -- try to implement parallel demuxultiplexer splitted on 2 parts\n" +
                        "    vb_sumInv(0) := '0';\n" +
                        "    for i in 0 to 103 loop\n" +
                        "        vb_sumInv(i + 1) := r.sum(103 - i);\n" +
                        "    end loop;\n" +
                        "    \n" +
                        "    vb_lshift_p1 := 0;\n" +
                        "    for i in 0 to 63 loop\n" +
                        "        if vb_lshift_p1 = 0 and vb_sumInv(i) = '1' then\n" +
                        "            vb_lshift_p1 := i;\n" +
                        "        end if;\n" +
                        "    end loop;\n" +
                        "    \n" +
                        "    vb_lshift_p2 := 0;\n" +
                        "    for i in 0 to 40 loop\n" +
                        "        if vb_lshift_p2 = 0 and vb_sumInv(64 + i) = '1' then\n" +
                        "            vb_lshift_p2 := 64 + i;\n" +
                        "        end if;\n" +
                        "    end loop;\n" +
                        "\n" +
                        "    if r.sum(105) = '1' then\n" +
                        "        vb_shift := \"1111111\";\n" +
                        "        v.overflow := '1';\n" +
                        "    elsif r.sum(104) = '1' then\n" +
                        "        vb_shift := (others => '0');\n" +
                        "    elsif vb_lshift_p1 /= 0 then\n" +
                        "        vb_shift := conv_std_logic_vector(vb_lshift_p1, 7);\n" +
                        "    else\n" +
                        "        vb_shift := conv_std_logic_vector(vb_lshift_p2, 7);\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if r.delay(14) = '1' then\n" +
                        "        v.shift := vb_shift;\n" +
                        "        v.overflow := '0';\n" +
                        "        if vb_shift = \"1111111\" then\n" +
                        "            v.overflow := '1';\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  o_result <= r.sum;\n" +
                        "  o_shift <= r.shift;\n" +
                        "  o_overflow <= r.overflow;\n" +
                        "  o_rdy <= r.delay(15);\n" +
                        "  \n" +
                        "  -- registers:\n" +
                        "  regs : process(i_nrst, i_clk)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_idiv53_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "\n" +
                        "entity idiv53 is \n" +
                        "  generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_nrst       : in std_logic;\n" +
                        "    i_clk        : in std_logic;\n" +
                        "    i_ena        : in std_logic;\n" +
                        "    i_divident   : in std_logic_vector(52 downto 0);\n" +
                        "    i_divisor    : in std_logic_vector(52 downto 0);\n" +
                        "    o_result     : out std_logic_vector(104 downto 0);\n" +
                        "    o_lshift     : out std_logic_vector(6 downto 0);\n" +
                        "    o_rdy        : out std_logic;\n" +
                        "    o_overflow   : out std_logic;\n" +
                        "    o_zero_resid : out std_logic\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_idiv53 of idiv53 is\n" +
                        "\n" +
                        "  constant zero53 : std_logic_vector(52 downto 0) := (others => '0');\n" +
                        "\n" +
                        "  component divstage53 is \n" +
                        "  port (\n" +
                        "    i_mux_ena    : in std_logic;  -- find first non-zero bit\n" +
                        "    i_muxind     : in std_logic_vector(55 downto 0);  -- bits indexes 8x7 bits bus\n" +
                        "    i_divident   : in std_logic_vector(60 downto 0);  -- integer value\n" +
                        "    i_divisor    : in std_logic_vector(52 downto 0);  -- integer value\n" +
                        "    o_dif        : out std_logic_vector(52 downto 0); -- residual value\n" +
                        "    o_bits       : out std_logic_vector(7 downto 0);  -- resulting bits\n" +
                        "    o_muxind     : out std_logic_vector(6 downto 0);  -- first found non-zero bit\n" +
                        "    o_muxind_rdy : out std_logic                      -- seeking was successfull\n" +
                        "  );\n" +
                        "  end component; \n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "    delay : std_logic_vector(14 downto 0);\n" +
                        "    lshift : std_logic_vector(6 downto 0);\n" +
                        "    lshift_rdy : std_logic;\n" +
                        "    divisor : std_logic_vector(52 downto 0);\n" +
                        "    divident : std_logic_vector(60 downto 0);\n" +
                        "    bits : std_logic_vector(104 downto 0);\n" +
                        "    overflow : std_logic;\n" +
                        "    zero_resid : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "    (others => '0'), (others => '0'), '0',\n" +
                        "    (others => '0'), (others => '0'), (others => '0'),\n" +
                        "    '0', '0');\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "  signal w_mux_ena_i : std_logic;\n" +
                        "  signal wb_muxind_i : std_logic_vector(55 downto 0);\n" +
                        "  signal wb_divident_i : std_logic_vector(60 downto 0);\n" +
                        "  signal wb_divisor_i : std_logic_vector(52 downto 0);\n" +
                        "  signal wb_dif_o : std_logic_vector(52 downto 0);\n" +
                        "  signal wb_bits_o : std_logic_vector(7 downto 0);\n" +
                        "  signal wb_muxind_o : std_logic_vector(6 downto 0);\n" +
                        "  signal w_muxind_rdy_o : std_logic;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  divstage0 : divstage53 port map (\n" +
                        "    i_mux_ena => w_mux_ena_i,\n" +
                        "    i_muxind => wb_muxind_i,\n" +
                        "    i_divident => wb_divident_i,\n" +
                        "    i_divisor => wb_divisor_i,\n" +
                        "    o_dif => wb_dif_o,\n" +
                        "    o_bits => wb_bits_o,\n" +
                        "    o_muxind => wb_muxind_o,\n" +
                        "    o_muxind_rdy => w_muxind_rdy_o\n" +
                        "  );\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  comb : process(i_nrst, i_ena, i_divident, i_divisor, r,\n" +
                        "                 wb_dif_o, wb_bits_o, wb_muxind_o, w_muxind_rdy_o)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable vb_muxind : std_logic_vector(55 downto 0);\n" +
                        "    variable vb_bits : std_logic_vector(104 downto 0);\n" +
                        "    variable v_mux_ena_i : std_logic;\n" +
                        "  begin\n" +
                        "    v := r;\n" +
                        "    vb_bits := r.bits;\n" +
                        "\n" +
                        "    v_mux_ena_i := '0';\n" +
                        "    v.delay := r.delay(13 downto 0) & i_ena;\n" +
                        "    vb_muxind := (others => '0');\n" +
                        "    if i_ena = '1' then\n" +
                        "        v.divident := X\"00\" & i_divident;\n" +
                        "        v.divisor := i_divisor;\n" +
                        "        v.lshift_rdy := '0';\n" +
                        "        v.overflow := '0';\n" +
                        "        v.zero_resid := '0';\n" +
                        "    elsif r.delay(0) = '1' then\n" +
                        "        v_mux_ena_i := not r.lshift_rdy;\n" +
                        "        v.divident := wb_dif_o & X\"00\";\n" +
                        "        vb_bits(104) := not wb_dif_o(52);\n" +
                        "    elsif r.delay(1) = '1' then\n" +
                        "        v_mux_ena_i := not r.lshift_rdy;\n" +
                        "        v.divident := wb_dif_o & X\"00\";\n" +
                        "        vb_muxind(55 downto 49) := conv_std_logic_vector(1, 7);\n" +
                        "        vb_muxind(48 downto 42) := conv_std_logic_vector(2, 7);\n" +
                        "        vb_muxind(41 downto 35) := conv_std_logic_vector(3, 7);\n" +
                        "        vb_muxind(34 downto 28) := conv_std_logic_vector(4, 7);\n" +
                        "        vb_muxind(27 downto 21) := conv_std_logic_vector(5, 7);\n" +
                        "        vb_muxind(20 downto 14) := conv_std_logic_vector(6, 7);\n" +
                        "        vb_muxind(13 downto 7)  := conv_std_logic_vector(7, 7);\n" +
                        "        vb_muxind(6 downto 0)   := conv_std_logic_vector(8, 7);\n" +
                        "        vb_bits(103 downto 96) := wb_bits_o;\n" +
                        "    elsif r.delay(2) = '1' then\n" +
                        "        v_mux_ena_i := not r.lshift_rdy;\n" +
                        "        v.divident := wb_dif_o & X\"00\";\n" +
                        "        vb_muxind(55 downto 49) := conv_std_logic_vector(9, 7);\n" +
                        "        vb_muxind(48 downto 42) := conv_std_logic_vector(10, 7);\n" +
                        "        vb_muxind(41 downto 35) := conv_std_logic_vector(11, 7);\n" +
                        "        vb_muxind(34 downto 28) := conv_std_logic_vector(12, 7);\n" +
                        "        vb_muxind(27 downto 21) := conv_std_logic_vector(13, 7);\n" +
                        "        vb_muxind(20 downto 14) := conv_std_logic_vector(14, 7);\n" +
                        "        vb_muxind(13 downto 7)  := conv_std_logic_vector(15, 7);\n" +
                        "        vb_muxind(6 downto 0)   := conv_std_logic_vector(16, 7);\n" +
                        "        vb_bits(95 downto 88) := wb_bits_o;\n" +
                        "    elsif r.delay(3) = '1' then\n" +
                        "        v_mux_ena_i := not r.lshift_rdy;\n" +
                        "        v.divident := wb_dif_o & X\"00\";\n" +
                        "        vb_muxind(55 downto 49) := conv_std_logic_vector(17, 7);\n" +
                        "        vb_muxind(48 downto 42) := conv_std_logic_vector(18, 7);\n" +
                        "        vb_muxind(41 downto 35) := conv_std_logic_vector(19, 7);\n" +
                        "        vb_muxind(34 downto 28) := conv_std_logic_vector(20, 7);\n" +
                        "        vb_muxind(27 downto 21) := conv_std_logic_vector(21, 7);\n" +
                        "        vb_muxind(20 downto 14) := conv_std_logic_vector(22, 7);\n" +
                        "        vb_muxind(13 downto 7)  := conv_std_logic_vector(23, 7);\n" +
                        "        vb_muxind(6 downto 0)   := conv_std_logic_vector(24, 7);\n" +
                        "        vb_bits(87 downto 80) := wb_bits_o;\n" +
                        "    elsif r.delay(4) = '1' then\n" +
                        "        v_mux_ena_i := not r.lshift_rdy;\n" +
                        "        v.divident := wb_dif_o & X\"00\";\n" +
                        "        vb_muxind(55 downto 49) := conv_std_logic_vector(25, 7);\n" +
                        "        vb_muxind(48 downto 42) := conv_std_logic_vector(26, 7);\n" +
                        "        vb_muxind(41 downto 35) := conv_std_logic_vector(27, 7);\n" +
                        "        vb_muxind(34 downto 28) := conv_std_logic_vector(28, 7);\n" +
                        "        vb_muxind(27 downto 21) := conv_std_logic_vector(29, 7);\n" +
                        "        vb_muxind(20 downto 14) := conv_std_logic_vector(30, 7);\n" +
                        "        vb_muxind(13 downto 7)  := conv_std_logic_vector(31, 7);\n" +
                        "        vb_muxind(6 downto 0)   := conv_std_logic_vector(32, 7);\n" +
                        "        vb_bits(79 downto 72) := wb_bits_o;\n" +
                        "    elsif r.delay(5) = '1' then\n" +
                        "        v_mux_ena_i := not r.lshift_rdy;\n" +
                        "        v.divident := wb_dif_o & X\"00\";\n" +
                        "        vb_muxind(55 downto 49) := conv_std_logic_vector(33, 7);\n" +
                        "        vb_muxind(48 downto 42) := conv_std_logic_vector(34, 7);\n" +
                        "        vb_muxind(41 downto 35) := conv_std_logic_vector(35, 7);\n" +
                        "        vb_muxind(34 downto 28) := conv_std_logic_vector(36, 7);\n" +
                        "        vb_muxind(27 downto 21) := conv_std_logic_vector(37, 7);\n" +
                        "        vb_muxind(20 downto 14) := conv_std_logic_vector(38, 7);\n" +
                        "        vb_muxind(13 downto 7)  := conv_std_logic_vector(39, 7);\n" +
                        "        vb_muxind(6 downto 0)   := conv_std_logic_vector(40, 7);\n" +
                        "        vb_bits(71 downto 64) := wb_bits_o;\n" +
                        "    elsif r.delay(6) = '1' then\n" +
                        "        v_mux_ena_i := not r.lshift_rdy;\n" +
                        "        v.divident := wb_dif_o & X\"00\";\n" +
                        "        vb_muxind(55 downto 49) := conv_std_logic_vector(41, 7);\n" +
                        "        vb_muxind(48 downto 42) := conv_std_logic_vector(42, 7);\n" +
                        "        vb_muxind(41 downto 35) := conv_std_logic_vector(43, 7);\n" +
                        "        vb_muxind(34 downto 28) := conv_std_logic_vector(44, 7);\n" +
                        "        vb_muxind(27 downto 21) := conv_std_logic_vector(45, 7);\n" +
                        "        vb_muxind(20 downto 14) := conv_std_logic_vector(46, 7);\n" +
                        "        vb_muxind(13 downto 7)  := conv_std_logic_vector(47, 7);\n" +
                        "        vb_muxind(6 downto 0)   := conv_std_logic_vector(48, 7);\n" +
                        "        vb_bits(63 downto 56) := wb_bits_o;\n" +
                        "    elsif r.delay(7) = '1' then\n" +
                        "        v_mux_ena_i := not r.lshift_rdy;\n" +
                        "        v.divident := wb_dif_o & X\"00\";\n" +
                        "        vb_muxind(55 downto 49) := conv_std_logic_vector(49, 7);\n" +
                        "        vb_muxind(48 downto 42) := conv_std_logic_vector(50, 7);\n" +
                        "        vb_muxind(41 downto 35) := conv_std_logic_vector(51, 7);\n" +
                        "        vb_muxind(34 downto 28) := conv_std_logic_vector(52, 7);\n" +
                        "        vb_muxind(27 downto 21) := conv_std_logic_vector(53, 7);\n" +
                        "        vb_muxind(20 downto 14) := conv_std_logic_vector(54, 7);\n" +
                        "        vb_muxind(13 downto 7)  := conv_std_logic_vector(55, 7);\n" +
                        "        vb_muxind(6 downto 0)   := conv_std_logic_vector(56, 7);\n" +
                        "        vb_bits(55 downto 48) := wb_bits_o;\n" +
                        "    elsif r.delay(8) = '1' then\n" +
                        "        v_mux_ena_i := not r.lshift_rdy;\n" +
                        "        v.divident := wb_dif_o & X\"00\";\n" +
                        "        vb_muxind(55 downto 49) := conv_std_logic_vector(57, 7);\n" +
                        "        vb_muxind(48 downto 42) := conv_std_logic_vector(58, 7);\n" +
                        "        vb_muxind(41 downto 35) := conv_std_logic_vector(59, 7);\n" +
                        "        vb_muxind(34 downto 28) := conv_std_logic_vector(60, 7);\n" +
                        "        vb_muxind(27 downto 21) := conv_std_logic_vector(61, 7);\n" +
                        "        vb_muxind(20 downto 14) := conv_std_logic_vector(62, 7);\n" +
                        "        vb_muxind(13 downto 7)  := conv_std_logic_vector(63, 7);\n" +
                        "        vb_muxind(6 downto 0)   := conv_std_logic_vector(64, 7);\n" +
                        "        vb_bits(47 downto 40) := wb_bits_o;\n" +
                        "    elsif r.delay(9) = '1' then\n" +
                        "        v_mux_ena_i := not r.lshift_rdy;\n" +
                        "        v.divident := wb_dif_o & X\"00\";\n" +
                        "        vb_muxind(55 downto 49) := conv_std_logic_vector(65, 7);\n" +
                        "        vb_muxind(48 downto 42) := conv_std_logic_vector(66, 7);\n" +
                        "        vb_muxind(41 downto 35) := conv_std_logic_vector(67, 7);\n" +
                        "        vb_muxind(34 downto 28) := conv_std_logic_vector(68, 7);\n" +
                        "        vb_muxind(27 downto 21) := conv_std_logic_vector(69, 7);\n" +
                        "        vb_muxind(20 downto 14) := conv_std_logic_vector(70, 7);\n" +
                        "        vb_muxind(13 downto 7)  := conv_std_logic_vector(71, 7);\n" +
                        "        vb_muxind(6 downto 0)   := conv_std_logic_vector(72, 7);\n" +
                        "        vb_bits(39 downto 32) := wb_bits_o;\n" +
                        "    elsif r.delay(10) = '1' then\n" +
                        "        v_mux_ena_i := not r.lshift_rdy;\n" +
                        "        v.divident := wb_dif_o & X\"00\";\n" +
                        "        vb_muxind(55 downto 49) := conv_std_logic_vector(73, 7);\n" +
                        "        vb_muxind(48 downto 42) := conv_std_logic_vector(74, 7);\n" +
                        "        vb_muxind(41 downto 35) := conv_std_logic_vector(75, 7);\n" +
                        "        vb_muxind(34 downto 28) := conv_std_logic_vector(76, 7);\n" +
                        "        vb_muxind(27 downto 21) := conv_std_logic_vector(77, 7);\n" +
                        "        vb_muxind(20 downto 14) := conv_std_logic_vector(78, 7);\n" +
                        "        vb_muxind(13 downto 7)  := conv_std_logic_vector(79, 7);\n" +
                        "        vb_muxind(6 downto 0)   := conv_std_logic_vector(80, 7);\n" +
                        "        vb_bits(31 downto 24) := wb_bits_o;\n" +
                        "    elsif r.delay(11) = '1' then\n" +
                        "        v_mux_ena_i := not r.lshift_rdy;\n" +
                        "        v.divident := wb_dif_o & X\"00\";\n" +
                        "        vb_muxind(55 downto 49) := conv_std_logic_vector(81, 7);\n" +
                        "        vb_muxind(48 downto 42) := conv_std_logic_vector(82, 7);\n" +
                        "        vb_muxind(41 downto 35) := conv_std_logic_vector(83, 7);\n" +
                        "        vb_muxind(34 downto 28) := conv_std_logic_vector(84, 7);\n" +
                        "        vb_muxind(27 downto 21) := conv_std_logic_vector(85, 7);\n" +
                        "        vb_muxind(20 downto 14) := conv_std_logic_vector(86, 7);\n" +
                        "        vb_muxind(13 downto 7)  := conv_std_logic_vector(87, 7);\n" +
                        "        vb_muxind(6 downto 0)   := conv_std_logic_vector(88, 7);\n" +
                        "        vb_bits(23 downto 16) := wb_bits_o;\n" +
                        "    elsif r.delay(12) = '1' then\n" +
                        "        v_mux_ena_i := not r.lshift_rdy;\n" +
                        "        v.divident := wb_dif_o & X\"00\";\n" +
                        "        vb_muxind(55 downto 49) := conv_std_logic_vector(89, 7);\n" +
                        "        vb_muxind(48 downto 42) := conv_std_logic_vector(90, 7);\n" +
                        "        vb_muxind(41 downto 35) := conv_std_logic_vector(91, 7);\n" +
                        "        vb_muxind(34 downto 28) := conv_std_logic_vector(92, 7);\n" +
                        "        vb_muxind(27 downto 21) := conv_std_logic_vector(93, 7);\n" +
                        "        vb_muxind(20 downto 14) := conv_std_logic_vector(94, 7);\n" +
                        "        vb_muxind(13 downto 7)  := conv_std_logic_vector(95, 7);\n" +
                        "        vb_muxind(6 downto 0)   := conv_std_logic_vector(96, 7);\n" +
                        "        vb_bits(15 downto 8) := wb_bits_o;\n" +
                        "    elsif r.delay(13) = '1' then\n" +
                        "        v_mux_ena_i := not r.lshift_rdy;\n" +
                        "        v.divident := wb_dif_o & X\"00\";\n" +
                        "        vb_muxind(55 downto 49) := conv_std_logic_vector(97, 7);\n" +
                        "        vb_muxind(48 downto 42) := conv_std_logic_vector(98, 7);\n" +
                        "        vb_muxind(41 downto 35) := conv_std_logic_vector(99, 7);\n" +
                        "        vb_muxind(34 downto 28) := conv_std_logic_vector(100, 7);\n" +
                        "        vb_muxind(27 downto 21) := conv_std_logic_vector(101, 7);\n" +
                        "        vb_muxind(20 downto 14) := conv_std_logic_vector(102, 7);\n" +
                        "        vb_muxind(13 downto 7)  := conv_std_logic_vector(103, 7);\n" +
                        "        vb_muxind(6 downto 0)   := conv_std_logic_vector(104, 7);\n" +
                        "        vb_bits(7 downto 0) := wb_bits_o;\n" +
                        "\n" +
                        "        if wb_dif_o = zero53 then\n" +
                        "            v.zero_resid := '1';\n" +
                        "        end if;\n" +
                        "        if r.lshift = \"1111111\" then\n" +
                        "            v.overflow := '1';\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if r.lshift_rdy = '0' then\n" +
                        "        if w_muxind_rdy_o = '1' then\n" +
                        "            v.lshift_rdy := '1';\n" +
                        "            v.lshift := wb_muxind_o;\n" +
                        "        elsif r.delay(13) = '1' then\n" +
                        "            v.lshift_rdy := '1';\n" +
                        "            v.lshift := conv_std_logic_vector(104, 7);\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_mux_ena_i <= v_mux_ena_i;\n" +
                        "    wb_divident_i <= r.divident;\n" +
                        "    wb_divisor_i <= r.divisor;\n" +
                        "    wb_muxind_i <= vb_muxind;\n" +
                        "    v.bits := vb_bits;\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  o_result <= r.bits;\n" +
                        "  o_lshift <= r.lshift;\n" +
                        "  o_overflow <= r.overflow;\n" +
                        "  o_zero_resid <= r.zero_resid;\n" +
                        "  o_rdy <= r.delay(14);\n" +
                        "  \n" +
                        "  -- registers:\n" +
                        "  regs : process(i_nrst, i_clk)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_fpu_top_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--library riverlib;\n" +
                        "use work.river_cfg.all;\n" +
                        "\n" +
                        "entity FpuTop is \n" +
                        "  generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_nrst         : in std_logic;\n" +
                        "    i_clk          : in std_logic;\n" +
                        "    i_ena          : in std_logic;\n" +
                        "    i_ivec         : in std_logic_vector(Instr_FPU_Total-1 downto 0);\n" +
                        "    i_a            : in std_logic_vector(63 downto 0);\n" +
                        "    i_b            : in std_logic_vector(63 downto 0);\n" +
                        "    o_res          : out std_logic_vector(63 downto 0);\n" +
                        "    o_ex_invalidop : out std_logic;   -- Exception: invalid operation\n" +
                        "    o_ex_divbyzero : out std_logic;   -- Exception: divide by zero\n" +
                        "    o_ex_overflow  : out std_logic;   -- Exception: overflow\n" +
                        "    o_ex_underflow : out std_logic;   -- Exception: underflow\n" +
                        "    o_ex_inexact   : out std_logic;   -- Exception: inexact\n" +
                        "    o_valid        : out std_logic;\n" +
                        "    o_busy         : out std_logic\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_FpuTop of FpuTop is\n" +
                        "\n" +
                        "  component DoubleAdd is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_nrst       : in std_logic;\n" +
                        "    i_clk        : in std_logic;\n" +
                        "    i_ena        : in std_logic;\n" +
                        "    i_add        : in std_logic;\n" +
                        "    i_sub        : in std_logic;\n" +
                        "    i_eq         : in std_logic;\n" +
                        "    i_lt         : in std_logic;\n" +
                        "    i_le         : in std_logic;\n" +
                        "    i_max        : in std_logic;\n" +
                        "    i_min        : in std_logic;\n" +
                        "    i_a          : in std_logic_vector(63 downto 0);\n" +
                        "    i_b          : in std_logic_vector(63 downto 0);\n" +
                        "    o_res        : out std_logic_vector(63 downto 0);\n" +
                        "    o_illegal_op : out std_logic;\n" +
                        "    o_overflow   : out std_logic;\n" +
                        "    o_valid      : out std_logic;\n" +
                        "    o_busy       : out std_logic\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "  component DoubleDiv is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_nrst       : in std_logic;\n" +
                        "    i_clk        : in std_logic;\n" +
                        "    i_ena        : in std_logic;\n" +
                        "    i_a          : in std_logic_vector(63 downto 0);\n" +
                        "    i_b          : in std_logic_vector(63 downto 0);\n" +
                        "    o_res        : out std_logic_vector(63 downto 0);\n" +
                        "    o_illegal_op : out std_logic;\n" +
                        "    o_divbyzero  : out std_logic;\n" +
                        "    o_overflow   : out std_logic;\n" +
                        "    o_underflow  : out std_logic;\n" +
                        "    o_valid      : out std_logic;\n" +
                        "    o_busy       : out std_logic\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "  component DoubleMul is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_nrst       : in std_logic;\n" +
                        "    i_clk        : in std_logic;\n" +
                        "    i_ena        : in std_logic;\n" +
                        "    i_a          : in std_logic_vector(63 downto 0);\n" +
                        "    i_b          : in std_logic_vector(63 downto 0);\n" +
                        "    o_res        : out std_logic_vector(63 downto 0);\n" +
                        "    o_illegal_op : out std_logic;\n" +
                        "    o_overflow   : out std_logic;\n" +
                        "    o_valid      : out std_logic;\n" +
                        "    o_busy       : out std_logic\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "  component Double2Long is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_nrst       : in std_logic;\n" +
                        "    i_clk        : in std_logic;\n" +
                        "    i_ena        : in std_logic;\n" +
                        "    i_signed     : in std_logic;\n" +
                        "    i_w32        : in std_logic;\n" +
                        "    i_a          : in std_logic_vector(63 downto 0);\n" +
                        "    o_res        : out std_logic_vector(63 downto 0);\n" +
                        "    o_overflow   : out std_logic;\n" +
                        "    o_underflow  : out std_logic;\n" +
                        "    o_valid      : out std_logic;\n" +
                        "    o_busy       : out std_logic\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "  component Long2Double is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_nrst       : in std_logic;\n" +
                        "    i_clk        : in std_logic;\n" +
                        "    i_ena        : in std_logic;\n" +
                        "    i_signed     : in std_logic;\n" +
                        "    i_w32        : in std_logic;\n" +
                        "    i_a          : in std_logic_vector(63 downto 0);\n" +
                        "    o_res        : out std_logic_vector(63 downto 0);\n" +
                        "    o_valid      : out std_logic;\n" +
                        "    o_busy       : out std_logic\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "    ivec : std_logic_vector(Instr_FPU_Total-1 downto 0);\n" +
                        "    busy : std_logic;\n" +
                        "    ready : std_logic;\n" +
                        "    a : std_logic_vector(63 downto 0);\n" +
                        "    b : std_logic_vector(63 downto 0);\n" +
                        "    result : std_logic_vector(63 downto 0);\n" +
                        "    ex_invalidop : std_logic;   -- Exception: invalid operation\n" +
                        "    ex_divbyzero : std_logic;   -- Exception: divide by zero\n" +
                        "    ex_overflow : std_logic;    -- Exception: overflow\n" +
                        "    ex_underflow : std_logic;   -- Exception: underflow\n" +
                        "    ex_inexact : std_logic;     -- Exception: inexact\n" +
                        "    ena_fadd : std_logic;\n" +
                        "    ena_fdiv : std_logic;\n" +
                        "    ena_fmul : std_logic;\n" +
                        "    ena_d2l : std_logic;\n" +
                        "    ena_l2d : std_logic;\n" +
                        "    ena_w32 : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "    (others => '0'),                                -- ivec\n" +
                        "    '0', '0', (others => '0'), (others => '0'),     -- busy, ready, a, b\n" +
                        "    (others => '0'),                                -- result\n" +
                        "    '0', '0', '0',                                  -- ex_invalidop, ex_divbyzero, ex_overflow\n" +
                        "    '0', '0', '0',                                  -- ex_underflow, ex_inexact, ena_fadd\n" +
                        "    '0', '0', '0', '0',                             -- ena_fdiv, ena_fmul, ena_d2l, ena_l2d\n" +
                        "    '0'                                             -- ena_w32\n" +
                        "  );\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "\n" +
                        "  signal w_fadd_d : std_logic;\n" +
                        "  signal w_fsub_d : std_logic;\n" +
                        "  signal w_feq_d : std_logic;\n" +
                        "  signal w_flt_d : std_logic;\n" +
                        "  signal w_fle_d : std_logic;\n" +
                        "  signal w_fmax_d : std_logic;\n" +
                        "  signal w_fmin_d : std_logic;\n" +
                        "  signal w_fcvt_signed : std_logic;\n" +
                        "  signal wb_res_fadd : std_logic_vector(63 downto 0);\n" +
                        "  signal w_valid_fadd : std_logic;\n" +
                        "  signal w_illegalop_fadd : std_logic;\n" +
                        "  signal w_overflow_fadd : std_logic;\n" +
                        "  signal w_busy_fadd : std_logic;\n" +
                        "\n" +
                        "  signal wb_res_fdiv : std_logic_vector(63 downto 0);\n" +
                        "  signal w_valid_fdiv : std_logic;\n" +
                        "  signal w_illegalop_fdiv : std_logic;\n" +
                        "  signal w_divbyzero_fdiv : std_logic;\n" +
                        "  signal w_overflow_fdiv : std_logic;\n" +
                        "  signal w_underflow_fdiv : std_logic;\n" +
                        "  signal w_busy_fdiv : std_logic;\n" +
                        "\n" +
                        "  signal wb_res_fmul : std_logic_vector(63 downto 0);\n" +
                        "  signal w_valid_fmul : std_logic;\n" +
                        "  signal w_illegalop_fmul : std_logic;\n" +
                        "  signal w_overflow_fmul : std_logic;\n" +
                        "  signal w_busy_fmul : std_logic;\n" +
                        "\n" +
                        "  signal wb_res_d2l : std_logic_vector(63 downto 0);\n" +
                        "  signal w_valid_d2l : std_logic;\n" +
                        "  signal w_overflow_d2l : std_logic;\n" +
                        "  signal w_underflow_d2l : std_logic;\n" +
                        "  signal w_busy_d2l : std_logic;\n" +
                        "\n" +
                        "  signal wb_res_l2d : std_logic_vector(63 downto 0);\n" +
                        "  signal w_valid_l2d : std_logic;\n" +
                        "  signal w_busy_l2d : std_logic;\n" +
                        "\n" +
                        "begin\n" +
                        "    fadd_d0 : DoubleAdd generic map (\n" +
                        "      async_reset => async_reset\n" +
                        "    ) port map (\n" +
                        "      i_clk => i_clk,\n" +
                        "      i_nrst => i_nrst,\n" +
                        "      i_ena => r.ena_fadd,\n" +
                        "      i_add => w_fadd_d,\n" +
                        "      i_sub => w_fsub_d,\n" +
                        "      i_eq => w_feq_d,\n" +
                        "      i_lt => w_flt_d,\n" +
                        "      i_le => w_fle_d,\n" +
                        "      i_max => w_fmax_d,\n" +
                        "      i_min => w_fmin_d,\n" +
                        "      i_a => r.a,\n" +
                        "      i_b => r.b,\n" +
                        "      o_res => wb_res_fadd,\n" +
                        "      o_illegal_op => w_illegalop_fadd,\n" +
                        "      o_overflow => w_overflow_fadd,\n" +
                        "      o_valid => w_valid_fadd,\n" +
                        "      o_busy => w_busy_fadd\n" +
                        "    );\n" +
                        "\n" +
                        "    fdiv_d0 : DoubleDiv generic map (\n" +
                        "      async_reset => async_reset\n" +
                        "    ) port map (\n" +
                        "      i_clk => i_clk,\n" +
                        "      i_nrst => i_nrst,\n" +
                        "      i_ena => r.ena_fdiv,\n" +
                        "      i_a => r.a,\n" +
                        "      i_b => r.b,\n" +
                        "      o_res => wb_res_fdiv,\n" +
                        "      o_illegal_op => w_illegalop_fdiv,\n" +
                        "      o_divbyzero => w_divbyzero_fdiv,\n" +
                        "      o_overflow => w_overflow_fdiv,\n" +
                        "      o_underflow => w_underflow_fdiv,\n" +
                        "      o_valid => w_valid_fdiv,\n" +
                        "      o_busy => w_busy_fdiv\n" +
                        "    );\n" +
                        "\n" +
                        "    fmul_d0 : DoubleMul generic map (\n" +
                        "      async_reset => async_reset\n" +
                        "    ) port map (\n" +
                        "      i_clk => i_clk,\n" +
                        "      i_nrst => i_nrst,\n" +
                        "      i_ena => r.ena_fmul,\n" +
                        "      i_a => r.a,\n" +
                        "      i_b => r.b,\n" +
                        "      o_res => wb_res_fmul,\n" +
                        "      o_illegal_op => w_illegalop_fmul,\n" +
                        "      o_overflow => w_overflow_fmul,\n" +
                        "      o_valid => w_valid_fmul,\n" +
                        "      o_busy => w_busy_fmul\n" +
                        "    );\n" +
                        "\n" +
                        "    d2l_d0 : Double2Long generic map (\n" +
                        "      async_reset => async_reset\n" +
                        "    ) port map (\n" +
                        "      i_clk => i_clk,\n" +
                        "      i_nrst => i_nrst,\n" +
                        "      i_ena => r.ena_d2l,\n" +
                        "      i_signed => w_fcvt_signed,\n" +
                        "      i_w32 => r.ena_w32,\n" +
                        "      i_a => r.a,\n" +
                        "      o_res => wb_res_d2l,\n" +
                        "      o_overflow => w_overflow_d2l,\n" +
                        "      o_underflow => w_underflow_d2l,\n" +
                        "      o_valid => w_valid_d2l,\n" +
                        "      o_busy => w_busy_d2l\n" +
                        "    );\n" +
                        "\n" +
                        "    l2d_d0 : Long2Double generic map (\n" +
                        "      async_reset => async_reset\n" +
                        "    ) port map (\n" +
                        "      i_clk => i_clk,\n" +
                        "      i_nrst => i_nrst,\n" +
                        "      i_ena => r.ena_l2d,\n" +
                        "      i_signed => w_fcvt_signed,\n" +
                        "      i_w32 => r.ena_w32,\n" +
                        "      i_a => r.a,\n" +
                        "      o_res => wb_res_l2d,\n" +
                        "      o_valid => w_valid_l2d,\n" +
                        "      o_busy => w_busy_l2d\n" +
                        "    );\n" +
                        "\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  comb : process(i_nrst, i_ena, i_ivec, i_a, i_b, r,\n" +
                        "                wb_res_fadd, w_valid_fadd, w_illegalop_fadd, w_overflow_fadd, w_busy_fadd,\n" +
                        "                wb_res_fdiv, w_valid_fdiv, w_illegalop_fdiv, w_divbyzero_fdiv, w_overflow_fdiv,\n" +
                        "                w_underflow_fdiv, w_busy_fdiv,\n" +
                        "                wb_res_fmul, w_valid_fmul, w_illegalop_fmul, w_overflow_fmul, w_busy_fmul,\n" +
                        "                wb_res_d2l, w_valid_d2l, w_overflow_d2l, w_underflow_d2l, w_busy_d2l,\n" +
                        "                wb_res_l2d, w_valid_l2d, w_busy_l2d)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable iv : std_logic_vector(Instr_FPU_Total-1 downto 0);\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "    iv := i_ivec;\n" +
                        "\n" +
                        "    v.ena_fadd := '0';\n" +
                        "    v.ena_fdiv := '0';\n" +
                        "    v.ena_fmul := '0';\n" +
                        "    v.ena_d2l := '0';\n" +
                        "    v.ena_l2d := '0';\n" +
                        "    v.ready := '0';\n" +
                        "    if i_ena = '1' and r.busy = '0' then\n" +
                        "        v.busy := '1';\n" +
                        "        v.a := i_a;\n" +
                        "        v.b := i_b;\n" +
                        "        v.ivec := i_ivec;\n" +
                        "        v.ex_invalidop := '0';\n" +
                        "        v.ex_divbyzero := '0';\n" +
                        "        v.ex_overflow := '0';\n" +
                        "        v.ex_underflow := '0';\n" +
                        "        v.ex_inexact := '0';\n" +
                        "\n" +
                        "        v.ena_fadd := iv(Instr_FADD_D - Instr_FADD_D)\n" +
                        "                    or iv(Instr_FSUB_D - Instr_FADD_D)\n" +
                        "                    or iv(Instr_FLE_D - Instr_FADD_D)\n" +
                        "                    or iv(Instr_FLT_D - Instr_FADD_D)\n" +
                        "                    or iv(Instr_FEQ_D - Instr_FADD_D)\n" +
                        "                    or iv(Instr_FMAX_D - Instr_FADD_D)\n" +
                        "                    or iv(Instr_FMIN_D - Instr_FADD_D);\n" +
                        "        v.ena_fdiv := iv(Instr_FDIV_D - Instr_FADD_D);\n" +
                        "        v.ena_fmul := iv(Instr_FMUL_D - Instr_FADD_D);\n" +
                        "        v.ena_d2l := iv(Instr_FCVT_LU_D - Instr_FADD_D)\n" +
                        "                    or iv(Instr_FCVT_L_D - Instr_FADD_D)\n" +
                        "                    or iv(Instr_FCVT_WU_D - Instr_FADD_D)\n" +
                        "                    or iv(Instr_FCVT_W_D - Instr_FADD_D);\n" +
                        "        v.ena_l2d := iv(Instr_FCVT_D_LU - Instr_FADD_D)\n" +
                        "                    or iv(Instr_FCVT_D_L - Instr_FADD_D)\n" +
                        "                    or iv(Instr_FCVT_D_WU - Instr_FADD_D)\n" +
                        "                    or iv(Instr_FCVT_D_W - Instr_FADD_D);\n" +
                        "\n" +
                        "        v.ena_w32 := iv(Instr_FCVT_WU_D - Instr_FADD_D)\n" +
                        "                    or iv(Instr_FCVT_W_D - Instr_FADD_D)\n" +
                        "                    or iv(Instr_FCVT_D_WU - Instr_FADD_D)\n" +
                        "                    or iv(Instr_FCVT_D_W - Instr_FADD_D);\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if r.busy = '1' and (r.ivec(Instr_FMOV_X_D - Instr_FADD_D)\n" +
                        "                        or r.ivec(Instr_FMOV_D_X - Instr_FADD_D)) = '1' then\n" +
                        "        v.busy := '0';\n" +
                        "        v.ready := '1';\n" +
                        "        v.result := r.a;\n" +
                        "    elsif w_valid_fadd = '1' then\n" +
                        "        v.busy := '0';\n" +
                        "        v.ready := '1';\n" +
                        "        v.result := wb_res_fadd;\n" +
                        "        v.ex_invalidop := w_illegalop_fadd;\n" +
                        "        v.ex_overflow := w_overflow_fadd;\n" +
                        "    elsif w_valid_fdiv = '1' then\n" +
                        "        v.busy := '0';\n" +
                        "        v.ready := '1';\n" +
                        "        v.result := wb_res_fdiv;\n" +
                        "        v.ex_invalidop := w_illegalop_fdiv;\n" +
                        "        v.ex_divbyzero := w_divbyzero_fdiv;\n" +
                        "        v.ex_overflow := w_overflow_fdiv;\n" +
                        "        v.ex_underflow := w_underflow_fdiv;\n" +
                        "    elsif w_valid_fmul = '1' then\n" +
                        "        v.busy := '0';\n" +
                        "        v.ready := '1';\n" +
                        "        v.result := wb_res_fmul;\n" +
                        "        v.ex_invalidop := w_illegalop_fmul;\n" +
                        "        v.ex_overflow := w_overflow_fmul;\n" +
                        "    elsif w_valid_d2l = '1' then\n" +
                        "        v.busy := '0';\n" +
                        "        v.ready := '1';\n" +
                        "        v.result := wb_res_d2l;\n" +
                        "        v.ex_overflow := w_overflow_d2l;\n" +
                        "        v.ex_underflow := w_underflow_d2l;\n" +
                        "    elsif w_valid_l2d = '1' then\n" +
                        "        v.busy := '0';\n" +
                        "        v.ready := '1';\n" +
                        "        v.result := wb_res_l2d;\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "    w_fadd_d <= r.ivec(Instr_FADD_D - Instr_FADD_D);\n" +
                        "    w_fsub_d <= r.ivec(Instr_FSUB_D - Instr_FADD_D);\n" +
                        "    w_feq_d <= r.ivec(Instr_FEQ_D - Instr_FADD_D);\n" +
                        "    w_flt_d <= r.ivec(Instr_FLT_D - Instr_FADD_D);\n" +
                        "    w_fle_d <= r.ivec(Instr_FLE_D - Instr_FADD_D);\n" +
                        "    w_fmax_d <= r.ivec(Instr_FMAX_D - Instr_FADD_D);\n" +
                        "    w_fmin_d <= r.ivec(Instr_FMIN_D - Instr_FADD_D);\n" +
                        "    w_fcvt_signed <= r.ivec(Instr_FCVT_L_D - Instr_FADD_D) or\n" +
                        "                     r.ivec(Instr_FCVT_D_L - Instr_FADD_D) or\n" +
                        "                     r.ivec(Instr_FCVT_W_D - Instr_FADD_D) or\n" +
                        "                     r.ivec(Instr_FCVT_D_W - Instr_FADD_D);\n" +
                        "\n" +
                        "    o_res <= r.result;\n" +
                        "    o_ex_invalidop <= r.ex_invalidop;\n" +
                        "    o_ex_divbyzero <= r.ex_divbyzero;\n" +
                        "    o_ex_overflow <= r.ex_overflow;\n" +
                        "    o_ex_underflow <= r.ex_underflow;\n" +
                        "    o_ex_inexact <= r.ex_inexact;\n" +
                        "    o_valid <= r.ready;\n" +
                        "    o_busy <= r.busy;\n" +
                        "  \n" +
                        "  -- registers:\n" +
                        "  regs : process(i_nrst, i_clk)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_fmul_d_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "\n" +
                        "entity DoubleMul is \n" +
                        "  generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_nrst       : in std_logic;\n" +
                        "    i_clk        : in std_logic;\n" +
                        "    i_ena        : in std_logic;\n" +
                        "    i_a          : in std_logic_vector(63 downto 0);\n" +
                        "    i_b          : in std_logic_vector(63 downto 0);\n" +
                        "    o_res        : out std_logic_vector(63 downto 0);\n" +
                        "    o_illegal_op : out std_logic;\n" +
                        "    o_overflow   : out std_logic;\n" +
                        "    o_valid      : out std_logic;\n" +
                        "    o_busy       : out std_logic\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_DoubleMul of DoubleMul is\n" +
                        "\n" +
                        "  component imul53 is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_nrst     : in std_logic;\n" +
                        "    i_clk      : in std_logic;\n" +
                        "    i_ena      : in std_logic;\n" +
                        "    i_a        : in std_logic_vector(52 downto 0);\n" +
                        "    i_b        : in std_logic_vector(52 downto 0);\n" +
                        "    o_result   : out std_logic_vector(105 downto 0);\n" +
                        "    o_shift    : out std_logic_vector(6 downto 0);\n" +
                        "    o_rdy      : out std_logic;\n" +
                        "    o_overflow : out std_logic\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "    busy : std_logic;\n" +
                        "    ena : std_logic_vector(4 downto 0);\n" +
                        "    a : std_logic_vector(63 downto 0);\n" +
                        "    b : std_logic_vector(63 downto 0);\n" +
                        "    result : std_logic_vector(63 downto 0);\n" +
                        "    zeroA : std_logic;\n" +
                        "    zeroB : std_logic;\n" +
                        "    mantA : std_logic_vector(52 downto 0);\n" +
                        "    mantB : std_logic_vector(52 downto 0);\n" +
                        "    expAB : std_logic_vector(12 downto 0);\n" +
                        "    expAlign : std_logic_vector(11 downto 0);\n" +
                        "    mantAlign : std_logic_vector(104 downto 0);\n" +
                        "    postShift : std_logic_vector(11 downto 0);\n" +
                        "    mantPostScale : std_logic_vector(104 downto 0);\n" +
                        "    nanA : std_logic;\n" +
                        "    nanB : std_logic;\n" +
                        "    overflow : std_logic;\n" +
                        "    illegal_op : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "    '0', (others => '0'),                               -- busy, ena\n" +
                        "    (others => '0'), (others => '0'), (others => '0'),  -- a, b, result\n" +
                        "    '0', '0', (others => '0'), (others => '0'),         -- zeroA, zeroB, mantA, mantB\n" +
                        "    (others => '0'), (others => '0'), (others => '0'),  -- expAB, expAlign, mantAlign\n" +
                        "    (others => '0'), (others => '0'),                   -- postShift, mantPostScale\n" +
                        "    '0', '0', '0', '0'                                  -- nanA, nanB, overflow, illegal_op\n" +
                        "  );\n" +
                        "\n" +
                        "  constant zero11 : std_logic_vector(10 downto 0) := (others => '0');\n" +
                        "  constant zero63 : std_logic_vector(62 downto 0) := (others => '0');\n" +
                        "  constant zero105 : std_logic_vector(104 downto 0) := (others => '0');\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "\n" +
                        "  signal w_imul_ena : std_logic;\n" +
                        "  signal wb_imul_result : std_logic_vector(105 downto 0);\n" +
                        "  signal wb_imul_shift : std_logic_vector(6 downto 0);\n" +
                        "  signal w_imul_rdy : std_logic;\n" +
                        "  signal w_imul_overflow : std_logic;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  u_imul53 : imul53 generic map (\n" +
                        "    async_reset => async_reset\n" +
                        "  ) port map (\n" +
                        "    i_nrst => i_nrst,\n" +
                        "    i_clk => i_clk,\n" +
                        "    i_ena => w_imul_ena,\n" +
                        "    i_a => r.mantA,\n" +
                        "    i_b => r.mantB,\n" +
                        "    o_result => wb_imul_result,\n" +
                        "    o_shift => wb_imul_shift,\n" +
                        "    o_rdy => w_imul_rdy,\n" +
                        "    o_overflow => w_imul_overflow\n" +
                        "  );\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  comb : process(i_nrst, i_ena, i_a, i_b, r,\n" +
                        "                 wb_imul_result, wb_imul_shift, w_imul_rdy, w_imul_overflow)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable signA : std_logic;\n" +
                        "    variable signB : std_logic;\n" +
                        "    variable mantA : std_logic_vector(52 downto 0);\n" +
                        "    variable mantB : std_logic_vector(52 downto 0);\n" +
                        "    variable zeroA : std_logic;\n" +
                        "    variable zeroB : std_logic;\n" +
                        "    variable expAB_t : std_logic_vector(11 downto 0);\n" +
                        "    variable expAB : std_logic_vector(12 downto 0);\n" +
                        "    variable mantAlign : std_logic_vector(104 downto 0);\n" +
                        "    variable expAlign_t : std_logic_vector(12 downto 0);\n" +
                        "    variable expAlign : std_logic_vector(12 downto 0);\n" +
                        "    variable postShift : std_logic_vector(11 downto 0);\n" +
                        "    variable mantPostScale : std_logic_vector(104 downto 0);\n" +
                        "    variable mantShort : std_logic_vector(52 downto 0);\n" +
                        "    variable tmpMant05 : std_logic_vector(51 downto 0);\n" +
                        "    variable mantOnes : std_logic;\n" +
                        "    variable mantEven : std_logic;\n" +
                        "    variable mant05 : std_logic;\n" +
                        "    variable rndBit : std_logic;\n" +
                        "    variable nanA : std_logic;\n" +
                        "    variable nanB : std_logic;\n" +
                        "    variable mantZeroA : std_logic;\n" +
                        "    variable mantZeroB : std_logic;\n" +
                        "    variable res : std_logic_vector(63 downto 0);\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    v.ena(0) := i_ena and not r.busy;\n" +
                        "    v.ena(1) := r.ena(0);\n" +
                        "    v.ena(4 downto 2) := r.ena(3 downto 2) & w_imul_rdy;\n" +
                        "\n" +
                        "    if i_ena = '1' then\n" +
                        "        v.busy := '1';\n" +
                        "        v.overflow := '0';\n" +
                        "        v.a := i_a;\n" +
                        "        v.b := i_b;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    signA := r.a(63);\n" +
                        "    signB := r.b(63);\n" +
                        "\n" +
                        "    zeroA := '0';\n" +
                        "    if r.a(62 downto 0) = zero63 then\n" +
                        "        zeroA := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    zeroB := '0';\n" +
                        "    if r.b(62 downto 0) = zero63 then\n" +
                        "        zeroB := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    mantA(51 downto 0) := r.a(51 downto 0);\n" +
                        "    mantA(52) := '0';\n" +
                        "    if r.a(62 downto 52) /= zero11 then\n" +
                        "        mantA(52) := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    mantB(51 downto 0) := r.b(51 downto 0);\n" +
                        "    mantB(52) := '0';\n" +
                        "    if r.b(62 downto 52) /= zero11 then\n" +
                        "        mantB(52) := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- expA - expB + 1023\n" +
                        "    expAB_t := ('0' & r.a(62 downto 52)) + ('0' & r.b(62 downto 52));\n" +
                        "    expAB := ('0' & expAB_t) - 1023;\n" +
                        "\n" +
                        "    if r.ena(0) = '1' then\n" +
                        "        v.expAB := expAB;\n" +
                        "        v.zeroA := zeroA;\n" +
                        "        v.zeroB := zeroB;\n" +
                        "        v.mantA := mantA;\n" +
                        "        v.mantB := mantB;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_imul_ena <= r.ena(1);\n" +
                        "\n" +
                        "    -- imul53 module:\n" +
                        "    mantAlign := (others => '0');\n" +
                        "    if wb_imul_result(105) = '1' then\n" +
                        "        mantAlign := wb_imul_result(105 downto 1);\n" +
                        "    elsif wb_imul_result(104) = '1' then\n" +
                        "        mantAlign := wb_imul_result(104 downto 0);\n" +
                        "    else\n" +
                        "        for i in 1 to 104 loop\n" +
                        "            if i = conv_integer(wb_imul_shift) then\n" +
                        "                mantAlign := wb_imul_result(104-i downto 0) & zero105(i-1 downto 0);\n" +
                        "            end if;\n" +
                        "        end loop;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    expAlign_t := r.expAB + 1;\n" +
                        "    if wb_imul_result(105) = '1' then\n" +
                        "        expAlign := expAlign_t;\n" +
                        "    elsif r.a(62 downto 52) = zero11 or r.b(62 downto 52) = zero11 then\n" +
                        "        expAlign := expAlign_t - (\"000000\" & wb_imul_shift);\n" +
                        "    else\n" +
                        "        expAlign := r.expAB - (\"000000\" & wb_imul_shift);\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- IMPORTANT exception! new ZERO value\n" +
                        "    if expAlign(12) = '1' or expAlign = zero63(12 downto 0) then\n" +
                        "        if wb_imul_shift = \"0000000\" or wb_imul_result(105) = '1'\n" +
                        "            or r.a(62 downto 52) = zero11 or r.b(62 downto 52) = zero11 then\n" +
                        "            postShift := not expAlign(11 downto 0) + 2;\n" +
                        "        else\n" +
                        "            postShift := not expAlign(11 downto 0) + 1;\n" +
                        "        end if;\n" +
                        "    else\n" +
                        "        postShift := (others => '0');\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if w_imul_rdy = '1' then\n" +
                        "        v.expAlign := expAlign(11 downto 0);\n" +
                        "        v.mantAlign := mantAlign;\n" +
                        "        v.postShift := postShift;\n" +
                        "\n" +
                        "        -- Exceptions:\n" +
                        "        v.nanA := '0';\n" +
                        "        if r.a(62 downto 52) = \"11111111111\" then\n" +
                        "            v.nanA := '1';\n" +
                        "        end if;\n" +
                        "        v.nanB := '0';\n" +
                        "        if r.b(62 downto 52) = \"11111111111\" then\n" +
                        "            v.nanB := '1';\n" +
                        "        end if;\n" +
                        "        v.overflow := '0';\n" +
                        "        if expAlign(12) = '0' and expAlign >= \"0011111111111\" then\n" +
                        "            v.overflow := '1';\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Prepare to mantissa post-scale\n" +
                        "    mantPostScale := (others => '0');\n" +
                        "    if r.postShift = X\"000\" then\n" +
                        "        mantPostScale := r.mantAlign;\n" +
                        "    elsif r.postShift < conv_std_logic_vector(105, 12) then\n" +
                        "        for i in 1 to 104 loop\n" +
                        "            if conv_std_logic_vector(i, 7) = r.postShift(6 downto 0) then\n" +
                        "                mantPostScale := zero105(i-1 downto 0) & r.mantAlign(104 downto i);\n" +
                        "            end if;\n" +
                        "        end loop;\n" +
                        "    end if;\n" +
                        "    if r.ena(2) = '1' then\n" +
                        "        v.mantPostScale := mantPostScale;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Rounding bit\n" +
                        "    mantShort := r.mantPostScale(104 downto 52);\n" +
                        "    tmpMant05 := r.mantPostScale(51 downto 0);\n" +
                        "    mantOnes := '0';\n" +
                        "    if mantShort(52) = '1' and mantShort(51 downto 0) = X\"fffffffffffff\" then\n" +
                        "        mantOnes := '1';\n" +
                        "    end if;\n" +
                        "    mantEven := r.mantPostScale(52);\n" +
                        "    mant05 := '0';\n" +
                        "    if tmpMant05 = X\"8000000000000\" then\n" +
                        "        mant05 := '1';\n" +
                        "    end if;\n" +
                        "    rndBit := r.mantPostScale(51) and not(mant05 and not mantEven);\n" +
                        "\n" +
                        "    -- Check Borders\n" +
                        "    nanA := '0';\n" +
                        "    if r.a(62 downto 52) = \"11111111111\" then\n" +
                        "        nanA := '1';\n" +
                        "    end if;\n" +
                        "    nanB := '0';\n" +
                        "    if r.b(62 downto 52) = \"11111111111\" then\n" +
                        "        nanB := '1';\n" +
                        "    end if;\n" +
                        "    mantZeroA := '0';\n" +
                        "    if r.a(51 downto 0) = zero63(51 downto 0) then\n" +
                        "        mantZeroA := '1';\n" +
                        "    end if;\n" +
                        "    mantZeroB := '0';\n" +
                        "    if r.b(51 downto 0) = zero63(51 downto 0) then\n" +
                        "        mantZeroB := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Result multiplexers:\n" +
                        "    if (nanA and mantZeroA and r.zeroB) = '1' or (nanB and mantZeroB and r.zeroA) = '1' then\n" +
                        "        res(63) := '1';\n" +
                        "    elsif (nanA and not mantZeroA) = '1' then\n" +
                        "        -- when both values are NaN, value B has higher priority if sign=1\n" +
                        "        res(63) := signA or (nanA and signB);\n" +
                        "    elsif (nanB and not mantZeroB) = '1' then\n" +
                        "        res(63) := signB;\n" +
                        "    else\n" +
                        "        res(63) := r.a(63) xor r.b(63);\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if nanA = '1' then\n" +
                        "        res(62 downto 52) := r.a(62 downto 52);\n" +
                        "    elsif nanB = '1' then\n" +
                        "        res(62 downto 52) := r.b(62 downto 52);\n" +
                        "    elsif (r.expAlign(11) or r.zeroA or r.zeroB) = '1' then\n" +
                        "        res(62 downto 52) := (others => '0');\n" +
                        "    elsif r.overflow = '1' then\n" +
                        "        res(62 downto 52) := (others => '1');\n" +
                        "    else\n" +
                        "        res(62 downto 52) := r.expAlign(10 downto 0)\n" +
                        "                       + (mantOnes and rndBit and not r.overflow);\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if (nanA and mantZeroA and not mantZeroB) = '1'\n" +
                        "        or (nanB and mantZeroB and not mantZeroA) = '1'\n" +
                        "        or (not nanA and not nanB and r.overflow) = '1' then\n" +
                        "        res(51 downto 0) := (others => '0');\n" +
                        "    elsif (nanA and not (nanB and signB)) = '1' then\n" +
                        "        -- when both values are NaN, value B has higher priority if sign=1\n" +
                        "        res(51) := '1';\n" +
                        "        res(50 downto 0) := r.a(50 downto 0);\n" +
                        "    elsif nanB = '1' then\n" +
                        "        res(51) := '1';\n" +
                        "        res(50 downto 0) := r.b(50 downto 0);\n" +
                        "    else\n" +
                        "        res(51 downto 0) := mantShort(51 downto 0) + rndBit;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if r.ena(3) = '1' then\n" +
                        "        v.result := res;\n" +
                        "        v.illegal_op := nanA or nanB;\n" +
                        "        v.busy := '0';\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  o_res <= r.result;\n" +
                        "  o_illegal_op <= r.illegal_op;\n" +
                        "  o_overflow <= r.overflow;\n" +
                        "  o_valid <= r.ena(4);\n" +
                        "  o_busy <= r.busy;\n" +
                        "  \n" +
                        "  -- registers:\n" +
                        "  regs : process(i_nrst, i_clk)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_fdiv_d_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "\n" +
                        "entity DoubleDiv is \n" +
                        "  generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_nrst       : in std_logic;\n" +
                        "    i_clk        : in std_logic;\n" +
                        "    i_ena        : in std_logic;\n" +
                        "    i_a          : in std_logic_vector(63 downto 0);\n" +
                        "    i_b          : in std_logic_vector(63 downto 0);\n" +
                        "    o_res        : out std_logic_vector(63 downto 0);\n" +
                        "    o_illegal_op : out std_logic;\n" +
                        "    o_divbyzero  : out std_logic;\n" +
                        "    o_overflow   : out std_logic;\n" +
                        "    o_underflow  : out std_logic;\n" +
                        "    o_valid      : out std_logic;\n" +
                        "    o_busy       : out std_logic\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_DoubleDiv of DoubleDiv is\n" +
                        "\n" +
                        "  component idiv53 is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_nrst       : in std_logic;\n" +
                        "    i_clk        : in std_logic;\n" +
                        "    i_ena        : in std_logic;\n" +
                        "    i_divident   : in std_logic_vector(52 downto 0);\n" +
                        "    i_divisor    : in std_logic_vector(52 downto 0);\n" +
                        "    o_result     : out std_logic_vector(104 downto 0);\n" +
                        "    o_lshift     : out std_logic_vector(6 downto 0);\n" +
                        "    o_rdy        : out std_logic;\n" +
                        "    o_overflow   : out std_logic;\n" +
                        "    o_zero_resid : out std_logic\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "    busy : std_logic;\n" +
                        "    ena : std_logic_vector(4 downto 0);\n" +
                        "    a : std_logic_vector(63 downto 0);\n" +
                        "    b : std_logic_vector(63 downto 0);\n" +
                        "    result : std_logic_vector(63 downto 0);\n" +
                        "    zeroA : std_logic;\n" +
                        "    zeroB : std_logic;\n" +
                        "    divisor : std_logic_vector(52 downto 0);\n" +
                        "    preShift : std_logic_vector(5 downto 0);\n" +
                        "    expAB : std_logic_vector(12 downto 0);\n" +
                        "    expAlign : std_logic_vector(11 downto 0);\n" +
                        "    mantAlign : std_logic_vector(104 downto 0);\n" +
                        "    postShift : std_logic_vector(11 downto 0);\n" +
                        "    mantPostScale : std_logic_vector(104 downto 0);\n" +
                        "    nanRes : std_logic;\n" +
                        "    overflow : std_logic;\n" +
                        "    underflow : std_logic;\n" +
                        "    illegal_op : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "    '0', (others => '0'),                               -- busy, ena\n" +
                        "    (others => '0'), (others => '0'), (others => '0'),  -- a, b, result\n" +
                        "    '0', '0', (others => '0'), (others => '0'),         -- zeroA, zeroB, divisor, preShift\n" +
                        "    (others => '0'), (others => '0'), (others => '0'),  -- expAB, expAlign, mantAlign\n" +
                        "    (others => '0'), (others => '0'),                   -- postShift, mantPostScale\n" +
                        "    '0', '0', '0', '0'                                  -- nanRes, overflow, underflow, illegal_op\n" +
                        "  );\n" +
                        "\n" +
                        "  constant zero105 : std_logic_vector(104 downto 0) := (others => '0');\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "\n" +
                        "  signal w_idiv_ena : std_logic;\n" +
                        "  signal wb_divident : std_logic_vector(52 downto 0);\n" +
                        "  signal wb_divisor : std_logic_vector(52 downto 0);\n" +
                        "  signal wb_idiv_result : std_logic_vector(104 downto 0);\n" +
                        "  signal wb_idiv_lshift : std_logic_vector(6 downto 0);\n" +
                        "  signal w_idiv_rdy : std_logic;\n" +
                        "  signal w_idiv_overflow : std_logic;\n" +
                        "  signal w_idiv_zeroresid : std_logic;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  u_idiv53 : idiv53 generic map (\n" +
                        "    async_reset => async_reset\n" +
                        "  ) port map (\n" +
                        "    i_nrst => i_nrst,\n" +
                        "    i_clk => i_clk,\n" +
                        "    i_ena => w_idiv_ena,\n" +
                        "    i_divident => wb_divident,\n" +
                        "    i_divisor => wb_divisor,\n" +
                        "    o_result => wb_idiv_result,\n" +
                        "    o_lshift => wb_idiv_lshift,\n" +
                        "    o_rdy => w_idiv_rdy,\n" +
                        "    o_overflow => w_idiv_overflow,\n" +
                        "    o_zero_resid => w_idiv_zeroresid\n" +
                        "  );\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  comb : process(i_nrst, i_ena, i_a, i_b, r,\n" +
                        "                 wb_idiv_result, wb_idiv_lshift, w_idiv_rdy, w_idiv_overflow,\n" +
                        "                 w_idiv_zeroresid)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable signA : std_logic;\n" +
                        "    variable signB : std_logic;\n" +
                        "    variable mantA : std_logic_vector(52 downto 0);\n" +
                        "    variable mantB : std_logic_vector(52 downto 0);\n" +
                        "    variable zeroA : std_logic;\n" +
                        "    variable zeroB : std_logic;\n" +
                        "    variable divisor : std_logic_vector(52 downto 0);\n" +
                        "    variable preShift : integer range 0 to 52;\n" +
                        "    variable expAB_t : std_logic_vector(11 downto 0);\n" +
                        "    variable expAB : std_logic_vector(12 downto 0);\n" +
                        "    variable mantAlign : std_logic_vector(104 downto 0);\n" +
                        "    variable expShift : std_logic_vector(11 downto 0);\n" +
                        "    variable expAlign : std_logic_vector(12 downto 0);\n" +
                        "    variable postShift : std_logic_vector(11 downto 0);\n" +
                        "    variable mantPostScale : std_logic_vector(104 downto 0);\n" +
                        "    variable mantShort : std_logic_vector(52 downto 0);\n" +
                        "    variable tmpMant05 : std_logic_vector(51 downto 0);\n" +
                        "    variable mantOnes : std_logic;\n" +
                        "    variable mantEven : std_logic;\n" +
                        "    variable mant05 : std_logic;\n" +
                        "    variable rndBit : std_logic;\n" +
                        "    variable nanA : std_logic;\n" +
                        "    variable nanB : std_logic;\n" +
                        "    variable mantZeroA : std_logic;\n" +
                        "    variable mantZeroB : std_logic;\n" +
                        "    variable res : std_logic_vector(63 downto 0);\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    v.ena(0) := i_ena and not r.busy;\n" +
                        "    v.ena(1) := r.ena(0);\n" +
                        "    v.ena(4 downto 2) := r.ena(3 downto 2) & w_idiv_rdy;\n" +
                        "\n" +
                        "    if i_ena = '1' then\n" +
                        "        v.busy := '1';\n" +
                        "        v.overflow := '0';\n" +
                        "        v.underflow := '0';\n" +
                        "        v.illegal_op := '0';\n" +
                        "        v.a := i_a;\n" +
                        "        v.b := i_b;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    signA := r.a(63);\n" +
                        "    signB := r.b(63);\n" +
                        "\n" +
                        "    zeroA := '0';\n" +
                        "    if r.a(62 downto 0) = zero105(62 downto 0) then\n" +
                        "        zeroA := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    zeroB := '0';\n" +
                        "    if r.b(62 downto 0) = zero105(62 downto 0) then\n" +
                        "        zeroB := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    mantA(51 downto 0) := r.a(51 downto 0);\n" +
                        "    mantA(52) := '0';\n" +
                        "    if r.a(62 downto 52) /= zero105(10 downto 0) then\n" +
                        "        mantA(52) := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    mantB(51 downto 0) := r.b(51 downto 0);\n" +
                        "    mantB(52) := '0';\n" +
                        "    if r.b(62 downto 52) /= zero105(10 downto 0) then\n" +
                        "        mantB(52) := '1';\n" +
                        "        divisor := mantB;\n" +
                        "        preShift := 0;\n" +
                        "    else\n" +
                        "        divisor := mantB;\n" +
                        "        preShift := 0;\n" +
                        "        for i in 1 to 52 loop\n" +
                        "            if preShift = 0 and mantB(52 - i) = '1' then\n" +
                        "                divisor := mantB(52-i downto 0) & zero105(i-1 downto 0);\n" +
                        "                preShift := i;\n" +
                        "            end if;\n" +
                        "        end loop;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- expA - expB + 1023\n" +
                        "    expAB_t := ('0' & r.a(62 downto 52)) + 1023;\n" +
                        "    expAB := ('0' & expAB_t) - (\"00\" & r.b(62 downto 52));\n" +
                        "\n" +
                        "    if r.ena(0) = '1' then\n" +
                        "        v.divisor := divisor;\n" +
                        "        v.preShift := conv_std_logic_vector(preShift, 6);\n" +
                        "        v.expAB := expAB;\n" +
                        "        v.zeroA := zeroA;\n" +
                        "        v.zeroB := zeroB;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_idiv_ena <= r.ena(1);\n" +
                        "    wb_divident <= mantA;\n" +
                        "    wb_divisor <= r.divisor;\n" +
                        "\n" +
                        "    -- idiv53 module:\n" +
                        "    mantAlign := (others => '0');\n" +
                        "    if wb_idiv_lshift = zero105(6 downto 0) then\n" +
                        "        mantAlign := wb_idiv_result;\n" +
                        "    else\n" +
                        "        for i in 1 to 104 loop\n" +
                        "            if i = conv_integer(wb_idiv_lshift) then\n" +
                        "                mantAlign := wb_idiv_result(104-i downto 0) & zero105(i-1 downto 0);\n" +
                        "            end if;\n" +
                        "        end loop;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    expShift := (\"000000\" & r.preShift) - (\"00000\" & wb_idiv_lshift);\n" +
                        "    if r.b(62 downto 52) = \"00000000000\" and r.a(62 downto 52) /= \"00000000000\" then\n" +
                        "        expShift := expShift - 1;\n" +
                        "    elsif r.b(62 downto 52) /= \"00000000000\" and r.a(62 downto 52) = \"00000000000\" then\n" +
                        "        expShift := expShift + 1;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    expAlign := r.expAB + (expShift(11) & expShift);\n" +
                        "    if expAlign(12) = '1' then\n" +
                        "        postShift := not expAlign(11 downto 0) + 2;\n" +
                        "    else\n" +
                        "        postShift := (others => '0');\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if w_idiv_rdy = '1' then\n" +
                        "        v.expAlign := expAlign(11 downto 0);\n" +
                        "        v.mantAlign := mantAlign;\n" +
                        "        v.postShift := postShift;\n" +
                        "\n" +
                        "        -- Exceptions:\n" +
                        "        v.nanRes := '0';\n" +
                        "        if expAlign = \"0011111111111\" then\n" +
                        "            v.nanRes := '1';\n" +
                        "        end if;\n" +
                        "        v.overflow := not expAlign(12) and expAlign(11);\n" +
                        "        v.underflow := expAlign(12) and expAlign(11);\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Prepare to mantissa post-scale\n" +
                        "    mantPostScale := (others => '0');\n" +
                        "    if r.postShift = X\"000\" then\n" +
                        "        mantPostScale := r.mantAlign;\n" +
                        "    elsif r.postShift < conv_std_logic_vector(105, 12) then\n" +
                        "        for i in 1 to 104 loop\n" +
                        "            if conv_std_logic_vector(i, 7) = r.postShift(6 downto 0) then\n" +
                        "                mantPostScale := zero105(i-1 downto 0) & r.mantAlign(104 downto i);\n" +
                        "            end if;\n" +
                        "        end loop;\n" +
                        "    end if;\n" +
                        "    if r.ena(2) = '1' then\n" +
                        "        v.mantPostScale := mantPostScale;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Rounding bit\n" +
                        "    mantShort := r.mantPostScale(104 downto 52);\n" +
                        "    tmpMant05 := r.mantPostScale(51 downto 0);\n" +
                        "    mantOnes := '0';\n" +
                        "    if mantShort(52) = '1' and mantShort(51 downto 0) = X\"fffffffffffff\" then\n" +
                        "        mantOnes := '1';\n" +
                        "    end if;\n" +
                        "    mantEven := r.mantPostScale(52);\n" +
                        "    mant05 := '0';\n" +
                        "    if tmpMant05 = X\"8000000000000\" then\n" +
                        "        mant05 := '1';\n" +
                        "    end if;\n" +
                        "    rndBit := r.mantPostScale(51) and not(mant05 and not mantEven);\n" +
                        "\n" +
                        "    -- Check Borders\n" +
                        "    nanA := '0';\n" +
                        "    if r.a(62 downto 52) = \"11111111111\" then\n" +
                        "        nanA := '1';\n" +
                        "    end if;\n" +
                        "    nanB := '0';\n" +
                        "    if r.b(62 downto 52) = \"11111111111\" then\n" +
                        "        nanB := '1';\n" +
                        "    end if;\n" +
                        "    mantZeroA := '0';\n" +
                        "    if r.a(51 downto 0) = zero105(51 downto 0) then\n" +
                        "        mantZeroA := '1';\n" +
                        "    end if;\n" +
                        "    mantZeroB := '0';\n" +
                        "    if r.b(51 downto 0) = zero105(51 downto 0) then\n" +
                        "        mantZeroB := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Result multiplexers:\n" +
                        "    if (nanA and mantZeroA and nanB and mantZeroB) = '1' then\n" +
                        "        res(63) := '1';\n" +
                        "    elsif (nanA and not mantZeroA) = '1' then\n" +
                        "        res(63) := signA;\n" +
                        "    elsif (nanB and not mantZeroB) = '1' then\n" +
                        "        res(63) := signB;\n" +
                        "    elsif (r.zeroA and r.zeroB) = '1' then\n" +
                        "        res(63) := '1';\n" +
                        "    else\n" +
                        "        res(63) := r.a(63) xor r.b(63);\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if nanB = '1' and mantZeroB = '0' then\n" +
                        "        res(62 downto 52) := r.b(62 downto 52);\n" +
                        "    elsif (r.underflow or r.zeroA) = '1' and r.zeroB = '0' then\n" +
                        "        res(62 downto 52) := (others => '0');\n" +
                        "    elsif (r.overflow or r.zeroB) = '1' then\n" +
                        "        res(62 downto 52) := (others => '1');\n" +
                        "    elsif nanA = '1' then\n" +
                        "        res(62 downto 52) := r.a(62 downto 52);\n" +
                        "    elsif ((nanB and mantZeroB) or r.expAlign(11)) = '1' then\n" +
                        "        res(62 downto 52) := (others => '0');\n" +
                        "    else\n" +
                        "        res(62 downto 52) := r.expAlign(10 downto 0)\n" +
                        "                       + (mantOnes and rndBit and not r.overflow);\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if (r.zeroA and r.zeroB) = '1'\n" +
                        "        or (nanA and mantZeroA and nanB and mantZeroB) = '1' then\n" +
                        "        res(51) := '1';\n" +
                        "        res(50 downto 0) := (others => '0');\n" +
                        "    elsif nanA = '1' and mantZeroA = '0' then\n" +
                        "        res(51) := '1';\n" +
                        "        res(50 downto 0) := r.a(50 downto 0);\n" +
                        "    elsif nanB = '1' and mantZeroB = '0'then\n" +
                        "        res(51) := '1';\n" +
                        "        res(50 downto 0) := r.b(50 downto 0);\n" +
                        "    elsif r.overflow = '1' or r.nanRes = '1' or (nanA and mantZeroA) = '1'\n" +
                        "          or (nanB and mantZeroB) = '1' then\n" +
                        "        res(51 downto 0) := (others => '0');\n" +
                        "    else\n" +
                        "        res(51 downto 0) := mantShort(51 downto 0) + rndBit;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if r.ena(3) = '1' then\n" +
                        "        v.result := res;\n" +
                        "        v.illegal_op := nanA or nanB;\n" +
                        "        v.busy := '0';\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  o_res <= r.result;\n" +
                        "  o_illegal_op <= r.illegal_op;\n" +
                        "  o_divbyzero <= r.zeroB;\n" +
                        "  o_overflow <= r.overflow;\n" +
                        "  o_underflow <= r.underflow;\n" +
                        "  o_valid <= r.ena(4);\n" +
                        "  o_busy <= r.busy;\n" +
                        "  \n" +
                        "  -- registers:\n" +
                        "  regs : process(i_nrst, i_clk)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_fadd_d_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "\n" +
                        "entity DoubleAdd is \n" +
                        "  generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_nrst       : in std_logic;\n" +
                        "    i_clk        : in std_logic;\n" +
                        "    i_ena        : in std_logic;\n" +
                        "    i_add        : in std_logic;\n" +
                        "    i_sub        : in std_logic;\n" +
                        "    i_eq         : in std_logic;\n" +
                        "    i_lt         : in std_logic;\n" +
                        "    i_le         : in std_logic;\n" +
                        "    i_max        : in std_logic;\n" +
                        "    i_min        : in std_logic;\n" +
                        "    i_a          : in std_logic_vector(63 downto 0);\n" +
                        "    i_b          : in std_logic_vector(63 downto 0);\n" +
                        "    o_res        : out std_logic_vector(63 downto 0);\n" +
                        "    o_illegal_op : out std_logic;\n" +
                        "    o_overflow   : out std_logic;\n" +
                        "    o_valid      : out std_logic;\n" +
                        "    o_busy       : out std_logic\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_DoubleAdd of DoubleAdd is\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "    busy : std_logic;\n" +
                        "    ena : std_logic_vector(7 downto 0);\n" +
                        "    a : std_logic_vector(63 downto 0);\n" +
                        "    b : std_logic_vector(63 downto 0);\n" +
                        "    result : std_logic_vector(63 downto 0);\n" +
                        "    illegal_op : std_logic;\n" +
                        "    overflow : std_logic;\n" +
                        "    add : std_logic;\n" +
                        "    sub : std_logic;\n" +
                        "    eq : std_logic;\n" +
                        "    lt : std_logic;\n" +
                        "    le : std_logic;\n" +
                        "    max : std_logic;\n" +
                        "    min : std_logic;\n" +
                        "    flMore : std_logic;\n" +
                        "    flEqual : std_logic;\n" +
                        "    flLess : std_logic;\n" +
                        "    preShift : integer range 0 to 4095;\n" +
                        "    signOpMore : std_logic;\n" +
                        "    expMore : std_logic_vector(10 downto 0);\n" +
                        "    mantMore : std_logic_vector(52 downto 0);\n" +
                        "    mantLess : std_logic_vector(52 downto 0);\n" +
                        "    mantLessScale : std_logic_vector(104 downto 0);\n" +
                        "    mantSum : std_logic_vector(105 downto 0);\n" +
                        "    lshift : integer range 0 to 127;\n" +
                        "    mantAlign : std_logic_vector(104 downto 0);\n" +
                        "    expPostScale : std_logic_vector(11 downto 0);\n" +
                        "    expPostScaleInv : integer range 0 to 4095;\n" +
                        "    mantPostScale : std_logic_vector(104 downto 0);\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "    '0', (others => '0'),                               -- busy, ena\n" +
                        "    (others => '0'), (others => '0'), (others => '0'),  -- a, b, result\n" +
                        "    '0', '0', '0', '0',                                 -- illegal_op, overflow, add, sub\n" +
                        "    '0', '0', '0', '0', '0',                            -- eq, lt, le, max, min\n" +
                        "    '0', '0', '0',                                      -- flMore, flEqual, flLess\n" +
                        "    0, '0', (others => '0'),                            -- preShift, signOpMore, expMore\n" +
                        "    (others => '0'), (others => '0'), (others => '0'),  -- mantMore, mantLess, mantLessScale\n" +
                        "    (others => '0'), 0, (others => '0'),                -- mantSum, lshift, mantAlign\n" +
                        "    (others => '0'), 0, (others => '0')                 -- expPostScale, expPostScaleInv, mantPostScale\n" +
                        "  );\n" +
                        "\n" +
                        "  constant zero105 : std_logic_vector(104 downto 0) := (others => '0');\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  comb : process(i_nrst, i_ena, i_add, i_sub, i_eq, i_lt, i_le, i_max, i_min,\n" +
                        "                 i_a, i_b, r)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable signOp : std_logic;\n" +
                        "    variable signA : std_logic;\n" +
                        "    variable signB : std_logic;\n" +
                        "    variable signOpB : std_logic;\n" +
                        "    variable mantA : std_logic_vector(52 downto 0);\n" +
                        "    variable mantB : std_logic_vector(52 downto 0);\n" +
                        "    variable mantDif : std_logic_vector(53 downto 0);\n" +
                        "    variable expDif : std_logic_vector(11 downto 0);\n" +
                        "    variable v_flMore : std_logic;\n" +
                        "    variable v_flEqual : std_logic;\n" +
                        "    variable v_flLess : std_logic;\n" +
                        "    variable vb_preShift : std_logic_vector(11 downto 0);\n" +
                        "    variable v_signOpMore : std_logic;\n" +
                        "    variable vb_expMore : std_logic_vector(10 downto 0);\n" +
                        "    variable vb_mantMore : std_logic_vector(52 downto 0);\n" +
                        "    variable vb_mantLess : std_logic_vector(52 downto 0);\n" +
                        "    variable mantMoreScale : std_logic_vector(104 downto 0);\n" +
                        "    variable mantLessScale : std_logic_vector(104 downto 0);\n" +
                        "    variable vb_mantSum : std_logic_vector(105 downto 0);\n" +
                        "    variable vb_mantSumInv : std_logic_vector(104 downto 0);\n" +
                        "    variable vb_lshift : integer range 0 to 127;\n" +
                        "    variable vb_lshift_p1 : integer range 0 to 127;\n" +
                        "    variable vb_lshift_p2 : integer range 0 to 127;\n" +
                        "    variable vb_mantAlign : std_logic_vector(104 downto 0);\n" +
                        "    variable vb_expPostScale : std_logic_vector(11 downto 0);\n" +
                        "    variable vb_mantPostScale : std_logic_vector(104 downto 0);\n" +
                        "    variable mantShort : std_logic_vector(52 downto 0);\n" +
                        "    variable tmpMant05 : std_logic_vector(51 downto 0);\n" +
                        "    variable mantOnes : std_logic;\n" +
                        "    variable mantEven : std_logic;\n" +
                        "    variable mant05 : std_logic;\n" +
                        "    variable rndBit : std_logic;\n" +
                        "    variable mantZeroA : std_logic;\n" +
                        "    variable mantZeroB : std_logic;\n" +
                        "    variable allZero : std_logic;\n" +
                        "    variable sumZero : std_logic;\n" +
                        "    variable nanA : std_logic;\n" +
                        "    variable nanB : std_logic;\n" +
                        "    variable nanAB : std_logic;\n" +
                        "    variable overflow : std_logic;\n" +
                        "    variable resAdd : std_logic_vector(63 downto 0);\n" +
                        "    variable resEQ : std_logic_vector(63 downto 0);\n" +
                        "    variable resLT : std_logic_vector(63 downto 0);\n" +
                        "    variable resLE : std_logic_vector(63 downto 0);\n" +
                        "    variable resMax : std_logic_vector(63 downto 0);\n" +
                        "    variable resMin : std_logic_vector(63 downto 0);\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    v.ena := r.ena(6 downto 0) & (i_ena and not r.busy);\n" +
                        "\n" +
                        "    if i_ena = '1' then\n" +
                        "        v.busy := '1';\n" +
                        "        v.add := i_add;\n" +
                        "        v.sub := i_sub;\n" +
                        "        v.eq := i_eq;\n" +
                        "        v.lt := i_lt;\n" +
                        "        v.le := i_le;\n" +
                        "        v.max := i_max;\n" +
                        "        v.min := i_min;\n" +
                        "        v.a := i_a;\n" +
                        "        v.b := i_b;\n" +
                        "        v.illegal_op := '0';\n" +
                        "        v.overflow := '0';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    signOp := r.sub or r.le or r.lt;\n" +
                        "    signA := r.a(63);\n" +
                        "    signB := r.b(63);\n" +
                        "    signOpB := signB xor signOp;\n" +
                        "\n" +
                        "    mantA(51 downto 0) := r.a(51 downto 0);\n" +
                        "    mantA(52) := '0';\n" +
                        "    if r.a(62 downto 52) /= zero105(10 downto 0) then\n" +
                        "        mantA(52) := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    mantB(51 downto 0) := r.b(51 downto 0);\n" +
                        "    mantB(52) := '0';\n" +
                        "    if r.b(62 downto 52) /= zero105(10 downto 0) then\n" +
                        "        mantB(52) := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if r.a(62 downto 52) /= \"00000000000\" and r.b(62 downto 52) = \"00000000000\" then\n" +
                        "        expDif := ('0' & r.a(62 downto 52)) - \"000000000001\";\n" +
                        "    elsif r.a(62 downto 52) = \"00000000000\" and r.b(62 downto 52) /= \"00000000000\" then\n" +
                        "        expDif := \"000000000001\" - ('0' & r.b(62 downto 52));\n" +
                        "    else\n" +
                        "        expDif := ('0' & r.a(62 downto 52)) - ('0' & r.b(62 downto 52));\n" +
                        "    end if;\n" +
                        "\n" +
                        "    mantDif := ('0' & mantA) - ('0' & mantB);\n" +
                        "    if expDif = X\"000\" then\n" +
                        "        vb_preShift := expDif;\n" +
                        "        if mantDif = zero105(53 downto 0) then\n" +
                        "            v_flMore := not signA and (signA xor signB);\n" +
                        "            v_flEqual := not (signA xor signB);\n" +
                        "            v_flLess := signA and (signA xor signB);\n" +
                        "\n" +
                        "            v_signOpMore := signA;\n" +
                        "            vb_expMore := r.a(62 downto 52);\n" +
                        "            vb_mantMore := mantA;\n" +
                        "            vb_mantLess := mantB;\n" +
                        "        elsif mantDif(53) = '0' then  -- A > B\n" +
                        "            v_flMore := not signA;\n" +
                        "            v_flEqual := '0';\n" +
                        "            v_flLess := signA;\n" +
                        "\n" +
                        "            v_signOpMore := signA;\n" +
                        "            vb_expMore := r.a(62 downto 52);\n" +
                        "            vb_mantMore := mantA;\n" +
                        "            vb_mantLess := mantB;\n" +
                        "        else\n" +
                        "            v_flMore := signB;\n" +
                        "            v_flEqual := '0';\n" +
                        "            v_flLess := not signB;\n" +
                        "\n" +
                        "            v_signOpMore := signOpB;\n" +
                        "            vb_expMore := r.b(62 downto 52);\n" +
                        "            vb_mantMore := mantB;\n" +
                        "            vb_mantLess := mantA;\n" +
                        "        end if;\n" +
                        "    elsif expDif(11) = '0' then\n" +
                        "        v_flMore := not signA;\n" +
                        "        v_flEqual := '0';\n" +
                        "        v_flLess := signA;\n" +
                        "\n" +
                        "        vb_preShift := expDif;\n" +
                        "        v_signOpMore := signA;\n" +
                        "        vb_expMore := r.a(62 downto 52);\n" +
                        "        vb_mantMore := mantA;\n" +
                        "        vb_mantLess := mantB;\n" +
                        "    else\n" +
                        "        v_flMore := signB;\n" +
                        "        v_flEqual := '0';\n" +
                        "        v_flLess := not signB;\n" +
                        "\n" +
                        "        vb_preShift := not expDif + 1;\n" +
                        "        v_signOpMore := signOpB;\n" +
                        "        vb_expMore := r.b(62 downto 52);\n" +
                        "        vb_mantMore := mantB;\n" +
                        "        vb_mantLess := mantA;\n" +
                        "    end if;\n" +
                        "    if r.ena(0) = '1' then\n" +
                        "        v.flMore := v_flMore;\n" +
                        "        v.flEqual := v_flEqual;\n" +
                        "        v.flLess := v_flLess;\n" +
                        "        v.preShift := conv_integer(vb_preShift);\n" +
                        "        v.signOpMore := v_signOpMore;\n" +
                        "        v.expMore := vb_expMore;\n" +
                        "        v.mantMore := vb_mantMore;\n" +
                        "        v.mantLess := vb_mantLess;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Pre-scale 105-bits mantissa if preShift < 105:\n" +
                        "    -- M = {mantM, 52'd0}\n" +
                        "    mantLessScale := r.mantLess & zero105(51 downto 0);\n" +
                        "    if r.ena(1) = '1' then\n" +
                        "        if r.preShift = 0 then\n" +
                        "            v.mantLessScale := mantLessScale;\n" +
                        "        else\n" +
                        "            v.mantLessScale := (others => '0');\n" +
                        "            for i in 1 to 104 loop\n" +
                        "                if i = r.preShift then\n" +
                        "                    v.mantLessScale := zero105(i-1 downto 0) & mantLessScale(104 downto i);\n" +
                        "                end if;\n" +
                        "            end loop;\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    mantMoreScale := r.mantMore & zero105(51 downto 0);\n" +
                        "\n" +
                        "    -- 106-bits adder/subtractor\n" +
                        "    if (signA xor signOpB) = '1' then\n" +
                        "        vb_mantSum := ('0' & mantMoreScale) - ('0' & r.mantLessScale);\n" +
                        "    else\n" +
                        "        vb_mantSum := ('0' & mantMoreScale) + ('0' & r.mantLessScale);\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if r.ena(2) = '1' then\n" +
                        "        v.mantSum := vb_mantSum;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- To avoid timing constrains violation occured in Vivado Studio\n" +
                        "    -- try to implement parallel demuxultiplexer splitted on 2 parts\n" +
                        "    vb_mantSumInv(0) := '0';\n" +
                        "    for i in 0 to 103 loop\n" +
                        "        vb_mantSumInv(i + 1) := r.mantSum(103 - i);\n" +
                        "    end loop;\n" +
                        "    \n" +
                        "    vb_lshift_p1 := 0;\n" +
                        "    for i in 0 to 63 loop\n" +
                        "        if vb_lshift_p1 = 0 and vb_mantSumInv(i) = '1' then\n" +
                        "            vb_lshift_p1 := i;\n" +
                        "        end if;\n" +
                        "    end loop;\n" +
                        "    \n" +
                        "    vb_lshift_p2 := 0;\n" +
                        "    for i in 0 to 40 loop\n" +
                        "        if vb_lshift_p2 = 0 and vb_mantSumInv(64 + i) = '1' then\n" +
                        "            vb_lshift_p2 := 64 + i;\n" +
                        "        end if;\n" +
                        "    end loop;\n" +
                        "\n" +
                        "    -- multiplexer\n" +
                        "    if r.mantSum(105) = '1' then\n" +
                        "        -- shift right\n" +
                        "        vb_lshift := 127;\n" +
                        "    elsif r.mantSum(104) = '1' then\n" +
                        "        vb_lshift := 0;\n" +
                        "    elsif vb_lshift_p1 /= 0 then\n" +
                        "        vb_lshift := vb_lshift_p1;\n" +
                        "    else\n" +
                        "        vb_lshift := vb_lshift_p2;\n" +
                        "    end if;\n" +
                        "    if r.ena(3) = '1' then\n" +
                        "        v.lshift := vb_lshift;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Prepare to mantissa post-scale\n" +
                        "    vb_mantAlign := (others => '0');\n" +
                        "    if r.lshift = 127 then\n" +
                        "        vb_mantAlign := r.mantSum(105 downto 1);\n" +
                        "    elsif r.lshift = 0 then\n" +
                        "        vb_mantAlign := r.mantSum(104 downto 0);\n" +
                        "    else\n" +
                        "        for i in 1 to 104 loop\n" +
                        "            if i = r.lshift then\n" +
                        "                vb_mantAlign := r.mantSum(104-i downto 0) & zero105(i-1 downto 0);\n" +
                        "            end if;\n" +
                        "        end loop;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if r.lshift = 127 then\n" +
                        "        if r.expMore = \"11111111111\" then\n" +
                        "            vb_expPostScale := ('0' & r.expMore);\n" +
                        "        else\n" +
                        "            vb_expPostScale := ('0' & r.expMore) + 1;\n" +
                        "        end if;\n" +
                        "    else\n" +
                        "        if r.expMore = \"00000000000\" and r.lshift = 0 then\n" +
                        "            vb_expPostScale := X\"001\";\n" +
                        "        else\n" +
                        "            vb_expPostScale := ('0' & r.expMore) - conv_std_logic_vector(r.lshift, 12);\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "    if (signA xor signOpB) = '1' then\n" +
                        "        -- subtractor only: result value becomes with exp=0\n" +
                        "        if r.expMore /= \"00000000000\" and\n" +
                        "           (vb_expPostScale(11) = '1' or vb_expPostScale = X\"000\") then\n" +
                        "            vb_expPostScale := vb_expPostScale - 1;\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "    if r.ena(4) = '1' then\n" +
                        "        v.mantAlign := vb_mantAlign;\n" +
                        "        v.expPostScale := vb_expPostScale;\n" +
                        "        v.expPostScaleInv := conv_integer((not vb_expPostScale) + 1);\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Mantissa post-scale:\n" +
                        "    --    Scaled = SumScale>>(-ExpSum) only if ExpSum < 0;\n" +
                        "    vb_mantPostScale := r.mantAlign;\n" +
                        "    if r.expPostScale(11) = '1' then\n" +
                        "        for i in 1 to 104 loop\n" +
                        "            if i = r.expPostScaleInv then\n" +
                        "                vb_mantPostScale := zero105(i-1 downto 0) & r.mantAlign(104 downto i);\n" +
                        "            end if;\n" +
                        "        end loop;\n" +
                        "    end if;\n" +
                        "    if r.ena(5) = '1' then\n" +
                        "        v.mantPostScale := vb_mantPostScale;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Rounding bit\n" +
                        "    mantShort := r.mantPostScale(104 downto 52);\n" +
                        "    tmpMant05 := r.mantPostScale(51 downto 0);\n" +
                        "    mantOnes := '0';\n" +
                        "    if mantShort(52) = '1' and mantShort(51 downto 0) = X\"fffffffffffff\" then\n" +
                        "        mantOnes := '1';\n" +
                        "    end if;\n" +
                        "    mantEven := r.mantPostScale(52);\n" +
                        "    mant05 := '0';\n" +
                        "    if tmpMant05 = X\"8000000000000\" then\n" +
                        "        mant05 := '1';\n" +
                        "    end if;\n" +
                        "    rndBit := r.mantPostScale(51) and not(mant05 and not mantEven);\n" +
                        "\n" +
                        "    -- Check Borders\n" +
                        "    mantZeroA := '0';\n" +
                        "    if r.a(51 downto 0) = zero105(51 downto 0) then\n" +
                        "        mantZeroA := '1';\n" +
                        "    end if;\n" +
                        "    mantZeroB := '0';\n" +
                        "    if r.b(51 downto 0) = zero105(51 downto 0) then\n" +
                        "        mantZeroB := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Exceptions\n" +
                        "    allZero := '0';\n" +
                        "    if r.a(62 downto 0) = zero105(62 downto 0) and\n" +
                        "       r.b(62 downto 0) = zero105(62 downto 0) then\n" +
                        "        allZero := '1';\n" +
                        "    end if;\n" +
                        "    sumZero := '0';\n" +
                        "    if r.mantPostScale = zero105 then\n" +
                        "        sumZero := '1';\n" +
                        "    end if;\n" +
                        "    nanA := '0';\n" +
                        "    if r.a(62 downto 52) = \"11111111111\" then\n" +
                        "        nanA := '1';\n" +
                        "    end if;\n" +
                        "    nanB := '0';\n" +
                        "    if r.b(62 downto 52) = \"11111111111\" then\n" +
                        "        nanB := '1';\n" +
                        "    end if;\n" +
                        "    nanAB := nanA and mantZeroA and nanB and mantZeroB;\n" +
                        "    overflow := '0';\n" +
                        "    if r.expPostScale = X\"7FF\" then   -- positive\n" +
                        "        overflow := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Result multiplexers:\n" +
                        "    if (nanAB and signOp) = '1' then\n" +
                        "        resAdd(63) := signA xor signOpB;\n" +
                        "    elsif nanA = '1' then\n" +
                        "        -- when both values are NaN, value B has higher priority if sign=1\n" +
                        "        resAdd(63) := signA or (nanB and signOpB);\n" +
                        "    elsif nanB = '1' then\n" +
                        "        resAdd(63) := signOpB xor (signOp and not mantZeroB);\n" +
                        "    elsif allZero = '1' then\n" +
                        "        resAdd(63) := signA and signOpB;\n" +
                        "    elsif sumZero = '1' then\n" +
                        "        resAdd(63) := '0';\n" +
                        "    else\n" +
                        "        resAdd(63) := r.signOpMore;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if (nanA or nanB) = '1' then\n" +
                        "        resAdd(62 downto 52) := (others => '1');\n" +
                        "    elsif r.expPostScale(11) = '1' or sumZero = '1' then\n" +
                        "        resAdd(62 downto 52) := (others => '0');\n" +
                        "    else\n" +
                        "        resAdd(62 downto 52) := r.expPostScale(10 downto 0)\n" +
                        "                       + (mantOnes and rndBit and not r.overflow);\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if (nanA and mantZeroA and nanB and mantZeroB) = '1' then\n" +
                        "        resAdd(51) := '1';\n" +
                        "        resAdd(50 downto 0) := (others => '0');\n" +
                        "    elsif nanA = '1' and (nanB and signOpB) = '0' then\n" +
                        "        -- when both values are NaN, value B has higher priority if sign=1\n" +
                        "        resAdd(51) := '1';\n" +
                        "        resAdd(50 downto 0) := r.a(50 downto 0);\n" +
                        "    elsif nanB = '1' then\n" +
                        "        resAdd(51) := '1';\n" +
                        "        resAdd(50 downto 0) := r.b(50 downto 0);\n" +
                        "    elsif r.overflow = '1'  then\n" +
                        "        resAdd(51 downto 0) := (others => '0');\n" +
                        "    else\n" +
                        "        resAdd(51 downto 0) := mantShort(51 downto 0) + rndBit;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    resEQ(63 downto 1) := (others => '0');\n" +
                        "    resEQ(0) := r.flEqual;\n" +
                        "\n" +
                        "    resLT(63 downto 1) := (others => '0');\n" +
                        "    resLT(0) := r.flLess;\n" +
                        "\n" +
                        "    resLE(63 downto 1) := (others => '0');\n" +
                        "    resLE(0) := r.flLess or r.flEqual;\n" +
                        "\n" +
                        "    if (nanA or nanB) = '1' then\n" +
                        "        resMax := r.b;\n" +
                        "    elsif r.flMore = '1' then\n" +
                        "        resMax := r.a;\n" +
                        "    else\n" +
                        "        resMax := r.b;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if (nanA or nanB) = '1' then\n" +
                        "        resMin := r.b;\n" +
                        "    elsif r.flLess = '1' then\n" +
                        "        resMin := r.a;\n" +
                        "    else\n" +
                        "        resMin := r.b;\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    if r.ena(6) = '1' then\n" +
                        "        if r.eq = '1' then\n" +
                        "            v.result := resEQ;\n" +
                        "        elsif r.lt = '1' then\n" +
                        "            v.result := resLT;\n" +
                        "        elsif r.le = '1' then\n" +
                        "            v.result := resLE;\n" +
                        "        elsif r.max = '1' then\n" +
                        "            v.result := resMax;\n" +
                        "        elsif r.min = '1' then\n" +
                        "            v.result := resMin;\n" +
                        "        else\n" +
                        "            v.result := resAdd;\n" +
                        "        end if;\n" +
                        "\n" +
                        "        v.illegal_op := nanA or nanB;\n" +
                        "        v.overflow := overflow;\n" +
                        "\n" +
                        "        v.busy := '0';\n" +
                        "        v.add := '0';\n" +
                        "        v.sub := '0';\n" +
                        "        v.eq := '0';\n" +
                        "        v.lt := '0';\n" +
                        "        v.le := '0';\n" +
                        "        v.max := '0';\n" +
                        "        v.min := '0';\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  o_res <= r.result;\n" +
                        "  o_illegal_op <= r.illegal_op;\n" +
                        "  o_overflow <= r.overflow;\n" +
                        "  o_valid <= r.ena(7);\n" +
                        "  o_busy <= r.busy;\n" +
                        "  \n" +
                        "  -- registers:\n" +
                        "  regs : process(i_nrst, i_clk)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_divstage53_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "\n" +
                        "entity divstage53 is \n" +
                        "  port (\n" +
                        "    i_mux_ena    : in std_logic;  -- find first non-zero bit\n" +
                        "    i_muxind     : in std_logic_vector(55 downto 0);  -- bits indexes 8x7 bits bus\n" +
                        "    i_divident   : in std_logic_vector(60 downto 0);  -- integer value\n" +
                        "    i_divisor    : in std_logic_vector(52 downto 0);  -- integer value\n" +
                        "    o_dif        : out std_logic_vector(52 downto 0); -- residual value\n" +
                        "    o_bits       : out std_logic_vector(7 downto 0);  -- resulting bits\n" +
                        "    o_muxind     : out std_logic_vector(6 downto 0);  -- first found non-zero bit\n" +
                        "    o_muxind_rdy : out std_logic                      -- seeking was successfull\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_divstage53 of divstage53 is\n" +
                        "\n" +
                        "  type thresh_type is array (15 downto 0) of std_logic_vector(61 downto 0);\n" +
                        "  type dif_type is array (3 downto 0) of std_logic_vector(60 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  comb : process(i_mux_ena, i_muxind, i_divident, i_divisor)\n" +
                        "    variable wb_thresh : thresh_type;\n" +
                        "    variable wb_dif : dif_type;\n" +
                        "    variable wb_bits : std_logic_vector(7 downto 0);\n" +
                        "    variable wb_divx3 : std_logic_vector(54 downto 0);\n" +
                        "    variable wb_divx2 : std_logic_vector(54 downto 0);\n" +
                        "    variable wb_muxind : std_logic_vector(6 downto 0);\n" +
                        "    variable w_muxind_rdy : std_logic;\n" +
                        "  begin\n" +
                        "    wb_divx2 := '0' & i_divisor & '0';\n" +
                        "    wb_divx3 := wb_divx2 + (\"00\" & i_divisor);\n" +
                        "\n" +
                        "    -- stage 1 of 4\n" +
                        "    wb_thresh(15) := ('0' & i_divident) - ('0' & wb_divx3 & \"000000\");\n" +
                        "    wb_thresh(14) := ('0' & i_divident) - ('0' & wb_divx2 & \"000000\");\n" +
                        "    wb_thresh(13) := ('0' & i_divident) - (\"000\" & i_divisor & \"000000\");\n" +
                        "    wb_thresh(12) := ('0' & i_divident);\n" +
                        "\n" +
                        "    if wb_thresh(15)(61) = '0' then\n" +
                        "        wb_bits(7 downto 6) := \"11\";\n" +
                        "        wb_dif(0) := wb_thresh(15)(60 downto 0);\n" +
                        "    elsif wb_thresh(14)(61) = '0' then\n" +
                        "        wb_bits(7 downto 6) := \"10\";\n" +
                        "        wb_dif(0) := wb_thresh(14)(60 downto 0);\n" +
                        "    elsif wb_thresh(13)(61) = '0' then\n" +
                        "        wb_bits(7 downto 6) := \"01\";\n" +
                        "        wb_dif(0) := wb_thresh(13)(60 downto 0);\n" +
                        "    else\n" +
                        "        wb_bits(7 downto 6) := \"00\";\n" +
                        "        wb_dif(0) := wb_thresh(12)(60 downto 0);\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- stage 2 of 4\n" +
                        "    wb_thresh(11) := ('0' & wb_dif(0)) - (\"000\" & wb_divx3 & \"0000\");\n" +
                        "    wb_thresh(10) := ('0' & wb_dif(0)) - (\"000\" & wb_divx2 & \"0000\");\n" +
                        "    wb_thresh(9) := ('0' & wb_dif(0)) - (\"00000\" & i_divisor & \"0000\");\n" +
                        "    wb_thresh(8) := ('0' & wb_dif(0));\n" +
                        "\n" +
                        "    if wb_thresh(11)(61) = '0' then\n" +
                        "        wb_bits(5 downto 4) := \"11\";\n" +
                        "        wb_dif(1) := wb_thresh(11)(60 downto 0);\n" +
                        "    elsif wb_thresh(10)(61) = '0' then\n" +
                        "        wb_bits(5 downto 4) := \"10\";\n" +
                        "        wb_dif(1) := wb_thresh(10)(60 downto 0);\n" +
                        "    elsif wb_thresh(9)(61) = '0' then\n" +
                        "        wb_bits(5 downto 4) := \"01\";\n" +
                        "        wb_dif(1) := wb_thresh(9)(60 downto 0);\n" +
                        "    else\n" +
                        "        wb_bits(5 downto 4) := \"00\";\n" +
                        "        wb_dif(1) := wb_thresh(8)(60 downto 0);\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- stage 3 of 4\n" +
                        "    wb_thresh(7) := ('0' & wb_dif(1)) - (\"00000\" & wb_divx3 & \"00\");\n" +
                        "    wb_thresh(6) := ('0' & wb_dif(1)) - (\"00000\" & wb_divx2 & \"00\");\n" +
                        "    wb_thresh(5) := ('0' & wb_dif(1)) - (\"0000000\" & i_divisor & \"00\");\n" +
                        "    wb_thresh(4) := ('0' & wb_dif(1));\n" +
                        "\n" +
                        "    if wb_thresh(7)(61) = '0' then\n" +
                        "        wb_bits(3 downto 2) := \"11\";\n" +
                        "        wb_dif(2) := wb_thresh(7)(60 downto 0);\n" +
                        "    elsif wb_thresh(6)(61) = '0' then\n" +
                        "        wb_bits(3 downto 2) := \"10\";\n" +
                        "        wb_dif(2) := wb_thresh(6)(60 downto 0);\n" +
                        "    elsif wb_thresh(5)(61) = '0' then\n" +
                        "        wb_bits(3 downto 2) := \"01\";\n" +
                        "        wb_dif(2) := wb_thresh(5)(60 downto 0);\n" +
                        "    else\n" +
                        "        wb_bits(3 downto 2) := \"00\";\n" +
                        "        wb_dif(2) := wb_thresh(4)(60 downto 0);\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- stage 4 of 4\n" +
                        "    wb_thresh(3) := ('0' & wb_dif(2)) - (\"0000000\" & wb_divx3);\n" +
                        "    wb_thresh(2) := ('0' & wb_dif(2)) - (\"0000000\" & wb_divx2);\n" +
                        "    wb_thresh(1) := ('0' & wb_dif(2)) - (\"000000000\" & i_divisor);\n" +
                        "    wb_thresh(0) := ('0' & wb_dif(2));\n" +
                        "\n" +
                        "    if wb_thresh(3)(61) = '0' then\n" +
                        "        wb_bits(1 downto 0) := \"11\";\n" +
                        "        wb_dif(3) := wb_thresh(3)(60 downto 0);\n" +
                        "    elsif wb_thresh(2)(61) = '0' then\n" +
                        "        wb_bits(1 downto 0) := \"10\";\n" +
                        "        wb_dif(3) := wb_thresh(2)(60 downto 0);\n" +
                        "    elsif wb_thresh(1)(61) = '0' then\n" +
                        "        wb_bits(1 downto 0) := \"01\";\n" +
                        "        wb_dif(3) := wb_thresh(1)(60 downto 0);\n" +
                        "    else\n" +
                        "        wb_bits(1 downto 0) := \"00\";\n" +
                        "        wb_dif(3) := wb_thresh(0)(60 downto 0);\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Number multiplexor\n" +
                        "    wb_muxind := (others => '0');\n" +
                        "    if i_mux_ena = '1' then\n" +
                        "        if wb_thresh(15)(61) = '0' then\n" +
                        "            wb_muxind := i_muxind(55 downto 49);\n" +
                        "        elsif wb_thresh(14)(61) = '0' then\n" +
                        "            wb_muxind := i_muxind(55 downto 49);\n" +
                        "        elsif wb_thresh(13)(61) = '0' then\n" +
                        "            wb_muxind := i_muxind(48 downto 42);\n" +
                        "        elsif wb_thresh(11)(61) = '0' then\n" +
                        "            wb_muxind := i_muxind(41 downto 35);\n" +
                        "        elsif wb_thresh(10)(61) = '0' then\n" +
                        "            wb_muxind := i_muxind(41 downto 35);\n" +
                        "        elsif wb_thresh(9)(61) = '0' then\n" +
                        "            wb_muxind := i_muxind(34 downto 28);\n" +
                        "        elsif wb_thresh(7)(61) = '0' then\n" +
                        "            wb_muxind := i_muxind(27 downto 21);\n" +
                        "        elsif wb_thresh(6)(61) = '0' then\n" +
                        "            wb_muxind := i_muxind(27 downto 21);\n" +
                        "        elsif wb_thresh(5)(61) = '0' then\n" +
                        "            wb_muxind := i_muxind(20 downto 14);\n" +
                        "        elsif wb_thresh(3)(61) = '0' then\n" +
                        "            wb_muxind := i_muxind(13 downto 7);\n" +
                        "        elsif wb_thresh(2)(61) = '0' then\n" +
                        "            wb_muxind := i_muxind(13 downto 7);\n" +
                        "        elsif wb_thresh(1)(61) = '0' then\n" +
                        "            wb_muxind := i_muxind(6 downto 0);\n" +
                        "        else\n" +
                        "            wb_muxind := i_muxind(6 downto 0);\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_muxind_rdy := '0';\n" +
                        "    if i_mux_ena = '1' and wb_bits /= X\"00\" then\n" +
                        "        w_muxind_rdy := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    o_bits <= wb_bits;\n" +
                        "    o_dif <= wb_dif(3)(52 downto 0);\n" +
                        "    o_muxind <= wb_muxind;\n" +
                        "    o_muxind_rdy <= w_muxind_rdy;\n" +
                        "\n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_d2l_d_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "\n" +
                        "entity Double2Long is \n" +
                        "  generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_nrst       : in std_logic;\n" +
                        "    i_clk        : in std_logic;\n" +
                        "    i_ena        : in std_logic;\n" +
                        "    i_signed     : in std_logic;\n" +
                        "    i_w32        : in std_logic;\n" +
                        "    i_a          : in std_logic_vector(63 downto 0);\n" +
                        "    o_res        : out std_logic_vector(63 downto 0);\n" +
                        "    o_overflow   : out std_logic;\n" +
                        "    o_underflow  : out std_logic;\n" +
                        "    o_valid      : out std_logic;\n" +
                        "    o_busy       : out std_logic\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_Double2Long of Double2Long is\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "    busy : std_logic;\n" +
                        "    ena : std_logic_vector(2 downto 0);\n" +
                        "    signA : std_logic;\n" +
                        "    expA : std_logic_vector(10 downto 0);\n" +
                        "    mantA : std_logic_vector(52 downto 0);\n" +
                        "    result : std_logic_vector(63 downto 0);\n" +
                        "    op_signed : std_logic;\n" +
                        "    w32 : std_logic;\n" +
                        "    mantPostScale : std_logic_vector(63 downto 0);\n" +
                        "    overflow : std_logic;\n" +
                        "    underflow : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "    '0', (others => '0'),                      -- busy, ena\n" +
                        "    '0', (others => '0'), (others => '0'),     -- signA, expA, mantA\n" +
                        "    (others => '0'), '0', '0',                 -- result, op_signed, w32\n" +
                        "    (others => '0'), '0', '0'                  -- mantPostScale, overflow, underflow\n" +
                        "  );\n" +
                        "\n" +
                        "  constant zero64 : std_logic_vector(63 downto 0) := (others => '0');\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  comb : process(i_nrst, i_ena, i_signed, i_w32, i_a, r)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable expDif : std_logic_vector(11 downto 0);\n" +
                        "    variable mantPreScale : std_logic_vector(63 downto 0);\n" +
                        "    variable mantPostScale : std_logic_vector(63 downto 0);\n" +
                        "    variable mantA : std_logic_vector(52 downto 0);\n" +
                        "    variable expDif_gr : std_logic;  -- greater than 1023 + 63\n" +
                        "    variable expDif_lt : std_logic;  -- less than 1023\n" +
                        "    variable overflow : std_logic;\n" +
                        "    variable underflow : std_logic;\n" +
                        "    variable expMax : std_logic_vector(10 downto 0);\n" +
                        "    variable expShift : std_logic_vector(5 downto 0);\n" +
                        "    variable resSign : std_logic;\n" +
                        "    variable resMant : std_logic_vector(63 downto 0);\n" +
                        "    variable res : std_logic_vector(63 downto 0);\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    v.ena := r.ena(1 downto 0) & (i_ena and not r.busy);\n" +
                        "\n" +
                        "    mantA(51 downto 0) := i_a(51 downto 0);\n" +
                        "    mantA(52) := '0';\n" +
                        "    if i_a(62 downto 52) /= zero64(10 downto 0) then\n" +
                        "        mantA(52) := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if i_ena = '1' then\n" +
                        "        v.busy := '1';\n" +
                        "        v.signA := i_a(63);\n" +
                        "        v.expA := i_a(62 downto 52);\n" +
                        "        v.mantA := mantA;\n" +
                        "        v.op_signed := i_signed;\n" +
                        "        v.w32 := i_w32;\n" +
                        "        v.overflow := '0';\n" +
                        "        v.underflow := '0';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- expShift = (1086 - expA)[5:0]\n" +
                        "    expShift := \"111110\" - r.expA(5 downto 0);\n" +
                        "    if r.w32 = '1' then\n" +
                        "        if r.op_signed = '1' then\n" +
                        "            expMax := conv_std_logic_vector(1053, 11);\n" +
                        "        else\n" +
                        "            expMax := conv_std_logic_vector(1085, 11);\n" +
                        "        end if;\n" +
                        "    else\n" +
                        "        if r.op_signed = '1' or r.signA = '1' then\n" +
                        "            expMax := conv_std_logic_vector(1085, 11);\n" +
                        "        else\n" +
                        "            expMax := conv_std_logic_vector(1086, 11);\n" +
                        "        end if;\n" +
                        "     end if;\n" +
                        "\n" +
                        "    expDif := ('0' & expMax) - ('0' & r.expA);\n" +
                        "    expDif_gr := expDif(11);\n" +
                        "    expDif_lt := '0';\n" +
                        "    if r.expA /= \"01111111111\" and r.expA(10) = '0' then\n" +
                        "        expDif_lt := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    mantPreScale := r.mantA & \"00000000000\";\n" +
                        "\n" +
                        "    mantPostScale := (others => '0');\n" +
                        "    if expDif_gr = '1' then\n" +
                        "        overflow := '1';\n" +
                        "        underflow := '0';\n" +
                        "    elsif expDif_lt = '1' then\n" +
                        "        overflow := '0';\n" +
                        "        underflow := '1';\n" +
                        "    else\n" +
                        "        overflow := '0';\n" +
                        "        underflow := '0';\n" +
                        "        -- Multiplexer, probably switch case in rtl\n" +
                        "        if expShift = \"000000\" then\n" +
                        "            mantPostScale := mantPreScale;\n" +
                        "        else\n" +
                        "            for i in 1 to 63 loop\n" +
                        "                if conv_integer(expShift) = i then\n" +
                        "                    mantPostScale := zero64(i-1 downto 0) & mantPreScale(63 downto i);\n" +
                        "                end if;\n" +
                        "            end loop;\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if r.ena(0) = '1' then\n" +
                        "        v.overflow := overflow;\n" +
                        "        v.underflow := underflow;\n" +
                        "        v.mantPostScale := mantPostScale;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Result multiplexers:\n" +
                        "    resSign := (r.signA or r.overflow) and not r.underflow;\n" +
                        "    if r.signA = '1' then\n" +
                        "        resMant := not r.mantPostScale + 1;\n" +
                        "    else\n" +
                        "        resMant := r.mantPostScale;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    res := resMant;\n" +
                        "    if r.op_signed = '1' then\n" +
                        "        if resSign = '1' then\n" +
                        "            if r.w32 = '1' then\n" +
                        "                res(63 downto 31) := (others => '1');\n" +
                        "            else\n" +
                        "                res(63) := '1';\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    else\n" +
                        "        if r.w32 = '1' then\n" +
                        "            res(63 downto 32) := (others => '0');\n" +
                        "        elsif r.overflow = '1' then\n" +
                        "            res(63) := '1';\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if r.ena(1) = '1' then\n" +
                        "        v.result := res;\n" +
                        "        v.busy := '0';\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  o_res <= r.result;\n" +
                        "  o_overflow <= r.overflow;\n" +
                        "  o_underflow <= r.underflow;\n" +
                        "  o_valid <= r.ena(2);\n" +
                        "  o_busy <= r.busy;\n" +
                        "  \n" +
                        "  -- registers:\n" +
                        "  regs : process(i_nrst, i_clk)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_shift_vhd_file(String Project_Folder_File) {
        String data =   "-----------------------------------------------------------------------------\n" +
                        "--! @file\n" +
                        "--! @copyright Copyright 2016 GNSS Sensor Ltd. All right reserved.\n" +
                        "--! @author    Sergey Khabarov - sergeykhbr@gmail.com\n" +
                        "--! @brief     Left/Right shifter arithmetic/logic 32/64 bits.\n" +
                        "--! \n" +
                        "--! @details   Vivado synthesizer (2016.2) doesn't support shift\n" +
                        "--!            from dynamic value, so implement this mux.\n" +
                        "------------------------------------------------------------------------------\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "--library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use work.river_cfg.all;\n" +
                        "\n" +
                        "\n" +
                        "entity Shifter is\n" +
                        "  port (\n" +
                        "    i_a1 : in std_logic_vector(RISCV_ARCH-1 downto 0);     -- Operand 1\n" +
                        "    i_a2 : in std_logic_vector(5 downto 0);                -- Shift bits number\n" +
                        "    o_sll : out std_logic_vector(RISCV_ARCH-1 downto 0);   -- Logical shift left 64-bits operand\n" +
                        "    o_sllw : out std_logic_vector(RISCV_ARCH-1 downto 0);  -- Logical shift left 32-bits operand\n" +
                        "    o_srl : out std_logic_vector(RISCV_ARCH-1 downto 0);   -- Logical shift 64 bits\n" +
                        "    o_sra : out std_logic_vector(RISCV_ARCH-1 downto 0);   -- Arith. shift 64 bits\n" +
                        "    o_srlw : out std_logic_vector(RISCV_ARCH-1 downto 0);  -- Logical shift 32 bits\n" +
                        "    o_sraw : out std_logic_vector(RISCV_ARCH-1 downto 0)   -- Arith. shift 32 bits\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_Shifter of Shifter is\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  comb : process(i_a1, i_a2)\n" +
                        "    variable wb_sll : std_logic_vector(63 downto 0);\n" +
                        "    variable wb_srl : std_logic_vector(63 downto 0);\n" +
                        "    variable wb_sra : std_logic_vector(63 downto 0);\n" +
                        "    variable wb_srlw : std_logic_vector(31 downto 0);\n" +
                        "    variable wb_sraw : std_logic_vector(63 downto 0);\n" +
                        "    variable v64 : std_logic_vector(63 downto 0);\n" +
                        "    variable v32 : std_logic_vector(31 downto 0);\n" +
                        "    variable msk64 : std_logic_vector(63 downto 0);\n" +
                        "    variable msk32 : std_logic_vector(63 downto 0);\n" +
                        "    variable shift64 : integer range 0 to 63;\n" +
                        "    variable shift32 : integer range 0 to 31;\n" +
                        "  begin\n" +
                        "\n" +
                        "    v64 := i_a1;\n" +
                        "    v32 := i_a1(31 downto 0);\n" +
                        "    msk64 := (others => i_a1(63));\n" +
                        "    msk32 := (others => i_a1(31));\n" +
                        "    shift64 := conv_integer(i_a2);\n" +
                        "    shift32 := conv_integer(i_a2(4 downto 0));\n" +
                        "\n" +
                        "    case shift64 is\n" +
                        "    when 0 =>\n" +
                        "        wb_sll := v64;\n" +
                        "        wb_srl := v64;\n" +
                        "        wb_sra := v64;\n" +
                        "    when 1 =>\n" +
                        "        wb_sll := v64(62 downto 0) & \"0\";\n" +
                        "        wb_srl := \"0\" & v64(63 downto 1);\n" +
                        "        wb_sra := (msk64(63 downto 63) & v64(63 downto 1));\n" +
                        "    when 2 =>\n" +
                        "        wb_sll := v64(61 downto 0) & \"00\";\n" +
                        "        wb_srl := \"00\" & v64(63 downto 2);\n" +
                        "        wb_sra := (msk64(63 downto 62) & v64(63 downto 2));\n" +
                        "    when 3 =>\n" +
                        "        wb_sll := v64(60 downto 0) & \"000\";\n" +
                        "        wb_srl := \"000\" & v64(63 downto 3);\n" +
                        "        wb_sra := (msk64(63 downto 61) & v64(63 downto 3));\n" +
                        "    when 4 =>\n" +
                        "        wb_sll := v64(59 downto 0) & X\"0\";\n" +
                        "        wb_srl := X\"0\" & v64(63 downto 4);\n" +
                        "        wb_sra := (msk64(63 downto 60) & v64(63 downto 4));\n" +
                        "    when 5 =>\n" +
                        "        wb_sll := v64(58 downto 0) & X\"0\" & \"0\";\n" +
                        "        wb_srl :=  X\"0\" & \"0\" & v64(63 downto 5);\n" +
                        "        wb_sra := (msk64(63 downto 59) & v64(63 downto 5));\n" +
                        "    when 6 =>\n" +
                        "        wb_sll := v64(57 downto 0) & X\"0\" & \"00\";\n" +
                        "        wb_srl := X\"0\" & \"00\" & v64(63 downto 6);\n" +
                        "        wb_sra := (msk64(63 downto 58) & v64(63 downto 6));\n" +
                        "    when 7 =>\n" +
                        "        wb_sll := v64(56 downto 0) & X\"0\" & \"000\";\n" +
                        "        wb_srl := X\"0\" & \"000\" & v64(63 downto 7);\n" +
                        "        wb_sra := (msk64(63 downto 57) & v64(63 downto 7));\n" +
                        "    when 8 =>\n" +
                        "        wb_sll := v64(55 downto 0) & X\"00\";\n" +
                        "        wb_srl := X\"00\" & v64(63 downto 8);\n" +
                        "        wb_sra := (msk64(63 downto 56) & v64(63 downto 8));\n" +
                        "    when 9 =>\n" +
                        "        wb_sll := v64(54 downto 0) & X\"00\" & \"0\";\n" +
                        "        wb_srl := X\"00\" & \"0\" & v64(63 downto 9);\n" +
                        "        wb_sra := (msk64(63 downto 55) & v64(63 downto 9));\n" +
                        "    when 10 =>\n" +
                        "        wb_sll := v64(53 downto 0) & X\"00\" & \"00\";\n" +
                        "        wb_srl := X\"00\" & \"00\" & v64(63 downto 10);\n" +
                        "        wb_sra := (msk64(63 downto 54) & v64(63 downto 10));\n" +
                        "    when 11 =>\n" +
                        "        wb_sll := v64(52 downto 0) & X\"00\" & \"000\";\n" +
                        "        wb_srl := X\"00\" & \"000\" & v64(63 downto 11);\n" +
                        "        wb_sra := (msk64(63 downto 53) & v64(63 downto 11));\n" +
                        "    when 12 =>\n" +
                        "        wb_sll := v64(51 downto 0) & X\"000\";\n" +
                        "        wb_srl := X\"000\" & v64(63 downto 12);\n" +
                        "        wb_sra := (msk64(63 downto 52) & v64(63 downto 12));\n" +
                        "    when 13 =>\n" +
                        "        wb_sll := v64(50 downto 0) & X\"000\" & \"0\";\n" +
                        "        wb_srl := X\"000\" & \"0\" & v64(63 downto 13);\n" +
                        "        wb_sra := (msk64(63 downto 51) & v64(63 downto 13));\n" +
                        "    when 14 =>\n" +
                        "        wb_sll := v64(49 downto 0) & X\"000\" & \"00\";\n" +
                        "        wb_srl := X\"000\" & \"00\" & v64(63 downto 14);\n" +
                        "        wb_sra := (msk64(63 downto 50) & v64(63 downto 14));\n" +
                        "    when 15 =>\n" +
                        "        wb_sll := v64(48 downto 0) & X\"000\" & \"000\";\n" +
                        "        wb_srl := X\"000\" & \"000\" & v64(63 downto 15);\n" +
                        "        wb_sra := (msk64(63 downto 49) & v64(63 downto 15));\n" +
                        "    when 16 =>\n" +
                        "        wb_sll := v64(47 downto 0) & X\"0000\";\n" +
                        "        wb_srl := X\"0000\" & v64(63 downto 16);\n" +
                        "        wb_sra := (msk64(63 downto 48) & v64(63 downto 16));\n" +
                        "    when 17 =>\n" +
                        "        wb_sll := v64(46 downto 0) & X\"0000\" & \"0\";\n" +
                        "        wb_srl := X\"0000\" & \"0\" & v64(63 downto 17);\n" +
                        "        wb_sra := (msk64(63 downto 47) & v64(63 downto 17));\n" +
                        "    when 18 =>\n" +
                        "        wb_sll := v64(45 downto 0) & X\"0000\" & \"00\";\n" +
                        "        wb_srl := X\"0000\" & \"00\" & v64(63 downto 18);\n" +
                        "        wb_sra := (msk64(63 downto 46) & v64(63 downto 18));\n" +
                        "    when 19 =>\n" +
                        "        wb_sll := v64(44 downto 0) & X\"0000\" & \"000\";\n" +
                        "        wb_srl := X\"0000\" & \"000\" & v64(63 downto 19);\n" +
                        "        wb_sra := (msk64(63 downto 45) & v64(63 downto 19));\n" +
                        "    when 20 =>\n" +
                        "        wb_sll := v64(43 downto 0) & X\"00000\";\n" +
                        "        wb_srl := X\"00000\" & v64(63 downto 20);\n" +
                        "        wb_sra := (msk64(63 downto 44) & v64(63 downto 20));\n" +
                        "    when 21 =>\n" +
                        "        wb_sll := v64(42 downto 0) & X\"00000\" & \"0\";\n" +
                        "        wb_srl := X\"00000\" & \"0\" & v64(63 downto 21);\n" +
                        "        wb_sra := (msk64(63 downto 43) & v64(63 downto 21));\n" +
                        "    when 22 =>\n" +
                        "        wb_sll := v64(41 downto 0) & X\"00000\" & \"00\";\n" +
                        "        wb_srl := X\"00000\" & \"00\" & v64(63 downto 22);\n" +
                        "        wb_sra := (msk64(63 downto 42) & v64(63 downto 22));\n" +
                        "    when 23 =>\n" +
                        "        wb_sll := v64(40 downto 0) & X\"00000\" & \"000\";\n" +
                        "        wb_srl := X\"00000\" & \"000\" & v64(63 downto 23);\n" +
                        "        wb_sra := (msk64(63 downto 41) & v64(63 downto 23));\n" +
                        "    when 24 =>\n" +
                        "        wb_sll := v64(39 downto 0) & X\"000000\";\n" +
                        "        wb_srl := X\"000000\" & v64(63 downto 24);\n" +
                        "        wb_sra := (msk64(63 downto 40) & v64(63 downto 24));\n" +
                        "    when 25 =>\n" +
                        "        wb_sll := v64(38 downto 0) & X\"000000\" & \"0\";\n" +
                        "        wb_srl := X\"000000\" & \"0\" & v64(63 downto 25);\n" +
                        "        wb_sra := (msk64(63 downto 39) & v64(63 downto 25));\n" +
                        "    when 26 =>\n" +
                        "        wb_sll := v64(37 downto 0) & X\"000000\" & \"00\";\n" +
                        "        wb_srl := X\"000000\" & \"00\" & v64(63 downto 26);\n" +
                        "        wb_sra := (msk64(63 downto 38) & v64(63 downto 26));\n" +
                        "    when 27 =>\n" +
                        "        wb_sll := v64(36 downto 0) & X\"000000\" & \"000\";\n" +
                        "        wb_srl := X\"000000\" & \"000\" & v64(63 downto 27);\n" +
                        "        wb_sra := (msk64(63 downto 37) & v64(63 downto 27));\n" +
                        "    when 28 =>\n" +
                        "        wb_sll := v64(35 downto 0) & X\"0000000\";\n" +
                        "        wb_srl := X\"0000000\" & v64(63 downto 28);\n" +
                        "        wb_sra := (msk64(63 downto 36) & v64(63 downto 28));\n" +
                        "    when 29 =>\n" +
                        "        wb_sll := v64(34 downto 0) & X\"0000000\" & \"0\";\n" +
                        "        wb_srl := X\"0000000\" & \"0\" & v64(63 downto 29);\n" +
                        "        wb_sra := (msk64(63 downto 35) & v64(63 downto 29));\n" +
                        "    when 30 =>\n" +
                        "        wb_sll := v64(33 downto 0) & X\"0000000\" & \"00\";\n" +
                        "        wb_srl := X\"0000000\" & \"00\" & v64(63 downto 30);\n" +
                        "        wb_sra := (msk64(63 downto 34) & v64(63 downto 30));\n" +
                        "    when 31 =>\n" +
                        "        wb_sll := v64(32 downto 0) & X\"0000000\" & \"000\";\n" +
                        "        wb_srl := X\"0000000\" & \"000\" & v64(63 downto 31);\n" +
                        "        wb_sra := (msk64(63 downto 33) & v64(63 downto 31));\n" +
                        "    when 32 =>\n" +
                        "        wb_sll := v64(31 downto 0) & X\"00000000\";\n" +
                        "        wb_srl := X\"00000000\" & v64(63 downto 32);\n" +
                        "        wb_sra := (msk64(63 downto 32) & v64(63 downto 32));\n" +
                        "    when 33 =>\n" +
                        "        wb_sll := v64(30 downto 0) & X\"00000000\" & \"0\";\n" +
                        "        wb_srl := X\"00000000\" & \"0\" & v64(63 downto 33);\n" +
                        "        wb_sra := (msk64(63 downto 31) & v64(63 downto 33));\n" +
                        "    when 34 =>\n" +
                        "        wb_sll := v64(29 downto 0) & X\"00000000\" & \"00\";\n" +
                        "        wb_srl := X\"00000000\" & \"00\" & v64(63 downto 34);\n" +
                        "        wb_sra := (msk64(63 downto 30) & v64(63 downto 34));\n" +
                        "    when 35 =>\n" +
                        "        wb_sll := v64(28 downto 0) & X\"00000000\" & \"000\";\n" +
                        "        wb_srl := X\"00000000\" & \"000\" & v64(63 downto 35);\n" +
                        "        wb_sra := (msk64(63 downto 29) & v64(63 downto 35));\n" +
                        "    when 36 =>\n" +
                        "        wb_sll := v64(27 downto 0) & X\"000000000\";\n" +
                        "        wb_srl := X\"000000000\" & v64(63 downto 36);\n" +
                        "        wb_sra := (msk64(63 downto 28) & v64(63 downto 36));\n" +
                        "    when 37 =>\n" +
                        "        wb_sll := v64(26 downto 0) & X\"000000000\" & \"0\";\n" +
                        "        wb_srl := X\"000000000\" & \"0\" & v64(63 downto 37);\n" +
                        "        wb_sra := (msk64(63 downto 27) & v64(63 downto 37));\n" +
                        "    when 38 =>\n" +
                        "        wb_sll := v64(25 downto 0) & X\"000000000\" & \"00\";\n" +
                        "        wb_srl := X\"000000000\" & \"00\" & v64(63 downto 38);\n" +
                        "        wb_sra := (msk64(63 downto 26) & v64(63 downto 38));\n" +
                        "    when 39 =>\n" +
                        "        wb_sll := v64(24 downto 0) & X\"000000000\" & \"000\";\n" +
                        "        wb_srl := X\"000000000\" & \"000\" & v64(63 downto 39);\n" +
                        "        wb_sra := (msk64(63 downto 25) & v64(63 downto 39));\n" +
                        "    when 40 =>\n" +
                        "        wb_sll := v64(23 downto 0) & X\"0000000000\";\n" +
                        "        wb_srl := X\"0000000000\" & v64(63 downto 40);\n" +
                        "        wb_sra := (msk64(63 downto 24) & v64(63 downto 40));\n" +
                        "    when 41 =>\n" +
                        "        wb_sll := v64(22 downto 0) & X\"0000000000\" & \"0\";\n" +
                        "        wb_srl := X\"0000000000\" & \"0\" & v64(63 downto 41);\n" +
                        "        wb_sra := (msk64(63 downto 23) & v64(63 downto 41));\n" +
                        "    when 42 =>\n" +
                        "        wb_sll := v64(21 downto 0) & X\"0000000000\" & \"00\";\n" +
                        "        wb_srl := X\"0000000000\" & \"00\" & v64(63 downto 42);\n" +
                        "        wb_sra := (msk64(63 downto 22) & v64(63 downto 42));\n" +
                        "    when 43 =>\n" +
                        "        wb_sll := v64(20 downto 0) & X\"0000000000\" & \"000\";\n" +
                        "        wb_srl := X\"0000000000\" & \"000\" & v64(63 downto 43);\n" +
                        "        wb_sra := (msk64(63 downto 21) & v64(63 downto 43));\n" +
                        "    when 44 =>\n" +
                        "        wb_sll := v64(19 downto 0) & X\"00000000000\";\n" +
                        "        wb_srl := X\"00000000000\" & v64(63 downto 44);\n" +
                        "        wb_sra := (msk64(63 downto 20) & v64(63 downto 44));\n" +
                        "    when 45 =>\n" +
                        "        wb_sll := v64(18 downto 0) & X\"00000000000\" & \"0\";\n" +
                        "        wb_srl := X\"00000000000\" & \"0\" & v64(63 downto 45);\n" +
                        "        wb_sra := (msk64(63 downto 19) & v64(63 downto 45));\n" +
                        "    when 46 =>\n" +
                        "        wb_sll := v64(17 downto 0) & X\"00000000000\" & \"00\";\n" +
                        "        wb_srl := X\"00000000000\" & \"00\" & v64(63 downto 46);\n" +
                        "        wb_sra := (msk64(63 downto 18) & v64(63 downto 46));\n" +
                        "    when 47 =>\n" +
                        "        wb_sll := v64(16 downto 0) & X\"00000000000\" & \"000\";\n" +
                        "        wb_srl := X\"00000000000\" & \"000\" & v64(63 downto 47);\n" +
                        "        wb_sra := (msk64(63 downto 17) & v64(63 downto 47));\n" +
                        "    when 48 =>\n" +
                        "        wb_sll := v64(15 downto 0) & X\"000000000000\";\n" +
                        "        wb_srl := X\"000000000000\" & v64(63 downto 48);\n" +
                        "        wb_sra := (msk64(63 downto 16) & v64(63 downto 48));\n" +
                        "    when 49 =>\n" +
                        "        wb_sll := v64(14 downto 0) & X\"000000000000\" & \"0\";\n" +
                        "        wb_srl := X\"000000000000\" & \"0\" & v64(63 downto 49);\n" +
                        "        wb_sra := (msk64(63 downto 15) & v64(63 downto 49));\n" +
                        "    when 50 =>\n" +
                        "        wb_sll := v64(13 downto 0) & X\"000000000000\" & \"00\";\n" +
                        "        wb_srl := X\"000000000000\" & \"00\" & v64(63 downto 50);\n" +
                        "        wb_sra := (msk64(63 downto 14) & v64(63 downto 50));\n" +
                        "    when 51 =>\n" +
                        "        wb_sll := v64(12 downto 0) & X\"000000000000\" & \"000\";\n" +
                        "        wb_srl := X\"000000000000\" & \"000\" & v64(63 downto 51);\n" +
                        "        wb_sra := (msk64(63 downto 13) & v64(63 downto 51));\n" +
                        "    when 52 =>\n" +
                        "        wb_sll := v64(11 downto 0) & X\"0000000000000\";\n" +
                        "        wb_srl := X\"0000000000000\" & v64(63 downto 52);\n" +
                        "        wb_sra := (msk64(63 downto 12) & v64(63 downto 52));\n" +
                        "    when 53 =>\n" +
                        "        wb_sll := v64(10 downto 0) & X\"0000000000000\" & \"0\";\n" +
                        "        wb_srl := X\"0000000000000\" & \"0\" & v64(63 downto 53);\n" +
                        "        wb_sra := (msk64(63 downto 11) & v64(63 downto 53));\n" +
                        "    when 54 =>\n" +
                        "        wb_sll := v64(9 downto 0) & X\"0000000000000\" & \"00\";\n" +
                        "        wb_srl := X\"0000000000000\" & \"00\" & v64(63 downto 54);\n" +
                        "        wb_sra := (msk64(63 downto 10) & v64(63 downto 54));\n" +
                        "    when 55 =>\n" +
                        "        wb_sll := v64(8 downto 0) & X\"0000000000000\" & \"000\";\n" +
                        "        wb_srl := X\"0000000000000\" & \"000\" & v64(63 downto 55);\n" +
                        "        wb_sra := (msk64(63 downto 9) & v64(63 downto 55));\n" +
                        "    when 56 =>\n" +
                        "        wb_sll := v64(7 downto 0) & X\"00000000000000\";\n" +
                        "        wb_srl := X\"00000000000000\" & v64(63 downto 56);\n" +
                        "        wb_sra := (msk64(63 downto 8) & v64(63 downto 56));\n" +
                        "    when 57 =>\n" +
                        "        wb_sll := v64(6 downto 0) & X\"00000000000000\" & \"0\";\n" +
                        "        wb_srl := X\"00000000000000\" & \"0\" & v64(63 downto 57);\n" +
                        "        wb_sra := (msk64(63 downto 7) & v64(63 downto 57));\n" +
                        "    when 58 =>\n" +
                        "        wb_sll := v64(5 downto 0) & X\"00000000000000\" & \"00\";\n" +
                        "        wb_srl := X\"00000000000000\" & \"00\" & v64(63 downto 58);\n" +
                        "        wb_sra := (msk64(63 downto 6) & v64(63 downto 58));\n" +
                        "    when 59 =>\n" +
                        "        wb_sll := v64(4 downto 0) & X\"00000000000000\" & \"000\";\n" +
                        "        wb_srl := X\"00000000000000\" & \"000\" & v64(63 downto 59);\n" +
                        "        wb_sra := (msk64(63 downto 5) & v64(63 downto 59));\n" +
                        "    when 60 =>\n" +
                        "        wb_sll := v64(3 downto 0) & X\"000000000000000\";\n" +
                        "        wb_srl := X\"000000000000000\" & v64(63 downto 60);\n" +
                        "        wb_sra := (msk64(63 downto 4) & v64(63 downto 60));\n" +
                        "    when 61 =>\n" +
                        "        wb_sll := v64(2 downto 0) & X\"000000000000000\" & \"0\";\n" +
                        "        wb_srl := X\"000000000000000\" & \"0\" & v64(63 downto 61);\n" +
                        "        wb_sra := (msk64(63 downto 3) & v64(63 downto 61));\n" +
                        "    when 62 =>\n" +
                        "        wb_sll := v64(1 downto 0) & X\"000000000000000\" & \"00\";\n" +
                        "        wb_srl := X\"000000000000000\" & \"00\" & v64(63 downto 62);\n" +
                        "        wb_sra := (msk64(63 downto 2) & v64(63 downto 62));\n" +
                        "    when 63 =>\n" +
                        "        wb_sll := v64(0) & X\"000000000000000\" & \"000\";\n" +
                        "        wb_srl := X\"000000000000000\" & \"000\" & v64(63);\n" +
                        "        wb_sra := (msk64(63 downto 1) & v64(63));\n" +
                        "    end case;\n" +
                        "\n" +
                        "    case shift32 is\n" +
                        "    when 0 =>\n" +
                        "        wb_srlw := v32;\n" +
                        "        wb_sraw := (msk32(63 downto 32) & v32);\n" +
                        "    when 1 =>\n" +
                        "        wb_srlw := \"0\" & v32(31 downto 1);\n" +
                        "        wb_sraw := (msk32(63 downto 31) & v32(31 downto 1));\n" +
                        "    when 2 =>\n" +
                        "        wb_srlw := \"00\" & v32(31 downto 2);\n" +
                        "        wb_sraw := (msk32(63 downto 30) & v32(31 downto 2));\n" +
                        "    when 3 =>\n" +
                        "        wb_srlw := \"000\" & v32(31 downto 3);\n" +
                        "        wb_sraw := (msk32(63 downto 29) & v32(31 downto 3));\n" +
                        "    when 4 =>\n" +
                        "        wb_srlw := X\"0\" & v32(31 downto 4);\n" +
                        "        wb_sraw := (msk32(63 downto 28) & v32(31 downto 4));\n" +
                        "    when 5 =>\n" +
                        "        wb_srlw := X\"0\" & \"0\" & v32(31 downto 5);\n" +
                        "        wb_sraw := (msk32(63 downto 27) & v32(31 downto 5));\n" +
                        "    when 6 =>\n" +
                        "        wb_srlw := X\"0\" & \"00\" & v32(31 downto 6);\n" +
                        "        wb_sraw := (msk32(63 downto 26) & v32(31 downto 6));\n" +
                        "    when 7 =>\n" +
                        "        wb_srlw := X\"0\" & \"000\" & v32(31 downto 7);\n" +
                        "        wb_sraw := (msk32(63 downto 25) & v32(31 downto 7));\n" +
                        "    when 8 =>\n" +
                        "        wb_srlw := X\"00\" & v32(31 downto 8);\n" +
                        "        wb_sraw := (msk32(63 downto 24) & v32(31 downto 8));\n" +
                        "    when 9 =>\n" +
                        "        wb_srlw := X\"00\" & \"0\" & v32(31 downto 9);\n" +
                        "        wb_sraw := (msk32(63 downto 23) & v32(31 downto 9));\n" +
                        "    when 10 =>\n" +
                        "        wb_srlw := X\"00\" & \"00\" & v32(31 downto 10);\n" +
                        "        wb_sraw := (msk32(63 downto 22) & v32(31 downto 10));\n" +
                        "    when 11 =>\n" +
                        "        wb_srlw := X\"00\" & \"000\" & v32(31 downto 11);\n" +
                        "        wb_sraw := (msk32(63 downto 21) & v32(31 downto 11));\n" +
                        "    when 12 =>\n" +
                        "        wb_srlw := X\"000\" & v32(31 downto 12);\n" +
                        "        wb_sraw := (msk32(63 downto 20) & v32(31 downto 12));\n" +
                        "    when 13 =>\n" +
                        "        wb_srlw := X\"000\" & \"0\" & v32(31 downto 13);\n" +
                        "        wb_sraw := (msk32(63 downto 19) & v32(31 downto 13));\n" +
                        "    when 14 =>\n" +
                        "        wb_srlw := X\"000\" & \"00\" & v32(31 downto 14);\n" +
                        "        wb_sraw := (msk32(63 downto 18) & v32(31 downto 14));\n" +
                        "    when 15 =>\n" +
                        "        wb_srlw := X\"000\" & \"000\" & v32(31 downto 15);\n" +
                        "        wb_sraw := (msk32(63 downto 17) & v32(31 downto 15));\n" +
                        "    when 16 =>\n" +
                        "        wb_srlw := X\"0000\" & v32(31 downto 16);\n" +
                        "        wb_sraw := (msk32(63 downto 16) & v32(31 downto 16));\n" +
                        "    when 17 =>\n" +
                        "        wb_srlw := X\"0000\" & \"0\" & v32(31 downto 17);\n" +
                        "        wb_sraw := (msk32(63 downto 15) & v32(31 downto 17));\n" +
                        "    when 18 =>\n" +
                        "        wb_srlw := X\"0000\" & \"00\" & v32(31 downto 18);\n" +
                        "        wb_sraw := (msk32(63 downto 14) & v32(31 downto 18));\n" +
                        "    when 19 =>\n" +
                        "        wb_srlw := X\"0000\" & \"000\" & v32(31 downto 19);\n" +
                        "        wb_sraw := (msk32(63 downto 13) & v32(31 downto 19));\n" +
                        "    when 20 =>\n" +
                        "        wb_srlw := X\"00000\" & v32(31 downto 20);\n" +
                        "        wb_sraw := (msk32(63 downto 12) & v32(31 downto 20));\n" +
                        "    when 21 =>\n" +
                        "        wb_srlw := X\"00000\" & \"0\" & v32(31 downto 21);\n" +
                        "        wb_sraw := (msk32(63 downto 11) & v32(31 downto 21));\n" +
                        "    when 22 =>\n" +
                        "        wb_srlw := X\"00000\" & \"00\" & v32(31 downto 22);\n" +
                        "        wb_sraw := (msk32(63 downto 10) & v32(31 downto 22));\n" +
                        "    when 23 =>\n" +
                        "        wb_srlw := X\"00000\" & \"000\" & v32(31 downto 23);\n" +
                        "        wb_sraw := (msk32(63 downto 9) & v32(31 downto 23));\n" +
                        "    when 24 =>\n" +
                        "        wb_srlw := X\"000000\" & v32(31 downto 24);\n" +
                        "        wb_sraw := (msk32(63 downto 8) & v32(31 downto 24));\n" +
                        "    when 25 =>\n" +
                        "        wb_srlw := X\"000000\" & \"0\" & v32(31 downto 25);\n" +
                        "        wb_sraw := (msk32(63 downto 7) & v32(31 downto 25));\n" +
                        "    when 26 =>\n" +
                        "        wb_srlw := X\"000000\" & \"00\" & v32(31 downto 26);\n" +
                        "        wb_sraw := (msk32(63 downto 6) & v32(31 downto 26));\n" +
                        "    when 27 =>\n" +
                        "        wb_srlw := X\"000000\" & \"000\" & v32(31 downto 27);\n" +
                        "        wb_sraw := (msk32(63 downto 5) & v32(31 downto 27));\n" +
                        "    when 28 =>\n" +
                        "        wb_srlw := X\"0000000\" & v32(31 downto 28);\n" +
                        "        wb_sraw := (msk32(63 downto 4) & v32(31 downto 28));\n" +
                        "    when 29 =>\n" +
                        "        wb_srlw := X\"0000000\" & \"0\" & v32(31 downto 29);\n" +
                        "        wb_sraw := (msk32(63 downto 3) & v32(31 downto 29));\n" +
                        "    when 30 =>\n" +
                        "        wb_srlw := X\"0000000\" & \"00\" & v32(31 downto 30);\n" +
                        "        wb_sraw := (msk32(63 downto 2) & v32(31 downto 30));\n" +
                        "    when 31 =>\n" +
                        "        wb_srlw := X\"0000000\" & \"000\" & v32(31 downto 31);\n" +
                        "        wb_sraw := (msk32(63 downto 1) & v32(31 downto 31));\n" +
                        "    end case;\n" +
                        "\n" +
                        "    o_sll <= wb_sll;\n" +
                        "    o_sllw(31 downto 0) <= wb_sll(31 downto 0);\n" +
                        "    o_sllw(63 downto 32) <= (others => wb_sll(31));\n" +
                        "    o_srl <= wb_srl;\n" +
                        "    o_sra <= wb_sra;\n" +
                        "    o_srlw <= X\"00000000\" & wb_srlw;\n" +
                        "    o_sraw <= wb_sraw;\n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_int_div_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "--library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use work.river_cfg.all;\n" +
                        "\n" +
                        "\n" +
                        "entity IntDiv is generic (\n" +
                        "    async_reset : boolean := false\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk  : in std_logic;\n" +
                        "    i_nrst : in std_logic;                               -- Reset Active LOW\n" +
                        "    i_ena : in std_logic;                                -- Enable bit\n" +
                        "    i_unsigned : in std_logic;                           -- Unsigned operands\n" +
                        "    i_rv32 : in std_logic;                               -- 32-bits operands enable\n" +
                        "    i_residual : in std_logic;                           -- Compute: 0 =division; 1=residual\n" +
                        "    i_a1 : in std_logic_vector(RISCV_ARCH-1 downto 0);   -- Operand 1\n" +
                        "    i_a2 : in std_logic_vector(RISCV_ARCH-1 downto 0);   -- Operand 1\n" +
                        "    o_res : out std_logic_vector(RISCV_ARCH-1 downto 0); -- Result\n" +
                        "    o_valid : out std_logic;                             -- Result is valid\n" +
                        "    o_busy : out std_logic                               -- Multiclock instruction under processing\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_IntDiv of IntDiv is\n" +
                        "\n" +
                        "  component divstage64 is \n" +
                        "  port (\n" +
                        "    i_divident   : in std_logic_vector(63 downto 0);  -- integer value\n" +
                        "    i_divisor    : in std_logic_vector(123 downto 0); -- integer value\n" +
                        "    o_resid      : out std_logic_vector(63 downto 0); -- residual value\n" +
                        "    o_bits       : out std_logic_vector(3 downto 0)   -- resulting bits\n" +
                        "  );\n" +
                        "  end component; \n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "      rv32 : std_logic;\n" +
                        "      resid : std_logic;                           -- Compute residual flag\n" +
                        "      invert : std_logic;                          -- invert result value before output\n" +
                        "      busy : std_logic;\n" +
                        "      ena : std_logic_vector(9 downto 0);\n" +
                        "      divident_i : std_logic_vector(63 downto 0);\n" +
                        "      divisor_i : std_logic_vector(119 downto 0);\n" +
                        "      bits_i : std_logic_vector(63 downto 0);\n" +
                        "      result : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "      '0', '0', '0', '0',                -- rv32, resid, invert, busy\n" +
                        "      (others => '0'), (others => '0'),  -- ena, divident_i\n" +
                        "      (others => '0'), (others => '0'),  -- divisor_i, bits_i\n" +
                        "      (others => '0')                    -- result\n" +
                        "  );\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "\n" +
                        "  signal wb_divisor0_i : std_logic_vector(123 downto 0);\n" +
                        "  signal wb_divisor1_i : std_logic_vector(123 downto 0);\n" +
                        "  signal wb_resid0_o : std_logic_vector(63 downto 0);\n" +
                        "  signal wb_resid1_o : std_logic_vector(63 downto 0);\n" +
                        "  signal wb_bits0_o : std_logic_vector(3 downto 0);\n" +
                        "  signal wb_bits1_o : std_logic_vector(3 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  stage0 : divstage64 port map (\n" +
                        "    i_divident => r.divident_i,\n" +
                        "    i_divisor => wb_divisor0_i,\n" +
                        "    o_bits => wb_bits0_o,\n" +
                        "    o_resid => wb_resid0_o\n" +
                        "  );\n" +
                        "\n" +
                        "  stage1 : divstage64 port map (\n" +
                        "    i_divident => wb_resid0_o,\n" +
                        "    i_divisor => wb_divisor1_i,\n" +
                        "    o_bits => wb_bits1_o,\n" +
                        "    o_resid => wb_resid1_o\n" +
                        "  );\n" +
                        "\n" +
                        "  comb : process(i_nrst, i_ena, i_unsigned, i_residual, i_rv32, i_a1, i_a2, r,\n" +
                        "                 wb_resid0_o, wb_resid1_o, wb_bits0_o, wb_bits1_o)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable wb_a1 : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable wb_a2 : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable wb_divident : std_logic_vector(64 downto 0);\n" +
                        "    variable wb_divider : std_logic_vector(64 downto 0);\n" +
                        "    variable w_invert64 : std_logic;\n" +
                        "    variable w_invert32 : std_logic;\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    w_invert64 := '0';\n" +
                        "    w_invert32 := '0';\n" +
                        "    wb_divident(64) := '0';\n" +
                        "    wb_divider(64) := '0';\n" +
                        "\n" +
                        "    if i_rv32 = '1' then\n" +
                        "        wb_a1(63 downto 32) := (others => '0');\n" +
                        "        wb_a2(63 downto 32) := (others => '0');\n" +
                        "        if i_unsigned = '1' or i_a1(31) = '0' then\n" +
                        "            wb_a1(31 downto 0) := i_a1(31 downto 0);\n" +
                        "        else\n" +
                        "            wb_a1(31 downto 0) := (not i_a1(31 downto 0)) + 1;\n" +
                        "        end if;\n" +
                        "        if i_unsigned = '1' or i_a2(31) = '0' then\n" +
                        "            wb_a2(31 downto 0) := i_a2(31 downto 0);\n" +
                        "        else\n" +
                        "            wb_a2(31 downto 0) := (not i_a2(31 downto 0)) + 1;\n" +
                        "        end if;\n" +
                        "    else\n" +
                        "        if i_unsigned = '1' or i_a1(63) = '0' then\n" +
                        "            wb_a1 := i_a1;\n" +
                        "        else\n" +
                        "            wb_a1 := (not i_a1) + 1;\n" +
                        "        end if;\n" +
                        "        if i_unsigned = '1' or i_a2(63) = '0' then\n" +
                        "            wb_a2 := i_a2;\n" +
                        "        else\n" +
                        "            wb_a2 := (not i_a2) + 1;\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    v.ena := r.ena(8 downto 0) & (i_ena and not r.busy);\n" +
                        "\n" +
                        "\n" +
                        "    if i_ena = '1' then\n" +
                        "        v.busy := '1';\n" +
                        "        v.rv32 := i_rv32;\n" +
                        "        v.resid := i_residual;\n" +
                        "\n" +
                        "        v.divident_i := wb_a1;\n" +
                        "        v.divisor_i := wb_a2 & X\"00000000000000\";\n" +
                        "\n" +
                        "        w_invert32 := not i_unsigned and\n" +
                        "                ((not i_residual and (i_a1(31) xor i_a2(31)))\n" +
                        "                or (i_residual and i_a1(31)));\n" +
                        "        w_invert64 := not i_unsigned and\n" +
                        "                ((not i_residual and (i_a1(63) xor i_a2(63)))\n" +
                        "                or (i_residual and i_a1(63)));\n" +
                        "        v.invert := (not i_rv32 and w_invert64) \n" +
                        "                or (i_rv32 and w_invert32);\n" +
                        "    elsif r.ena(8) = '1' then\n" +
                        "        v.busy := '0';\n" +
                        "        if r.resid = '1' then\n" +
                        "            if r.invert = '1' then\n" +
                        "                v.result := (not r.divident_i) + 1;\n" +
                        "            else\n" +
                        "                v.result := r.divident_i;\n" +
                        "            end if;\n" +
                        "        else\n" +
                        "            if r.invert = '1' then\n" +
                        "                v.result := (not r.bits_i) + 1;\n" +
                        "            else\n" +
                        "                v.result := r.bits_i;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    elsif r.busy = '1' then\n" +
                        "        v.divident_i := wb_resid1_o;\n" +
                        "        v.divisor_i := X\"00\" & r.divisor_i(119 downto 8);\n" +
                        "        v.bits_i := r.bits_i(55 downto 0) & wb_bits0_o & wb_bits1_o;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    wb_divisor0_i <= r.divisor_i & \"0000\";\n" +
                        "    wb_divisor1_i <= \"0000\" & r.divisor_i;\n" +
                        "\n" +
                        "    o_res <= r.result;\n" +
                        "    o_valid <= r.ena(9);\n" +
                        "    o_busy <= r.busy;\n" +
                        "    \n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(i_clk, i_nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_int_mul_cyclone_v_vhd_file(String Project_Folder_File) {
        String data =   "-----------------------------------------------------------------------------\n" +
                        "--! @file\n" +
                        "--! @copyright Copyright 2016 GNSS Sensor Ltd. All right reserved.\n" +
                        "--! @author    Sergey Khabarov - sergeykhbr@gmail.com\n" +
                        "--! @brief     Integer multiplier.\n" +
                        "--! @details   Implemented algorithm provides 4 clocks per instruction\n" +
                        "------------------------------------------------------------------------------\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "--library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use work.river_cfg.all;\n" +
                        "\n" +
                        "\n" +
                        "entity IntMulCycloneV is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk  : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_ena : in std_logic;                                -- Enable bit\n" +
                        "    i_unsigned : in std_logic;                           -- Unsigned operands\n" +
                        "    i_high : in std_logic;                               -- High multiplied bits [127:64]\n" +
                        "    i_rv32 : in std_logic;                               -- 32-bits operands enable\n" +
                        "    i_a1 : in std_logic_vector(RISCV_ARCH-1 downto 0);   -- Operand 1\n" +
                        "    i_a2 : in std_logic_vector(RISCV_ARCH-1 downto 0);   -- Operand 1\n" +
                        "    o_res : out std_logic_vector(RISCV_ARCH-1 downto 0); -- Result\n" +
                        "    o_valid : out std_logic;                             -- Result is valid\n" +
                        "    o_busy : out std_logic                               -- Multiclock instruction under processing\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_IntMulCycloneV of IntMulCycloneV is\n" +
                        "\n" +
                        "	signal result_s	: std_logic_vector ((RISCV_ARCH*2)-1 DOWNTO 0);\n" +
                        "	\n" +
                        "begin\n" +
                        "\n" +
                        "	mulDSP0 : entity work.mul_int_64 port map (\n" +
                        "      dataa  	=> i_a1,\n" +
                        "      datab 	=> i_a2,\n" +
                        "      result 	=> result_s\n" +
                        "	);\n" +
                        "  \n" +
                        "	-- registers:\n" +
                        "	regs : process(i_clk, i_nrst)\n" +
                        "	begin \n" +
                        "		if async_reset and i_nrst = '0' then\n" +
                        "			o_res <= (others => '0');\n" +
                        "			o_valid <= '0';\n" +
                        "		elsif rising_edge(i_clk) then\n" +
                        "			if i_ena = '1' then\n" +
                        "				o_res <= result_s(RISCV_ARCH-1 DOWNTO 0);\n" +
                        "				o_valid <= '1';\n" +
                        "			else\n" +
                        "				o_valid <= '0';\n" +
                        "			end if;\n" +
                        "		end if; \n" +
                        "	end process;\n" +
                        "	\n" +
                        "	o_busy <= '0';\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_divstage64_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.std_logic_misc.all;  -- or_reduce()\n" +
                        "--library commonlib;\n" +
                        "use work.types_common.all;\n" +
                        "\n" +
                        "entity divstage64 is \n" +
                        "  port (\n" +
                        "    i_divident   : in std_logic_vector(63 downto 0);  -- integer value\n" +
                        "    i_divisor    : in std_logic_vector(123 downto 0); -- integer value\n" +
                        "    o_resid      : out std_logic_vector(63 downto 0); -- residual value\n" +
                        "    o_bits       : out std_logic_vector(3 downto 0)   -- resulting bits\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_divstage64 of divstage64 is\n" +
                        "\n" +
                        "  type thresh_type is array (15 downto 0) of std_logic_vector(65 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  comb : process(i_divident, i_divisor)\n" +
                        "    variable wb_thresh : thresh_type;\n" +
                        "    variable wb_dif : std_logic_vector(63 downto 0);\n" +
                        "    variable wb_bits : std_logic_vector(3 downto 0);\n" +
                        "    variable wb_divident : std_logic_vector(64 downto 0);\n" +
                        "    variable wb_divx1 : std_logic_vector(64 downto 0);\n" +
                        "    variable wb_divx2 : std_logic_vector(64 downto 0);\n" +
                        "    variable wb_divx3 : std_logic_vector(64 downto 0);\n" +
                        "    variable wb_divx4 : std_logic_vector(64 downto 0);\n" +
                        "    variable wb_divx5 : std_logic_vector(64 downto 0);\n" +
                        "    variable wb_divx6 : std_logic_vector(64 downto 0);\n" +
                        "    variable wb_divx7 : std_logic_vector(64 downto 0);\n" +
                        "    variable wb_divx8 : std_logic_vector(64 downto 0);\n" +
                        "    variable wb_divx9 : std_logic_vector(64 downto 0);\n" +
                        "    variable wb_divx10 : std_logic_vector(64 downto 0);\n" +
                        "    variable wb_divx11 : std_logic_vector(64 downto 0);\n" +
                        "    variable wb_divx12 : std_logic_vector(64 downto 0);\n" +
                        "    variable wb_divx13 : std_logic_vector(64 downto 0);\n" +
                        "    variable wb_divx14 : std_logic_vector(64 downto 0);\n" +
                        "    variable wb_divx15 : std_logic_vector(64 downto 0);\n" +
                        "    variable wb_divx16 : std_logic_vector(64 downto 0);\n" +
                        "\n" +
                        "  begin\n" +
                        "    wb_divident := '0' & i_divident;\n" +
                        "\n" +
                        "    wb_divx1(63 downto 0) := i_divisor(63 downto 0);\n" +
                        "    wb_divx1(64) := or_reduce(i_divisor(123 downto 64));\n" +
                        "\n" +
                        "    wb_divx2(63 downto 0) := i_divisor(62 downto 0) & '0';\n" +
                        "    wb_divx2(64) := or_reduce(i_divisor(123 downto 63));\n" +
                        "\n" +
                        "    wb_divx3(64 downto 0) := ('0' & wb_divx2(63 downto 0)) + ('0' & wb_divx1(63 downto 0));\n" +
                        "    wb_divx3(64) := wb_divx3(64) or wb_divx2(64);\n" +
                        "\n" +
                        "    wb_divx4(63 downto 0) := i_divisor(61 downto 0) & \"00\";\n" +
                        "    wb_divx4(64) := or_reduce(i_divisor(123 downto 62));\n" +
                        "\n" +
                        "    wb_divx5(64 downto 0) := ('0' & wb_divx4(63 downto 0)) + ('0' & wb_divx1(63 downto 0));\n" +
                        "    wb_divx5(64) := wb_divx5(64) or wb_divx4(64);\n" +
                        "\n" +
                        "    wb_divx6(63 downto 0) := wb_divx3(62 downto 0) & '0';\n" +
                        "    wb_divx6(64) := wb_divx3(64) or wb_divx3(63);\n" +
                        "\n" +
                        "    wb_divx8(63 downto 0) := wb_divx1(60 downto 0) & \"000\";\n" +
                        "    wb_divx8(64) := or_reduce(i_divisor(123 downto 61));\n" +
                        "\n" +
                        "    -- 7 = 8 - 1\n" +
                        "    wb_divx7(64 downto 0) := wb_divx8(64 downto 0) - ('0' & wb_divx1(63 downto 0));\n" +
                        "    wb_divx7(64) := wb_divx7(64) or or_reduce(i_divisor(123 downto 62));\n" +
                        "\n" +
                        "    -- 9 = 8 + 1\n" +
                        "    wb_divx9(64 downto 0) := ('0' & wb_divx8(63 downto 0)) + ('0' & wb_divx1(63 downto 0));\n" +
                        "    wb_divx9(64) := wb_divx9(64) or or_reduce(i_divisor(123 downto 61));\n" +
                        "\n" +
                        "    -- 10 = 8 + 2\n" +
                        "    wb_divx10(64 downto 0) := ('0' & wb_divx8(63 downto 0)) + ('0' & wb_divx2(63 downto 0));\n" +
                        "    wb_divx10(64) := wb_divx10(64) or or_reduce(i_divisor(123 downto 61));\n" +
                        "\n" +
                        "    -- 11 = 8 + 3\n" +
                        "    wb_divx11(64 downto 0) := ('0' & wb_divx8(63 downto 0)) + ('0' & wb_divx3(63 downto 0));\n" +
                        "    wb_divx11(64) := wb_divx11(64) or or_reduce(i_divisor(123 downto 61));\n" +
                        "\n" +
                        "    -- 12 = 3 << 2\n" +
                        "    wb_divx12(63 downto 0) := wb_divx3(61 downto 0) & \"00\";\n" +
                        "    wb_divx12(64) := wb_divx3(64) or wb_divx3(63) or wb_divx3(62);\n" +
                        "\n" +
                        "    -- 16 = divisor << 4\n" +
                        "    wb_divx16(63 downto 0) := wb_divx1(59 downto 0) & \"0000\";\n" +
                        "    wb_divx16(64) := or_reduce(i_divisor(123 downto 60));\n" +
                        "\n" +
                        "    -- 13 = 16 - 3\n" +
                        "    wb_divx13(64 downto 0) := wb_divx16(64 downto 0) - ('0' & wb_divx3(63 downto 0));\n" +
                        "    wb_divx13(64) := wb_divx13(64) or or_reduce(i_divisor(123 downto 61));\n" +
                        "\n" +
                        "    -- 14 = 7 << 1\n" +
                        "    wb_divx14(63 downto 0) := wb_divx7(62 downto 0) & '0';\n" +
                        "    wb_divx14(64) := wb_divx7(64) or wb_divx7(63);\n" +
                        "\n" +
                        "    -- 15 = 16 - 1\n" +
                        "    wb_divx15(64 downto 0) := wb_divx16(64 downto 0) - ('0' & wb_divx1(63 downto 0));\n" +
                        "    wb_divx15(64) := wb_divx15(64) or or_reduce(i_divisor(123 downto 61));\n" +
                        "\n" +
                        "    wb_thresh(15) := ('0' & wb_divident) - ('0' & wb_divx15);\n" +
                        "    wb_thresh(14) := ('0' & wb_divident) - ('0' & wb_divx14);\n" +
                        "    wb_thresh(13) := ('0' & wb_divident) - ('0' & wb_divx13);\n" +
                        "    wb_thresh(12) := ('0' & wb_divident) - ('0' & wb_divx12);\n" +
                        "    wb_thresh(11) := ('0' & wb_divident) - ('0' & wb_divx11);\n" +
                        "    wb_thresh(10) := ('0' & wb_divident) - ('0' & wb_divx10);\n" +
                        "    wb_thresh(9) := ('0' & wb_divident) - ('0' & wb_divx9);\n" +
                        "    wb_thresh(8) := ('0' & wb_divident) - ('0' & wb_divx8);\n" +
                        "    wb_thresh(7) := ('0' & wb_divident) - ('0' & wb_divx7);\n" +
                        "    wb_thresh(6) := ('0' & wb_divident) - ('0' & wb_divx6);\n" +
                        "    wb_thresh(5) := ('0' & wb_divident) - ('0' & wb_divx5);\n" +
                        "    wb_thresh(4) := ('0' & wb_divident) - ('0' & wb_divx4);\n" +
                        "    wb_thresh(3) := ('0' & wb_divident) - ('0' & wb_divx3);\n" +
                        "    wb_thresh(2) := ('0' & wb_divident) - ('0' & wb_divx2);\n" +
                        "    wb_thresh(1) := ('0' & wb_divident) - ('0' & wb_divx1);\n" +
                        "    wb_thresh(0) := ('0' & wb_divident);\n" +
                        "\n" +
                        "    if wb_thresh(15)(65) = '0' then\n" +
                        "        wb_bits := X\"F\";\n" +
                        "        wb_dif := wb_thresh(15)(63 downto 0);\n" +
                        "    elsif wb_thresh(14)(65) = '0' then\n" +
                        "        wb_bits := X\"E\";\n" +
                        "        wb_dif := wb_thresh(14)(63 downto 0);\n" +
                        "    elsif wb_thresh(13)(65) = '0' then\n" +
                        "        wb_bits := X\"D\";\n" +
                        "        wb_dif := wb_thresh(13)(63 downto 0);\n" +
                        "    elsif wb_thresh(12)(65) = '0' then\n" +
                        "        wb_bits := X\"C\";\n" +
                        "        wb_dif := wb_thresh(12)(63 downto 0);\n" +
                        "    elsif wb_thresh(11)(65) = '0' then\n" +
                        "        wb_bits := X\"B\";\n" +
                        "        wb_dif := wb_thresh(11)(63 downto 0);\n" +
                        "    elsif wb_thresh(10)(65) = '0' then\n" +
                        "        wb_bits := X\"A\";\n" +
                        "        wb_dif := wb_thresh(10)(63 downto 0);\n" +
                        "    elsif wb_thresh(9)(65) = '0' then\n" +
                        "        wb_bits := X\"9\";\n" +
                        "        wb_dif := wb_thresh(9)(63 downto 0);\n" +
                        "    elsif wb_thresh(8)(65) = '0' then\n" +
                        "        wb_bits := X\"8\";\n" +
                        "        wb_dif := wb_thresh(8)(63 downto 0);\n" +
                        "    elsif wb_thresh(7)(65) = '0' then\n" +
                        "        wb_bits := X\"7\";\n" +
                        "        wb_dif := wb_thresh(7)(63 downto 0);\n" +
                        "    elsif wb_thresh(6)(65) = '0' then\n" +
                        "        wb_bits := X\"6\";\n" +
                        "        wb_dif := wb_thresh(6)(63 downto 0);\n" +
                        "    elsif wb_thresh(5)(65) = '0' then\n" +
                        "        wb_bits := X\"5\";\n" +
                        "        wb_dif := wb_thresh(5)(63 downto 0);\n" +
                        "    elsif wb_thresh(4)(65) = '0' then\n" +
                        "        wb_bits := X\"4\";\n" +
                        "        wb_dif := wb_thresh(4)(63 downto 0);\n" +
                        "    elsif wb_thresh(3)(65) = '0' then\n" +
                        "        wb_bits := X\"3\";\n" +
                        "        wb_dif := wb_thresh(3)(63 downto 0);\n" +
                        "    elsif wb_thresh(2)(65) = '0' then\n" +
                        "        wb_bits := X\"2\";\n" +
                        "        wb_dif := wb_thresh(2)(63 downto 0);\n" +
                        "    elsif wb_thresh(1)(65) = '0' then\n" +
                        "        wb_bits := X\"1\";\n" +
                        "        wb_dif := wb_thresh(1)(63 downto 0);\n" +
                        "    else\n" +
                        "        wb_bits := X\"0\";\n" +
                        "        wb_dif := wb_thresh(0)(63 downto 0);\n" +
                        "    end if;\n" +
                        "\n" +
                        "    o_bits <= wb_bits;\n" +
                        "    o_resid <= wb_dif;\n" +
                        "\n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_mul_int_64_vhd_file(String Project_Folder_File) {
        String data =   "-- megafunction wizard: %LPM_MULT%\n" +
                        "-- GENERATION: STANDARD\n" +
                        "-- VERSION: WM1.0\n" +
                        "-- MODULE: lpm_mult \n" +
                        "\n" +
                        "-- ============================================================\n" +
                        "-- File Name: mul_int_64.vhd\n" +
                        "-- Megafunction Name(s):\n" +
                        "-- 			lpm_mult\n" +
                        "--\n" +
                        "-- Simulation Library Files(s):\n" +
                        "-- 			lpm\n" +
                        "-- ============================================================\n" +
                        "-- ************************************************************\n" +
                        "-- THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!\n" +
                        "--\n" +
                        "-- 18.0.0 Build 614 04/24/2018 SJ Lite Edition\n" +
                        "-- ************************************************************\n" +
                        "\n" +
                        "\n" +
                        "--Copyright (C) 2018  Intel Corporation. All rights reserved.\n" +
                        "--Your use of Intel Corporation's design tools, logic functions \n" +
                        "--and other software and tools, and its AMPP partner logic \n" +
                        "--functions, and any output files from any of the foregoing \n" +
                        "--(including device programming or simulation files), and any \n" +
                        "--associated documentation or information are expressly subject \n" +
                        "--to the terms and conditions of the Intel Program License \n" +
                        "--Subscription Agreement, the Intel Quartus Prime License Agreement,\n" +
                        "--the Intel FPGA IP License Agreement, or other applicable license\n" +
                        "--agreement, including, without limitation, that your use is for\n" +
                        "--the sole purpose of programming logic devices manufactured by\n" +
                        "--Intel and sold by Intel or its authorized distributors.  Please\n" +
                        "--refer to the applicable agreement for further details.\n" +
                        "\n" +
                        "\n" +
                        "LIBRARY ieee;\n" +
                        "USE ieee.std_logic_1164.all;\n" +
                        "\n" +
                        "LIBRARY lpm;\n" +
                        "USE lpm.all;\n" +
                        "\n" +
                        "ENTITY mul_int_64 IS\n" +
                        "	PORT\n" +
                        "	(\n" +
                        "		dataa		: IN STD_LOGIC_VECTOR (63 DOWNTO 0);\n" +
                        "		datab		: IN STD_LOGIC_VECTOR (63 DOWNTO 0);\n" +
                        "		result		: OUT STD_LOGIC_VECTOR (127 DOWNTO 0)\n" +
                        "	);\n" +
                        "END mul_int_64;\n" +
                        "\n" +
                        "\n" +
                        "ARCHITECTURE SYN OF mul_int_64 IS\n" +
                        "\n" +
                        "	SIGNAL sub_wire0	: STD_LOGIC_VECTOR (127 DOWNTO 0);\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "	COMPONENT lpm_mult\n" +
                        "	GENERIC (\n" +
                        "		lpm_hint		: STRING;\n" +
                        "		lpm_representation		: STRING;\n" +
                        "		lpm_type		: STRING;\n" +
                        "		lpm_widtha		: NATURAL;\n" +
                        "		lpm_widthb		: NATURAL;\n" +
                        "		lpm_widthp		: NATURAL\n" +
                        "	);\n" +
                        "	PORT (\n" +
                        "			dataa	: IN STD_LOGIC_VECTOR (63 DOWNTO 0);\n" +
                        "			datab	: IN STD_LOGIC_VECTOR (63 DOWNTO 0);\n" +
                        "			result	: OUT STD_LOGIC_VECTOR (127 DOWNTO 0)\n" +
                        "	);\n" +
                        "	END COMPONENT;\n" +
                        "\n" +
                        "BEGIN\n" +
                        "	result    <= sub_wire0(127 DOWNTO 0);\n" +
                        "\n" +
                        "	lpm_mult_component : lpm_mult\n" +
                        "	GENERIC MAP (\n" +
                        "		lpm_hint => \"MAXIMIZE_SPEED=1\",\n" +
                        "		lpm_representation => \"SIGNED\",\n" +
                        "		lpm_type => \"LPM_MULT\",\n" +
                        "		lpm_widtha => 64,\n" +
                        "		lpm_widthb => 64,\n" +
                        "		lpm_widthp => 128\n" +
                        "	)\n" +
                        "	PORT MAP (\n" +
                        "		dataa => dataa,\n" +
                        "		datab => datab,\n" +
                        "		result => sub_wire0\n" +
                        "	);\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "END SYN;\n" +
                        "\n" +
                        "-- ============================================================\n" +
                        "-- CNX file retrieval info\n" +
                        "-- ============================================================\n" +
                        "-- Retrieval info: PRIVATE: AutoSizeResult NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: B_isConstant NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: ConstantB NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: INTENDED_DEVICE_FAMILY STRING \"Cyclone V\"\n" +
                        "-- Retrieval info: PRIVATE: LPM_PIPELINE NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: Latency NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: SYNTH_WRAPPER_GEN_POSTFIX STRING \"0\"\n" +
                        "-- Retrieval info: PRIVATE: SignedMult NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: USE_MULT NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: ValidConstant NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: WidthA NUMERIC \"64\"\n" +
                        "-- Retrieval info: PRIVATE: WidthB NUMERIC \"64\"\n" +
                        "-- Retrieval info: PRIVATE: WidthP NUMERIC \"128\"\n" +
                        "-- Retrieval info: PRIVATE: aclr NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: clken NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: new_diagram STRING \"1\"\n" +
                        "-- Retrieval info: PRIVATE: optimize NUMERIC \"2\"\n" +
                        "-- Retrieval info: LIBRARY: lpm lpm.lpm_components.all\n" +
                        "-- Retrieval info: CONSTANT: LPM_HINT STRING \"MAXIMIZE_SPEED=1\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_REPRESENTATION STRING \"SIGNED\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_TYPE STRING \"LPM_MULT\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_WIDTHA NUMERIC \"64\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_WIDTHB NUMERIC \"64\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_WIDTHP NUMERIC \"128\"\n" +
                        "-- Retrieval info: USED_PORT: dataa 0 0 64 0 INPUT NODEFVAL \"dataa[63..0]\"\n" +
                        "-- Retrieval info: USED_PORT: datab 0 0 64 0 INPUT NODEFVAL \"datab[63..0]\"\n" +
                        "-- Retrieval info: USED_PORT: result 0 0 128 0 OUTPUT NODEFVAL \"result[127..0]\"\n" +
                        "-- Retrieval info: CONNECT: @dataa 0 0 64 0 dataa 0 0 64 0\n" +
                        "-- Retrieval info: CONNECT: @datab 0 0 64 0 datab 0 0 64 0\n" +
                        "-- Retrieval info: CONNECT: result 0 0 128 0 @result 0 0 128 0\n" +
                        "-- Retrieval info: GEN_FILE: TYPE_NORMAL mul_int_64.vhd TRUE\n" +
                        "-- Retrieval info: GEN_FILE: TYPE_NORMAL mul_int_64.inc FALSE\n" +
                        "-- Retrieval info: GEN_FILE: TYPE_NORMAL mul_int_64.cmp FALSE\n" +
                        "-- Retrieval info: GEN_FILE: TYPE_NORMAL mul_int_64.bsf FALSE\n" +
                        "-- Retrieval info: GEN_FILE: TYPE_NORMAL mul_int_64_inst.vhd FALSE\n" +
                        "-- Retrieval info: LIB_FILE: lpm";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_mul_int_64_qip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -name IP_TOOL_NAME \"LPM_MULT\"\n" +
                        "set_global_assignment -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -name IP_GENERATED_DEVICE_FAMILY \"{Cyclone V}\"\n" +
                        "set_global_assignment -name VHDL_FILE [file join $::quartus(qip_path) \"mul_int_64.vhd\"]";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_mul_int_20_7_vhd_file(String Project_Folder_File) {
        String data =   "-- megafunction wizard: %LPM_MULT%\n" +
                        "-- GENERATION: STANDARD\n" +
                        "-- VERSION: WM1.0\n" +
                        "-- MODULE: lpm_mult \n" +
                        "\n" +
                        "-- ============================================================\n" +
                        "-- File Name: mul_int_20_7.vhd\n" +
                        "-- Megafunction Name(s):\n" +
                        "-- 			lpm_mult\n" +
                        "--\n" +
                        "-- Simulation Library Files(s):\n" +
                        "-- 			lpm\n" +
                        "-- ============================================================\n" +
                        "-- ************************************************************\n" +
                        "-- THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!\n" +
                        "--\n" +
                        "-- 18.0.0 Build 614 04/24/2018 SJ Lite Edition\n" +
                        "-- ************************************************************\n" +
                        "\n" +
                        "\n" +
                        "--Copyright (C) 2018  Intel Corporation. All rights reserved.\n" +
                        "--Your use of Intel Corporation's design tools, logic functions \n" +
                        "--and other software and tools, and its AMPP partner logic \n" +
                        "--functions, and any output files from any of the foregoing \n" +
                        "--(including device programming or simulation files), and any \n" +
                        "--associated documentation or information are expressly subject \n" +
                        "--to the terms and conditions of the Intel Program License \n" +
                        "--Subscription Agreement, the Intel Quartus Prime License Agreement,\n" +
                        "--the Intel FPGA IP License Agreement, or other applicable license\n" +
                        "--agreement, including, without limitation, that your use is for\n" +
                        "--the sole purpose of programming logic devices manufactured by\n" +
                        "--Intel and sold by Intel or its authorized distributors.  Please\n" +
                        "--refer to the applicable agreement for further details.\n" +
                        "\n" +
                        "\n" +
                        "LIBRARY ieee;\n" +
                        "USE ieee.std_logic_1164.all;\n" +
                        "\n" +
                        "LIBRARY lpm;\n" +
                        "USE lpm.all;\n" +
                        "\n" +
                        "ENTITY mul_int_20_7 IS\n" +
                        "	PORT\n" +
                        "	(\n" +
                        "		dataa		: IN STD_LOGIC_VECTOR (19 DOWNTO 0);\n" +
                        "		datab		: IN STD_LOGIC_VECTOR (6 DOWNTO 0);\n" +
                        "		result		: OUT STD_LOGIC_VECTOR (26 DOWNTO 0)\n" +
                        "	);\n" +
                        "END mul_int_20_7;\n" +
                        "\n" +
                        "\n" +
                        "ARCHITECTURE SYN OF mul_int_20_7 IS\n" +
                        "\n" +
                        "	SIGNAL sub_wire0	: STD_LOGIC_VECTOR (26 DOWNTO 0);\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "	COMPONENT lpm_mult\n" +
                        "	GENERIC (\n" +
                        "		lpm_hint		: STRING;\n" +
                        "		lpm_representation		: STRING;\n" +
                        "		lpm_type		: STRING;\n" +
                        "		lpm_widtha		: NATURAL;\n" +
                        "		lpm_widthb		: NATURAL;\n" +
                        "		lpm_widthp		: NATURAL\n" +
                        "	);\n" +
                        "	PORT (\n" +
                        "			dataa	: IN STD_LOGIC_VECTOR (19 DOWNTO 0);\n" +
                        "			datab	: IN STD_LOGIC_VECTOR (6 DOWNTO 0);\n" +
                        "			result	: OUT STD_LOGIC_VECTOR (26 DOWNTO 0)\n" +
                        "	);\n" +
                        "	END COMPONENT;\n" +
                        "\n" +
                        "BEGIN\n" +
                        "	result    <= sub_wire0(26 DOWNTO 0);\n" +
                        "\n" +
                        "	lpm_mult_component : lpm_mult\n" +
                        "	GENERIC MAP (\n" +
                        "		lpm_hint => \"DEDICATED_MULTIPLIER_CIRCUITRY=YES,MAXIMIZE_SPEED=9\",\n" +
                        "		lpm_representation => \"UNSIGNED\",\n" +
                        "		lpm_type => \"LPM_MULT\",\n" +
                        "		lpm_widtha => 20,\n" +
                        "		lpm_widthb => 7,\n" +
                        "		lpm_widthp => 27\n" +
                        "	)\n" +
                        "	PORT MAP (\n" +
                        "		dataa => dataa,\n" +
                        "		datab => datab,\n" +
                        "		result => sub_wire0\n" +
                        "	);\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "END SYN;\n" +
                        "\n" +
                        "-- ============================================================\n" +
                        "-- CNX file retrieval info\n" +
                        "-- ============================================================\n" +
                        "-- Retrieval info: PRIVATE: AutoSizeResult NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: B_isConstant NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: ConstantB NUMERIC \"100\"\n" +
                        "-- Retrieval info: PRIVATE: INTENDED_DEVICE_FAMILY STRING \"Cyclone V\"\n" +
                        "-- Retrieval info: PRIVATE: LPM_PIPELINE NUMERIC \"5\"\n" +
                        "-- Retrieval info: PRIVATE: Latency NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: SYNTH_WRAPPER_GEN_POSTFIX STRING \"0\"\n" +
                        "-- Retrieval info: PRIVATE: SignedMult NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: USE_MULT NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: ValidConstant NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: WidthA NUMERIC \"20\"\n" +
                        "-- Retrieval info: PRIVATE: WidthB NUMERIC \"7\"\n" +
                        "-- Retrieval info: PRIVATE: WidthP NUMERIC \"27\"\n" +
                        "-- Retrieval info: PRIVATE: aclr NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: clken NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: new_diagram STRING \"1\"\n" +
                        "-- Retrieval info: PRIVATE: optimize NUMERIC \"1\"\n" +
                        "-- Retrieval info: LIBRARY: lpm lpm.lpm_components.all\n" +
                        "-- Retrieval info: CONSTANT: LPM_HINT STRING \"DEDICATED_MULTIPLIER_CIRCUITRY=YES,MAXIMIZE_SPEED=9\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_REPRESENTATION STRING \"UNSIGNED\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_TYPE STRING \"LPM_MULT\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_WIDTHA NUMERIC \"20\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_WIDTHB NUMERIC \"7\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_WIDTHP NUMERIC \"27\"\n" +
                        "-- Retrieval info: USED_PORT: dataa 0 0 20 0 INPUT NODEFVAL \"dataa[19..0]\"\n" +
                        "-- Retrieval info: USED_PORT: datab 0 0 7 0 INPUT NODEFVAL \"datab[6..0]\"\n" +
                        "-- Retrieval info: USED_PORT: result 0 0 27 0 OUTPUT NODEFVAL \"result[26..0]\"\n" +
                        "-- Retrieval info: CONNECT: @dataa 0 0 20 0 dataa 0 0 20 0\n" +
                        "-- Retrieval info: CONNECT: @datab 0 0 7 0 datab 0 0 7 0\n" +
                        "-- Retrieval info: CONNECT: result 0 0 27 0 @result 0 0 27 0\n" +
                        "-- Retrieval info: LIB_FILE: lpm";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_mul_int_20_7_qip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -name IP_TOOL_NAME \"LPM_MULT\"\n" +
                        "set_global_assignment -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -name IP_GENERATED_DEVICE_FAMILY \"{Cyclone V}\"\n" +
                        "set_global_assignment -name VHDL_FILE [file join $::quartus(qip_path) \"mul_int_20_7.vhd\"]";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_div_int_20_7_speed_vhd_file(String Project_Folder_File) {
        String data =   "-- megafunction wizard: %LPM_DIVIDE%\n" +
                        "-- GENERATION: STANDARD\n" +
                        "-- VERSION: WM1.0\n" +
                        "-- MODULE: LPM_DIVIDE \n" +
                        "\n" +
                        "-- ============================================================\n" +
                        "-- File Name: div_int_20_7_speed.vhd\n" +
                        "-- Megafunction Name(s):\n" +
                        "-- 			LPM_DIVIDE\n" +
                        "--\n" +
                        "-- Simulation Library Files(s):\n" +
                        "-- 			lpm\n" +
                        "-- ============================================================\n" +
                        "-- ************************************************************\n" +
                        "-- THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!\n" +
                        "--\n" +
                        "-- 18.0.0 Build 614 04/24/2018 SJ Lite Edition\n" +
                        "-- ************************************************************\n" +
                        "\n" +
                        "\n" +
                        "--Copyright (C) 2018  Intel Corporation. All rights reserved.\n" +
                        "--Your use of Intel Corporation's design tools, logic functions \n" +
                        "--and other software and tools, and its AMPP partner logic \n" +
                        "--functions, and any output files from any of the foregoing \n" +
                        "--(including device programming or simulation files), and any \n" +
                        "--associated documentation or information are expressly subject \n" +
                        "--to the terms and conditions of the Intel Program License \n" +
                        "--Subscription Agreement, the Intel Quartus Prime License Agreement,\n" +
                        "--the Intel FPGA IP License Agreement, or other applicable license\n" +
                        "--agreement, including, without limitation, that your use is for\n" +
                        "--the sole purpose of programming logic devices manufactured by\n" +
                        "--Intel and sold by Intel or its authorized distributors.  Please\n" +
                        "--refer to the applicable agreement for further details.\n" +
                        "\n" +
                        "\n" +
                        "LIBRARY ieee;\n" +
                        "USE ieee.std_logic_1164.all;\n" +
                        "\n" +
                        "LIBRARY lpm;\n" +
                        "USE lpm.all;\n" +
                        "\n" +
                        "ENTITY div_int_20_7_speed IS\n" +
                        "	PORT\n" +
                        "	(\n" +
                        "		denom		: IN STD_LOGIC_VECTOR (6 DOWNTO 0);\n" +
                        "		numer		: IN STD_LOGIC_VECTOR (19 DOWNTO 0);\n" +
                        "		quotient		: OUT STD_LOGIC_VECTOR (19 DOWNTO 0);\n" +
                        "		remain		: OUT STD_LOGIC_VECTOR (6 DOWNTO 0)\n" +
                        "	);\n" +
                        "END div_int_20_7_speed;\n" +
                        "\n" +
                        "\n" +
                        "ARCHITECTURE SYN OF div_int_20_7_speed IS\n" +
                        "\n" +
                        "	SIGNAL sub_wire0	: STD_LOGIC_VECTOR (19 DOWNTO 0);\n" +
                        "	SIGNAL sub_wire1	: STD_LOGIC_VECTOR (6 DOWNTO 0);\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "	COMPONENT lpm_divide\n" +
                        "	GENERIC (\n" +
                        "		lpm_drepresentation		: STRING;\n" +
                        "		lpm_hint		: STRING;\n" +
                        "		lpm_nrepresentation		: STRING;\n" +
                        "		lpm_type		: STRING;\n" +
                        "		lpm_widthd		: NATURAL;\n" +
                        "		lpm_widthn		: NATURAL\n" +
                        "	);\n" +
                        "	PORT (\n" +
                        "			denom	: IN STD_LOGIC_VECTOR (6 DOWNTO 0);\n" +
                        "			numer	: IN STD_LOGIC_VECTOR (19 DOWNTO 0);\n" +
                        "			quotient	: OUT STD_LOGIC_VECTOR (19 DOWNTO 0);\n" +
                        "			remain	: OUT STD_LOGIC_VECTOR (6 DOWNTO 0)\n" +
                        "	);\n" +
                        "	END COMPONENT;\n" +
                        "\n" +
                        "BEGIN\n" +
                        "	quotient    <= sub_wire0(19 DOWNTO 0);\n" +
                        "	remain    <= sub_wire1(6 DOWNTO 0);\n" +
                        "\n" +
                        "	LPM_DIVIDE_component : LPM_DIVIDE\n" +
                        "	GENERIC MAP (\n" +
                        "		lpm_drepresentation => \"UNSIGNED\",\n" +
                        "		lpm_hint => \"MAXIMIZE_SPEED=6,LPM_REMAINDERPOSITIVE=TRUE\",\n" +
                        "		lpm_nrepresentation => \"UNSIGNED\",\n" +
                        "		lpm_type => \"LPM_DIVIDE\",\n" +
                        "		lpm_widthd => 7,\n" +
                        "		lpm_widthn => 20\n" +
                        "	)\n" +
                        "	PORT MAP (\n" +
                        "		denom => denom,\n" +
                        "		numer => numer,\n" +
                        "		quotient => sub_wire0,\n" +
                        "		remain => sub_wire1\n" +
                        "	);\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "END SYN;\n" +
                        "\n" +
                        "-- ============================================================\n" +
                        "-- CNX file retrieval info\n" +
                        "-- ============================================================\n" +
                        "-- Retrieval info: PRIVATE: INTENDED_DEVICE_FAMILY STRING \"Cyclone V\"\n" +
                        "-- Retrieval info: PRIVATE: PRIVATE_LPM_REMAINDERPOSITIVE STRING \"TRUE\"\n" +
                        "-- Retrieval info: PRIVATE: PRIVATE_MAXIMIZE_SPEED NUMERIC \"6\"\n" +
                        "-- Retrieval info: PRIVATE: SYNTH_WRAPPER_GEN_POSTFIX STRING \"0\"\n" +
                        "-- Retrieval info: PRIVATE: USING_PIPELINE NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: VERSION_NUMBER NUMERIC \"2\"\n" +
                        "-- Retrieval info: PRIVATE: new_diagram STRING \"1\"\n" +
                        "-- Retrieval info: LIBRARY: lpm lpm.lpm_components.all\n" +
                        "-- Retrieval info: CONSTANT: LPM_DREPRESENTATION STRING \"UNSIGNED\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_HINT STRING \"MAXIMIZE_SPEED=6,LPM_REMAINDERPOSITIVE=TRUE\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_NREPRESENTATION STRING \"UNSIGNED\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_TYPE STRING \"LPM_DIVIDE\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_WIDTHD NUMERIC \"7\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_WIDTHN NUMERIC \"20\"\n" +
                        "-- Retrieval info: USED_PORT: denom 0 0 7 0 INPUT NODEFVAL \"denom[6..0]\"\n" +
                        "-- Retrieval info: USED_PORT: numer 0 0 20 0 INPUT NODEFVAL \"numer[19..0]\"\n" +
                        "-- Retrieval info: USED_PORT: quotient 0 0 20 0 OUTPUT NODEFVAL \"quotient[19..0]\"\n" +
                        "-- Retrieval info: USED_PORT: remain 0 0 7 0 OUTPUT NODEFVAL \"remain[6..0]\"\n" +
                        "-- Retrieval info: CONNECT: @denom 0 0 7 0 denom 0 0 7 0\n" +
                        "-- Retrieval info: CONNECT: @numer 0 0 20 0 numer 0 0 20 0\n" +
                        "-- Retrieval info: CONNECT: quotient 0 0 20 0 @quotient 0 0 20 0\n" +
                        "-- Retrieval info: CONNECT: remain 0 0 7 0 @remain 0 0 7 0\n" +
                        "-- Retrieval info: LIB_FILE: lpm";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_div_int_20_7_speed_qip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -name IP_TOOL_NAME \"LPM_DIVIDE\"\n" +
                        "set_global_assignment -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -name IP_GENERATED_DEVICE_FAMILY \"{Cyclone V}\"\n" +
                        "set_global_assignment -name VHDL_FILE [file join $::quartus(qip_path) \"div_int_20_7_speed.vhd\"]";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_div_int_20_17_speed_vhd_file(String Project_Folder_File) {
        String data =   "-- megafunction wizard: %LPM_DIVIDE%\n" +
                        "-- GENERATION: STANDARD\n" +
                        "-- VERSION: WM1.0\n" +
                        "-- MODULE: LPM_DIVIDE \n" +
                        "\n" +
                        "-- ============================================================\n" +
                        "-- File Name: div_int_20_17_speed.vhd\n" +
                        "-- Megafunction Name(s):\n" +
                        "-- 			LPM_DIVIDE\n" +
                        "--\n" +
                        "-- Simulation Library Files(s):\n" +
                        "-- 			lpm\n" +
                        "-- ============================================================\n" +
                        "-- ************************************************************\n" +
                        "-- THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!\n" +
                        "--\n" +
                        "-- 18.0.0 Build 614 04/24/2018 SJ Lite Edition\n" +
                        "-- ************************************************************\n" +
                        "\n" +
                        "\n" +
                        "--Copyright (C) 2018  Intel Corporation. All rights reserved.\n" +
                        "--Your use of Intel Corporation's design tools, logic functions \n" +
                        "--and other software and tools, and its AMPP partner logic \n" +
                        "--functions, and any output files from any of the foregoing \n" +
                        "--(including device programming or simulation files), and any \n" +
                        "--associated documentation or information are expressly subject \n" +
                        "--to the terms and conditions of the Intel Program License \n" +
                        "--Subscription Agreement, the Intel Quartus Prime License Agreement,\n" +
                        "--the Intel FPGA IP License Agreement, or other applicable license\n" +
                        "--agreement, including, without limitation, that your use is for\n" +
                        "--the sole purpose of programming logic devices manufactured by\n" +
                        "--Intel and sold by Intel or its authorized distributors.  Please\n" +
                        "--refer to the applicable agreement for further details.\n" +
                        "\n" +
                        "\n" +
                        "LIBRARY ieee;\n" +
                        "USE ieee.std_logic_1164.all;\n" +
                        "\n" +
                        "LIBRARY lpm;\n" +
                        "USE lpm.all;\n" +
                        "\n" +
                        "ENTITY div_int_20_17_speed IS\n" +
                        "	PORT\n" +
                        "	(\n" +
                        "		denom		: IN STD_LOGIC_VECTOR (16 DOWNTO 0);\n" +
                        "		numer		: IN STD_LOGIC_VECTOR (19 DOWNTO 0);\n" +
                        "		quotient		: OUT STD_LOGIC_VECTOR (19 DOWNTO 0);\n" +
                        "		remain		: OUT STD_LOGIC_VECTOR (16 DOWNTO 0)\n" +
                        "	);\n" +
                        "END div_int_20_17_speed;\n" +
                        "\n" +
                        "\n" +
                        "ARCHITECTURE SYN OF div_int_20_17_speed IS\n" +
                        "\n" +
                        "	SIGNAL sub_wire0	: STD_LOGIC_VECTOR (19 DOWNTO 0);\n" +
                        "	SIGNAL sub_wire1	: STD_LOGIC_VECTOR (16 DOWNTO 0);\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "	COMPONENT lpm_divide\n" +
                        "	GENERIC (\n" +
                        "		lpm_drepresentation		: STRING;\n" +
                        "		lpm_hint		: STRING;\n" +
                        "		lpm_nrepresentation		: STRING;\n" +
                        "		lpm_type		: STRING;\n" +
                        "		lpm_widthd		: NATURAL;\n" +
                        "		lpm_widthn		: NATURAL\n" +
                        "	);\n" +
                        "	PORT (\n" +
                        "			denom	: IN STD_LOGIC_VECTOR (16 DOWNTO 0);\n" +
                        "			numer	: IN STD_LOGIC_VECTOR (19 DOWNTO 0);\n" +
                        "			quotient	: OUT STD_LOGIC_VECTOR (19 DOWNTO 0);\n" +
                        "			remain	: OUT STD_LOGIC_VECTOR (16 DOWNTO 0)\n" +
                        "	);\n" +
                        "	END COMPONENT;\n" +
                        "\n" +
                        "BEGIN\n" +
                        "	quotient    <= sub_wire0(19 DOWNTO 0);\n" +
                        "	remain    <= sub_wire1(16 DOWNTO 0);\n" +
                        "\n" +
                        "	LPM_DIVIDE_component : LPM_DIVIDE\n" +
                        "	GENERIC MAP (\n" +
                        "		lpm_drepresentation => \"UNSIGNED\",\n" +
                        "		lpm_hint => \"MAXIMIZE_SPEED=6,LPM_REMAINDERPOSITIVE=TRUE\",\n" +
                        "		lpm_nrepresentation => \"UNSIGNED\",\n" +
                        "		lpm_type => \"LPM_DIVIDE\",\n" +
                        "		lpm_widthd => 17,\n" +
                        "		lpm_widthn => 20\n" +
                        "	)\n" +
                        "	PORT MAP (\n" +
                        "		denom => denom,\n" +
                        "		numer => numer,\n" +
                        "		quotient => sub_wire0,\n" +
                        "		remain => sub_wire1\n" +
                        "	);\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "END SYN;\n" +
                        "\n" +
                        "-- ============================================================\n" +
                        "-- CNX file retrieval info\n" +
                        "-- ============================================================\n" +
                        "-- Retrieval info: PRIVATE: INTENDED_DEVICE_FAMILY STRING \"Cyclone V\"\n" +
                        "-- Retrieval info: PRIVATE: PRIVATE_LPM_REMAINDERPOSITIVE STRING \"TRUE\"\n" +
                        "-- Retrieval info: PRIVATE: PRIVATE_MAXIMIZE_SPEED NUMERIC \"6\"\n" +
                        "-- Retrieval info: PRIVATE: SYNTH_WRAPPER_GEN_POSTFIX STRING \"0\"\n" +
                        "-- Retrieval info: PRIVATE: USING_PIPELINE NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: VERSION_NUMBER NUMERIC \"2\"\n" +
                        "-- Retrieval info: PRIVATE: new_diagram STRING \"1\"\n" +
                        "-- Retrieval info: LIBRARY: lpm lpm.lpm_components.all\n" +
                        "-- Retrieval info: CONSTANT: LPM_DREPRESENTATION STRING \"UNSIGNED\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_HINT STRING \"MAXIMIZE_SPEED=6,LPM_REMAINDERPOSITIVE=TRUE\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_NREPRESENTATION STRING \"UNSIGNED\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_TYPE STRING \"LPM_DIVIDE\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_WIDTHD NUMERIC \"17\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_WIDTHN NUMERIC \"20\"\n" +
                        "-- Retrieval info: USED_PORT: denom 0 0 17 0 INPUT NODEFVAL \"denom[16..0]\"\n" +
                        "-- Retrieval info: USED_PORT: numer 0 0 20 0 INPUT NODEFVAL \"numer[19..0]\"\n" +
                        "-- Retrieval info: USED_PORT: quotient 0 0 20 0 OUTPUT NODEFVAL \"quotient[19..0]\"\n" +
                        "-- Retrieval info: USED_PORT: remain 0 0 17 0 OUTPUT NODEFVAL \"remain[16..0]\"\n" +
                        "-- Retrieval info: CONNECT: @denom 0 0 17 0 denom 0 0 17 0\n" +
                        "-- Retrieval info: CONNECT: @numer 0 0 20 0 numer 0 0 20 0\n" +
                        "-- Retrieval info: CONNECT: quotient 0 0 20 0 @quotient 0 0 20 0\n" +
                        "-- Retrieval info: CONNECT: remain 0 0 17 0 @remain 0 0 17 0\n" +
                        "-- Retrieval info: LIB_FILE: lpm";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_div_int_20_17_speed_qip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -name IP_TOOL_NAME \"LPM_DIVIDE\"\n" +
                        "set_global_assignment -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -name IP_GENERATED_DEVICE_FAMILY \"{Cyclone V}\"\n" +
                        "set_global_assignment -name VHDL_FILE [file join $::quartus(qip_path) \"div_int_20_17_speed.vhd\"]";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_clock_generator_vhd_file(String Project_Folder_File) {
        String data =   "-- megafunction wizard: %PLL Intel FPGA IP v18.0%\n" +
                        "-- GENERATION: XML\n" +
                        "-- clock_generator.vhd\n" +
                        "\n" +
                        "-- Generated using ACDS version 18.0 614\n" +
                        "\n" +
                        "library IEEE;\n" +
                        "use IEEE.std_logic_1164.all;\n" +
                        "use IEEE.numeric_std.all;\n" +
                        "\n" +
                        "entity clock_generator is\n" +
                        "	port (\n" +
                        "		refclk   : in  std_logic := '0'; --  refclk.clk\n" +
                        "		rst      : in  std_logic := '0'; --   reset.reset\n" +
                        "		outclk_0 : out std_logic;        -- outclk0.clk\n" +
                        "		outclk_1 : out std_logic;        -- outclk1.clk\n" +
                        "		locked   : out std_logic         --  locked.export\n" +
                        "	);\n" +
                        "end entity clock_generator;\n" +
                        "\n" +
                        "architecture rtl of clock_generator is\n" +
                        "	component clock_generator_0002 is\n" +
                        "		port (\n" +
                        "			refclk   : in  std_logic := 'X'; -- clk\n" +
                        "			rst      : in  std_logic := 'X'; -- reset\n" +
                        "			outclk_0 : out std_logic;        -- clk\n" +
                        "			outclk_1 : out std_logic;        -- clk\n" +
                        "			locked   : out std_logic         -- export\n" +
                        "		);\n" +
                        "	end component clock_generator_0002;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "	clock_generator_inst : component clock_generator_0002\n" +
                        "		port map (\n" +
                        "			refclk   => refclk,   --  refclk.clk\n" +
                        "			rst      => rst,      --   reset.reset\n" +
                        "			outclk_0 => outclk_0, -- outclk0.clk\n" +
                        "			outclk_1 => outclk_1, -- outclk1.clk\n" +
                        "			locked   => locked    --  locked.export\n" +
                        "		);\n" +
                        "\n" +
                        "end architecture rtl; -- of clock_generator\n" +
                        "-- Retrieval info: <?xml version=\"1.0\"?>\n" +
                        "--<!--\n" +
                        "--	Generated by Altera MegaWizard Launcher Utility version 1.0\n" +
                        "--	************************************************************\n" +
                        "--	THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!\n" +
                        "--	************************************************************\n" +
                        "--	Copyright (C) 1991-2019 Altera Corporation\n" +
                        "--	Any megafunction design, and related net list (encrypted or decrypted),\n" +
                        "--	support information, device programming or simulation file, and any other\n" +
                        "--	associated documentation or information provided by Altera or a partner\n" +
                        "--	under Altera's Megafunction Partnership Program may be used only to\n" +
                        "--	program PLD devices (but not masked PLD devices) from Altera.  Any other\n" +
                        "--	use of such megafunction design, net list, support information, device\n" +
                        "--	programming or simulation file, or any other related documentation or\n" +
                        "--	information is prohibited for any other purpose, including, but not\n" +
                        "--	limited to modification, reverse engineering, de-compiling, or use with\n" +
                        "--	any other silicon devices, unless such use is explicitly licensed under\n" +
                        "--	a separate agreement with Altera or a megafunction partner.  Title to\n" +
                        "--	the intellectual property, including patents, copyrights, trademarks,\n" +
                        "--	trade secrets, or maskworks, embodied in any such megafunction design,\n" +
                        "--	net list, support information, device programming or simulation file, or\n" +
                        "--	any other related documentation or information provided by Altera or a\n" +
                        "--	megafunction partner, remains with Altera, the megafunction partner, or\n" +
                        "--	their respective licensors.  No other licenses, including any licenses\n" +
                        "--	needed under any third party's intellectual property, are provided herein.\n" +
                        "---->\n" +
                        "-- Retrieval info: <instance entity-name=\"altera_pll\" version=\"18.0\" >\n" +
                        "-- Retrieval info: 	<generic name=\"debug_print_output\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"debug_use_rbc_taf_method\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"device_family\" value=\"Cyclone V\" />\n" +
                        "-- Retrieval info: 	<generic name=\"device\" value=\"5CEBA2F17A7\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_device_speed_grade\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_pll_mode\" value=\"Integer-N PLL\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_reference_clock_frequency\" value=\"100.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_channel_spacing\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_operation_mode\" value=\"direct\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_feedback_clock\" value=\"Global Clock\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_fractional_cout\" value=\"32\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_dsm_out_sel\" value=\"1st_order\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_use_locked\" value=\"true\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_en_adv_params\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_number_of_clocks\" value=\"2\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_multiply_factor\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_frac_multiply_factor\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_n\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter0\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency0\" value=\"75.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c0\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency0\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units0\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift0\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg0\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift0\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle0\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter1\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency1\" value=\"50.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c1\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency1\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units1\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift1\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg1\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift1\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle1\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter2\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency2\" value=\"100.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c2\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency2\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units2\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift2\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg2\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift2\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle2\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter3\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency3\" value=\"100.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c3\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency3\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units3\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift3\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg3\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift3\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle3\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter4\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency4\" value=\"100.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c4\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency4\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units4\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift4\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg4\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift4\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle4\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter5\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency5\" value=\"100.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c5\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency5\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units5\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift5\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg5\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift5\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle5\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter6\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency6\" value=\"100.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c6\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency6\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units6\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift6\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg6\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift6\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle6\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter7\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency7\" value=\"100.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c7\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency7\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units7\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift7\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg7\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift7\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle7\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter8\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency8\" value=\"100.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c8\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency8\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units8\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift8\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg8\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift8\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle8\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter9\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency9\" value=\"100.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c9\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency9\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units9\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift9\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg9\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift9\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle9\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter10\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency10\" value=\"100.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c10\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency10\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units10\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift10\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg10\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift10\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle10\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter11\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency11\" value=\"100.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c11\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency11\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units11\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift11\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg11\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift11\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle11\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter12\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency12\" value=\"100.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c12\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency12\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units12\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift12\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg12\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift12\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle12\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter13\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency13\" value=\"100.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c13\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency13\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units13\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift13\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg13\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift13\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle13\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter14\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency14\" value=\"100.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c14\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency14\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units14\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift14\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg14\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift14\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle14\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter15\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency15\" value=\"100.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c15\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency15\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units15\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift15\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg15\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift15\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle15\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter16\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency16\" value=\"100.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c16\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency16\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units16\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift16\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg16\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift16\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle16\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter17\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency17\" value=\"100.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c17\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency17\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units17\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift17\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg17\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift17\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle17\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_pll_auto_reset\" value=\"Off\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_pll_bandwidth_preset\" value=\"Auto\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_en_reconf\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_en_dps_ports\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_en_phout_ports\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phout_division\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_mif_generate\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_enable_mif_dps\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_dps_cntr\" value=\"C0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_dps_num\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_dps_dir\" value=\"Positive\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_refclk_switch\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_refclk1_frequency\" value=\"100.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_switchover_mode\" value=\"Automatic Switchover\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_switchover_delay\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_active_clk\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_clk_bad\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_enable_cascade_out\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_outclk_index\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_enable_cascade_in\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_pll_cascading_mode\" value=\"Create an adjpllin signal to connect with an upstream PLL\" />\n" +
                        "-- Retrieval info: </instance>\n" +
                        "-- IPFS_FILES : clock_generator.vho\n" +
                        "-- RELATED_FILES: clock_generator.vhd, clock_generator_0002.v";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_clock_generator_qip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -entity \"clock_generator\" -library \"clock_generator\" -name IP_TOOL_NAME \"altera_pll\"\n" +
                        "set_global_assignment -entity \"clock_generator\" -library \"clock_generator\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"clock_generator\" -library \"clock_generator\" -name IP_TOOL_ENV \"mwpim\"\n" +
                        "set_global_assignment -library \"clock_generator\" -name MISC_FILE [file join $::quartus(qip_path) \"clock_generator.cmp\"]\n" +
                        "set_global_assignment -entity \"clock_generator\" -library \"clock_generator\" -name IP_TARGETED_DEVICE_FAMILY \"Cyclone V\"\n" +
                        "set_global_assignment -entity \"clock_generator\" -library \"clock_generator\" -name IP_GENERATED_DEVICE_FAMILY \"{Cyclone V}\"\n" +
                        "set_global_assignment -entity \"clock_generator\" -library \"clock_generator\" -name IP_QSYS_MODE \"UNKNOWN\"\n" +
                        "set_global_assignment -name SYNTHESIS_ONLY_QIP ON\n" +
                        "set_global_assignment -entity \"clock_generator\" -library \"clock_generator\" -name IP_COMPONENT_NAME \"Y2xvY2tfZ2VuZXJhdG9y\"\n" +
                        "set_global_assignment -entity \"clock_generator\" -library \"clock_generator\" -name IP_COMPONENT_DISPLAY_NAME \"UExMIEludGVsIEZQR0EgSVA=\"\n" +
                        "set_global_assignment -entity \"clock_generator\" -library \"clock_generator\" -name IP_COMPONENT_REPORT_HIERARCHY \"Off\"\n" +
                        "set_global_assignment -entity \"clock_generator\" -library \"clock_generator\" -name IP_COMPONENT_INTERNAL \"Off\"\n" +
                        "set_global_assignment -entity \"clock_generator\" -library \"clock_generator\" -name IP_COMPONENT_AUTHOR \"SW50ZWwgQ29ycG9yYXRpb24=\"\n" +
                        "set_global_assignment -entity \"clock_generator\" -library \"clock_generator\" -name IP_COMPONENT_VERSION \"MTguMA==\"\n" +
                        "set_global_assignment -entity \"clock_generator\" -library \"clock_generator\" -name IP_COMPONENT_DESCRIPTION \"SW50ZWwgUGhhc2UtTG9ja2VkIExvb3A=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_NAME \"Y2xvY2tfZ2VuZXJhdG9yXzAwMDI=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_DISPLAY_NAME \"UExMIEludGVsIEZQR0EgSVA=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_REPORT_HIERARCHY \"Off\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_INTERNAL \"Off\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_AUTHOR \"SW50ZWwgQ29ycG9yYXRpb24=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_VERSION \"MTguMA==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_DESCRIPTION \"SW50ZWwgUGhhc2UtTG9ja2VkIExvb3A=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"ZGVidWdfcHJpbnRfb3V0cHV0::ZmFsc2U=::ZGVidWdfcHJpbnRfb3V0cHV0\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"ZGVidWdfdXNlX3JiY190YWZfbWV0aG9k::ZmFsc2U=::ZGVidWdfdXNlX3JiY190YWZfbWV0aG9k\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"ZGV2aWNl::NUNFQkEyRjE3QTc=::ZGV2aWNl\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BsbF9tb2Rl::SW50ZWdlci1OIFBMTA==::UExMIE1vZGU=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"ZnJhY3Rpb25hbF92Y29fbXVsdGlwbGllcg==::ZmFsc2U=::ZnJhY3Rpb25hbF92Y29fbXVsdGlwbGllcg==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3JlZmVyZW5jZV9jbG9ja19mcmVxdWVuY3k=::MTAwLjA=::UmVmZXJlbmNlIENsb2NrIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"cmVmZXJlbmNlX2Nsb2NrX2ZyZXF1ZW5jeQ==::MTAwLjAgTUh6::cmVmZXJlbmNlX2Nsb2NrX2ZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2NoYW5uZWxfc3BhY2luZw==::MC4w::Q2hhbm5lbCBTcGFjaW5n\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX29wZXJhdGlvbl9tb2Rl::ZGlyZWN0::T3BlcmF0aW9uIE1vZGU=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2ZlZWRiYWNrX2Nsb2Nr::R2xvYmFsIENsb2Nr::RmVlZGJhY2sgQ2xvY2s=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2ZyYWN0aW9uYWxfY291dA==::MzI=::RnJhY3Rpb25hbCBjYXJyeSBvdXQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RzbV9vdXRfc2Vs::MXN0X29yZGVy::RFNNIE9yZGVy\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"b3BlcmF0aW9uX21vZGU=::ZGlyZWN0::b3BlcmF0aW9uX21vZGU=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3VzZV9sb2NrZWQ=::dHJ1ZQ==::RW5hYmxlIGxvY2tlZCBvdXRwdXQgcG9ydA==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2VuX2Fkdl9wYXJhbXM=::ZmFsc2U=::RW5hYmxlIHBoeXNpY2FsIG91dHB1dCBjbG9jayBwYXJhbWV0ZXJz\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX251bWJlcl9vZl9jbG9ja3M=::Mg==::TnVtYmVyIE9mIENsb2Nrcw==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"bnVtYmVyX29mX2Nsb2Nrcw==::Mg==::bnVtYmVyX29mX2Nsb2Nrcw==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX211bHRpcGx5X2ZhY3Rvcg==::MQ==::TXVsdGlwbHkgRmFjdG9yIChNLUNvdW50ZXIp\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2ZyYWNfbXVsdGlwbHlfZmFjdG9y::MQ==::RnJhY3Rpb25hbCBNdWx0aXBseSBGYWN0b3IgKEsp\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3Jfbg==::MQ==::RGl2aWRlIEZhY3RvciAoTi1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjA=::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3kw::NzUuMA==::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzA=::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3Iw::Mw==::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3RvcjA=::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yMA==::NA==::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5MA==::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzMA==::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0MA==::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzA=::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDA=::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGUw::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjE=::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3kx::NTAuMA==::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzE=::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3Ix::Mw==::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3RvcjE=::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yMQ==::Ng==::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5MQ==::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzMQ==::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0MQ==::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzE=::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDE=::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGUx::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjI=::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3ky::MTAwLjA=::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzI=::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3Iy::MQ==::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3RvcjI=::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yMg==::MQ==::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5Mg==::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzMg==::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0Mg==::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzI=::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDI=::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGUy::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjM=::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3kz::MTAwLjA=::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzM=::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3Iz::MQ==::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3RvcjM=::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yMw==::MQ==::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5Mw==::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzMw==::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0Mw==::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzM=::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDM=::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGUz::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjQ=::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3k0::MTAwLjA=::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzQ=::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3I0::MQ==::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3RvcjQ=::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yNA==::MQ==::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5NA==::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzNA==::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0NA==::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzQ=::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDQ=::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGU0::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjU=::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3k1::MTAwLjA=::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzU=::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3I1::MQ==::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3RvcjU=::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yNQ==::MQ==::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5NQ==::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzNQ==::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0NQ==::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzU=::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDU=::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGU1::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjY=::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3k2::MTAwLjA=::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzY=::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3I2::MQ==::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3RvcjY=::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yNg==::MQ==::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5Ng==::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzNg==::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0Ng==::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzY=::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDY=::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGU2::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjc=::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3k3::MTAwLjA=::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzc=::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3I3::MQ==::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3Rvcjc=::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yNw==::MQ==::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5Nw==::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzNw==::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0Nw==::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzc=::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDc=::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGU3::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjg=::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3k4::MTAwLjA=::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzg=::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3I4::MQ==::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3Rvcjg=::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yOA==::MQ==::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5OA==::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzOA==::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0OA==::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzg=::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDg=::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGU4::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjk=::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3k5::MTAwLjA=::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzk=::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3I5::MQ==::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3Rvcjk=::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yOQ==::MQ==::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5OQ==::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzOQ==::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0OQ==::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzk=::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDk=::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGU5::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjEw::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3kxMA==::MTAwLjA=::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzEw::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3IxMA==::MQ==::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3RvcjEw::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yMTA=::MQ==::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5MTA=::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzMTA=::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0MTA=::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzEw::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDEw::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGUxMA==::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjEx::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3kxMQ==::MTAwLjA=::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzEx::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3IxMQ==::MQ==::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3RvcjEx::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yMTE=::MQ==::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5MTE=::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzMTE=::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0MTE=::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzEx::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDEx::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGUxMQ==::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjEy::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3kxMg==::MTAwLjA=::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzEy::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3IxMg==::MQ==::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3RvcjEy::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yMTI=::MQ==::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5MTI=::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzMTI=::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0MTI=::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzEy::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDEy::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGUxMg==::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjEz::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3kxMw==::MTAwLjA=::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzEz::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3IxMw==::MQ==::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3RvcjEz::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yMTM=::MQ==::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5MTM=::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzMTM=::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0MTM=::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzEz::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDEz::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGUxMw==::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjE0::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3kxNA==::MTAwLjA=::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzE0::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3IxNA==::MQ==::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3RvcjE0::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yMTQ=::MQ==::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5MTQ=::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzMTQ=::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0MTQ=::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzE0::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDE0::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGUxNA==::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjE1::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3kxNQ==::MTAwLjA=::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzE1::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3IxNQ==::MQ==::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3RvcjE1::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yMTU=::MQ==::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5MTU=::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzMTU=::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0MTU=::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzE1::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDE1::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGUxNQ==::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjE2::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3kxNg==::MTAwLjA=::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzE2::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3IxNg==::MQ==::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3RvcjE2::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yMTY=::MQ==::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5MTY=::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzMTY=::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0MTY=::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzE2::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDE2::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGUxNg==::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjE3::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3kxNw==::MTAwLjA=::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzE3::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3IxNw==::MQ==::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3RvcjE3::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yMTc=::MQ==::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5MTc=::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzMTc=::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0MTc=::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzE3::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDE3::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGUxNw==::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTA=::NzUuMDAwMDAwIE1Ieg==::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTA=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQw::MCBwcw==::cGhhc2Vfc2hpZnQw\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTA=::NTA=::ZHV0eV9jeWNsZTA=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTE=::NTAuMDAwMDAwIE1Ieg==::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTE=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQx::MCBwcw==::cGhhc2Vfc2hpZnQx\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTE=::NTA=::ZHV0eV9jeWNsZTE=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTI=::MCBNSHo=::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTI=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQy::MCBwcw==::cGhhc2Vfc2hpZnQy\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTI=::NTA=::ZHV0eV9jeWNsZTI=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTM=::MCBNSHo=::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTM=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQz::MCBwcw==::cGhhc2Vfc2hpZnQz\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTM=::NTA=::ZHV0eV9jeWNsZTM=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTQ=::MCBNSHo=::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQ0::MCBwcw==::cGhhc2Vfc2hpZnQ0\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTQ=::NTA=::ZHV0eV9jeWNsZTQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTU=::MCBNSHo=::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTU=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQ1::MCBwcw==::cGhhc2Vfc2hpZnQ1\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTU=::NTA=::ZHV0eV9jeWNsZTU=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTY=::MCBNSHo=::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTY=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQ2::MCBwcw==::cGhhc2Vfc2hpZnQ2\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTY=::NTA=::ZHV0eV9jeWNsZTY=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTc=::MCBNSHo=::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTc=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQ3::MCBwcw==::cGhhc2Vfc2hpZnQ3\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTc=::NTA=::ZHV0eV9jeWNsZTc=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTg=::MCBNSHo=::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTg=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQ4::MCBwcw==::cGhhc2Vfc2hpZnQ4\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTg=::NTA=::ZHV0eV9jeWNsZTg=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTk=::MCBNSHo=::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTk=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQ5::MCBwcw==::cGhhc2Vfc2hpZnQ5\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTk=::NTA=::ZHV0eV9jeWNsZTk=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTEw::MCBNSHo=::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTEw\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQxMA==::MCBwcw==::cGhhc2Vfc2hpZnQxMA==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTEw::NTA=::ZHV0eV9jeWNsZTEw\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTEx::MCBNSHo=::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTEx\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQxMQ==::MCBwcw==::cGhhc2Vfc2hpZnQxMQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTEx::NTA=::ZHV0eV9jeWNsZTEx\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTEy::MCBNSHo=::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTEy\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQxMg==::MCBwcw==::cGhhc2Vfc2hpZnQxMg==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTEy::NTA=::ZHV0eV9jeWNsZTEy\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTEz::MCBNSHo=::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTEz\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQxMw==::MCBwcw==::cGhhc2Vfc2hpZnQxMw==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTEz::NTA=::ZHV0eV9jeWNsZTEz\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTE0::MCBNSHo=::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTE0\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQxNA==::MCBwcw==::cGhhc2Vfc2hpZnQxNA==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTE0::NTA=::ZHV0eV9jeWNsZTE0\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTE1::MCBNSHo=::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTE1\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQxNQ==::MCBwcw==::cGhhc2Vfc2hpZnQxNQ==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTE1::NTA=::ZHV0eV9jeWNsZTE1\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTE2::MCBNSHo=::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTE2\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQxNg==::MCBwcw==::cGhhc2Vfc2hpZnQxNg==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTE2::NTA=::ZHV0eV9jeWNsZTE2\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTE3::MCBNSHo=::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTE3\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQxNw==::MCBwcw==::cGhhc2Vfc2hpZnQxNw==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTE3::NTA=::ZHV0eV9jeWNsZTE3\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BsbF9hdXRvX3Jlc2V0::T2Zm::UExMIEF1dG8gUmVzZXQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BsbF9iYW5kd2lkdGhfcHJlc2V0::QXV0bw==::UExMIEJhbmR3aWR0aCBQcmVzZXQ=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2VuX3JlY29uZg==::ZmFsc2U=::RW5hYmxlIGR5bmFtaWMgcmVjb25maWd1cmF0aW9uIG9mIFBMTA==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2VuX2Rwc19wb3J0cw==::ZmFsc2U=::RW5hYmxlIGFjY2VzcyB0byBkeW5hbWljIHBoYXNlIHNoaWZ0IHBvcnRz\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2VuX3Bob3V0X3BvcnRz::ZmFsc2U=::RW5hYmxlIGFjY2VzcyB0byBQTEwgRFBBIG91dHB1dCBwb3J0\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"cGxsX3R5cGU=::R2VuZXJhbA==::UExMIFRZUEU=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"cGxsX3N1YnR5cGU=::R2VuZXJhbA==::UExMIFNVQlRZUEU=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BhcmFtZXRlcl9saXN0::TS1Db3VudGVyIEhpIERpdmlkZSxNLUNvdW50ZXIgTG93IERpdmlkZSxOLUNvdW50ZXIgSGkgRGl2aWRlLE4tQ291bnRlciBMb3cgRGl2aWRlLE0tQ291bnRlciBCeXBhc3MgRW5hYmxlLE4tQ291bnRlciBCeXBhc3MgRW5hYmxlLE0tQ291bnRlciBPZGQgRGl2aWRlIEVuYWJsZSxOLUNvdW50ZXIgT2RkIERpdmlkZSBFbmFibGUsQy1Db3VudGVyLTAgSGkgRGl2aWRlLEMtQ291bnRlci0wIExvdyBEaXZpZGUsQy1Db3VudGVyLTAgQ29hcnNlIFBoYXNlIFNoaWZ0LEMtQ291bnRlci0wIFZDTyBQaGFzZSBUYXAsQy1Db3VudGVyLTAgSW5wdXQgU291cmNlLEMtQ291bnRlci0wIEJ5cGFzcyBFbmFibGUsQy1Db3VudGVyLTAgT2RkIERpdmlkZSBFbmFibGUsQy1Db3VudGVyLTEgSGkgRGl2aWRlLEMtQ291bnRlci0xIExvdyBEaXZpZGUsQy1Db3VudGVyLTEgQ29hcnNlIFBoYXNlIFNoaWZ0LEMtQ291bnRlci0xIFZDTyBQaGFzZSBUYXAsQy1Db3VudGVyLTEgSW5wdXQgU291cmNlLEMtQ291bnRlci0xIEJ5cGFzcyBFbmFibGUsQy1Db3VudGVyLTEgT2RkIERpdmlkZSBFbmFibGUsVkNPIFBvc3QgRGl2aWRlIENvdW50ZXIgRW5hYmxlLENoYXJnZSBQdW1wIGN1cnJlbnQgKHVBKSxMb29wIEZpbHRlciBCYW5kd2lkdGggUmVzaXN0b3IgKE9obXMpICxQTEwgT3V0cHV0IFZDTyBGcmVxdWVuY3ksSy1GcmFjdGlvbmFsIERpdmlzaW9uIFZhbHVlIChEU00pLEZlZWRiYWNrIENsb2NrIFR5cGUsRmVlZGJhY2sgQ2xvY2sgTVVYIDEsRmVlZGJhY2sgQ2xvY2sgTVVYIDIsTSBDb3VudGVyIFNvdXJjZSBNVVgsUExMIEF1dG8gUmVzZXQ=::UGFyYW1ldGVyIE5hbWVz\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BhcmFtZXRlcl92YWx1ZXM=::MiwxLDI1NiwyNTYsZmFsc2UsdHJ1ZSx0cnVlLGZhbHNlLDIsMiwxLDAscGhfbXV4X2NsayxmYWxzZSxmYWxzZSwzLDMsMSwwLHBoX211eF9jbGssZmFsc2UsZmFsc2UsMiwyMCwyMDAwLDMwMC4wIE1IeiwxLG5vbmUsZ2xiLG1fY250LHBoX211eF9jbGssZmFsc2U=::UGFyYW1ldGVyIFZhbHVlcw==\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX21pZl9nZW5lcmF0ZQ==::ZmFsc2U=::R2VuZXJhdGUgTUlGIGZpbGU=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2VuYWJsZV9taWZfZHBz::ZmFsc2U=::RW5hYmxlIER5bmFtaWMgUGhhc2UgU2hpZnQgZm9yIE1JRiBzdHJlYW1pbmc=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Rwc19jbnRy::QzA=::RFBTIENvdW50ZXIgU2VsZWN0aW9u\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Rwc19udW0=::MQ==::TnVtYmVyIG9mIER5bmFtaWMgUGhhc2UgU2hpZnRz\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Rwc19kaXI=::UG9zaXRpdmU=::RHluYW1pYyBQaGFzZSBTaGlmdCBEaXJlY3Rpb24=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX3JlZmNsa19zd2l0Y2g=::ZmFsc2U=::Q3JlYXRlIGEgc2Vjb25kIGlucHV0IGNsayAncmVmY2xrMSc=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2VuYWJsZV9jYXNjYWRlX291dA==::ZmFsc2U=::Q3JlYXRlIGEgJ2Nhc2NhZGVfb3V0JyBzaWduYWwgdG8gY29ubmVjdCB3aXRoIGEgZG93bnN0cmVhbSBQTEw=\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_COMPONENT_PARAMETER \"Z3VpX2VuYWJsZV9jYXNjYWRlX2lu::ZmFsc2U=::Q3JlYXRlIGFuIGFkanBsbGluIG9yIGNjbGsgc2lnbmFsIHRvIGNvbm5lY3Qgd2l0aCBhbiB1cHN0cmVhbSBQTEw=\"\n" +
                        "\n" +
                        "set_global_assignment -library \"clock_generator\" -name VHDL_FILE [file join $::quartus(qip_path) \"clock_generator.vhd\"]\n" +
                        "set_global_assignment -library \"clock_generator\" -name VERILOG_FILE [file join $::quartus(qip_path) \"clock_generator/clock_generator_0002.v\"]\n" +
                        "set_global_assignment -library \"clock_generator\" -name QIP_FILE [file join $::quartus(qip_path) \"clock_generator/clock_generator_0002.qip\"]\n" +
                        "\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_TOOL_NAME \"altera_pll\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"clock_generator_0002\" -library \"clock_generator\" -name IP_TOOL_ENV \"mwpim\"";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_clock_generator_sip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -entity \"clock_generator\" -library \"lib_clock_generator\" -name IP_TOOL_NAME \"altera_pll\"\n" +
                        "set_global_assignment -entity \"clock_generator\" -library \"lib_clock_generator\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"clock_generator\" -library \"lib_clock_generator\" -name IP_TOOL_ENV \"mwpim\"\n" +
                        "set_global_assignment -library \"lib_clock_generator\" -name SPD_FILE [file join $::quartus(sip_path) \"clock_generator.spd\"]\n" +
                        "\n" +
                        "set_global_assignment -library \"lib_clock_generator\" -name MISC_FILE [file join $::quartus(sip_path) \"clock_generator_sim/clock_generator.vho\"]";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_clock_generator_spd_file(String Project_Folder_File) {
        String data =   "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" +
                        "<simPackage>\n" +
                        " <file path=\"clock_generator_sim/clock_generator.vho\" type=\"VHDL\" />\n" +
                        " <topLevel name=\"clock_generator\" />\n" +
                        " <deviceFamily name=\"cyclonev\" />\n" +
                        "</simPackage>";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_clock_generator_0002_v_file(String Project_Folder_File) {
        String data =   "`timescale 1ns/10ps\n" +
                        "module  clock_generator_0002(\n" +
                        "\n" +
                        "	// interface 'refclk'\n" +
                        "	input wire refclk,\n" +
                        "\n" +
                        "	// interface 'reset'\n" +
                        "	input wire rst,\n" +
                        "\n" +
                        "	// interface 'outclk0'\n" +
                        "	output wire outclk_0,\n" +
                        "\n" +
                        "	// interface 'outclk1'\n" +
                        "	output wire outclk_1,\n" +
                        "\n" +
                        "	// interface 'locked'\n" +
                        "	output wire locked\n" +
                        ");\n" +
                        "\n" +
                        "	altera_pll #(\n" +
                        "		.fractional_vco_multiplier(\"false\"),\n" +
                        "		.reference_clock_frequency(\"125.0 MHz\"),\n" +
                        "		.operation_mode(\"direct\"),\n" +
                        "		.number_of_clocks(2),\n" +
                        "		.output_clock_frequency0(\""+(Data.CPU_RV64_Freq/1000000)+" MHz\"),\n" +
                        "		.phase_shift0(\"0 ps\"),\n" +
                        "		.duty_cycle0(50),\n" +
                        "		.output_clock_frequency1(\""+(Data.PWM_RV64_HW_Freq/1000000)+" MHz\"),\n" +
                        "		.phase_shift1(\"0 ps\"),\n" +
                        "		.duty_cycle1(50),\n" +
                        "		.output_clock_frequency2(\"0 MHz\"),\n" +
                        "		.phase_shift2(\"0 ps\"),\n" +
                        "		.duty_cycle2(50),\n" +
                        "		.output_clock_frequency3(\"0 MHz\"),\n" +
                        "		.phase_shift3(\"0 ps\"),\n" +
                        "		.duty_cycle3(50),\n" +
                        "		.output_clock_frequency4(\"0 MHz\"),\n" +
                        "		.phase_shift4(\"0 ps\"),\n" +
                        "		.duty_cycle4(50),\n" +
                        "		.output_clock_frequency5(\"0 MHz\"),\n" +
                        "		.phase_shift5(\"0 ps\"),\n" +
                        "		.duty_cycle5(50),\n" +
                        "		.output_clock_frequency6(\"0 MHz\"),\n" +
                        "		.phase_shift6(\"0 ps\"),\n" +
                        "		.duty_cycle6(50),\n" +
                        "		.output_clock_frequency7(\"0 MHz\"),\n" +
                        "		.phase_shift7(\"0 ps\"),\n" +
                        "		.duty_cycle7(50),\n" +
                        "		.output_clock_frequency8(\"0 MHz\"),\n" +
                        "		.phase_shift8(\"0 ps\"),\n" +
                        "		.duty_cycle8(50),\n" +
                        "		.output_clock_frequency9(\"0 MHz\"),\n" +
                        "		.phase_shift9(\"0 ps\"),\n" +
                        "		.duty_cycle9(50),\n" +
                        "		.output_clock_frequency10(\"0 MHz\"),\n" +
                        "		.phase_shift10(\"0 ps\"),\n" +
                        "		.duty_cycle10(50),\n" +
                        "		.output_clock_frequency11(\"0 MHz\"),\n" +
                        "		.phase_shift11(\"0 ps\"),\n" +
                        "		.duty_cycle11(50),\n" +
                        "		.output_clock_frequency12(\"0 MHz\"),\n" +
                        "		.phase_shift12(\"0 ps\"),\n" +
                        "		.duty_cycle12(50),\n" +
                        "		.output_clock_frequency13(\"0 MHz\"),\n" +
                        "		.phase_shift13(\"0 ps\"),\n" +
                        "		.duty_cycle13(50),\n" +
                        "		.output_clock_frequency14(\"0 MHz\"),\n" +
                        "		.phase_shift14(\"0 ps\"),\n" +
                        "		.duty_cycle14(50),\n" +
                        "		.output_clock_frequency15(\"0 MHz\"),\n" +
                        "		.phase_shift15(\"0 ps\"),\n" +
                        "		.duty_cycle15(50),\n" +
                        "		.output_clock_frequency16(\"0 MHz\"),\n" +
                        "		.phase_shift16(\"0 ps\"),\n" +
                        "		.duty_cycle16(50),\n" +
                        "		.output_clock_frequency17(\"0 MHz\"),\n" +
                        "		.phase_shift17(\"0 ps\"),\n" +
                        "		.duty_cycle17(50),\n" +
                        "		.pll_type(\"General\"),\n" +
                        "		.pll_subtype(\"General\")\n" +
                        "	) altera_pll_i (\n" +
                        "		.rst	(rst),\n" +
                        "		.outclk	({outclk_1, outclk_0}),\n" +
                        "		.locked	(locked),\n" +
                        "		.fboutclk	( ),\n" +
                        "		.fbclk	(1'b0),\n" +
                        "		.refclk	(refclk)\n" +
                        "	);\n" +
                        "endmodule";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_clock_generator_0002_qip_file(String Project_Folder_File) {
        String data =   "set_instance_assignment -name PLL_COMPENSATION_MODE DIRECT -to \"*clock_generator_0002*|altera_pll:altera_pll_i*|*\"\n" +
                        " \n" +
                        "set_instance_assignment -name PLL_AUTO_RESET OFF -to \"*clock_generator_0002*|altera_pll:altera_pll_i*|*\"\n" +
                        "set_instance_assignment -name PLL_BANDWIDTH_PRESET AUTO -to \"*clock_generator_0002*|altera_pll:altera_pll_i*|*\"";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_clock_generator_vho_file(String Project_Folder_File) {
        String data =   "--IP Functional Simulation Model\n" +
                        "--VERSION_BEGIN 18.0 cbx_mgl 2018:04:18:07:37:08:SJ cbx_simgen 2018:04:18:06:50:44:SJ  VERSION_END\n" +
                        "\n" +
                        "\n" +
                        "-- Copyright (C) 2018  Intel Corporation. All rights reserved.\n" +
                        "-- Your use of Intel Corporation's design tools, logic functions \n" +
                        "-- and other software and tools, and its AMPP partner logic \n" +
                        "-- functions, and any output files from any of the foregoing \n" +
                        "-- (including device programming or simulation files), and any \n" +
                        "-- associated documentation or information are expressly subject \n" +
                        "-- to the terms and conditions of the Intel Program License \n" +
                        "-- Subscription Agreement, the Intel Quartus Prime License Agreement,\n" +
                        "-- the Intel FPGA IP License Agreement, or other applicable license\n" +
                        "-- agreement, including, without limitation, that your use is for\n" +
                        "-- the sole purpose of programming logic devices manufactured by\n" +
                        "-- Intel and sold by Intel or its authorized distributors.  Please\n" +
                        "-- refer to the applicable agreement for further details.\n" +
                        "\n" +
                        "-- You may only use these simulation model output files for simulation\n" +
                        "-- purposes and expressly not for synthesis or any other purposes (in which\n" +
                        "-- event Intel disclaims all warranties of any kind).\n" +
                        "\n" +
                        "\n" +
                        "--synopsys translate_off\n" +
                        "\n" +
                        " LIBRARY altera_lnsim;\n" +
                        " USE altera_lnsim.altera_lnsim_components.all;\n" +
                        "\n" +
                        "--synthesis_resources = altera_pll 1 \n" +
                        " LIBRARY ieee;\n" +
                        " USE ieee.std_logic_1164.all;\n" +
                        "\n" +
                        " ENTITY  clock_generator IS \n" +
                        "	 PORT \n" +
                        "	 ( \n" +
                        "		 locked	:	OUT  STD_LOGIC;\n" +
                        "		 outclk_0	:	OUT  STD_LOGIC;\n" +
                        "		 outclk_1	:	OUT  STD_LOGIC;\n" +
                        "		 refclk	:	IN  STD_LOGIC;\n" +
                        "		 rst	:	IN  STD_LOGIC\n" +
                        "	 ); \n" +
                        " END clock_generator;\n" +
                        "\n" +
                        " ARCHITECTURE RTL OF clock_generator IS\n" +
                        "\n" +
                        "	 ATTRIBUTE synthesis_clearbox : natural;\n" +
                        "	 ATTRIBUTE synthesis_clearbox OF RTL : ARCHITECTURE IS 1;\n" +
                        "	 SIGNAL  wire_gnd	:	STD_LOGIC;\n" +
                        "	 SIGNAL  wire_clock_generator_altera_pll_altera_pll_i_1098_locked	:	STD_LOGIC;\n" +
                        "	 SIGNAL  wire_clock_generator_altera_pll_altera_pll_i_1098_outclk	:	STD_LOGIC_VECTOR (1 DOWNTO 0);\n" +
                        " BEGIN\n" +
                        "\n" +
                        "	wire_gnd <= '0';\n" +
                        "	locked <= wire_clock_generator_altera_pll_altera_pll_i_1098_locked;\n" +
                        "	outclk_0 <= wire_clock_generator_altera_pll_altera_pll_i_1098_outclk(0);\n" +
                        "	outclk_1 <= wire_clock_generator_altera_pll_altera_pll_i_1098_outclk(1);\n" +
                        "	clock_generator_altera_pll_altera_pll_i_1098 :  altera_pll\n" +
                        "	  GENERIC MAP (\n" +
                        "		c_cnt_bypass_en0 => \"false\",\n" +
                        "		c_cnt_bypass_en1 => \"false\",\n" +
                        "		c_cnt_bypass_en10 => \"false\",\n" +
                        "		c_cnt_bypass_en11 => \"false\",\n" +
                        "		c_cnt_bypass_en12 => \"false\",\n" +
                        "		c_cnt_bypass_en13 => \"false\",\n" +
                        "		c_cnt_bypass_en14 => \"false\",\n" +
                        "		c_cnt_bypass_en15 => \"false\",\n" +
                        "		c_cnt_bypass_en16 => \"false\",\n" +
                        "		c_cnt_bypass_en17 => \"false\",\n" +
                        "		c_cnt_bypass_en2 => \"false\",\n" +
                        "		c_cnt_bypass_en3 => \"false\",\n" +
                        "		c_cnt_bypass_en4 => \"false\",\n" +
                        "		c_cnt_bypass_en5 => \"false\",\n" +
                        "		c_cnt_bypass_en6 => \"false\",\n" +
                        "		c_cnt_bypass_en7 => \"false\",\n" +
                        "		c_cnt_bypass_en8 => \"false\",\n" +
                        "		c_cnt_bypass_en9 => \"false\",\n" +
                        "		c_cnt_hi_div0 => 1,\n" +
                        "		c_cnt_hi_div1 => 1,\n" +
                        "		c_cnt_hi_div10 => 1,\n" +
                        "		c_cnt_hi_div11 => 1,\n" +
                        "		c_cnt_hi_div12 => 1,\n" +
                        "		c_cnt_hi_div13 => 1,\n" +
                        "		c_cnt_hi_div14 => 1,\n" +
                        "		c_cnt_hi_div15 => 1,\n" +
                        "		c_cnt_hi_div16 => 1,\n" +
                        "		c_cnt_hi_div17 => 1,\n" +
                        "		c_cnt_hi_div2 => 1,\n" +
                        "		c_cnt_hi_div3 => 1,\n" +
                        "		c_cnt_hi_div4 => 1,\n" +
                        "		c_cnt_hi_div5 => 1,\n" +
                        "		c_cnt_hi_div6 => 1,\n" +
                        "		c_cnt_hi_div7 => 1,\n" +
                        "		c_cnt_hi_div8 => 1,\n" +
                        "		c_cnt_hi_div9 => 1,\n" +
                        "		c_cnt_in_src0 => \"ph_mux_clk\",\n" +
                        "		c_cnt_in_src1 => \"ph_mux_clk\",\n" +
                        "		c_cnt_in_src10 => \"ph_mux_clk\",\n" +
                        "		c_cnt_in_src11 => \"ph_mux_clk\",\n" +
                        "		c_cnt_in_src12 => \"ph_mux_clk\",\n" +
                        "		c_cnt_in_src13 => \"ph_mux_clk\",\n" +
                        "		c_cnt_in_src14 => \"ph_mux_clk\",\n" +
                        "		c_cnt_in_src15 => \"ph_mux_clk\",\n" +
                        "		c_cnt_in_src16 => \"ph_mux_clk\",\n" +
                        "		c_cnt_in_src17 => \"ph_mux_clk\",\n" +
                        "		c_cnt_in_src2 => \"ph_mux_clk\",\n" +
                        "		c_cnt_in_src3 => \"ph_mux_clk\",\n" +
                        "		c_cnt_in_src4 => \"ph_mux_clk\",\n" +
                        "		c_cnt_in_src5 => \"ph_mux_clk\",\n" +
                        "		c_cnt_in_src6 => \"ph_mux_clk\",\n" +
                        "		c_cnt_in_src7 => \"ph_mux_clk\",\n" +
                        "		c_cnt_in_src8 => \"ph_mux_clk\",\n" +
                        "		c_cnt_in_src9 => \"ph_mux_clk\",\n" +
                        "		c_cnt_lo_div0 => 1,\n" +
                        "		c_cnt_lo_div1 => 1,\n" +
                        "		c_cnt_lo_div10 => 1,\n" +
                        "		c_cnt_lo_div11 => 1,\n" +
                        "		c_cnt_lo_div12 => 1,\n" +
                        "		c_cnt_lo_div13 => 1,\n" +
                        "		c_cnt_lo_div14 => 1,\n" +
                        "		c_cnt_lo_div15 => 1,\n" +
                        "		c_cnt_lo_div16 => 1,\n" +
                        "		c_cnt_lo_div17 => 1,\n" +
                        "		c_cnt_lo_div2 => 1,\n" +
                        "		c_cnt_lo_div3 => 1,\n" +
                        "		c_cnt_lo_div4 => 1,\n" +
                        "		c_cnt_lo_div5 => 1,\n" +
                        "		c_cnt_lo_div6 => 1,\n" +
                        "		c_cnt_lo_div7 => 1,\n" +
                        "		c_cnt_lo_div8 => 1,\n" +
                        "		c_cnt_lo_div9 => 1,\n" +
                        "		c_cnt_odd_div_duty_en0 => \"false\",\n" +
                        "		c_cnt_odd_div_duty_en1 => \"false\",\n" +
                        "		c_cnt_odd_div_duty_en10 => \"false\",\n" +
                        "		c_cnt_odd_div_duty_en11 => \"false\",\n" +
                        "		c_cnt_odd_div_duty_en12 => \"false\",\n" +
                        "		c_cnt_odd_div_duty_en13 => \"false\",\n" +
                        "		c_cnt_odd_div_duty_en14 => \"false\",\n" +
                        "		c_cnt_odd_div_duty_en15 => \"false\",\n" +
                        "		c_cnt_odd_div_duty_en16 => \"false\",\n" +
                        "		c_cnt_odd_div_duty_en17 => \"false\",\n" +
                        "		c_cnt_odd_div_duty_en2 => \"false\",\n" +
                        "		c_cnt_odd_div_duty_en3 => \"false\",\n" +
                        "		c_cnt_odd_div_duty_en4 => \"false\",\n" +
                        "		c_cnt_odd_div_duty_en5 => \"false\",\n" +
                        "		c_cnt_odd_div_duty_en6 => \"false\",\n" +
                        "		c_cnt_odd_div_duty_en7 => \"false\",\n" +
                        "		c_cnt_odd_div_duty_en8 => \"false\",\n" +
                        "		c_cnt_odd_div_duty_en9 => \"false\",\n" +
                        "		c_cnt_ph_mux_prst0 => 0,\n" +
                        "		c_cnt_ph_mux_prst1 => 0,\n" +
                        "		c_cnt_ph_mux_prst10 => 0,\n" +
                        "		c_cnt_ph_mux_prst11 => 0,\n" +
                        "		c_cnt_ph_mux_prst12 => 0,\n" +
                        "		c_cnt_ph_mux_prst13 => 0,\n" +
                        "		c_cnt_ph_mux_prst14 => 0,\n" +
                        "		c_cnt_ph_mux_prst15 => 0,\n" +
                        "		c_cnt_ph_mux_prst16 => 0,\n" +
                        "		c_cnt_ph_mux_prst17 => 0,\n" +
                        "		c_cnt_ph_mux_prst2 => 0,\n" +
                        "		c_cnt_ph_mux_prst3 => 0,\n" +
                        "		c_cnt_ph_mux_prst4 => 0,\n" +
                        "		c_cnt_ph_mux_prst5 => 0,\n" +
                        "		c_cnt_ph_mux_prst6 => 0,\n" +
                        "		c_cnt_ph_mux_prst7 => 0,\n" +
                        "		c_cnt_ph_mux_prst8 => 0,\n" +
                        "		c_cnt_ph_mux_prst9 => 0,\n" +
                        "		c_cnt_prst0 => 1,\n" +
                        "		c_cnt_prst1 => 1,\n" +
                        "		c_cnt_prst10 => 1,\n" +
                        "		c_cnt_prst11 => 1,\n" +
                        "		c_cnt_prst12 => 1,\n" +
                        "		c_cnt_prst13 => 1,\n" +
                        "		c_cnt_prst14 => 1,\n" +
                        "		c_cnt_prst15 => 1,\n" +
                        "		c_cnt_prst16 => 1,\n" +
                        "		c_cnt_prst17 => 1,\n" +
                        "		c_cnt_prst2 => 1,\n" +
                        "		c_cnt_prst3 => 1,\n" +
                        "		c_cnt_prst4 => 1,\n" +
                        "		c_cnt_prst5 => 1,\n" +
                        "		c_cnt_prst6 => 1,\n" +
                        "		c_cnt_prst7 => 1,\n" +
                        "		c_cnt_prst8 => 1,\n" +
                        "		c_cnt_prst9 => 1,\n" +
                        "		clock_name_0 => \"UNUSED\",\n" +
                        "		clock_name_1 => \"UNUSED\",\n" +
                        "		clock_name_2 => \"UNUSED\",\n" +
                        "		clock_name_3 => \"UNUSED\",\n" +
                        "		clock_name_4 => \"UNUSED\",\n" +
                        "		clock_name_5 => \"UNUSED\",\n" +
                        "		clock_name_6 => \"UNUSED\",\n" +
                        "		clock_name_7 => \"UNUSED\",\n" +
                        "		clock_name_8 => \"UNUSED\",\n" +
                        "		clock_name_global_0 => \"false\",\n" +
                        "		clock_name_global_1 => \"false\",\n" +
                        "		clock_name_global_2 => \"false\",\n" +
                        "		clock_name_global_3 => \"false\",\n" +
                        "		clock_name_global_4 => \"false\",\n" +
                        "		clock_name_global_5 => \"false\",\n" +
                        "		clock_name_global_6 => \"false\",\n" +
                        "		clock_name_global_7 => \"false\",\n" +
                        "		clock_name_global_8 => \"false\",\n" +
                        "		data_rate => 0,\n" +
                        "		deserialization_factor => 4,\n" +
                        "		duty_cycle0 => 50,\n" +
                        "		duty_cycle1 => 50,\n" +
                        "		duty_cycle10 => 50,\n" +
                        "		duty_cycle11 => 50,\n" +
                        "		duty_cycle12 => 50,\n" +
                        "		duty_cycle13 => 50,\n" +
                        "		duty_cycle14 => 50,\n" +
                        "		duty_cycle15 => 50,\n" +
                        "		duty_cycle16 => 50,\n" +
                        "		duty_cycle17 => 50,\n" +
                        "		duty_cycle2 => 50,\n" +
                        "		duty_cycle3 => 50,\n" +
                        "		duty_cycle4 => 50,\n" +
                        "		duty_cycle5 => 50,\n" +
                        "		duty_cycle6 => 50,\n" +
                        "		duty_cycle7 => 50,\n" +
                        "		duty_cycle8 => 50,\n" +
                        "		duty_cycle9 => 50,\n" +
                        "		fractional_vco_multiplier => \"false\",\n" +
                        "		m_cnt_bypass_en => \"false\",\n" +
                        "		m_cnt_hi_div => 1,\n" +
                        "		m_cnt_lo_div => 1,\n" +
                        "		m_cnt_odd_div_duty_en => \"false\",\n" +
                        "		mimic_fbclk_type => \"gclk\",\n" +
                        "		n_cnt_bypass_en => \"false\",\n" +
                        "		n_cnt_hi_div => 1,\n" +
                        "		n_cnt_lo_div => 1,\n" +
                        "		n_cnt_odd_div_duty_en => \"false\",\n" +
                        "		number_of_clocks => 2,\n" +
                        "		operation_mode => \"direct\",\n" +
                        "		output_clock_frequency0 => \"75.000000 MHz\",\n" +
                        "		output_clock_frequency1 => \"50.000000 MHz\",\n" +
                        "		output_clock_frequency10 => \"0 MHz\",\n" +
                        "		output_clock_frequency11 => \"0 MHz\",\n" +
                        "		output_clock_frequency12 => \"0 MHz\",\n" +
                        "		output_clock_frequency13 => \"0 MHz\",\n" +
                        "		output_clock_frequency14 => \"0 MHz\",\n" +
                        "		output_clock_frequency15 => \"0 MHz\",\n" +
                        "		output_clock_frequency16 => \"0 MHz\",\n" +
                        "		output_clock_frequency17 => \"0 MHz\",\n" +
                        "		output_clock_frequency2 => \"0 MHz\",\n" +
                        "		output_clock_frequency3 => \"0 MHz\",\n" +
                        "		output_clock_frequency4 => \"0 MHz\",\n" +
                        "		output_clock_frequency5 => \"0 MHz\",\n" +
                        "		output_clock_frequency6 => \"0 MHz\",\n" +
                        "		output_clock_frequency7 => \"0 MHz\",\n" +
                        "		output_clock_frequency8 => \"0 MHz\",\n" +
                        "		output_clock_frequency9 => \"0 MHz\",\n" +
                        "		phase_shift0 => \"0 ps\",\n" +
                        "		phase_shift1 => \"0 ps\",\n" +
                        "		phase_shift10 => \"0 ps\",\n" +
                        "		phase_shift11 => \"0 ps\",\n" +
                        "		phase_shift12 => \"0 ps\",\n" +
                        "		phase_shift13 => \"0 ps\",\n" +
                        "		phase_shift14 => \"0 ps\",\n" +
                        "		phase_shift15 => \"0 ps\",\n" +
                        "		phase_shift16 => \"0 ps\",\n" +
                        "		phase_shift17 => \"0 ps\",\n" +
                        "		phase_shift2 => \"0 ps\",\n" +
                        "		phase_shift3 => \"0 ps\",\n" +
                        "		phase_shift4 => \"0 ps\",\n" +
                        "		phase_shift5 => \"0 ps\",\n" +
                        "		phase_shift6 => \"0 ps\",\n" +
                        "		phase_shift7 => \"0 ps\",\n" +
                        "		phase_shift8 => \"0 ps\",\n" +
                        "		phase_shift9 => \"0 ps\",\n" +
                        "		pll_auto_clk_sw_en => \"false\",\n" +
                        "		pll_bw_sel => \"low\",\n" +
                        "		pll_bwctrl => 0,\n" +
                        "		pll_clk_loss_sw_en => \"false\",\n" +
                        "		pll_clk_sw_dly => 0,\n" +
                        "		pll_clkin_0_src => \"clk_0\",\n" +
                        "		pll_clkin_1_src => \"clk_0\",\n" +
                        "		pll_cp_current => 0,\n" +
                        "		pll_dsm_out_sel => \"1st_order\",\n" +
                        "		pll_extclk_0_cnt_src => \"pll_extclk_cnt_src_vss\",\n" +
                        "		pll_extclk_1_cnt_src => \"pll_extclk_cnt_src_vss\",\n" +
                        "		pll_fbclk_mux_1 => \"glb\",\n" +
                        "		pll_fbclk_mux_2 => \"fb_1\",\n" +
                        "		pll_fractional_cout => 24,\n" +
                        "		pll_fractional_division => 1,\n" +
                        "		pll_m_cnt_in_src => \"ph_mux_clk\",\n" +
                        "		pll_manu_clk_sw_en => \"false\",\n" +
                        "		pll_output_clk_frequency => \"0 MHz\",\n" +
                        "		pll_slf_rst => \"false\",\n" +
                        "		pll_subtype => \"General\",\n" +
                        "		pll_type => \"General\",\n" +
                        "		pll_vco_div => 1,\n" +
                        "		pll_vcoph_div => 1,\n" +
                        "		refclk1_frequency => \"0 MHz\",\n" +
                        "		reference_clock_frequency => \"100.0 MHz\",\n" +
                        "		sim_additional_refclk_cycles_to_lock => 0\n" +
                        "	  )\n" +
                        "	  PORT MAP ( \n" +
                        "		fbclk => wire_gnd,\n" +
                        "		locked => wire_clock_generator_altera_pll_altera_pll_i_1098_locked,\n" +
                        "		outclk => wire_clock_generator_altera_pll_altera_pll_i_1098_outclk,\n" +
                        "		refclk => refclk,\n" +
                        "		rst => rst\n" +
                        "	  );\n" +
                        "\n" +
                        " END RTL; --clock_generator\n" +
                        "--synopsys translate_on\n" +
                        "--VALID FILE";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_test_vhd_file(String Project_Folder_File) {
        String data =   "";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
}
