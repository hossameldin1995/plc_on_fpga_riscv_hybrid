/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package rv_fpga_plc_ide.helper.RV64.Write_Generated_Files;

import java.io.File;
import rv_fpga_plc_ide.helper.Data;
import rv_fpga_plc_ide.helper.GeneralFunctions;

/**
 *
 * @author hossameldin
 */
public class Write_Hardware_Files {
    public void generate_q_files(String Project_Folder) {
        generate_q_subfolders(Project_Folder+"rtl/");
        
        generate_project_files(Project_Folder);
        generate_top_level_files(Project_Folder);
        generate_ambalib_files(Project_Folder+"rtl/ambalib/");
        generate_commonlib_files(Project_Folder+"rtl/commonlib/");
        generate_misclib_files(Project_Folder+"rtl/misclib/");
        generate_funcblocklib_files(Project_Folder+"rtl/funcblocklib/");
        generate_techmap_files(Project_Folder+"rtl/techmap/");
        generate_riverlib_files(Project_Folder+"rtl/riverlib/");
        generate_arithlib_files(Project_Folder+"rtl/arithlib/");
    }
    
    private void generate_q_subfolders(String Project_Folder) {
        File file;
        file = new File(Project_Folder+"ambalib"); file.mkdirs();
        
        file = new File(Project_Folder+"arithlib"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/MUL"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/DIV"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/FP_ADD_32"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/FP_ADD_32/FP_ADD_32"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/FP_ADD_32/FP_ADD_32_sim"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/FP_ADD_SUB_64"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/FP_ADD_SUB_64/FP_ADD_SUB_64"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/FP_ADD_SUB_64/FP_ADD_SUB_64_sim"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/FP_EQ_64"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/FP_EQ_64/FP_EQ_64"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/FP_EQ_64/FP_EQ_64_sim"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/FP_LE_64"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/FP_LE_64/FP_LE_64"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/FP_LE_64/FP_LE_64_sim"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/FP_LT_64"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/FP_LT_64/FP_LT_64"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/FP_LT_64/FP_LT_64_sim"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/FP_MAX_64"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/FP_MAX_64/FP_MAX_64"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/FP_MAX_64/FP_MAX_64_sim"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/FP_MUL_32"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/FP_MUL_32/FP_MUL_32"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/FP_MUL_32/FP_MUL_32_sim"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/FP_MUL_64"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/FP_MUL_64/FP_MUL_64"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/FP_MUL_64/FP_MUL_64_sim"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/FP_SUB_32"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/FP_SUB_32/FP_SUB_32"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/FP_SUB_32/FP_SUB_32_sim"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/FP_S2D"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/FP_S2D/FP_S2D"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/FP_S2D/FP_S2D_sim"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/FP_D2S"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/FP_D2S/FP_D2S"); file.mkdirs();
        file = new File(Project_Folder+"arithlib/FP_D2S/FP_D2S_sim"); file.mkdirs();
        
        
        file = new File(Project_Folder+"commonlib"); file.mkdirs();
        
        file = new File(Project_Folder+"funcblocklib"); file.mkdirs();
        file = new File(Project_Folder+"funcblocklib/time_measurement"); file.mkdirs();
        file = new File(Project_Folder+"funcblocklib/TON"); file.mkdirs();
        file = new File(Project_Folder+"funcblocklib/PWM"); file.mkdirs();
        file = new File(Project_Folder+"funcblocklib/PWM/CDC"); file.mkdirs();
        file = new File(Project_Folder+"funcblocklib/PID"); file.mkdirs();
        
        file = new File(Project_Folder+"misclib"); file.mkdirs();
        
        file = new File(Project_Folder+"riverlib/"); file.mkdirs();
        file = new File(Project_Folder+"riverlib/cache"); file.mkdirs();
        file = new File(Project_Folder+"riverlib/core"); file.mkdirs();
        file = new File(Project_Folder+"riverlib/core/arith"); file.mkdirs();
        file = new File(Project_Folder+"riverlib/core/fpu_d"); file.mkdirs();
        
        file = new File(Project_Folder+"techmap"); file.mkdirs();
        file = new File(Project_Folder+"techmap/gencomp"); file.mkdirs();
        file = new File(Project_Folder+"techmap/mem"); file.mkdirs();
        file = new File(Project_Folder+"techmap/pll"); file.mkdirs();
        file = new File(Project_Folder+"techmap/pll/SysPLL_c5g"); file.mkdirs();
        file = new File(Project_Folder+"techmap/pll/SysPLL_c5g/SysPLL_c5g"); file.mkdirs();
        file = new File(Project_Folder+"techmap/pll/SysPLL_c5g/SysPLL_c5g_sim"); file.mkdirs();
        
        file = new File(Project_Folder+"work"); file.mkdirs();
    }
    
    private void generate_project_files(String Project_Folder_File) {
        generate_River_SoC_qpf_file(Project_Folder_File+"River_SoC.qpf");
        generate_River_SoC_qsf_file(Project_Folder_File+"River_SoC.qsf");
        generate_River_SoC_sdc_file(Project_Folder_File+"River_SoC.SDC");
    }
    
    private void generate_top_level_files(String Project_Folder_File) {
        generate_RV_FPGA_PLC_River_vhd_file(Project_Folder_File+"RV_FPGA_PLC_River.vhd");
        generate_riscv_soc_vhd_file(Project_Folder_File+"rtl/work/riscv_soc.vhd");
        generate_config_c5g_vhd_file(Project_Folder_File+"config_c5g.vhd");
    }
    
    private void generate_ambalib_files(String Project_Folder_File) {
        generate_axictrl_bus0_vhd_file(Project_Folder_File+"axictrl_bus0.vhd");
        generate_axislv_vhd_file(Project_Folder_File+"axislv.vhd");
        generate_defslv_vhd_file(Project_Folder_File+"defslv.vhd");
        generate_types_amba4_vhd_file(Project_Folder_File+"types_amba4.vhd");
        generate_types_bus0_vhd_file(Project_Folder_File+"types_bus0.vhd");
    }
    
    private void generate_commonlib_files(String Project_Folder_File) {
        generate_types_common_vhd_file(Project_Folder_File+"types_common.vhd");
        generate_types_util_vhd_file(Project_Folder_File+"types_util.vhd");
    }
    
    private void generate_misclib_files(String Project_Folder_File) {
        generate_types_misc_vhd_file(Project_Folder_File+"types_misc.vhd");
        generate_reset_glb_vhd_file(Project_Folder_File+"reset_glb.vhd");
        generate_axi4_uart_vhd_file(Project_Folder_File+"axi4_uart.vhd");
        generate_axi4_sram_vhd_file(Project_Folder_File+"axi4_sram.vhd");
        generate_axi4_rom_vhd_file(Project_Folder_File+"axi4_rom.vhd");
        generate_axi4_irqctrl_vhd_file(Project_Folder_File+"axi4_irqctrl.vhd");
        generate_axi4_gptimers_vhd_file(Project_Folder_File+"axi4_gptimers.vhd");
        generate_axi4_gpio_vhd_file(Project_Folder_File+"axi4_gpio.vhd");
        generate_axi4_time_measurement_vhd_file(Project_Folder_File+"axi4_time_measurement.vhd");
        generate_axi4_ton_vhd_file(Project_Folder_File+"axi4_ton.vhd");
        generate_axi4_pwm_vhd_file(Project_Folder_File+"axi4_pwm.vhd");
        generate_axi4_pid_vhd_file(Project_Folder_File+"axi4_pid.vhd");
    }
    
    private void generate_funcblocklib_files(String Project_Folder_File) {
        generate_Counter_Down_64_bit_Cin_vhd_file(Project_Folder_File+"TON/Counter_Down_64_bit_Cin.vhd");
        
        generate_PID_Top_vhd_file(Project_Folder_File+"PID/PID_Top.vhd");
        
        generate_PWM_32_bit_vhd_file(Project_Folder_File+"PWM/PWM_32_bit.vhd");
        generate_PWM_Signal_vhd_file(Project_Folder_File+"PWM/PWM_Signal.vhd");
        generate_CDC_Frq_vhd_file(Project_Folder_File+"PWM/CDC/CDC_Frq.vhd");
        generate_CDC_Frq_qip_file(Project_Folder_File+"PWM/CDC/CDC_Frq.qip");
        generate_CDC_DC_vhd_file(Project_Folder_File+"PWM/CDC/CDC_DC.vhd");
        generate_CDC_DC_qip_file(Project_Folder_File+"PWM/CDC/CDC_DC.qip");
        generate_CDC_Q_vhd_file(Project_Folder_File+"PWM/CDC/CDC_Q.vhd");
        generate_CDC_Q_qip_file(Project_Folder_File+"PWM/CDC/CDC_Q.qip");
        
        generate_Time_Calculation_vhd_file(Project_Folder_File+"time_measurement/Time_Calculation.vhd");
        generate_Write_To_Hexa_vhd_file(Project_Folder_File+"time_measurement/Write_To_Hexa.vhd");
        generate_SEG7_LUT_4_v_file(Project_Folder_File+"time_measurement/SEG7_LUT_4.v");
        generate_SEG7_LUT_v_file(Project_Folder_File+"time_measurement/SEG7_LUT.v");
    }
    
    private void generate_techmap_files(String Project_Folder_File) {
        generate_gencomp_vhd_file(Project_Folder_File+"gencomp/gencomp.vhd");
        
        generate_types_mem_vhd_file(Project_Folder_File+"mem/types_mem.vhd");
        generate_rom_tech_vhd_file(Project_Folder_File+"mem/rom_tech.vhd");
        generate_ram_tech_vhd_file(Project_Folder_File+"mem/ram_tech.vhd");
        generate_dpram_tech_vhd_file(Project_Folder_File+"mem/dpram_tech.vhd");
        generate_rom_c5g_vhd_file(Project_Folder_File+"mem/rom_c5g.vhd");
        generate_dpram_inferred_tech_vhd_file(Project_Folder_File+"mem/dpram_inferred.vhd");
        generate_srambytes_tech_vhd_file(Project_Folder_File+"mem/srambytes_tech.vhd");
        generate_sram8_inferred_vhd_file(Project_Folder_File+"mem/sram8_inferred.vhd");
        generate_sram8_inferred_init_vhd_file(Project_Folder_File+"mem/sram8_inferred_init.vhd");
        generate_ram_inferred_vhd_file(Project_Folder_File+"mem/ram_inferred.vhd");
        
        generate_SysPLL_inferred_vhd_file(Project_Folder_File+"pll/SysPLL_inferred.vhd");
        generate_SysPLL_tech_vhd_file(Project_Folder_File+"pll/SysPLL_tech.vhd");
        generate_types_pll_vhd_file(Project_Folder_File+"pll/types_pll.vhd");
        generate_SysPLL_c5g_qip_file(Project_Folder_File+"pll/SysPLL_c5g/SysPLL_c5g.qip");
        generate_SysPLL_c5g_sip_file(Project_Folder_File+"pll/SysPLL_c5g/SysPLL_c5g.sip");
        generate_SysPLL_c5g_spd_file(Project_Folder_File+"pll/SysPLL_c5g/SysPLL_c5g.spd");
        generate_SysPLL_c5g_vhd_file(Project_Folder_File+"pll/SysPLL_c5g/SysPLL_c5g.vhd");
        generate_SysPLL_c5g_0002_qip_file(Project_Folder_File+"pll/SysPLL_c5g/SysPLL_c5g/SysPLL_c5g_0002.qip");
        generate_SysPLL_c5g_0002_v_file(Project_Folder_File+"pll/SysPLL_c5g/SysPLL_c5g/SysPLL_c5g_0002.v");
        generate_SysPLL_c5g_vho_file(Project_Folder_File+"pll/SysPLL_c5g/SysPLL_c5g_sim/SysPLL_c5g.vho");
    }
    
    private void generate_riverlib_files(String Project_Folder_File) {
        generate_types_river_vhd_file(Project_Folder_File+"types_river.vhd");
        generate_river_top_vhd_file(Project_Folder_File+"river_top.vhd");
        generate_river_cfg_vhd_file(Project_Folder_File+"river_cfg.vhd");
        generate_river_amba_vhd_file(Project_Folder_File+"river_amba.vhd");
        
        generate_types_cache_vhd_file(Project_Folder_File+"cache/types_cache.vhd");
        generate_iwaymem_vhd_file(Project_Folder_File+"cache/iwaymem.vhd");
        generate_ilru_vhd_file(Project_Folder_File+"cache/ilru.vhd");
        generate_icache_lru_vhd_file(Project_Folder_File+"cache/icache_lru.vhd");
        generate_icache_vhd_file(Project_Folder_File+"cache/icache.vhd");
        generate_dcache_vhd_file(Project_Folder_File+"cache/dcache.vhd");
        generate_cache_top_vhd_file(Project_Folder_File+"cache/cache_top.vhd");
        
        generate_stacktrbuf_vhd_file(Project_Folder_File+"core/stacktrbuf.vhd");
        generate_regibank_vhd_file(Project_Folder_File+"core/regibank.vhd");
        generate_regfbank_vhd_file(Project_Folder_File+"core/regfbank.vhd");
        generate_proc_vhd_file(Project_Folder_File+"core/proc.vhd");
        generate_memaccess_vhd_file(Project_Folder_File+"core/memaccess.vhd");
        generate_fetch_vhd_file(Project_Folder_File+"core/fetch.vhd");
        generate_execute_vhd_file(Project_Folder_File+"core/execute.vhd");
        generate_decoder_vhd_file(Project_Folder_File+"core/decoder.vhd");
        generate_dbg_port_vhd_file(Project_Folder_File+"core/dbg_port.vhd");
        generate_csr_vhd_file(Project_Folder_File+"core/csr.vhd");
        generate_bp_predic_vhd_file(Project_Folder_File+"core/bp_predic.vhd");
        
        generate_l2d_d_vhd_file(Project_Folder_File+"core/fpu_d/l2d_d.vhd");
        generate_idiv53_vhd_file(Project_Folder_File+"core/fpu_d/idiv53.vhd");
        generate_fpu_top_vhd_file(Project_Folder_File+"core/fpu_d/fpu_top.vhd");
        generate_fmul_d_vhd_file(Project_Folder_File+"core/fpu_d/fmul_d.vhd");
        generate_fdiv_d_vhd_file(Project_Folder_File+"core/fpu_d/fdiv_d.vhd");
        generate_fadd_d_vhd_file(Project_Folder_File+"core/fpu_d/fadd_d.vhd");
        generate_divstage53_vhd_file(Project_Folder_File+"core/fpu_d/divstage53.vhd");
        generate_d2l_d_vhd_file(Project_Folder_File+"core/fpu_d/d2l_d.vhd");
        generate_d2s_d_vhd_file(Project_Folder_File+"core/fpu_d/d2s_d.vhd");
        generate_s2d_d_vhd_file(Project_Folder_File+"core/fpu_d/s2d_d.vhd");
        
        generate_shift_vhd_file(Project_Folder_File+"core/arith/shift.vhd");
        generate_int_div_vhd_file(Project_Folder_File+"core/arith/int_div.vhd");
        generate_int_mul_cyclone_v_vhd_file(Project_Folder_File+"core/arith/int_mul_cyclone_v.vhd");
        generate_divstage64_vhd_file(Project_Folder_File+"core/arith/divstage64.vhd");
    }
    
    private void generate_arithlib_files(String Project_Folder_File) {
        generate_mul_int_64_vhd_file(Project_Folder_File+"MUL/mul_int_64.vhd");
        generate_mul_int_64_qip_file(Project_Folder_File+"MUL/mul_int_64.qip");
        generate_mul_int_20_7_vhd_file(Project_Folder_File+"MUL/mul_int_20_7.vhd");
        generate_mul_int_20_7_qip_file(Project_Folder_File+"MUL/mul_int_20_7.qip");
        
        generate_div_int_20_7_speed_vhd_file(Project_Folder_File+"DIV/div_int_20_7_speed.vhd");
        generate_div_int_20_7_speed_qip_file(Project_Folder_File+"DIV/div_int_20_7_speed.qip");
        generate_div_int_20_17_speed_vhd_file(Project_Folder_File+"DIV/div_int_20_17_speed.vhd");
        generate_div_int_20_17_speed_qip_file(Project_Folder_File+"DIV/div_int_20_17_speed.qip");
        
        generate_FP_ADD_SUB_64_qip_file(Project_Folder_File+"FP_ADD_SUB_64/FP_ADD_SUB_64.qip");
        generate_FP_ADD_SUB_64_sip_file(Project_Folder_File+"FP_ADD_SUB_64/FP_ADD_SUB_64.sip");
        generate_FP_ADD_SUB_64_vhd_file(Project_Folder_File+"FP_ADD_SUB_64/FP_ADD_SUB_64.vhd");
        generate_FP_ADD_SUB_64_0002_64_vhd_file(Project_Folder_File+"FP_ADD_SUB_64/FP_ADD_SUB_64/FP_ADD_SUB_64_0002.vhd");
        generate_dspba_library_vhd_file(Project_Folder_File+"FP_ADD_SUB_64/FP_ADD_SUB_64/dspba_library.vhd");
        generate_dspba_library_package_vhd_file(Project_Folder_File+"FP_ADD_SUB_64/FP_ADD_SUB_64/dspba_library_package.vhd");
        
        generate_FP_EQ_64_qip_file(Project_Folder_File+"FP_EQ_64/FP_EQ_64.qip");
        generate_FP_EQ_64_sip_file(Project_Folder_File+"FP_EQ_64/FP_EQ_64.sip");
        generate_FP_EQ_64_vhd_file(Project_Folder_File+"FP_EQ_64/FP_EQ_64.vhd");
        generate_FP_EQ_64_0002_vhd_file(Project_Folder_File+"FP_EQ_64/FP_EQ_64/FP_EQ_64_0002.vhd");
        generate_dspba_library_vhd_file(Project_Folder_File+"FP_EQ_64/FP_EQ_64/dspba_library.vhd");
        generate_dspba_library_package_vhd_file(Project_Folder_File+"FP_EQ_64/FP_EQ_64/dspba_library_package.vhd");
        
        generate_FP_LE_64_qip_file(Project_Folder_File+"FP_LE_64/FP_LE_64.qip");
        generate_FP_LE_64_sip_file(Project_Folder_File+"FP_LE_64/FP_LE_64.sip");
        generate_FP_LE_64_vhd_file(Project_Folder_File+"FP_LE_64/FP_LE_64.vhd");
        generate_FP_LE_64_0002_vhd_file(Project_Folder_File+"FP_LE_64/FP_LE_64/FP_LE_64_0002.vhd");
        generate_dspba_library_vhd_file(Project_Folder_File+"FP_LE_64/FP_LE_64/dspba_library.vhd");
        generate_dspba_library_package_vhd_file(Project_Folder_File+"FP_LE_64/FP_LE_64/dspba_library_package.vhd");
        
        generate_FP_LT_64_qip_file(Project_Folder_File+"FP_LT_64/FP_LT_64.qip");
        generate_FP_LT_64_sip_file(Project_Folder_File+"FP_LT_64/FP_LT_64.sip");
        generate_FP_LT_64_vhd_file(Project_Folder_File+"FP_LT_64/FP_LT_64.vhd");
        generate_FP_LT_64_0002_vhd_file(Project_Folder_File+"FP_LT_64/FP_LT_64/FP_LT_64_0002.vhd");
        generate_dspba_library_vhd_file(Project_Folder_File+"FP_LT_64/FP_LT_64/dspba_library.vhd");
        generate_dspba_library_package_vhd_file(Project_Folder_File+"FP_LT_64/FP_LT_64/dspba_library_package.vhd");
        
        generate_FP_MAX_64_qip_file(Project_Folder_File+"FP_MAX_64/FP_MAX_64.qip");
        generate_FP_MAX_64_sip_file(Project_Folder_File+"FP_MAX_64/FP_MAX_64.sip");
        generate_FP_MAX_64_vhd_file(Project_Folder_File+"FP_MAX_64/FP_MAX_64.vhd");
        generate_FP_MAX_64_0002_vhd_file(Project_Folder_File+"FP_MAX_64/FP_MAX_64/FP_MAX_64_0002.vhd");
        generate_dspba_library_vhd_file(Project_Folder_File+"FP_MAX_64/FP_MAX_64/dspba_library.vhd");
        generate_dspba_library_package_vhd_file(Project_Folder_File+"FP_MAX_64/FP_MAX_64/dspba_library_package.vhd");
        
        generate_FP_MUL_64_qip_file(Project_Folder_File+"FP_MUL_64/FP_MUL_64.qip");
        generate_FP_MUL_64_sip_file(Project_Folder_File+"FP_MUL_64/FP_MUL_64.sip");
        generate_FP_MUL_64_vhd_file(Project_Folder_File+"FP_MUL_64/FP_MUL_64.vhd");
        generate_FP_MUL_64_0002_vhd_file(Project_Folder_File+"FP_MUL_64/FP_MUL_64/FP_MUL_64_0002.vhd");
        generate_dspba_library_vhd_file(Project_Folder_File+"FP_MUL_64/FP_MUL_64/dspba_library.vhd");
        generate_dspba_library_package_vhd_file(Project_Folder_File+"FP_MUL_64/FP_MUL_64/dspba_library_package.vhd");
        
        generate_FP_ADD_32_qip_file(Project_Folder_File+"FP_ADD_32/FP_ADD_32.qip");
        generate_FP_ADD_32_sip_file(Project_Folder_File+"FP_ADD_32/FP_ADD_32.sip");
        generate_FP_ADD_32_vhd_file(Project_Folder_File+"FP_ADD_32/FP_ADD_32.vhd");
        generate_FP_ADD_32_0002_vhd_file(Project_Folder_File+"FP_ADD_32/FP_ADD_32/FP_ADD_32_0002.vhd");
        generate_dspba_library_vhd_file(Project_Folder_File+"FP_ADD_32/FP_ADD_32/dspba_library.vhd");
        generate_dspba_library_package_vhd_file(Project_Folder_File+"FP_ADD_32/FP_ADD_32/dspba_library_package.vhd");
        
        generate_FP_SUB_32_qip_file(Project_Folder_File+"FP_SUB_32/FP_SUB_32.qip");
        generate_FP_SUB_32_sip_file(Project_Folder_File+"FP_SUB_32/FP_SUB_32.sip");
        generate_FP_SUB_32_vhd_file(Project_Folder_File+"FP_SUB_32/FP_SUB_32.vhd");
        generate_FP_SUB_32_0002_vhd_file(Project_Folder_File+"FP_SUB_32/FP_SUB_32/FP_SUB_32_0002.vhd");
        generate_dspba_library_vhd_file(Project_Folder_File+"FP_SUB_32/FP_SUB_32/dspba_library.vhd");
        generate_dspba_library_package_vhd_file(Project_Folder_File+"FP_SUB_32/FP_SUB_32/dspba_library_package.vhd");
        
        generate_FP_MUL_32_qip_file(Project_Folder_File+"FP_MUL_32/FP_MUL_32.qip");
        generate_FP_MUL_32_sip_file(Project_Folder_File+"FP_MUL_32/FP_MUL_32.sip");
        generate_FP_MUL_32_vhd_file(Project_Folder_File+"FP_MUL_32/FP_MUL_32.vhd");
        generate_FP_MUL_32_0002_vhd_file(Project_Folder_File+"FP_MUL_32/FP_MUL_32/FP_MUL_32_0002.vhd");
        generate_dspba_library_vhd_file(Project_Folder_File+"FP_MUL_32/FP_MUL_32/dspba_library.vhd");
        generate_dspba_library_package_vhd_file(Project_Folder_File+"FP_MUL_32/FP_MUL_32/dspba_library_package.vhd");
        
        generate_FP_S2D_qip_file(Project_Folder_File+"FP_S2D/FP_S2D.qip");
        generate_FP_S2D_sip_file(Project_Folder_File+"FP_S2D/FP_S2D.sip");
        generate_FP_S2D_vhd_file(Project_Folder_File+"FP_S2D/FP_S2D.vhd");
        generate_FP_S2D_0002_vhd_file(Project_Folder_File+"FP_S2D/FP_S2D/FP_S2D_0002.vhd");
        generate_dspba_library_vhd_file(Project_Folder_File+"FP_S2D/FP_S2D/dspba_library.vhd");
        generate_dspba_library_package_vhd_file(Project_Folder_File+"FP_S2D/FP_S2D/dspba_library_package.vhd");
        
        generate_FP_D2S_qip_file(Project_Folder_File+"FP_D2S/FP_D2S.qip");
        generate_FP_D2S_sip_file(Project_Folder_File+"FP_D2S/FP_D2S.sip");
        generate_FP_D2S_vhd_file(Project_Folder_File+"FP_D2S/FP_D2S.vhd");
        generate_FP_D2S_0002_vhd_file(Project_Folder_File+"FP_D2S/FP_D2S/FP_D2S_0002.vhd");
        generate_dspba_library_vhd_file(Project_Folder_File+"FP_D2S/FP_D2S/dspba_library.vhd");
        generate_dspba_library_package_vhd_file(Project_Folder_File+"FP_D2S/FP_D2S/dspba_library_package.vhd");
    }
    
    private void generate_River_SoC_qpf_file(String Project_Folder_File) {
        String data =   "# -------------------------------------------------------------------------- #\n" +
                        "#\n" +
                        "# Copyright (C) 2018  Intel Corporation. All rights reserved.\n" +
                        "# Your use of Intel Corporation's design tools, logic functions \n" +
                        "# and other software and tools, and its AMPP partner logic \n" +
                        "# functions, and any output files from any of the foregoing \n" +
                        "# (including device programming or simulation files), and any \n" +
                        "# associated documentation or information are expressly subject \n" +
                        "# to the terms and conditions of the Intel Program License \n" +
                        "# Subscription Agreement, the Intel Quartus Prime License Agreement,\n" +
                        "# the Intel FPGA IP License Agreement, or other applicable license\n" +
                        "# agreement, including, without limitation, that your use is for\n" +
                        "# the sole purpose of programming logic devices manufactured by\n" +
                        "# Intel and sold by Intel or its authorized distributors.  Please\n" +
                        "# refer to the applicable agreement for further details.\n" +
                        "#\n" +
                        "# -------------------------------------------------------------------------- #\n" +
                        "#\n" +
                        "# Quartus Prime\n" +
                        "# Version 18.0.0 Build 614 04/24/2018 SJ Lite Edition\n" +
                        "# Date created = 18:37:11  September 05, 2019\n" +
                        "#\n" +
                        "# -------------------------------------------------------------------------- #\n" +
                        "\n" +
                        "QUARTUS_VERSION = \"18.0\"\n" +
                        "DATE = \"18:37:11  September 05, 2019\"\n" +
                        "\n" +
                        "# Revisions\n" +
                        "\n" +
                        "PROJECT_REVISION = \"River_SoC\"";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_River_SoC_qsf_file(String Project_Folder_File) {
        String data =   "#============================================================\n" +
                        "# Build by Terasic System Builder\n" +
                        "#============================================================\n" +
                        "\n" +
                        "set_global_assignment -name FAMILY \"Cyclone V\"\n" +
                        "set_global_assignment -name DEVICE 5CGXFC5C6F27C7\n" +
                        "set_global_assignment -name TOP_LEVEL_ENTITY \"RV_FPGA_PLC_River\"\n" +
                        "set_global_assignment -name ORIGINAL_QUARTUS_VERSION 16.0.2\n" +
                        "set_global_assignment -name LAST_QUARTUS_VERSION \"18.0.0 Lite Edition\"\n" +
                        "set_global_assignment -name PROJECT_CREATION_TIME_DATE \"17:54:50 MAY 02,2020\"\n" +
                        "set_global_assignment -name DEVICE_FILTER_PACKAGE FBGA\n" +
                        "set_global_assignment -name DEVICE_FILTER_PIN_COUNT 896\n" +
                        "set_global_assignment -name DEVICE_FILTER_SPEED_GRADE 6\n" +
                        "\n" +
                        "#============================================================\n" +
                        "# CLOCK\n" +
                        "#============================================================\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to CLOCK_50_B3B\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to CLOCK_50_B5B\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to CLOCK_50_B6A\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to CLOCK_50_B7A\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to CLOCK_50_B8A\n" +
                        "set_instance_assignment -name IO_STANDARD LVDS -to CLOCK_125_p\n" +
                        "set_location_assignment PIN_T13 -to CLOCK_50_B3B\n" +
                        "set_location_assignment PIN_R20 -to CLOCK_50_B5B\n" +
                        "set_location_assignment PIN_N20 -to CLOCK_50_B6A\n" +
                        "set_location_assignment PIN_H12 -to CLOCK_50_B7A\n" +
                        "set_location_assignment PIN_M10 -to CLOCK_50_B8A\n" +
                        "set_location_assignment PIN_U12 -to CLOCK_125_p\n" +
                        "set_location_assignment PIN_V12 -to \"CLOCK_125_p(n)\"\n" +
                        "\n" +
                        "#============================================================\n" +
                        "# KEY\n" +
                        "#============================================================\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to KEY_n[3]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to KEY_n[2]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to KEY_n[1]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to KEY_n[0]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to CPU_RESET_n\n" +
                        "set_location_assignment PIN_P11 -to KEY_n[0]\n" +
                        "set_location_assignment PIN_P12 -to KEY_n[1]\n" +
                        "set_location_assignment PIN_Y15 -to KEY_n[2]\n" +
                        "set_location_assignment PIN_Y16 -to KEY_n[3]\n" +
                        "set_location_assignment PIN_AB24 -to CPU_RESET_n\n" +
                        "\n" +
                        "#============================================================\n" +
                        "# SW\n" +
                        "#============================================================\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to SW[9]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to SW[8]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to SW[7]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to SW[6]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to SW[5]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to SW[4]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to SW[3]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to SW[2]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to SW[1]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to SW[0]\n" +
                        "set_location_assignment PIN_AC9 -to SW[0]\n" +
                        "set_location_assignment PIN_AE10 -to SW[1]\n" +
                        "set_location_assignment PIN_AD13 -to SW[2]\n" +
                        "set_location_assignment PIN_AC8 -to SW[3]\n" +
                        "set_location_assignment PIN_W11 -to SW[4]\n" +
                        "set_location_assignment PIN_AB10 -to SW[5]\n" +
                        "set_location_assignment PIN_V10 -to SW[6]\n" +
                        "set_location_assignment PIN_AC10 -to SW[7]\n" +
                        "set_location_assignment PIN_Y11 -to SW[8]\n" +
                        "set_location_assignment PIN_AE19 -to SW[9]\n" +
                        "\n" +
                        "#============================================================\n" +
                        "# LED\n" +
                        "#============================================================\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDR[9]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDR[8]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDR[7]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDR[6]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDR[5]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDR[4]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDR[3]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDR[2]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDR[1]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDR[0]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDG[7]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDG[6]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDG[5]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDG[4]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDG[3]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDG[2]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDG[1]\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to LEDG[0]\n" +
                        "set_location_assignment PIN_F7 -to LEDR[0]\n" +
                        "set_location_assignment PIN_F6 -to LEDR[1]\n" +
                        "set_location_assignment PIN_G6 -to LEDR[2]\n" +
                        "set_location_assignment PIN_G7 -to LEDR[3]\n" +
                        "set_location_assignment PIN_J8 -to LEDR[4]\n" +
                        "set_location_assignment PIN_J7 -to LEDR[5]\n" +
                        "set_location_assignment PIN_K10 -to LEDR[6]\n" +
                        "set_location_assignment PIN_K8 -to LEDR[7]\n" +
                        "set_location_assignment PIN_H7 -to LEDR[8]\n" +
                        "set_location_assignment PIN_J10 -to LEDR[9]\n" +
                        "set_location_assignment PIN_L7 -to LEDG[0]\n" +
                        "set_location_assignment PIN_K6 -to LEDG[1]\n" +
                        "set_location_assignment PIN_D8 -to LEDG[2]\n" +
                        "set_location_assignment PIN_E9 -to LEDG[3]\n" +
                        "set_location_assignment PIN_A5 -to LEDG[4]\n" +
                        "set_location_assignment PIN_B6 -to LEDG[5]\n" +
                        "set_location_assignment PIN_H8 -to LEDG[6]\n" +
                        "set_location_assignment PIN_H9 -to LEDG[7]\n" +
                        "\n" +
                        "#============================================================\n" +
                        "# Seg7\n" +
                        "#============================================================\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to HEX0[0]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to HEX0[1]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to HEX0[2]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to HEX0[3]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to HEX0[4]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to HEX0[5]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to HEX0[6]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to HEX1[0]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to HEX1[1]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to HEX1[2]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to HEX1[3]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to HEX1[4]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to HEX1[5]\n" +
                        "set_instance_assignment -name IO_STANDARD \"1.2 V\" -to HEX1[6]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to HEX2[0]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to HEX2[1]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to HEX2[2]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to HEX2[3]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to HEX2[4]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to HEX2[5]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to HEX2[6]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to HEX3[0]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to HEX3[1]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to HEX3[2]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to HEX3[3]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to HEX3[4]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to HEX3[5]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to HEX3[6]\n" +
                        "set_location_assignment PIN_V19 -to HEX0[0]\n" +
                        "set_location_assignment PIN_V18 -to HEX0[1]\n" +
                        "set_location_assignment PIN_V17 -to HEX0[2]\n" +
                        "set_location_assignment PIN_W18 -to HEX0[3]\n" +
                        "set_location_assignment PIN_Y20 -to HEX0[4]\n" +
                        "set_location_assignment PIN_Y19 -to HEX0[5]\n" +
                        "set_location_assignment PIN_Y18 -to HEX0[6]\n" +
                        "set_location_assignment PIN_AA18 -to HEX1[0]\n" +
                        "set_location_assignment PIN_AD26 -to HEX1[1]\n" +
                        "set_location_assignment PIN_AB19 -to HEX1[2]\n" +
                        "set_location_assignment PIN_AE26 -to HEX1[3]\n" +
                        "set_location_assignment PIN_AE25 -to HEX1[4]\n" +
                        "set_location_assignment PIN_AC19 -to HEX1[5]\n" +
                        "set_location_assignment PIN_AF24 -to HEX1[6]\n" +
                        "set_location_assignment PIN_AD7 -to HEX2[0]\n" +
                        "set_location_assignment PIN_AD6 -to HEX2[1]\n" +
                        "set_location_assignment PIN_U20 -to HEX2[2]\n" +
                        "set_location_assignment PIN_V22 -to HEX2[3]\n" +
                        "set_location_assignment PIN_V20 -to HEX2[4]\n" +
                        "set_location_assignment PIN_W21 -to HEX2[5]\n" +
                        "set_location_assignment PIN_W20 -to HEX2[6]\n" +
                        "set_location_assignment PIN_Y24 -to HEX3[0]\n" +
                        "set_location_assignment PIN_Y23 -to HEX3[1]\n" +
                        "set_location_assignment PIN_AA23 -to HEX3[2]\n" +
                        "set_location_assignment PIN_AA22 -to HEX3[3]\n" +
                        "set_location_assignment PIN_AC24 -to HEX3[4]\n" +
                        "set_location_assignment PIN_AC23 -to HEX3[5]\n" +
                        "set_location_assignment PIN_AC22 -to HEX3[6]\n" +
                        "\n" +
                        "#============================================================\n" +
                        "# SDRAM\n" +
                        "#============================================================\n" +
                        "\n" +
                        "#============================================================\n" +
                        "# ADC\n" +
                        "#============================================================\n" +
                        "\n" +
                        "#============================================================\n" +
                        "# UART\n" +
                        "#============================================================\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to UART_TX\n" +
                        "set_instance_assignment -name IO_STANDARD \"2.5 V\" -to UART_RX\n" +
                        "set_location_assignment PIN_L9 -to UART_TX\n" +
                        "set_location_assignment PIN_M9 -to UART_RX\n" +
                        "\n" +
                        "#============================================================\n" +
                        "# GPIO, GPIO connect to GPIO Default\n" +
                        "#============================================================\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[0]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[1]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[17]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[16]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[15]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[14]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[13]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[12]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[11]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[10]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[2]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[4]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[3]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[5]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[6]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[7]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[8]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_IN[9]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[1]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[2]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[0]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[3]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[4]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[5]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[6]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[7]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[8]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[9]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[10]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[11]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[12]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[13]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[14]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[15]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[16]\n" +
                        "set_instance_assignment -name IO_STANDARD \"3.3-V LVTTL\" -to GPIO_OUT[17]\n" +
                        "set_location_assignment PIN_T21 -to GPIO_IN[0]\n" +
                        "set_location_assignment PIN_D26 -to GPIO_IN[1]\n" +
                        "set_location_assignment PIN_Y9 -to GPIO_IN[17]\n" +
                        "set_location_assignment PIN_F26 -to GPIO_IN[16]\n" +
                        "set_location_assignment PIN_R10 -to GPIO_IN[15]\n" +
                        "set_location_assignment PIN_R9 -to GPIO_IN[14]\n" +
                        "set_location_assignment PIN_R8 -to GPIO_IN[13]\n" +
                        "set_location_assignment PIN_P8 -to GPIO_IN[12]\n" +
                        "set_location_assignment PIN_U22 -to GPIO_IN[11]\n" +
                        "set_location_assignment PIN_U19 -to GPIO_IN[10]\n" +
                        "set_location_assignment PIN_K25 -to GPIO_IN[2]\n" +
                        "set_location_assignment PIN_K26 -to GPIO_IN[4]\n" +
                        "set_location_assignment PIN_E26 -to GPIO_IN[3]\n" +
                        "set_location_assignment PIN_M26 -to GPIO_IN[5]\n" +
                        "set_location_assignment PIN_M21 -to GPIO_IN[6]\n" +
                        "set_location_assignment PIN_P20 -to GPIO_IN[7]\n" +
                        "set_location_assignment PIN_T22 -to GPIO_IN[8]\n" +
                        "set_location_assignment PIN_T19 -to GPIO_IN[9]\n" +
                        "set_location_assignment PIN_Y8 -to GPIO_OUT[1]\n" +
                        "set_location_assignment PIN_AA7 -to GPIO_OUT[2]\n" +
                        "set_location_assignment PIN_G26 -to GPIO_OUT[0]\n" +
                        "set_location_assignment PIN_AA6 -to GPIO_OUT[3]\n" +
                        "\n" +
                        "#============================================================\n" +
                        "# End of pin assignments by Terasic System Builder\n" +
                        "#============================================================\n" +
                        "\n" +
                        "set_global_assignment -name NUM_PARALLEL_PROCESSORS 4\n" +
                        "set_global_assignment -name FITTER_EFFORT FAST_FIT\n" +
                        "set_global_assignment -name PHYSICAL_SYNTHESIS_EFFORT FAST\n" +
                        "\n" +
                        "set_global_assignment -name PARTITION_NETLIST_TYPE SOURCE -section_id Top\n" +
                        "set_global_assignment -name PROJECT_OUTPUT_DIRECTORY output_files\n" +
                        "set_global_assignment -name PARTITION_FITTER_PRESERVATION_LEVEL PLACEMENT_AND_ROUTING -section_id Top\n" +
                        "set_global_assignment -name PARTITION_COLOR 16764057 -section_id Top\n" +
                        "set_global_assignment -name MIN_CORE_JUNCTION_TEMP 0\n" +
                        "set_global_assignment -name MAX_CORE_JUNCTION_TEMP 85\n" +
                        "set_global_assignment -name POWER_PRESET_COOLING_SOLUTION \"23 MM HEAT SINK WITH 200 LFPM AIRFLOW\"\n" +
                        "set_global_assignment -name POWER_BOARD_THERMAL_MODEL \"NONE (CONSERVATIVE)\"\n" +
                        "\n" +
                        "set_global_assignment -name EDA_SIMULATION_TOOL \"ModelSim-Altera (VHDL)\"\n" +
                        "set_global_assignment -name EDA_OUTPUT_DATA_FORMAT VHDL -section_id eda_simulatio\n" +
                        "\n" +
                        "set_global_assignment -name VERILOG_FILE rtl/funcblocklib/time_measurement/SEG7_LUT.v\n" +
                        "set_global_assignment -name VERILOG_FILE rtl/funcblocklib/time_measurement/SEG7_LUT_4.v\n" +
                        "set_global_assignment -name VHDL_FILE rtl/work/riscv_soc.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/funcblocklib/PID/PID_Top.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/funcblocklib/PWM/PWM_32_bit.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/funcblocklib/PWM/PWM_Signal.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/funcblocklib/time_measurement/Time_Calculation.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/funcblocklib/time_measurement/Write_To_Hexa.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/funcblocklib/TON/Counter_Down_64_bit_Cin.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/misclib/axi4_pid.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/misclib/axi4_pwm.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/misclib/axi4_time_measurement.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/misclib/axi4_ton.vhd\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/cache/iwaymem.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/cache/ilru.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/cache/icache.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/cache/dcache.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/regfbank.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/techmap/mem/rom_c5g.vhd -library techmap\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/cache/types_cache.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/cache/icache_lru.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/cache/cache_top.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/fpu_d/l2d_d.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/fpu_d/idiv53.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/fpu_d/fpu_top.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/fpu_d/fmul_d.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/fpu_d/fdiv_d.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/fpu_d/fadd_d.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/fpu_d/divstage53.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/fpu_d/d2l_d.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/fpu_d/d2s_d.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/fpu_d/s2d_d.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/arith/shift.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/arith/int_mul_cyclone_v.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/arith/int_div.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/arith/divstage64.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/stacktrbuf.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/regibank.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/proc.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/memaccess.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/fetch.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/execute.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/decoder.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/dbg_port.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/csr.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/core/bp_predic.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/misclib/types_misc.vhd -library misclib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/misclib/reset_glb.vhd -library misclib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/misclib/axi4_uart.vhd -library misclib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/misclib/axi4_sram.vhd -library misclib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/misclib/axi4_rom.vhd -library misclib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/misclib/axi4_irqctrl.vhd -library misclib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/misclib/axi4_gptimers.vhd -library misclib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/misclib/axi4_gpio.vhd -library misclib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/techmap/pll/types_pll.vhd -library techmap\n" +
                        "set_global_assignment -name VHDL_FILE rtl/techmap/pll/SysPLL_tech.vhd -library techmap\n" +
                        "set_global_assignment -name VHDL_FILE rtl/techmap/pll/SysPLL_inferred.vhd -library techmap\n" +
                        "set_global_assignment -name VHDL_FILE rtl/techmap/mem/types_mem.vhd -library techmap\n" +
                        "set_global_assignment -name VHDL_FILE rtl/techmap/mem/srambytes_tech.vhd -library techmap\n" +
                        "set_global_assignment -name VHDL_FILE rtl/techmap/mem/sram8_inferred_init.vhd -library techmap\n" +
                        "set_global_assignment -name VHDL_FILE rtl/techmap/mem/sram8_inferred.vhd -library techmap\n" +
                        "set_global_assignment -name VHDL_FILE rtl/techmap/mem/rom_tech.vhd -library techmap\n" +
                        "set_global_assignment -name VHDL_FILE rtl/techmap/mem/ram_tech.vhd -library techmap\n" +
                        "set_global_assignment -name VHDL_FILE rtl/techmap/mem/ram_inferred.vhd -library techmap\n" +
                        "set_global_assignment -name VHDL_FILE rtl/techmap/gencomp/gencomp.vhd -library techmap\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/types_river.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/river_top.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/river_cfg.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/riverlib/river_amba.vhd -library riverlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/commonlib/types_util.vhd -library commonlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/commonlib/types_common.vhd -library commonlib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/ambalib/types_bus0.vhd -library ambalib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/ambalib/types_amba4.vhd -library ambalib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/ambalib/defslv.vhd -library ambalib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/ambalib/axislv.vhd -library ambalib\n" +
                        "set_global_assignment -name VHDL_FILE rtl/ambalib/axictrl_bus0.vhd -library ambalib\n" +
                        "set_global_assignment -name VHDL_FILE config_c5g.vhd -library target\n" +
                        "set_global_assignment -name QIP_FILE rtl/arithlib/FP_EQ_64/FP_EQ_64.qip\n" +
                        "set_global_assignment -name SIP_FILE rtl/arithlib/FP_EQ_64/FP_EQ_64.sip\n" +
                        "set_global_assignment -name QIP_FILE rtl/arithlib/FP_LT_64/FP_LT_64.qip\n" +
                        "set_global_assignment -name SIP_FILE rtl/arithlib/FP_LT_64/FP_LT_64.sip\n" +
                        "set_global_assignment -name QIP_FILE rtl/arithlib/FP_LE_64/FP_LE_64.qip\n" +
                        "set_global_assignment -name SIP_FILE rtl/arithlib/FP_LE_64/FP_LE_64.sip\n" +
                        "set_global_assignment -name QIP_FILE rtl/arithlib/FP_MAX_64/FP_MAX_64.qip\n" +
                        "set_global_assignment -name SIP_FILE rtl/arithlib/FP_MAX_64/FP_MAX_64.sip\n" +
                        "set_global_assignment -name QIP_FILE rtl/arithlib/FP_ADD_SUB_64/FP_ADD_SUB_64.qip\n" +
                        "set_global_assignment -name SIP_FILE rtl/arithlib/FP_ADD_SUB_64/FP_ADD_SUB_64.sip\n" +
                        "set_global_assignment -name QIP_FILE rtl/arithlib/FP_MUL_64/FP_MUL_64.qip\n" +
                        "set_global_assignment -name SIP_FILE rtl/arithlib/FP_MUL_64/FP_MUL_64.sip\n" +
                        "set_global_assignment -name QIP_FILE rtl/techmap/pll/SysPLL_c5g/SysPLL_c5g.qip\n" +
                        "set_global_assignment -name SIP_FILE rtl/techmap/pll/SysPLL_c5g/SysPLL_c5g.sip\n" +
                        "set_global_assignment -name QIP_FILE rtl/arithlib/FP_ADD_32/FP_ADD_32.qip\n" +
                        "set_global_assignment -name SIP_FILE rtl/arithlib/FP_ADD_32/FP_ADD_32.sip\n" +
                        "set_global_assignment -name QIP_FILE rtl/arithlib/FP_MUL_32/FP_MUL_32.qip\n" +
                        "set_global_assignment -name SIP_FILE rtl/arithlib/FP_MUL_32/FP_MUL_32.sip\n" +
                        "set_global_assignment -name QIP_FILE rtl/arithlib/FP_SUB_32/FP_SUB_32.qip\n" +
                        "set_global_assignment -name SIP_FILE rtl/arithlib/FP_SUB_32/FP_SUB_32.sip\n" +
                        "set_global_assignment -name QIP_FILE rtl/arithlib/FP_D2S/FP_D2S.qip\n" +
                        "set_global_assignment -name SIP_FILE rtl/arithlib/FP_D2S/FP_D2S.sip\n" +
                        "set_global_assignment -name QIP_FILE rtl/arithlib/FP_S2D/FP_S2D.qip\n" +
                        "set_global_assignment -name SIP_FILE rtl/arithlib/FP_S2D/FP_S2D.sip\n" +
                        "set_global_assignment -name QIP_FILE rtl/arithlib/MUL/mul_int_20_7.qip\n" +
                        "set_global_assignment -name QIP_FILE rtl/arithlib/DIV/div_int_20_17_speed.qip\n" +
                        "set_global_assignment -name QIP_FILE rtl/arithlib/DIV/div_int_20_7_speed.qip\n" +
                        "set_global_assignment -name QIP_FILE rtl/arithlib/MUL/mul_int_64.qip -library arithlib\n"
                +       "set_global_assignment -name QIP_FILE rtl/funcblocklib/PWM/CDC/CDC_DC.qip\n" +
                        "set_global_assignment -name QIP_FILE rtl/funcblocklib/PWM/CDC/CDC_Q.qip\n" +
                        "set_global_assignment -name QIP_FILE rtl/funcblocklib/PWM/CDC/CDC_Frq.qip\n" +
                        "set_global_assignment -name SDC_FILE River_SoC.SDC\n" +
                        "\n" +
                        "\n" +
                        "set_instance_assignment -name PARTITION_HIERARCHY root_partition -to | -section_id Top";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_River_SoC_sdc_file(String Project_Folder_File) {
        String data =   "#**************************************************************\n" +
                        "# This .sdc file is created by Terasic Tool.\n" +
                        "# Users are recommended to modify this file to match users logic.\n" +
                        "#**************************************************************\n" +
                        "\n" +
                        "#**************************************************************\n" +
                        "# Create Clock\n" +
                        "#**************************************************************\n" +
                        "create_clock -period 8 [get_ports CLOCK_125_p]\n" +
                        "create_clock -period 20 [get_ports CLOCK_50_B5B]\n" +
                        "create_clock -period 20 [get_ports CLOCK_50_B6A]\n" +
                        "create_clock -period 20 [get_ports CLOCK_50_B7A]\n" +
                        "create_clock -period 20 [get_ports CLOCK_50_B8A]\n" +
                        "\n" +
                        "#**************************************************************\n" +
                        "# Create Generated Clock\n" +
                        "#**************************************************************\n" +
                        "derive_pll_clocks -create_base_clocks\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "#**************************************************************\n" +
                        "# Set Clock Latency\n" +
                        "#**************************************************************\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "#**************************************************************\n" +
                        "# Set Clock Uncertainty\n" +
                        "#**************************************************************\n" +
                        "derive_clock_uncertainty\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "#**************************************************************\n" +
                        "# Set Input Delay\n" +
                        "#**************************************************************\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "#**************************************************************\n" +
                        "# Set Output Delay\n" +
                        "#**************************************************************\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "#**************************************************************\n" +
                        "# Set Clock Groups\n" +
                        "#**************************************************************\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "#**************************************************************\n" +
                        "# Set False Path\n" +
                        "#**************************************************************\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "#**************************************************************\n" +
                        "# Set Multicycle Path\n" +
                        "#**************************************************************\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "#**************************************************************\n" +
                        "# Set Maximum Delay\n" +
                        "#**************************************************************\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "#**************************************************************\n" +
                        "# Set Minimum Delay\n" +
                        "#**************************************************************\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "#**************************************************************\n" +
                        "# Set Input Transition\n" +
                        "#**************************************************************\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "#**************************************************************\n" +
                        "# Set Load\n" +
                        "#**************************************************************";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_RV_FPGA_PLC_River_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "--! Standard library\n" +
                        "library IEEE;\n" +
                        "use IEEE.STD_LOGIC_1164.ALL;\n" +
                        "\n" +
                        "--! Technology definition library.\n" +
                        "library techmap;\n" +
                        "--! \"Virtual\" PLL declaration.\n" +
                        "use techmap.types_pll.all;\n" +
                        "\n" +
                        " --! Top-level implementaion library\n" +
                        " library target;\n" +
                        " use target.config_target.all;\n" +
                        "\n" +
                        "entity RV_FPGA_PLC_River is\n" +
                        "port\n" +
                        "(\n" +
                        "\n" +
                        "	--------- CLOCK ---------\n" +
                        "		CLOCK_125_p	: in std_logic;\n" +
                        "		CLOCK_50_B3B: in std_logic;\n" +
                        "		CLOCK_50_B5B: in std_logic;\n" +
                        "		CLOCK_50_B6A: in std_logic;\n" +
                        "		CLOCK_50_B7A: in std_logic;\n" +
                        "		CLOCK_50_B8A: in std_logic;\n" +
                        "		\n" +
                        "		--------- CPU ---------\n" +
                        "		CPU_RESET_n	: in std_logic;\n" +
                        "		\n" +
                        "		--------- GPIO ---------\n" +
                        "		GPIO_IN		: in std_logic_vector(17 DOWNTO 0);\n" +
                        "		GPIO_OUT		: out std_logic_vector(17 DOWNTO 0);\n" +
                        "		\n" +
                        "		--------- HEX0 ---------\n" +
                        "		HEX0			: out std_logic_vector(6 DOWNTO 0);\n" +
                        "\n" +
                        "		--------- HEX1 ---------\n" +
                        "		HEX1			: out std_logic_vector(6 DOWNTO 0);\n" +
                        "		\n" +
                        "		--------- HEX2 ---------\n" +
                        "		HEX2			: out std_logic_vector(6 DOWNTO 0);\n" +
                        "		\n" +
                        "		--------- HEX3 ---------\n" +
                        "		HEX3			: out std_logic_vector(6 DOWNTO 0);\n" +
                        "		\n" +
                        "		--------- KEY ---------\n" +
                        "		KEY_n			: in std_logic_vector(3 DOWNTO 0);\n" +
                        "\n" +
                        "		--------- LEDG ---------\n" +
                        "		LEDG			: out std_logic_vector(7 DOWNTO 0);\n" +
                        "\n" +
                        "		--------- LEDR ---------\n" +
                        "		LEDR			: out std_logic_vector(9 DOWNTO 0);\n" +
                        "		\n" +
                        "		--------- SW ---------\n" +
                        "		SW				: in std_logic_vector(9 DOWNTO 0);\n" +
                        "\n" +
                        "		--------- UART ---------\n" +
                        "		UART_RX		: in std_logic;\n" +
                        "		UART_TX		: out std_logic\n" +
                        ");\n" +
                        "\n" +
                        "end entity;\n" +
                        "\n" +
                        "architecture arch_RV_FPGA_PLC_River of RV_FPGA_PLC_River is\n" +
                        "\n" +
                        "component riscv_soc is port \n" +
                        "( \n" +
                        "  i_rst     : in std_logic;\n" +
                        "  i_clk     : in std_logic;\n" +
                        "  i_clk_pwm : in std_logic;\n" +
                        "  --! UART1 signals:\n" +
                        "  i_uart1_ctsn : in std_logic;\n" +
                        "  i_uart1_rd   : in std_logic;\n" +
                        "  o_uart1_td   : out std_logic;\n" +
                        "  o_uart1_rtsn : out std_logic;\n" +
                        "  --! GPIO\n" +
                        "  KEY				: in std_logic_vector(3 DOWNTO 0);\n" +
                        "  SW				: in std_logic_vector(9 DOWNTO 0);\n" +
                        "  LEDG			: out std_logic_vector(7 DOWNTO 0);\n" +
                        "  LEDR			: out std_logic_vector(9 DOWNTO 0);\n" +
                        "  GPIO_IN		: in std_logic_vector(17 DOWNTO 0);\n" +
                        "  GPIO_OUT		: out std_logic_vector(17 DOWNTO 0);\n" +
                        "  --! Time measurements\n" +
                        "  HEX0			: out std_logic_vector(6 DOWNTO 0);\n" +
                        "  HEX1			: out std_logic_vector(6 DOWNTO 0);\n" +
                        "  HEX2			: out std_logic_vector(6 DOWNTO 0);\n" +
                        "  HEX3			: out std_logic_vector(6 DOWNTO 0)\n" +
                        ");\n" +
                        "end component;\n" +
                        "\n" +
                        "  signal i_rst     : std_logic;\n" +
                        "  signal KEY       : std_logic_vector(3 DOWNTO 0);\n" +
                        "\n" +
                        "  signal w_ext_reset : std_ulogic; -- External system reset or PLL unlcoked. MUST NOT USED BY DEVICES.\n" +
                        "  signal w_clk_bus  : std_ulogic; -- bus clock from the internal PLL (100MHz virtex6/40MHz Spartan6)\n" +
                        "  signal w_clk_pwm : std_ulogic;\n" +
                        "  signal w_pll_lock : std_ulogic; -- PLL status signal. 0=Unlocked; 1=locked.\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  i_rst <= not(CPU_RESET_n);\n" +
                        "  KEY   <= not(KEY_n);\n" +
                        "\n" +
                        "  ------------------------------------\n" +
                        "  -- @brief Internal PLL device instance.\n" +
                        "  pll0 : SysPLL_tech generic map (\n" +
                        "    tech => CFG_FABTECH\n" +
                        "  ) port map (\n" +
                        "    i_reset     => i_rst,\n" +
                        "    i_clk_tcxo	=> CLOCK_125_p,\n" +
                        "    o_clk_bus   => w_clk_bus,\n" +
                        "    o_clk_pwm   => w_clk_pwm,\n" +
                        "    o_locked    => w_pll_lock\n" +
                        "  );\n" +
                        "  w_ext_reset <= i_rst or not w_pll_lock;\n" +
                        "\n" +
                        "\n" +
                        "  soc0 : riscv_soc port map\n" +
                        "  ( \n" +
                        "    i_rst     => w_ext_reset,\n" +
                        "    i_clk     => w_clk_bus,\n" +
                        "    i_clk_pwm => w_clk_pwm,\n" +
                        "    --! UART1 signals:\n" +
                        "    i_uart1_ctsn => '0',\n" +
                        "    i_uart1_rd   => UART_RX,\n" +
                        "    o_uart1_td   => UART_TX,\n" +
                        "    o_uart1_rtsn => open,\n" +
                        "	 --! GPIO\n" +
                        "    KEY			  => KEY,\n" +
                        "    SW			  => SW,\n" +
                        "    LEDG			  => LEDG,\n" +
                        "    LEDR			  => LEDR,\n" +
                        "    GPIO_IN		  => GPIO_IN,\n" +
                        "    GPIO_OUT	  => GPIO_OUT,\n" +
                        "	 --! Time measurements\n" +
                        "    HEX0			  => HEX0,\n" +
                        "    HEX1			  => HEX1,\n" +
                        "    HEX2			  => HEX2,\n" +
                        "    HEX3			  => HEX3\n" +
                        "  );\n" +
                        "\n" +
                        "end arch_RV_FPGA_PLC_River;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_riscv_soc_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "-- 0x00000000		64 KB		Boot ROM\n" +
                        "-- 0x10000000		256KB		RAM\n" +
                        "-- 0x80000000		4  KB		GPIO\n" +
                        "-- 0x80001000		4  KB		UART1\n" +
                        "-- 0x80002000		4  KB		IRQ Controller\n" +
                        "-- 0x80003000		4  KB		GP Timers				Two general purpose timers with RTC\n" +
                        "-- 0x80004000		4  KB		Time Measurement\n";
                        for (int i = 0; ((i < Data.Number_Of_Timers_In_Program) && (Data.Compiling_Type == Data.HW_COMPILING)); i++) {
                            data += "-- 0x800"+new GeneralFunctions().dec2hex_str(5 + i, 2)+"000		4  KB		TON: "+Data.Name_of_Timers[i]+"\n";
                        }
                        for (int i = 0; ((i < Data.Number_Of_PWMs_In_Program) && (Data.Compiling_Type == Data.HW_COMPILING)); i++) {
                            data += "-- 0x800"+new GeneralFunctions().dec2hex_str(Data.Number_Of_Timers_In_Program + 5 + i, 2)+"000		4  KB		PWM: "+Data.Name_of_PWMs[i]+"\n";
                        }
                        for (int i = 0; ((i < Data.Number_Of_PIDs_In_Program) && (Data.Compiling_Type == Data.HW_COMPILING)); i++) {
                            data += "-- 0x800"+new GeneralFunctions().dec2hex_str(Data.Number_Of_Timers_In_Program + Data.Number_Of_PWMs_In_Program + 5 + i, 2)+"000		4  KB		PID: "+Data.Name_of_PIDs[i]+"\n";
                        }
                data += "\n" +
                        "--! Standard library\n" +
                        "library IEEE;\n" +
                        "use IEEE.STD_LOGIC_1164.ALL;\n" +
                        "\n" +
                        "--! Data transformation and math functions library\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "\n" +
                        "--! Technology definition library.\n" +
                        "library techmap;\n" +
                        "--! Technology constants definition.\n" +
                        "use techmap.gencomp.all;\n" +
                        "\n" +
                        "--! AMBA system bus specific library\n" +
                        "library ambalib;\n" +
                        "--! AXI4 configuration constants.\n" +
                        "use ambalib.types_amba4.all;\n" +
                        "use ambalib.types_bus0.all;\n" +
                        "--! Misc modules library\n" +
                        "library misclib;\n" +
                        "use misclib.types_misc.all;\n" +
                        "\n" +
                        "--! River CPU specific library\n" +
                        "library riverlib;\n" +
                        "--! River top level with AMBA interface module declaration\n" +
                        "use riverlib.types_river.all;\n" +
                        "\n" +
                        "library target;\n" +
                        "use target.config_target.all;\n" +
                        "\n" +
                        "--! @brief   SOC Top-level entity declaration.\n" +
                        "--! @details This module implements full SOC functionality and all IO signals\n" +
                        "--!          are available on FPGA/ASIC IO pins.\n" +
                        "entity riscv_soc is port \n" +
                        "( \n" +
                        "  i_rst     : in std_logic;\n" +
                        "  i_clk     : in std_logic;\n" +
                        "  i_clk_pwm : in std_logic;\n" +
                        "  --! UART1 signals:\n" +
                        "  i_uart1_ctsn : in std_logic;\n" +
                        "  i_uart1_rd   : in std_logic;\n" +
                        "  o_uart1_td   : out std_logic;\n" +
                        "  o_uart1_rtsn : out std_logic;\n" +
                        "  --! GPIO\n" +
                        "  KEY				: in std_logic_vector(3 DOWNTO 0);\n" +
                        "  SW				: in std_logic_vector(9 DOWNTO 0);\n" +
                        "  LEDG			: out std_logic_vector(7 DOWNTO 0);\n" +
                        "  LEDR			: out std_logic_vector(9 DOWNTO 0);\n" +
                        "  GPIO_IN		: in std_logic_vector(17 DOWNTO 0);\n" +
                        "  GPIO_OUT		: out std_logic_vector(17 DOWNTO 0);\n" +
                        "  --! Time measurements\n" +
                        "  HEX0			: out std_logic_vector(6 DOWNTO 0);\n" +
                        "  HEX1			: out std_logic_vector(6 DOWNTO 0);\n" +
                        "  HEX2			: out std_logic_vector(6 DOWNTO 0);\n" +
                        "  HEX3			: out std_logic_vector(6 DOWNTO 0)\n" +
                        ");\n" +
                        "  --! @}\n" +
                        "\n" +
                        "end riscv_soc;\n" +
                        "\n" +
                        "--! @brief SOC top-level  architecture declaration.\n" +
                        "architecture arch_riscv_soc of riscv_soc is\n" +
                        "\n" +
                        "  signal w_glob_rst  : std_ulogic; -- Global reset active HIGH\n" +
                        "  signal w_glob_nrst : std_ulogic; -- Global reset active LOW\n" +
                        "  signal w_bus_nrst : std_ulogic; -- Global reset and Soft Reset active LOW\n" +
                        "  \n" +
                        "  signal uart1i : uart_in_type;\n" +
                        "  signal uart1o : uart_out_type;\n" +
                        "\n" +
                        "  --! Arbiter is switching only slaves output signal, data from noc\n" +
                        "  --! is connected to all slaves and to the arbiter itself.\n" +
                        "  signal aximi   : bus0_xmst_in_vector;\n" +
                        "  signal aximo   : bus0_xmst_out_vector;\n" +
                        "  signal axisi   : bus0_xslv_in_vector;\n" +
                        "  signal axiso   : bus0_xslv_out_vector;\n" +
                        "  signal slv_cfg : bus0_xslv_cfg_vector;\n" +
                        "  signal w_ext_irq : std_logic;\n" +
                        "  signal dport_i : dport_in_vector;\n" +
                        "\n" +
                        "  signal irq_pins : std_logic_vector(CFG_IRQ_TOTAL-1 downto 1);\n" +
                        "begin\n" +
                        "\n" +
                        "\n" +
                        " ------------------------------------\n" +
                        "  --! @brief System Reset device instance.\n" +
                        "  rst0 : reset_global port map (\n" +
                        "    inSysReset  => i_rst,\n" +
                        "    inSysClk    => i_clk,\n" +
                        "    outReset    => w_glob_rst\n" +
                        "  );\n" +
                        "  w_glob_nrst <= not w_glob_rst;\n" +
                        "  w_bus_nrst <= not w_glob_rst;\n" +
                        "\n" +
                        "  --! @brief AXI4 controller.\n" +
                        "  ctrl0 : axictrl_bus0 generic map (\n" +
                        "    async_reset => CFG_ASYNC_RESET\n" +
                        "  ) port map (\n" +
                        "    i_clk    => i_clk,\n" +
                        "    i_nrst   => w_glob_nrst,\n" +
                        "    i_slvcfg => slv_cfg,\n" +
                        "    i_slvo   => axiso,\n" +
                        "    i_msto   => aximo,\n" +
                        "    o_slvi   => axisi,\n" +
                        "    o_msti   => aximi,\n" +
                        "    o_bus_util_w => open, -- Bus write access utilization per master statistic\n" +
                        "    o_bus_util_r => open  -- Bus read access utilization per master statistic\n" +
                        "  );\n" +
                        "\n" +
                        "  --! @brief RISC-V Processor core (River or Rocket).\n" +
                        "  cpu0 : river_amba generic map (\n" +
                        "    memtech  => CFG_MEMTECH,\n" +
                        "    hartid => 0,\n" +
                        "    async_reset => CFG_ASYNC_RESET\n" +
                        "  ) port map ( \n" +
                        "    i_nrst   => w_bus_nrst,\n" +
                        "    i_clk    => i_clk,\n" +
                        "    i_msti   => aximi(CFG_BUS0_XMST_CPU0),\n" +
                        "    o_msto   => aximo(CFG_BUS0_XMST_CPU0),\n" +
                        "    o_mstcfg => open,\n" +
                        "    i_dport => dport_i(0),\n" +
                        "    o_dport => open,\n" +
                        "    i_ext_irq => w_ext_irq\n" +
                        "  );\n" +
                        "\n" +
                        "  ------------------------------------\n" +
                        "  --! @brief BOOT ROM module instance with the AXI4 interface.\n" +
                        "  --! @details Map address:\n" +
                        "  --!          0x00000000..0x00000000+((CFG_ROM_SIZE*1024) - 1)\n" +
                        "  boot0 : axi4_rom generic map (\n" +
                        "    memtech  => CFG_MEMTECH,\n" +
                        "    async_reset => CFG_ASYNC_RESET,\n" +
                        "    xaddr    => 16#00000#,\n" +
                        "    xmask    => CFG_ROM_MASK,\n" +
                        "    sim_hexfile => CFG_SIM_BOOTROM_HEX\n" +
                        "  ) port map (\n" +
                        "    clk  => i_clk,\n" +
                        "    nrst => w_glob_nrst,\n" +
                        "    cfg  => slv_cfg(CFG_BUS0_XSLV_BOOTROM),\n" +
                        "    i    => axisi(CFG_BUS0_XSLV_BOOTROM),\n" +
                        "    o    => axiso(CFG_BUS0_XSLV_BOOTROM)\n" +
                        "  );\n" +
                        "\n" +
                        "  ------------------------------------\n" +
                        "  --! Internal SRAM module instance with the AXI4 interface.\n" +
                        "  --! @details Map address:\n" +
                        "  --!          0x10000000..0x10000000+((CFG_RAM_SIZE*1024) - 1)\n" +
                        "  sram0 : axi4_sram generic map (\n" +
                        "    memtech  => CFG_MEMTECH,\n" +
                        "    async_reset => CFG_ASYNC_RESET,\n" +
                        "    xaddr    => 16#10000#,\n" +
                        "    xmask    => CFG_RAM_MASK,\n" +
                        "    abits    => (10 + log2(CFG_RAM_SIZE))\n" +
                        "  ) port map (\n" +
                        "    clk  => i_clk,\n" +
                        "    nrst => w_glob_nrst,\n" +
                        "    cfg  => slv_cfg(CFG_BUS0_XSLV_SRAM),\n" +
                        "    i    => axisi(CFG_BUS0_XSLV_SRAM),\n" +
                        "    o    => axiso(CFG_BUS0_XSLV_SRAM)\n" +
                        "  );\n" +
                        "\n" +
                        "\n" +
                        "  ------------------------------------\n" +
                        "  --! @brief Controller of the LEDs, DIPs and GPIO with the AXI4 interface.\n" +
                        "  --! @details Map address:\n" +
                        "  --!          0x80000000..0x80000fff (4 KB total)\n" +
                        "  gpio0 : axi4_gpio generic map (\n" +
                        "    async_reset => CFG_ASYNC_RESET,\n" +
                        "    xaddr    => 16#80000#,\n" +
                        "    xmask    => 16#fffff#,\n" +
                        "    xirq     => 0\n" +
                        "  ) port map (\n" +
                        "    clk   	=> i_clk,\n" +
                        "    nrst  	=> w_glob_nrst,\n" +
                        "    cfg   	=> slv_cfg(CFG_BUS0_XSLV_GPIO),\n" +
                        "    i			=> axisi(CFG_BUS0_XSLV_GPIO),\n" +
                        "    o			=> axiso(CFG_BUS0_XSLV_GPIO),\n" +
                        "    KEY		=> KEY,\n" +
                        "	 SW		=> SW,\n" +
                        "	 LEDG		=> LEDG,\n" +
                        "	 LEDR		=> LEDR,\n" +
                        "	 GPIO_IN	=> GPIO_IN,\n" +
                        "	 GPIO_OUT=> GPIO_OUT\n" +
                        "  );\n" +
                        "  \n" +
                        "  \n" +
                        "  ------------------------------------\n" +
                        "  uart1i.cts   <= not i_uart1_ctsn;\n" +
                        "  uart1i.rd    <= i_uart1_rd;\n" +
                        "\n" +
                        "  --! @brief UART Controller with the AXI4 interface.\n" +
                        "  --! @details Map address:\n" +
                        "  --!          0x80001000..0x80001fff (4 KB total)\n" +
                        "  uart1 : axi4_uart generic map (\n" +
                        "    async_reset => CFG_ASYNC_RESET,\n" +
                        "    xaddr    => 16#80001#,\n" +
                        "    xmask    => 16#FFFFF#,\n" +
                        "    xirq     => CFG_IRQ_UART1,\n" +
                        "    fifosz   => 16\n" +
                        "  ) port map (\n" +
                        "    nrst   => w_glob_nrst, \n" +
                        "    clk    => i_clk, \n" +
                        "    cfg    => slv_cfg(CFG_BUS0_XSLV_UART1),\n" +
                        "    i_uart => uart1i, \n" +
                        "    o_uart => uart1o,\n" +
                        "    i_axi  => axisi(CFG_BUS0_XSLV_UART1),\n" +
                        "    o_axi  => axiso(CFG_BUS0_XSLV_UART1),\n" +
                        "    o_irq  => irq_pins(CFG_IRQ_UART1)\n" +
                        "  );\n" +
                        "  o_uart1_td  <= uart1o.td;\n" +
                        "  o_uart1_rtsn <= not uart1o.rts;\n" +
                        "\n" +
                        "\n" +
                        "  ------------------------------------\n" +
                        "  --! @brief Interrupt controller with the AXI4 interface.\n" +
                        "  --! @details Map address:\n" +
                        "  --!          0x80002000..0x80002fff (4 KB total)\n" +
                        "  irq0 : axi4_irqctrl generic map (\n" +
                        "    async_reset => CFG_ASYNC_RESET,\n" +
                        "    xaddr      => 16#80002#,\n" +
                        "    xmask      => 16#FFFFF#\n" +
                        "  ) port map (\n" +
                        "    clk    => i_clk,\n" +
                        "    nrst   => w_bus_nrst,\n" +
                        "    i_irqs => irq_pins,\n" +
                        "    o_cfg  => slv_cfg(CFG_BUS0_XSLV_IRQCTRL),\n" +
                        "    i_axi  => axisi(CFG_BUS0_XSLV_IRQCTRL),\n" +
                        "    o_axi  => axiso(CFG_BUS0_XSLV_IRQCTRL),\n" +
                        "    o_irq_meip => w_ext_irq\n" +
                        "  );\n" +
                        "\n" +
                        "  --! @brief Timers with the AXI4 interface.\n" +
                        "  --! @details Map address:\n" +
                        "  --!          0x80003000..0x80003fff (4 KB total)\n" +
                        "  gptmr0 : axi4_gptimers  generic map (\n" +
                        "    async_reset => CFG_ASYNC_RESET,\n" +
                        "    xaddr     => 16#80003#,\n" +
                        "    xmask     => 16#fffff#,\n" +
                        "    xirq      => CFG_IRQ_GPTIMERS,\n" +
                        "    tmr_total => 2\n" +
                        "  ) port map (\n" +
                        "    clk    => i_clk,\n" +
                        "    nrst   => w_glob_nrst,\n" +
                        "    cfg    => slv_cfg(CFG_BUS0_XSLV_GPTIMERS),\n" +
                        "    i_axi  => axisi(CFG_BUS0_XSLV_GPTIMERS),\n" +
                        "    o_axi  => axiso(CFG_BUS0_XSLV_GPTIMERS),\n" +
                        "    o_irq  => irq_pins(CFG_IRQ_GPTIMERS)\n" +
                        "  );\n" +
                        "  \n" +
                        "  time_measurement : axi4_time_measurement generic map (\n" +
                        "    async_reset => CFG_ASYNC_RESET,\n" +
                        "    xaddr    => 16#80004#,\n" +
                        "    xmask    => 16#fffff#,\n" +
                        "    xirq     => 0\n" +
                        "  ) port map (\n" +
                        "    clk   	=> i_clk,\n" +
                        "    nrst  	=> w_glob_nrst,\n" +
                        "    cfg   	=> slv_cfg(CFG_BUS0_XSLV_TIME_MEASUREMENT),\n" +
                        "    i			=> axisi(CFG_BUS0_XSLV_TIME_MEASUREMENT),\n" +
                        "    o			=> axiso(CFG_BUS0_XSLV_TIME_MEASUREMENT),\n" +
                        "	 HEX0			=> HEX0,\n" +
                        "	 HEX1			=> HEX1,\n" +
                        "	 HEX2			=> HEX2,\n" +
                        "	 HEX3			=> HEX3\n" +
                        "  );\n" +
                        "\n";
                        for (int i = 0; ((i < Data.Number_Of_Timers_In_Program) && (Data.Compiling_Type == Data.HW_COMPILING)); i++) {
                            data += "  "+Data.Name_of_Timers[i]+" : entity work.axi4_ton generic map (\n" +
                                    "    async_reset => CFG_ASYNC_RESET,\n" +
                                    "    xaddr    => 16#800"+new GeneralFunctions().dec2hex_str(5 + i, 2)+"#,\n" +
                                    "    xmask    => 16#fffff#,\n" +
                                    "    xirq     => 0\n" +
                                    "  ) port map (\n" +
                                    "    clk   	=> i_clk,\n" +
                                    "    nrst  	=> w_glob_nrst,\n" +
                                    "    cfg   	=> slv_cfg(CFG_BUS0_XSLV_TON_"+Data.Name_of_Timers[i]+"),\n" +
                                    "    i			=> axisi(CFG_BUS0_XSLV_TON_"+Data.Name_of_Timers[i]+"),\n" +
                                    "    o			=> axiso(CFG_BUS0_XSLV_TON_"+Data.Name_of_Timers[i]+")\n" +
                                    "  );\n\n";
                        }
                        for (int i = 0; ((i < Data.Number_Of_PWMs_In_Program) && (Data.Compiling_Type == Data.HW_COMPILING)); i++) {
                            data += "  "+Data.Name_of_PWMs[i]+" : entity work.axi4_pwm generic map (\n" +
                                    "    async_reset => CFG_ASYNC_RESET,\n" +
                                    "    xaddr    => 16#800"+new GeneralFunctions().dec2hex_str(Data.Number_Of_Timers_In_Program + 5 + i, 2)+"#,\n" +
                                    "    xmask    => 16#fffff#,\n" +
                                    "    xirq     => 0\n" +
                                    "  ) port map (\n" +
                                    "    clk   	=> i_clk,\n" +
                                    "    clk_pwm 	=> i_clk_pwm,\n" +
                                    "    nrst  	=> w_glob_nrst,\n" +
                                    "    cfg   	=> slv_cfg(CFG_BUS0_XSLV_PWM_"+Data.Name_of_PWMs[i]+"),\n" +
                                    "    i			=> axisi(CFG_BUS0_XSLV_PWM_"+Data.Name_of_PWMs[i]+"),\n" +
                                    "    o			=> axiso(CFG_BUS0_XSLV_PWM_"+Data.Name_of_PWMs[i]+")\n" +
                                    "  );\n\n";
                        }
                        for (int i = 0; ((i < Data.Number_Of_PIDs_In_Program) && (Data.Compiling_Type == Data.HW_COMPILING)); i++) {
                            data += "  "+Data.Name_of_PIDs[i]+" : entity work.axi4_pid generic map (\n" +
                                    "    async_reset => CFG_ASYNC_RESET,\n" +
                                    "    xaddr    => 16#800"+new GeneralFunctions().dec2hex_str(Data.Number_Of_Timers_In_Program + Data.Number_Of_PWMs_In_Program + 5 + i, 2)+"#,\n" +
                                    "    xmask    => 16#fffff#,\n" +
                                    "    xirq     => 0\n" +
                                    "  ) port map (\n" +
                                    "    clk   	=> i_clk,\n" +
                                    "    nrst  	=> w_glob_nrst,\n" +
                                    "    cfg   	=> slv_cfg(CFG_BUS0_XSLV_PID_"+Data.Name_of_PIDs[i]+"),\n" +
                                    "    i			=> axisi(CFG_BUS0_XSLV_PID_"+Data.Name_of_PIDs[i]+"),\n" +
                                    "    o			=> axiso(CFG_BUS0_XSLV_PID_"+Data.Name_of_PIDs[i]+")\n" +
                                    "  );\n\n";
                        }
                data += "end arch_riscv_soc;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_config_c5g_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library IEEE;\n" +
                        "use IEEE.STD_LOGIC_1164.ALL;\n" +
                        "library techmap;\n" +
                        "use techmap.gencomp.all;\n" +
                        "\n" +
                        "package config_target is\n" +
                        "-- Technology and synthesis options\n" +
                        "  constant CFG_FABTECH : integer := cyclonevc5g;\n" +
                        "  constant CFG_MEMTECH : integer := cyclonevc5g;\n" +
                        "  constant CFG_PADTECH : integer := cyclonevc5g;\n" +
                        "  constant CFG_JTAGTECH : integer := cyclonevc5g;\n" +
                        "\n" +
                        "  constant CFG_ASYNC_RESET : boolean := false;\n" +
                        "\n" +
                        "  constant CFG_TOPDIR : string := \"./\";\n" +
                        "\n" +
                        "  --! @brief   Number of processors in a system\n" +
                        "  --! @details This value may be in a range 1 to CFG_TOTAL_CPU_MAX-1\n" +
                        "  constant CFG_CPU_NUM : integer := 1;\n" +
                        "\n" +
                        "  --! @brief   HEX-image for the initialization of the Boot ROM.\n" +
                        "  --! @details This file is used by \\e inferred ROM implementation.\n" +
                        "  constant CFG_SIM_BOOTROM_HEX : string := \n" +
                        "                CFG_TOPDIR & \""+Data.Project_Name+".mif\";\n" +
                        "\n" +
                        "\n" +
                        "  --! @brief Hardware SoC Identificator.\n" +
                        "  --!\n" +
                        "  --! @details Read Only unique platform identificator that could be\n" +
                        "  --!          read by firmware from the Plug'n'Play support module.\n" +
                        "  constant CFG_HW_ID : std_logic_vector(31 downto 0) := X\"20200207\";\n" +
                        "\n" +
                        "  --! @brief Enabling Ethernet MAC interface.\n" +
                        "  --! @details By default MAC module enables support of the debug feature EDCL.\n" +
                        "  constant CFG_ETHERNET_ENABLE : boolean := false;\n" +
                        "\n" +
                        "  --! @brief Enable/Disable Debug Unit \n" +
                        "  constant CFG_DSU_ENABLE : boolean := false;\n" +
                        "\n" +
                        "  --! External Flash IC connected via SPI\n" +
                        "  constant CFG_EXT_FLASH_ENA : boolean := false;\n" +
                        "\n" +
                        "  --! GNSS sub-system\n" +
                        "  constant CFG_GNSS_SS_ENA : boolean := false;\n" +
                        "\n" +
                        "  --! OTP 8 KB memory bank\n" +
                        "  constant CFG_OTP8KB_ENA : boolean := false;\n" +
                        "\n" +
                        "  --! Coherent bridge with L2-cache\n" +
                        "  constant CFG_L2CACHE_ENA : boolean := false;\n" +
                        "\n" +
                        "  --! Configure arithmetic unit\n" +
                        "  constant CFG_FPU_ENABLE : boolean := "+new GeneralFunctions().bool2str(Data.is_fpu_RV64_enabeled)+";\n" +
                        "  constant CFG_MUL_ENABLE : boolean := "+new GeneralFunctions().bool2str(Data.is_mul_RV64_enabeled)+";\n" +
                        "  constant CFG_DIV_ENABLE : boolean := "+new GeneralFunctions().bool2str(Data.is_div_RV64_enabeled)+";\n" +
                        "\n" +
                        "--! Memory sizes\n" +
                        "  constant CFG_RAM_MASK     : integer := 16#fffc0#; -- 256 KB mask\n" +
                        "  constant CFG_RAM_SIZE     : integer := 256;       -- 256 KB address\n" +
                        "\n" +
                        "  constant CFG_ROM_MASK     : integer := 16#ffff0#; -- 64  KB mask\n" +
                        "  constant CFG_ROM_SIZE     : integer := 64;        -- 64  KB address" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_axictrl_bus0_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "library ambalib;\n" +
                        "use ambalib.types_amba4.all;\n" +
                        "use ambalib.types_bus0.all;\n" +
                        "\n" +
                        "entity axictrl_bus0 is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk    : in std_logic;\n" +
                        "    i_nrst   : in std_logic;\n" +
                        "    i_slvcfg : in  bus0_xslv_cfg_vector;\n" +
                        "    i_slvo   : in  bus0_xslv_out_vector;\n" +
                        "    i_msto   : in  bus0_xmst_out_vector;\n" +
                        "    o_slvi   : out bus0_xslv_in_vector;\n" +
                        "    o_msti   : out bus0_xmst_in_vector;\n" +
                        "    o_bus_util_w : out std_logic_vector(CFG_BUS0_XMST_TOTAL-1 downto 0);\n" +
                        "    o_bus_util_r : out std_logic_vector(CFG_BUS0_XMST_TOTAL-1 downto 0)\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_axictrl_bus0 of axictrl_bus0 is\n" +
                        "\n" +
                        "  type nasti_master_out_vector_miss is array (0 to CFG_BUS0_XMST_TOTAL) \n" +
                        "       of axi4_master_out_type;\n" +
                        "\n" +
                        "  type nasti_master_in_vector_miss is array (0 to CFG_BUS0_XMST_TOTAL) \n" +
                        "       of axi4_master_in_type;\n" +
                        "\n" +
                        "  type nasti_slave_out_vector_miss is array (0 to CFG_BUS0_XSLV_TOTAL) \n" +
                        "       of axi4_slave_out_type;\n" +
                        "\n" +
                        "  type nasti_slave_in_vector_miss is array (0 to CFG_BUS0_XSLV_TOTAL) \n" +
                        "       of axi4_slave_in_type;\n" +
                        "       \n" +
                        "  type reg_type is record\n" +
                        "     r_midx : integer range 0 to CFG_BUS0_XMST_TOTAL;\n" +
                        "     r_sidx : integer range 0 to CFG_BUS0_XSLV_TOTAL;\n" +
                        "     w_midx : integer range 0 to CFG_BUS0_XMST_TOTAL;\n" +
                        "     w_sidx : integer range 0 to CFG_BUS0_XSLV_TOTAL;\n" +
                        "     b_midx : integer range 0 to CFG_BUS0_XMST_TOTAL;\n" +
                        "     b_sidx : integer range 0 to CFG_BUS0_XSLV_TOTAL;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : reg_type := (\n" +
                        "      CFG_BUS0_XMST_TOTAL, CFG_BUS0_XSLV_TOTAL,\n" +
                        "      CFG_BUS0_XMST_TOTAL, CFG_BUS0_XSLV_TOTAL,\n" +
                        "      CFG_BUS0_XMST_TOTAL, CFG_BUS0_XSLV_TOTAL);\n" +
                        "\n" +
                        "  signal rin, r : reg_type;\n" +
                        "\n" +
                        "  signal defslv_i : axi4_slave_in_type;\n" +
                        "  signal defslv_o : axi4_slave_out_type;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  xdef0 : axi4_defslv generic map (\n" +
                        "    async_reset => async_reset\n" +
                        "  ) port map (\n" +
                        "    i_clk => i_clk,\n" +
                        "    i_nrst => i_nrst,\n" +
                        "    i_xslvi => defslv_i,\n" +
                        "    o_xslvo => defslv_o\n" +
                        "  );\n" +
                        "\n" +
                        "  comblogic : process(i_nrst, i_slvcfg, i_msto, i_slvo, defslv_o, r)\n" +
                        "    variable v : reg_type;\n" +
                        "    variable ar_midx : integer range 0 to CFG_BUS0_XMST_TOTAL;\n" +
                        "    variable aw_midx : integer range 0 to CFG_BUS0_XMST_TOTAL;\n" +
                        "    variable ar_sidx : integer range 0 to CFG_BUS0_XSLV_TOTAL; -- +1 miss access\n" +
                        "    variable aw_sidx : integer range 0 to CFG_BUS0_XSLV_TOTAL; -- +1 miss access\n" +
                        "    variable vmsto : nasti_master_out_vector_miss;\n" +
                        "    variable vmsti : nasti_master_in_vector_miss;\n" +
                        "    variable vslvi : nasti_slave_in_vector_miss;\n" +
                        "    variable vslvo : nasti_slave_out_vector_miss;\n" +
                        "    variable aw_fire : std_logic;\n" +
                        "    variable ar_fire : std_logic;\n" +
                        "    variable w_fire : std_logic;\n" +
                        "    variable w_busy : std_logic;\n" +
                        "    variable r_fire : std_logic;\n" +
                        "    variable r_busy : std_logic;\n" +
                        "    variable b_fire : std_logic;\n" +
                        "    variable b_busy : std_logic;\n" +
                        "    -- Bus statistic signals\n" +
                        "    variable wb_bus_util_w : std_logic_vector(CFG_BUS0_XMST_TOTAL downto 0);\n" +
                        "    variable wb_bus_util_r : std_logic_vector(CFG_BUS0_XMST_TOTAL downto 0);\n" +
                        "\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    for m in 0 to CFG_BUS0_XMST_TOTAL-1 loop\n" +
                        "       vmsto(m) := i_msto(m);\n" +
                        "       vmsti(m) := axi4_master_in_none;\n" +
                        "    end loop;\n" +
                        "    vmsto(CFG_BUS0_XMST_TOTAL) := axi4_master_out_none;\n" +
                        "    vmsti(CFG_BUS0_XMST_TOTAL) := axi4_master_in_none;\n" +
                        "\n" +
                        "    for s in 0 to CFG_BUS0_XSLV_TOTAL-1 loop\n" +
                        "       vslvo(s) := i_slvo(s);\n" +
                        "       vslvi(s) := axi4_slave_in_none;\n" +
                        "    end loop;\n" +
                        "    vslvo(CFG_BUS0_XSLV_TOTAL) := defslv_o;\n" +
                        "    vslvi(CFG_BUS0_XSLV_TOTAL) := axi4_slave_in_none;\n" +
                        "\n" +
                        "    ar_midx := CFG_BUS0_XMST_TOTAL;\n" +
                        "    aw_midx := CFG_BUS0_XMST_TOTAL;\n" +
                        "    ar_sidx := CFG_BUS0_XSLV_TOTAL;\n" +
                        "    aw_sidx := CFG_BUS0_XSLV_TOTAL;\n" +
                        "\n" +
                        "    -- select master bus:\n" +
                        "    for m in 0 to CFG_BUS0_XMST_TOTAL-1 loop\n" +
                        "        if i_msto(m).ar_valid = '1' then\n" +
                        "            ar_midx := m;\n" +
                        "        end if;\n" +
                        "        if i_msto(m).aw_valid = '1' then\n" +
                        "            aw_midx := m;\n" +
                        "        end if;\n" +
                        "    end loop;\n" +
                        "\n" +
                        "    -- select slave interface\n" +
                        "    for s in 0 to CFG_BUS0_XSLV_TOTAL-1 loop\n" +
                        "        if i_slvcfg(s).xmask /= X\"00000\" and\n" +
                        "           (vmsto(ar_midx).ar_bits.addr(CFG_SYSBUS_ADDR_BITS-1 downto 12) \n" +
                        "            and i_slvcfg(s).xmask) = i_slvcfg(s).xaddr then\n" +
                        "            ar_sidx := s;\n" +
                        "        end if;\n" +
                        "        if i_slvcfg(s).xmask /= X\"00000\" and\n" +
                        "           (vmsto(aw_midx).aw_bits.addr(CFG_SYSBUS_ADDR_BITS-1 downto 12)\n" +
                        "            and i_slvcfg(s).xmask) = i_slvcfg(s).xaddr then\n" +
                        "            aw_sidx := s;\n" +
                        "        end if;\n" +
                        "    end loop;\n" +
                        "\n" +
                        "    -- Read Channel:\n" +
                        "    ar_fire := vmsto(ar_midx).ar_valid and vslvo(ar_sidx).ar_ready;\n" +
                        "    r_fire := vmsto(r.r_midx).r_ready and vslvo(r.r_sidx).r_valid and vslvo(r.r_sidx).r_last;\n" +
                        "    -- Write channel:\n" +
                        "    aw_fire := vmsto(aw_midx).aw_valid and vslvo(aw_sidx).aw_ready;\n" +
                        "    w_fire := vmsto(r.w_midx).w_valid and vmsto(r.w_midx).w_last and vslvo(r.w_sidx).w_ready;\n" +
                        "    -- Write confirm channel\n" +
                        "    b_fire := vmsto(r.b_midx).b_ready and vslvo(r.b_sidx).b_valid;\n" +
                        "\n" +
                        "    r_busy := '0';\n" +
                        "    if r.r_sidx /= CFG_BUS0_XSLV_TOTAL and r_fire = '0' then\n" +
                        "        r_busy := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_busy := '0';\n" +
                        "    if (r.w_sidx /= CFG_BUS0_XSLV_TOTAL and w_fire = '0') \n" +
                        "       or (r.b_sidx /= CFG_BUS0_XSLV_TOTAL and b_fire = '0') then\n" +
                        "        w_busy := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    b_busy := '0';\n" +
                        "    if (r.b_sidx /= CFG_BUS0_XSLV_TOTAL and b_fire = '0')  then\n" +
                        "        b_busy := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if ar_fire = '1' and r_busy = '0' then\n" +
                        "        v.r_sidx := ar_sidx;\n" +
                        "        v.r_midx := ar_midx;\n" +
                        "    elsif r_fire = '1' then\n" +
                        "        v.r_sidx := CFG_BUS0_XSLV_TOTAL;\n" +
                        "        v.r_midx := CFG_BUS0_XMST_TOTAL;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if aw_fire = '1' and w_busy = '0' then\n" +
                        "        v.w_sidx := aw_sidx;\n" +
                        "        v.w_midx := aw_midx;\n" +
                        "    elsif w_fire = '1' and b_busy = '0' then\n" +
                        "        v.w_sidx := CFG_BUS0_XSLV_TOTAL;\n" +
                        "        v.w_midx := CFG_BUS0_XMST_TOTAL;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if w_fire = '1' and b_busy = '0' then\n" +
                        "        v.b_sidx := r.w_sidx;\n" +
                        "        v.b_midx := r.w_midx;\n" +
                        "    elsif b_fire = '1' then\n" +
                        "        v.b_sidx := CFG_BUS0_XSLV_TOTAL;\n" +
                        "        v.b_midx := CFG_BUS0_XMST_TOTAL;\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    vmsti(ar_midx).ar_ready := vslvo(ar_sidx).ar_ready and not r_busy;\n" +
                        "    vslvi(ar_sidx).ar_valid := vmsto(ar_midx).ar_valid and not r_busy;\n" +
                        "    vslvi(ar_sidx).ar_bits  := vmsto(ar_midx).ar_bits;\n" +
                        "    vslvi(ar_sidx).ar_id    := vmsto(ar_midx).ar_id;\n" +
                        "    vslvi(ar_sidx).ar_user  := vmsto(ar_midx).ar_user;\n" +
                        "\n" +
                        "    vmsti(r.r_midx).r_valid := vslvo(r.r_sidx).r_valid;\n" +
                        "    vmsti(r.r_midx).r_resp  := vslvo(r.r_sidx).r_resp;\n" +
                        "    vmsti(r.r_midx).r_data  := vslvo(r.r_sidx).r_data;\n" +
                        "    vmsti(r.r_midx).r_last  := vslvo(r.r_sidx).r_last;\n" +
                        "    vmsti(r.r_midx).r_id    := vslvo(r.r_sidx).r_id;\n" +
                        "    vmsti(r.r_midx).r_user  := vslvo(r.r_sidx).r_user;\n" +
                        "    vslvi(r.r_sidx).r_ready := vmsto(r.r_midx).r_ready;\n" +
                        "\n" +
                        "    vmsti(aw_midx).aw_ready := vslvo(aw_sidx).aw_ready and not w_busy;\n" +
                        "    vslvi(aw_sidx).aw_valid := vmsto(aw_midx).aw_valid and not w_busy;\n" +
                        "    vslvi(aw_sidx).aw_bits  := vmsto(aw_midx).aw_bits;\n" +
                        "    vslvi(aw_sidx).aw_id    := vmsto(aw_midx).aw_id;\n" +
                        "    vslvi(aw_sidx).aw_user  := vmsto(aw_midx).aw_user;\n" +
                        "\n" +
                        "    vmsti(r.w_midx).w_ready := vslvo(r.w_sidx).w_ready and not b_busy;\n" +
                        "    vslvi(r.w_sidx).w_valid := vmsto(r.w_midx).w_valid and not b_busy;\n" +
                        "    vslvi(r.w_sidx).w_data := vmsto(r.w_midx).w_data;\n" +
                        "    vslvi(r.w_sidx).w_last := vmsto(r.w_midx).w_last;\n" +
                        "    vslvi(r.w_sidx).w_strb := vmsto(r.w_midx).w_strb;\n" +
                        "    vslvi(r.w_sidx).w_user := vmsto(r.w_midx).w_user;\n" +
                        "\n" +
                        "    vmsti(r.b_midx).b_valid := vslvo(r.b_sidx).b_valid;\n" +
                        "    vmsti(r.b_midx).b_resp := vslvo(r.b_sidx).b_resp;\n" +
                        "    vmsti(r.b_midx).b_id := vslvo(r.b_sidx).b_id;\n" +
                        "    vmsti(r.b_midx).b_user := vslvo(r.b_sidx).b_user;\n" +
                        "    vslvi(r.b_sidx).b_ready := vmsto(r.b_midx).b_ready;\n" +
                        "\n" +
                        "    -- Statistic\n" +
                        "    wb_bus_util_w := (others => '0');\n" +
                        "    wb_bus_util_w(r.w_midx) :=  '1';\n" +
                        "    wb_bus_util_r := (others => '0');\n" +
                        "    wb_bus_util_r(r.r_midx) := '1';\n" +
                        "\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        " \n" +
                        "    rin <= v;\n" +
                        "\n" +
                        "    for m in 0 to CFG_BUS0_XMST_TOTAL-1 loop\n" +
                        "       o_msti(m) <= vmsti(m);\n" +
                        "    end loop;\n" +
                        "    for s in 0 to CFG_BUS0_XSLV_TOTAL-1 loop\n" +
                        "       o_slvi(s) <= vslvi(s);\n" +
                        "    end loop;\n" +
                        "    defslv_i <= vslvi(CFG_BUS0_XSLV_TOTAL);\n" +
                        "    o_bus_util_w <= wb_bus_util_w(CFG_BUS0_XMST_TOTAL-1 downto 0);\n" +
                        "    o_bus_util_r <= wb_bus_util_r(CFG_BUS0_XMST_TOTAL-1 downto 0);\n" +
                        "  end process;\n" +
                        "\n" +
                        "  regs : process(i_clk, i_nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "         r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "         r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_axislv_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "library ambalib;\n" +
                        "use ambalib.types_amba4.all;\n" +
                        "\n" +
                        "entity axi4_slave is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_xcfg : in axi4_slave_config_type;\n" +
                        "    i_xslvi : in axi4_slave_in_type;\n" +
                        "    o_xslvo : out axi4_slave_out_type;\n" +
                        "    i_ready : in std_logic;\n" +
                        "    i_rdata : in std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "    o_re : out std_logic;\n" +
                        "    o_r32 : out std_logic;\n" +
                        "    o_radr : out global_addr_array_type;\n" +
                        "    o_wadr : out global_addr_array_type;\n" +
                        "    o_we : out std_logic;\n" +
                        "    o_wstrb : out std_logic_vector(CFG_SYSBUS_DATA_BYTES-1 downto 0);\n" +
                        "    o_wdata : out std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0)\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_axi4_slave of axi4_slave is\n" +
                        "\n" +
                        "  --! Slave device states during reading value operation.\n" +
                        "  type axi_slave_rstatetype is (rwait, rhold, rtrans);\n" +
                        "  --! Slave device states during writting data operation.\n" +
                        "  type axi_slave_wstatetype is (wwait, wtrans);\n" +
                        "\n" +
                        "  --! @brief Template bank of registers for any slave device.\n" +
                        "  type axi_slave_bank_type is record\n" +
                        "    rstate : axi_slave_rstatetype;\n" +
                        "    wstate : axi_slave_wstatetype;\n" +
                        "\n" +
                        "    rburst : std_logic_vector(1 downto 0);\n" +
                        "    rsize  : integer;\n" +
                        "    raddr  : global_addr_array_type;\n" +
                        "    rlen   : integer;                       --! AXI4 supports 256 burst operation\n" +
                        "    rid    : std_logic_vector(CFG_ROCKET_ID_BITS-1 downto 0);\n" +
                        "    rresp  : std_logic_vector(1 downto 0);  --! OK=0\n" +
                        "    ruser  : std_logic;\n" +
                        "    rswap : std_logic;\n" +
                        "    rwaitready : std_logic;                 --! Reading wait state flag: 0=waiting. User's waitstates\n" +
                        "    \n" +
                        "    wburst : std_logic_vector(1 downto 0);  -- 0=INCREMENT\n" +
                        "    wsize  : integer;                       -- code in range 0=1 Bytes upto 7=128 Bytes. \n" +
                        "    waddr  : global_addr_array_type;        --! 4 KB bank\n" +
                        "    wlen   : integer;                       --! AXI4 supports 256 burst operation\n" +
                        "    wid    : std_logic_vector(CFG_ROCKET_ID_BITS-1 downto 0);\n" +
                        "    wresp  : std_logic_vector(1 downto 0);  --! OK=0\n" +
                        "    wuser  : std_logic;\n" +
                        "    wswap : std_logic;\n" +
                        "    b_valid : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  --! Reset value of the template bank of registers of a slave device.\n" +
                        "  constant AXI_SLAVE_BANK_RESET : axi_slave_bank_type := (\n" +
                        "    rwait, wwait,\n" +
                        "    AXI_BURST_FIXED, 0, (others=>(others=>'0')), 0, (others=>'0'), AXI_RESP_OKAY, '0', '0', '1',\n" +
                        "    AXI_BURST_FIXED, 0, (others=>(others=>'0')), 0, (others=>'0'), AXI_RESP_OKAY, '0', '0', '0'\n" +
                        "  );\n" +
                        "\n" +
                        "  signal rin, r : axi_slave_bank_type;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  comblogic : process(i_nrst, i_xcfg, i_xslvi, i_ready, i_rdata, r)\n" +
                        "    variable v : axi_slave_bank_type;\n" +
                        "    variable traddr : std_logic_vector(CFG_SYSBUS_ADDR_BITS-1 downto 0);\n" +
                        "    variable twaddr : std_logic_vector(CFG_SYSBUS_ADDR_BITS-1 downto 0);\n" +
                        "    variable v_raddr_bus : global_addr_array_type;\n" +
                        "    variable v_raddr_bus_swp : global_addr_array_type;\n" +
                        "    variable v_raddr_bus_nxt : global_addr_array_type;\n" +
                        "    variable v_raddr_bus_nxt_swp : global_addr_array_type;\n" +
                        "    variable v_raddr_burst_nxt_swp : global_addr_array_type;\n" +
                        "    variable v_wadr_bus : global_addr_array_type;\n" +
                        "    variable v_wadr_bus_swp : global_addr_array_type;\n" +
                        "    variable v_waddr_burst_nxt_swp : global_addr_array_type;\n" +
                        "    variable v_re : std_logic;\n" +
                        "    variable v_r32 : std_logic;\n" +
                        "    variable v_radr : global_addr_array_type;\n" +
                        "    variable v_we : std_logic_vector(CFG_SYSBUS_DATA_BYTES-1 downto 0);\n" +
                        "    variable v_wstrb : std_logic_vector(CFG_SYSBUS_DATA_BYTES-1 downto 0);\n" +
                        "    variable v_wdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "    variable v_aw_ready : std_logic;\n" +
                        "    variable v_w_ready : std_logic;\n" +
                        "    variable v_ar_ready : std_logic;\n" +
                        "    variable v_r_valid : std_logic;\n" +
                        "    variable v_r_last : std_logic;\n" +
                        "    variable vb_r_data : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    traddr := (i_xslvi.ar_bits.addr(CFG_SYSBUS_ADDR_BITS-1 downto 12) and (not i_xcfg.xmask))\n" +
                        "             & i_xslvi.ar_bits.addr(11 downto 0);\n" +
                        "\n" +
                        "    twaddr := (i_xslvi.aw_bits.addr(CFG_SYSBUS_ADDR_BITS-1 downto 12) and (not i_xcfg.xmask))\n" +
                        "             & i_xslvi.aw_bits.addr(11 downto 0);\n" +
                        "\n" +
                        "    for n in 0 to CFG_WORDS_ON_BUS-1 loop\n" +
                        "        v_raddr_bus(n) := traddr + n*CFG_ALIGN_BYTES;\n" +
                        "        v_raddr_bus_nxt(n) := v_raddr_bus(n) + XSizeToBytes(conv_integer(i_xslvi.ar_bits.size));\n" +
                        "        if i_xslvi.ar_bits.burst = AXI_BURST_WRAP then\n" +
                        "            v_raddr_bus_nxt(n)(CFG_SYSBUS_ADDR_BITS-1 downto 5) \n" +
                        "                 := v_raddr_bus(n)(CFG_SYSBUS_ADDR_BITS-1 downto 5);\n" +
                        "        end if;\n" +
                        "\n" +
                        "        v_wadr_bus(n) := twaddr + n*CFG_ALIGN_BYTES;\n" +
                        "    end loop;\n" +
                        "\n" +
                        "    v_re := '0';\n" +
                        "    v_r32 := '0';\n" +
                        "    v_radr(0) := (others => '0');\n" +
                        "    v_radr(1) := (others => '0');\n" +
                        "\n" +
                        "    -- Next hold read address while write transaction not finished\n" +
                        "    if i_xslvi.ar_bits.addr(2) = '0' then\n" +
                        "        v_raddr_bus_swp := v_raddr_bus;\n" +
                        "    else\n" +
                        "        v_raddr_bus_swp(0) := v_raddr_bus(1);\n" +
                        "        v_raddr_bus_swp(1) := v_raddr_bus(0);\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Next read accepted address if no write request\n" +
                        "    if (i_xslvi.ar_bits.addr(2) = '0' and i_xslvi.ar_bits.size = \"011\") or\n" +
                        "       (i_xslvi.ar_bits.addr(2) = '1' and i_xslvi.ar_bits.size = \"010\") then\n" +
                        "        v_raddr_bus_nxt_swp := v_raddr_bus_nxt;\n" +
                        "    else\n" +
                        "        v_raddr_bus_nxt_swp(0) := v_raddr_bus_nxt(1);\n" +
                        "        v_raddr_bus_nxt_swp(1) := v_raddr_bus_nxt(0);\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Next burst read address\n" +
                        "    if r.rsize = 4 then\n" +
                        "        v_raddr_burst_nxt_swp(0) := r.raddr(1) + r.rsize;\n" +
                        "        v_raddr_burst_nxt_swp(1) := r.raddr(0) + r.rsize;\n" +
                        "        if r.rburst = AXI_BURST_WRAP then\n" +
                        "            v_raddr_burst_nxt_swp(0)(CFG_SYSBUS_ADDR_BITS-1 downto 5) \n" +
                        "                 := r.raddr(1)(CFG_SYSBUS_ADDR_BITS-1 downto 5);\n" +
                        "            v_raddr_burst_nxt_swp(1)(CFG_SYSBUS_ADDR_BITS-1 downto 5) \n" +
                        "                 := r.raddr(0)(CFG_SYSBUS_ADDR_BITS-1 downto 5);\n" +
                        "        end if;\n" +
                        "    else\n" +
                        "        v_raddr_burst_nxt_swp(0) := r.raddr(0) + r.rsize;\n" +
                        "        v_raddr_burst_nxt_swp(1) := r.raddr(1) + r.rsize;\n" +
                        "        if r.rburst = AXI_BURST_WRAP then\n" +
                        "            v_raddr_burst_nxt_swp(0)(CFG_SYSBUS_ADDR_BITS-1 downto 5) \n" +
                        "                 := r.raddr(0)(CFG_SYSBUS_ADDR_BITS-1 downto 5);\n" +
                        "            v_raddr_burst_nxt_swp(1)(CFG_SYSBUS_ADDR_BITS-1 downto 5) \n" +
                        "                 := r.raddr(1)(CFG_SYSBUS_ADDR_BITS-1 downto 5);\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    -- Write swapped address\n" +
                        "    if i_xslvi.aw_bits.addr(2) = '0' then\n" +
                        "        v_wadr_bus_swp := v_wadr_bus;\n" +
                        "    else\n" +
                        "        v_wadr_bus_swp(0) := v_wadr_bus(1);\n" +
                        "        v_wadr_bus_swp(1) := v_wadr_bus(0);\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Next burst write address\n" +
                        "    if r.wsize = 4 then\n" +
                        "        v_waddr_burst_nxt_swp(0) := r.waddr(1) + r.wsize;\n" +
                        "        v_waddr_burst_nxt_swp(1) := r.waddr(0) + r.wsize;\n" +
                        "        if r.wburst = AXI_BURST_WRAP then\n" +
                        "            v_waddr_burst_nxt_swp(0)(CFG_SYSBUS_ADDR_BITS-1 downto 5) \n" +
                        "                 := r.waddr(1)(CFG_SYSBUS_ADDR_BITS-1 downto 5);\n" +
                        "            v_waddr_burst_nxt_swp(1)(CFG_SYSBUS_ADDR_BITS-1 downto 5) \n" +
                        "                 := r.waddr(0)(CFG_SYSBUS_ADDR_BITS-1 downto 5);\n" +
                        "        end if;\n" +
                        "    else\n" +
                        "        v_waddr_burst_nxt_swp(0) := r.waddr(0) + r.wsize;\n" +
                        "        v_waddr_burst_nxt_swp(1) := r.waddr(1) + r.wsize;\n" +
                        "        if r.wburst = AXI_BURST_WRAP then\n" +
                        "            v_waddr_burst_nxt_swp(0)(CFG_SYSBUS_ADDR_BITS-1 downto 5) \n" +
                        "                 := r.waddr(0)(CFG_SYSBUS_ADDR_BITS-1 downto 5);\n" +
                        "            v_waddr_burst_nxt_swp(1)(CFG_SYSBUS_ADDR_BITS-1 downto 5) \n" +
                        "                 := r.waddr(1)(CFG_SYSBUS_ADDR_BITS-1 downto 5);\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    v_we := (others => '0');\n" +
                        "\n" +
                        "    v_ar_ready := '0';\n" +
                        "    v_r_valid := '0';\n" +
                        "    v_r_last := '0';\n" +
                        "    v_aw_ready := '0';\n" +
                        "    v_w_ready := '0';\n" +
                        "\n" +
                        "    -- Reading state machine:\n" +
                        "    case r.rstate is\n" +
                        "    when rwait =>\n" +
                        "        v_ar_ready := '1';\n" +
                        "        v_radr := v_raddr_bus_swp;\n" +
                        "\n" +
                        "        if i_xslvi.ar_valid = '1' then\n" +
                        "            if i_xslvi.aw_valid = '0' and r.wstate = wwait then\n" +
                        "                v_re := '1';\n" +
                        "                v.rstate := rtrans;\n" +
                        "                v.raddr := v_raddr_bus_nxt_swp;\n" +
                        "            else\n" +
                        "                v.rstate := rhold;\n" +
                        "                v.raddr := v_raddr_bus_swp;\n" +
                        "            end if;\n" +
                        "\n" +
                        "            if i_xslvi.ar_bits.size = \"010\" then\n" +
                        "                v_r32 := '1';\n" +
                        "            end if;\n" +
                        "            v.rswap := i_xslvi.ar_bits.addr(2);\n" +
                        "            v.rsize := XSizeToBytes(conv_integer(i_xslvi.ar_bits.size));\n" +
                        "            v.rburst := i_xslvi.ar_bits.burst;\n" +
                        "            v.rlen := conv_integer(i_xslvi.ar_bits.len);\n" +
                        "            v.rid := i_xslvi.ar_id;\n" +
                        "            v.rresp := AXI_RESP_OKAY;\n" +
                        "            v.ruser := i_xslvi.ar_user;\n" +
                        "        end if;\n" +
                        "    when rhold =>\n" +
                        "        v_radr := r.raddr;\n" +
                        "        if r.rsize = 4 then\n" +
                        "            v_r32 := '1';\n" +
                        "        end if;\n" +
                        "        if i_xslvi.aw_valid = '0' and r.wstate = wwait then\n" +
                        "            v_re := '1';\n" +
                        "            v.rstate := rtrans;\n" +
                        "            v.raddr := v_raddr_burst_nxt_swp;\n" +
                        "        end if;\n" +
                        "    when rtrans =>\n" +
                        "        v_r_valid := i_ready;\n" +
                        "        v_radr := r.raddr;\n" +
                        "        if r.rlen /= 0 then\n" +
                        "            v_re := '1';   -- request next burst read address even if no ready data\n" +
                        "        end if;\n" +
                        "        if r.rsize = 4 then\n" +
                        "            v_r32 := '1';\n" +
                        "        end if;\n" +
                        "        if i_xslvi.r_ready = '1' and i_ready = '1' then\n" +
                        "            if r.rsize = 4 then\n" +
                        "                v.rswap := not r.rswap;\n" +
                        "            end if;\n" +
                        "            v.raddr := v_raddr_burst_nxt_swp;\n" +
                        "            -- End of transaction (or process another one):\n" +
                        "            if r.rlen = 0 then\n" +
                        "                v_r_last := '1';\n" +
                        "                v_ar_ready := '1';\n" +
                        "                v_radr := v_raddr_bus_swp;\n" +
                        "                if i_xslvi.ar_valid = '1' then\n" +
                        "                    if i_xslvi.aw_valid = '0' and r.wstate = wwait then\n" +
                        "                        v_re := '1';\n" +
                        "                        v.rstate := rtrans;\n" +
                        "                        v.raddr := v_raddr_bus_nxt_swp;\n" +
                        "                    else\n" +
                        "                        v.rstate := rhold;\n" +
                        "                        v.raddr := v_raddr_bus_swp;\n" +
                        "                    end if;\n" +
                        "\n" +
                        "                    if i_xslvi.ar_bits.size = \"010\" then\n" +
                        "                        v_r32 := '1';\n" +
                        "                    end if;\n" +
                        "                    v.rswap := i_xslvi.ar_bits.addr(2);\n" +
                        "                    v.rsize := XSizeToBytes(conv_integer(i_xslvi.ar_bits.size));\n" +
                        "                    v.rburst := i_xslvi.ar_bits.burst;\n" +
                        "                    v.rlen := conv_integer(i_xslvi.ar_bits.len);\n" +
                        "                    v.rid := i_xslvi.ar_id;\n" +
                        "                    v.rresp := AXI_RESP_OKAY;\n" +
                        "                    v.ruser := i_xslvi.ar_user;\n" +
                        "                else\n" +
                        "                    v.rstate := rwait;\n" +
                        "                end if;\n" +
                        "            else\n" +
                        "                v.rlen := r.rlen - 1;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    end case;\n" +
                        "\n" +
                        "    -- Writing state machine:\n" +
                        "    case r.wstate is\n" +
                        "    when wwait =>\n" +
                        "        if r.rlen = 0 or r.rstate = rhold then\n" +
                        "            v_aw_ready := '1';\n" +
                        "        end if;\n" +
                        "        if i_xslvi.aw_valid = '1' and (r.rlen = 0 or r.rstate = rhold) then\n" +
                        "            v.wstate := wtrans;\n" +
                        "            v.waddr := v_wadr_bus_swp;\n" +
                        "            v.wswap := i_xslvi.aw_bits.addr(2);\n" +
                        "            v.wsize := XSizeToBytes(conv_integer(i_xslvi.aw_bits.size));\n" +
                        "            v.wburst := i_xslvi.aw_bits.burst;\n" +
                        "            v.wlen := conv_integer(i_xslvi.aw_bits.len);\n" +
                        "            v.wid := i_xslvi.aw_id;\n" +
                        "            v.wresp := AXI_RESP_OKAY;\n" +
                        "            v.wuser := i_xslvi.aw_user;\n" +
                        "        end if;\n" +
                        "    when wtrans =>\n" +
                        "        v_we := (others => '1');\n" +
                        "        v_w_ready := i_ready;\n" +
                        "        if i_xslvi.w_valid = '1' and i_ready = '1' then\n" +
                        "            if r.wsize = 4 then\n" +
                        "                v.wswap := not r.wswap;\n" +
                        "            end if;\n" +
                        "            v.waddr := v_waddr_burst_nxt_swp;\n" +
                        "            -- End of transaction:\n" +
                        "            if r.wlen = 0 then\n" +
                        "                v.b_valid := '1';\n" +
                        "                v_aw_ready := '1';\n" +
                        "                if i_xslvi.aw_valid = '0' then\n" +
                        "                    v.wstate := wwait;\n" +
                        "                else\n" +
                        "                    v.waddr := v_wadr_bus_swp;\n" +
                        "                    v.wswap := i_xslvi.aw_bits.addr(2);\n" +
                        "                    v.wsize := XSizeToBytes(conv_integer(i_xslvi.aw_bits.size));\n" +
                        "                    v.wburst := i_xslvi.aw_bits.burst;\n" +
                        "                    v.wlen := conv_integer(i_xslvi.aw_bits.len);\n" +
                        "                    v.wid := i_xslvi.aw_id;\n" +
                        "                    v.wresp := AXI_RESP_OKAY;\n" +
                        "                    v.wuser := i_xslvi.aw_user;\n" +
                        "                end if;\n" +
                        "            else\n" +
                        "                v.wlen := r.wlen - 1;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    end case;\n" +
                        "\n" +
                        "    if i_xslvi.b_ready = '1' and r.b_valid = '1' then\n" +
                        "        if r.wstate = wtrans and i_xslvi.w_valid = '1' and r.wlen = 0 then\n" +
                        "            v.b_valid := '1';\n" +
                        "        else\n" +
                        "            v.b_valid := '0';\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- AXI Lite must be 8-byte aligned in this implementation\n" +
                        "    if r.wswap = '0' then\n" +
                        "        v_wdata := i_xslvi.w_data;\n" +
                        "        v_wstrb := i_xslvi.w_strb and v_we;\n" +
                        "    else\n" +
                        "        v_wdata(31 downto 0) := i_xslvi.w_data(63 downto 32);\n" +
                        "        v_wdata(63 downto 32) := i_xslvi.w_data(31 downto 0);\n" +
                        "        v_wstrb := (i_xslvi.w_strb(3 downto 0) & i_xslvi.w_strb(7 downto 4))\n" +
                        "               and (v_we(3 downto 0) & v_we(7 downto 4));\n" +
                        "    end if;\n" +
                        "\n" +
                        "    o_re <= v_re;\n" +
                        "    o_radr <= v_radr;\n" +
                        "    o_r32 <= v_r32;\n" +
                        "    o_wadr <= r.waddr;\n" +
                        "    o_we <= v_we(0);\n" +
                        "    o_wdata <= v_wdata;\n" +
                        "    o_wstrb <= v_wstrb;\n" +
                        "\n" +
                        "    if r.rswap = '0' then\n" +
                        "        vb_r_data := i_rdata;\n" +
                        "    else\n" +
                        "        vb_r_data := i_rdata(31 downto 0) & i_rdata(63 downto 32);\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := AXI_SLAVE_BANK_RESET;\n" +
                        "    end if;\n" +
                        " \n" +
                        "    rin <= v;\n" +
                        "\n" +
                        "    o_xslvo.aw_ready <= v_aw_ready;\n" +
                        "    o_xslvo.w_ready <= v_w_ready;\n" +
                        "    o_xslvo.ar_ready <= v_ar_ready;\n" +
                        "    o_xslvo.r_valid <= v_r_valid;\n" +
                        "    o_xslvo.r_last <= v_r_last;\n" +
                        "    o_xslvo.r_data <= vb_r_data;\n" +
                        "    o_xslvo.r_id <= r.rid;\n" +
                        "    o_xslvo.r_resp <= r.rresp;\n" +
                        "    o_xslvo.r_user <= r.ruser;\n" +
                        "\n" +
                        "    -- Write Handshaking:\n" +
                        "    o_xslvo.b_id <= r.wid;\n" +
                        "    o_xslvo.b_resp <= r.wresp;\n" +
                        "    o_xslvo.b_user <= r.wuser;\n" +
                        "    o_xslvo.b_valid <= r.b_valid;\n" +
                        "\n" +
                        "  end process;\n" +
                        "\n" +
                        "  -- registers\n" +
                        "  regs : process(i_clk, i_nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "         r <= AXI_SLAVE_BANK_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "         r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_defslv_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "library ambalib;\n" +
                        "use ambalib.types_amba4.all;\n" +
                        "\n" +
                        "entity axi4_defslv is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_xslvi : in axi4_slave_in_type;\n" +
                        "    o_xslvo : out axi4_slave_out_type\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_axi4_defslv of axi4_defslv is\n" +
                        "\n" +
                        "  type defslv_state_type is (DefSlave_Idle, DefSlave_R, DefSlave_W, DefSlave_B);\n" +
                        "\n" +
                        "  type registers_type is record\n" +
                        "    state : defslv_state_type;\n" +
                        "    burst_cnt : std_logic_vector(7 downto 0);\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : registers_type := (DefSlave_Idle, X\"00\");\n" +
                        "\n" +
                        "  signal rin, r : registers_type;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  comblogic : process(i_nrst, i_xslvi, r)\n" +
                        "    variable v : registers_type;\n" +
                        "    variable vslvo : axi4_slave_out_type;\n" +
                        "  begin\n" +
                        "    v := r;\n" +
                        "    vslvo := axi4_slave_out_none;\n" +
                        "    vslvo.b_resp := AXI_RESP_DECERR;\n" +
                        "    vslvo.r_resp := AXI_RESP_DECERR;\n" +
                        "\n" +
                        "    case r.state is\n" +
                        "    when DefSlave_Idle =>\n" +
                        "        vslvo.ar_ready := '1';\n" +
                        "        vslvo.aw_ready := '1';\n" +
                        "        if i_xslvi.aw_valid = '1' then\n" +
                        "            vslvo.ar_ready := '0';\n" +
                        "            v.state := DefSlave_W;\n" +
                        "            v.burst_cnt := i_xslvi.aw_bits.len;\n" +
                        "        elsif i_xslvi.ar_valid = '1' then\n" +
                        "            v.state := DefSlave_R;\n" +
                        "            v.burst_cnt := i_xslvi.ar_bits.len;\n" +
                        "        end if;\n" +
                        "    when DefSlave_R =>\n" +
                        "        vslvo.r_valid := '1';\n" +
                        "        vslvo.r_data := (others => '1');\n" +
                        "        if r.burst_cnt = X\"00\" then\n" +
                        "           v.state := DefSlave_Idle;\n" +
                        "           vslvo.r_last := '1';\n" +
                        "        else\n" +
                        "           v.burst_cnt := r.burst_cnt - 1;\n" +
                        "        end if;\n" +
                        "    when DefSlave_W =>\n" +
                        "        vslvo.w_ready := '1';\n" +
                        "        if r.burst_cnt = X\"00\" then\n" +
                        "           v.state := DefSlave_B;\n" +
                        "        else\n" +
                        "           v.burst_cnt := r.burst_cnt - 1;\n" +
                        "        end if;\n" +
                        "    when DefSlave_B =>\n" +
                        "        vslvo.b_valid := '1';\n" +
                        "        v.state := DefSlave_Idle;\n" +
                        "    when others =>\n" +
                        "    end case;\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    rin <= v;\n" +
                        "    o_xslvo <= vslvo;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  -- registers\n" +
                        "  regs : process(i_clk, i_nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "         r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "         r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_types_amba4_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "--! Standard library\n" +
                        "library ieee;\n" +
                        "--! Standard signal types import\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--! Standard numerical types import\n" +
                        "use ieee.numeric_std.all;\n" +
                        "--! Common constants and data conversion functions library\n" +
                        "library commonlib;\n" +
                        "--! Import SoC specific types common for all devices\n" +
                        "use commonlib.types_common.all;\n" +
                        "\n" +
                        "--! @brief   System bus AMBA AXI(NASTI) types definition.\n" +
                        "--! @details This package provides general constants, data structures and\n" +
                        "--!          and functions description that define behaviour of all\n" +
                        "--!          peripheries devices implementing AXI4 interface.\n" +
                        "package types_amba4 is\n" +
                        "\n" +
                        "--! @defgroup scala_cfg_group SCALA generated parameters\n" +
                        "--! @ingroup axi4_config_generic_group\n" +
                        "--! @details  This constant must correspond to Scala defined ones.\n" +
                        "--! @{\n" +
                        "\n" +
                        "--! User defined address ID bitwidth (aw_id / ar_id fields).\n" +
                        "constant CFG_ROCKET_ID_BITS      : integer := 5;\n" +
                        "--! Data bus bits width.\n" +
                        "constant CFG_SYSBUS_DATA_BITS    : integer := 64;\n" +
                        "--! Data bus bytes width\n" +
                        "constant CFG_SYSBUS_DATA_BYTES   : integer := CFG_SYSBUS_DATA_BITS / 8;\n" +
                        "\n" +
                        "--! Address bus bits width.\n" +
                        "constant CFG_SYSBUS_ADDR_BITS    : integer := 32;\n" +
                        "--! Definition of number of bits in address bus per one data transaction.\n" +
                        "constant CFG_SYSBUS_ADDR_OFFSET  : integer := log2(CFG_SYSBUS_DATA_BYTES);\n" +
                        "--! @brief Number of address bits used for device addressing. \n" +
                        "--! @details Default is 12 bits = 4 KB of address space minimum per each \n" +
                        "--!          mapped device.\n" +
                        "constant CFG_SYSBUS_CFG_ADDR_BITS : integer := CFG_SYSBUS_ADDR_BITS-12;\n" +
                        "--! @brief Global alignment is set 32 bits.\n" +
                        "constant CFG_ALIGN_BYTES         : integer := 4;\n" +
                        "--! @brief  Number of parallel access to the atomic data.\n" +
                        "constant CFG_WORDS_ON_BUS        : integer := CFG_SYSBUS_DATA_BYTES/CFG_ALIGN_BYTES;\n" +
                        "--! @}\n" +
                        "\n" +
                        "--! @name   AXI Response values\n" +
                        "--! @brief  AMBA 4.0 specified response types from a slave device.\n" +
                        "--! @{\n" +
                        "\n" +
                        "--! @brief Normal access success. \n" +
                        "--! @details Indicates that a normal access has been\n" +
                        "--! successful. Can also indicate an exclusive access has failed. \n" +
                        "constant AXI_RESP_OKAY     : std_logic_vector(1 downto 0) := \"00\";\n" +
                        "--! @brief Exclusive access okay. \n" +
                        "--! @details Indicates that either the read or write\n" +
                        "--! portion of an exclusive access has been successful.\n" +
                        "constant AXI_RESP_EXOKAY   : std_logic_vector(1 downto 0) := \"01\";\n" +
                        "--! @brief Slave error. \n" +
                        "--! @details Used when the access has reached the slave successfully,\n" +
                        "--! but the slave wishes to return an error condition to the originating\n" +
                        "--! master.\n" +
                        "constant AXI_RESP_SLVERR   : std_logic_vector(1 downto 0) := \"10\";\n" +
                        "--! @brief Decode error. \n" +
                        "--! @details Generated, typically by an interconnect component,\n" +
                        "--! to indicate that there is no slave at the transaction address.\n" +
                        "constant AXI_RESP_DECERR   : std_logic_vector(1 downto 0) := \"11\";\n" +
                        "--! @}\n" +
                        "\n" +
                        "--! @name   AXI burst request type.\n" +
                        "--! @brief  AMBA 4.0 specified burst operation request types.\n" +
                        "--! @{\n" +
                        "\n" +
                        "--! @brief Fixed address burst operation.\n" +
                        "--! @details The address is the same for every transfer in the burst \n" +
                        "--!          (FIFO type)\n" +
                        "constant AXI_BURST_FIXED   : std_logic_vector(1 downto 0) := \"00\";\n" +
                        "--! @brief Burst operation with address increment.\n" +
                        "--! @details The address for each transfer in the burst is an increment of\n" +
                        "--!        the address for the previous transfer. The increment value depends \n" +
                        "--!        on the size of the transfer.\n" +
                        "constant AXI_BURST_INCR    : std_logic_vector(1 downto 0) := \"01\";\n" +
                        "--! @brief Burst operation with address increment and wrapping.\n" +
                        "--! @details A wrapping burst is similar to an incrementing burst, except that\n" +
                        "--!          the address wraps around to a lower address if an upper address \n" +
                        "--!          limit is reached\n" +
                        "constant AXI_BURST_WRAP    : std_logic_vector(1 downto 0) := \"10\";\n" +
                        "--! @}\n" +
                        "\n" +
                        "--! @name Vendor IDs defintion.\n" +
                        "--! @{\n" +
                        "\n" +
                        "--! GNSS Sensor Ltd. vendor identificator.\n" +
                        "constant VENDOR_GNSSSENSOR        : std_logic_vector(15 downto 0) := X\"00F1\"; \n" +
                        "--! @}\n" +
                        "\n" +
                        "--! @name Master Device IDs definition:\n" +
                        "--! @{\n" +
                        "\n" +
                        "--! Empty master slot device\n" +
                        "constant MST_DID_EMPTY            : std_logic_vector(15 downto 0) := X\"7755\";\n" +
                        "--! RISC-V \"Rocket-chip\" core Cached TileLink master device.\n" +
                        "constant RISCV_CACHED_TILELINK    : std_logic_vector(15 downto 0) := X\"0500\";\n" +
                        "--! RISC-V \"Rocket-chip\" core Uncached TileLink master device.\n" +
                        "constant RISCV_UNCACHED_TILELINK  : std_logic_vector(15 downto 0) := X\"0501\";\n" +
                        "--! Ethernet MAC master device.\n" +
                        "constant GAISLER_ETH_MAC_MASTER   : std_logic_vector(15 downto 0) := X\"0502\";\n" +
                        "--! Ethernet MAC master debug interface (EDCL).\n" +
                        "constant GAISLER_ETH_EDCL_MASTER  : std_logic_vector(15 downto 0) := X\"0503\";\n" +
                        "--! \"River\" CPU Device ID.\n" +
                        "constant RISCV_RIVER_CPU          : std_logic_vector(15 downto 0) := X\"0505\";\n" +
                        "--! UART with DMA: Test Access Point (TAP)\n" +
                        "constant GNSSSENSOR_UART_TAP      : std_logic_vector(15 downto 0) := X\"050A\";\n" +
                        "--! JTAG Test Access Point (TAP)\n" +
                        "constant GNSSSENSOR_JTAG_TAP      : std_logic_vector(15 downto 0) := X\"050B\";\n" +
                        "--! @}\n" +
                        "\n" +
                        "--! @name Slave Device IDs definition:\n" +
                        "--! @{\n" +
                        "\n" +
                        "--! Empty slave slot device\n" +
                        "constant SLV_DID_EMPTY           : std_logic_vector(15 downto 0) := X\"5577\";\n" +
                        "--! GNSS Engine Stub device\n" +
                        "constant GNSS_SUB_SYSTEM         : std_logic_vector(15 downto 0) := X\"0067\";\n" +
                        "--! GNSS Engine Stub device\n" +
                        "constant GNSSSENSOR_ENGINE_STUB   : std_logic_vector(15 downto 0) := X\"0068\";\n" +
                        "--! Fast Search Engines Device ID provided by gnsslib\n" +
                        "constant GNSSSENSOR_FSE_V2_GPS    : std_logic_vector(15 downto 0) := X\"0069\";\n" +
                        "--! Boot ROM Device ID\n" +
                        "constant GNSSSENSOR_ROM           : std_logic_vector(15 downto 0) := X\"0071\";\n" +
                        "--! Internal SRAM block Device ID\n" +
                        "constant GNSSSENSOR_SRAM          : std_logic_vector(15 downto 0) := X\"0073\";\n" +
                        "--! Configuration Registers Module Device ID provided by gnsslib\n" +
                        "constant GNSSSENSOR_PNP           : std_logic_vector(15 downto 0) := X\"0074\";\n" +
                        "--! SD-card controller Device ID provided by gnsslib\n" +
                        "constant GNSSSENSOR_SPI_FLASH     : std_logic_vector(15 downto 0) := X\"0075\";\n" +
                        "--! General purpose IOs Device ID provided by gnsslib\n" +
                        "constant GNSSSENSOR_GPIO          : std_logic_vector(15 downto 0) := X\"0076\";\n" +
                        "--! RF front-end controller Device ID provided by gnsslib\n" +
                        "constant GNSSSENSOR_RF_CONTROL    : std_logic_vector(15 downto 0) := X\"0077\";\n" +
                        "--! GNSS Engine Device ID provided by gnsslib\n" +
                        "constant GNSSSENSOR_ENGINE        : std_logic_vector(15 downto 0) := X\"0078\";\n" +
                        "--! rs-232 UART Device ID\n" +
                        "constant GNSSSENSOR_UART          : std_logic_vector(15 downto 0) := X\"007a\";\n" +
                        "--! Accelerometer Device ID provided by gnsslib\n" +
                        "constant GNSSSENSOR_ACCELEROMETER : std_logic_vector(15 downto 0) := X\"007b\";\n" +
                        "--! Gyroscope Device ID provided by gnsslib\n" +
                        "constant GNSSSENSOR_GYROSCOPE     : std_logic_vector(15 downto 0) := X\"007c\";\n" +
                        "--! Interrupt controller\n" +
                        "constant GNSSSENSOR_IRQCTRL       : std_logic_vector(15 downto 0) := X\"007d\";\n" +
                        "--! Ethernet MAC inherited from Gaisler greth module.\n" +
                        "constant GNSSSENSOR_ETHMAC        : std_logic_vector(15 downto 0) := X\"007f\";\n" +
                        "--! Debug Support Unit device id.\n" +
                        "constant GNSSSENSOR_DSU           : std_logic_vector(15 downto 0) := X\"0080\";\n" +
                        "--! GP Timers device id.\n" +
                        "constant GNSSSENSOR_GPTIMERS      : std_logic_vector(15 downto 0) := X\"0081\";\n" +
                        "--! ADC samples recorder\n" +
                        "constant GNSSSENSOR_ADC_RECORDER  : std_logic_vector(15 downto 0) := X\"0082\";\n" +
                        "-- OTP Memory 8KB bank\n" +
                        "constant GNSSSENSOR_OTP_8KB       : std_logic_vector(15 downto 0) := X\"0083\";\n" +
                        "--! @}\n" +
                        "\n" +
                        "--! @name Decoder of the transaction size.\n" +
                        "--! @{\n" +
                        "\n" +
                        "--! Burst length size decoder\n" +
                        "constant XSIZE_TOTAL : integer := 8;\n" +
                        "--! Definition of the AXI bytes converter.\n" +
                        "type xsize_type is array (0 to XSIZE_TOTAL-1) of integer;\n" +
                        "--! Decoder of the transaction bytes from AXI format to Bytes.\n" +
                        "constant XSizeToBytes : xsize_type := (\n" +
                        "   0 => 1,\n" +
                        "   1 => 2,\n" +
                        "   2 => 4,\n" +
                        "   3 => 8,\n" +
                        "   4 => 16,\n" +
                        "   5 => 32,\n" +
                        "   6 => 64,\n" +
                        "   7 => 128\n" +
                        ");\n" +
                        "--! @}\n" +
                        "\n" +
                        "--! @name Plug'n'Play descriptor constants.\n" +
                        "--! @{\n" +
                        "--! Undefined type of the descriptor (empty device).\n" +
                        "constant PNP_CFG_TYPE_INVALID   : std_logic_vector := \"00\";\n" +
                        "--! AXI slave device standard descriptor.\n" +
                        "constant PNP_CFG_TYPE_MASTER  : std_logic_vector := \"01\";\n" +
                        "--! AXI master device standard descriptor.\n" +
                        "constant PNP_CFG_TYPE_SLAVE : std_logic_vector := \"10\";\n" +
                        "--! @brief Size in bytes of the standard slave descriptor..\n" +
                        "--! @details Firmware uses this value instead of sizeof(nasti_slave_config_type).\n" +
                        "constant PNP_CFG_SLAVE_DESCR_BYTES : std_logic_vector(7 downto 0) := X\"10\";\n" +
                        "--! @brief Size in bytes of the standard master descriptor.\n" +
                        "--! @details Firmware uses this value instead of sizeof(nasti_master_config_type).\n" +
                        "constant PNP_CFG_MASTER_DESCR_BYTES : std_logic_vector(7 downto 0) := X\"08\";\n" +
                        "--! @}\n" +
                        "\n" +
                        "\n" +
                        "--! @brief   Plug-n-play descriptor structure for slave device.\n" +
                        "--! @details Each slave device must generates this datatype output that\n" +
                        "--!          is connected directly to the 'pnp' slave module on system bus.\n" +
                        "type axi4_slave_config_type is record\n" +
                        "    --! Descriptor size in bytes.\n" +
                        "    descrsize : std_logic_vector(7 downto 0);\n" +
                        "    --! Descriptor type.\n" +
                        "    descrtype : std_logic_vector(1 downto 0);\n" +
                        "    --! Descriptor size in bytes.\n" +
                        "    irq_idx : std_logic_vector(7 downto 0);\n" +
                        "    --! Base address value.\n" +
                        "    xaddr  : std_logic_vector(CFG_SYSBUS_CFG_ADDR_BITS-1 downto 0);\n" +
                        "    --! Maskable bits of the base address.\n" +
                        "    xmask  : std_logic_vector(CFG_SYSBUS_CFG_ADDR_BITS-1 downto 0);\n" +
                        "    --! Vendor ID.\n" +
                        "    vid    : std_logic_vector(15 downto 0);\n" +
                        "    --! Device ID.\n" +
                        "    did    : std_logic_vector(15 downto 0);\n" +
                        "end record;\n" +
                        "\n" +
                        "--! @brief Default slave config value.\n" +
                        "--! @default This value corresponds to an empty device and often used\n" +
                        "--!          as assignment of outputs for the disabled device.\n" +
                        "constant axi4_slave_config_none : axi4_slave_config_type := (\n" +
                        "    PNP_CFG_SLAVE_DESCR_BYTES, PNP_CFG_TYPE_SLAVE, (others => '0'), \n" +
                        "    (others => '0'), (others => '0'), VENDOR_GNSSSENSOR, SLV_DID_EMPTY);\n" +
                        "\n" +
                        "\n" +
                        "--! @brief   Plug-n-play descriptor structure for master device.\n" +
                        "--! @details Each master device must generates this datatype output that\n" +
                        "--!          is connected directly to the 'pnp' slave module on system bus.\n" +
                        "type axi4_master_config_type is record\n" +
                        "    --! Descriptor size in bytes.\n" +
                        "    descrsize : std_logic_vector(7 downto 0);\n" +
                        "    --! Descriptor type.\n" +
                        "    descrtype : std_logic_vector(1 downto 0);\n" +
                        "    --! Vendor ID.\n" +
                        "    vid    : std_logic_vector(15 downto 0);\n" +
                        "    --! Device ID.\n" +
                        "    did    : std_logic_vector(15 downto 0);\n" +
                        "end record;\n" +
                        "\n" +
                        "--! @brief Default master config value.\n" +
                        "constant axi4_master_config_none : axi4_master_config_type := (\n" +
                        "    PNP_CFG_MASTER_DESCR_BYTES, PNP_CFG_TYPE_MASTER, \n" +
                        "    VENDOR_GNSSSENSOR, MST_DID_EMPTY);\n" +
                        "\n" +
                        "\n" +
                        "--! @brief AMBA AXI4 compliant data structure.\n" +
                        "type axi4_metadata_type is record\n" +
                        "  --! @brief Read address.\n" +
                        "  --! @details The read address gives the address of the first transfer\n" +
                        "  --!          in a read burst transaction.\n" +
                        "  addr   : std_logic_vector(CFG_SYSBUS_ADDR_BITS-1 downto 0);\n" +
                        "  --! @brief   Burst length.\n" +
                        "  --! @details This signal indicates the exact number of transfers in \n" +
                        "  --!          a burst. This changes between AXI3 and AXI4. nastiXLenBits=8 so\n" +
                        "  --!          this is an AXI4 implementation.\n" +
                        "  --!              Burst_Length = len[7:0] + 1\n" +
                        "  len    : std_logic_vector(7 downto 0);\n" +
                        "  --! @brief   Burst size.\n" +
                        "  --! @details This signal indicates the size of each transfer \n" +
                        "  --!          in the burst: 0=1 byte; ..., 6=64 bytes; 7=128 bytes;\n" +
                        "  size   : std_logic_vector(2 downto 0);\n" +
                        "  --! @brief   Read response.\n" +
                        "  --! @details This signal indicates the status of the read transfer. \n" +
                        "  --! The responses are:\n" +
                        "  --!      0b00 FIXED - In a fixed burst, the address is the same for every transfer \n" +
                        "  --!                  in the burst. Typically is used for FIFO.\n" +
                        "  --!      0b01 INCR - Incrementing. In an incrementing burst, the address for each\n" +
                        "  --!                  transfer in the burst is an increment of the address for the \n" +
                        "  --!                  previous transfer. The increment value depends on the size of \n" +
                        "  --!                  the transfer.\n" +
                        "  --!      0b10 WRAP - A wrapping burst is similar to an incrementing burst, except \n" +
                        "  --!                  that the address wraps around to a lower address if an upper address \n" +
                        "  --!                  limit is reached.\n" +
                        "  --!      0b11 resrved.\n" +
                        "  burst  : std_logic_vector(1 downto 0);\n" +
                        "  --! @brief   Lock type.\n" +
                        "  --! @details Not supported in AXI4.\n" +
                        "  lock   : std_logic;\n" +
                        "  --! @brief   Memory type.\n" +
                        "  --! @details See table for write and read transactions.\n" +
                        "  cache  : std_logic_vector(3 downto 0);\n" +
                        "  --! @brief   Protection type.\n" +
                        "  --! @details This signal indicates the privilege and security level \n" +
                        "  --!          of the transaction, and whether the transaction is a data access\n" +
                        "  --!          or an instruction access:\n" +
                        "  --!  [0] :   0 = Unpriviledge access\n" +
                        "  --!          1 = Priviledge access\n" +
                        "  --!  [1] :   0 = Secure access\n" +
                        "  --!          1 = Non-secure access\n" +
                        "  --!  [2] :   0 = Data access\n" +
                        "  --!          1 = Instruction access\n" +
                        "  prot   : std_logic_vector(2 downto 0);\n" +
                        "  --! @brief   Quality of Service, QoS. \n" +
                        "  --! @details QoS identifier sent for each read transaction. \n" +
                        "  --!          Implemented only in AXI4:\n" +
                        "  --!              0b0000 - default value. Indicates that the interface is \n" +
                        "  --!                       not participating in any QoS scheme.\n" +
                        "  qos    : std_logic_vector(3 downto 0);\n" +
                        "  --! @brief Region identifier.\n" +
                        "  --! @details Permits a single physical interface on a slave to be used for \n" +
                        "  --!          multiple logical interfaces. Implemented only in AXI4. This is \n" +
                        "  --!          similar to the banks implementation in Leon3 without address \n" +
                        "  --!          decoding.\n" +
                        "  region : std_logic_vector(3 downto 0);\n" +
                        "end record;\n" +
                        "\n" +
                        "--! @brief Empty metadata value.\n" +
                        "constant META_NONE : axi4_metadata_type := (\n" +
                        "  (others =>'0'), X\"00\", \"000\", AXI_BURST_INCR, '0', X\"0\", \"000\", \"0000\", \"0000\"\n" +
                        ");\n" +
                        "\n" +
                        "--! @brief Master device output signals\n" +
                        "type axi4_master_out_type is record\n" +
                        "  --! Write Address channel:\n" +
                        "  aw_valid : std_logic;\n" +
                        "  --! metadata of the read channel.\n" +
                        "  aw_bits : axi4_metadata_type;\n" +
                        "  --! Write address ID. Identification tag used for a trasaction ordering.\n" +
                        "  aw_id   : std_logic_vector(CFG_ROCKET_ID_BITS-1 downto 0);\n" +
                        "  --! Optional user defined signal in a write address channel.\n" +
                        "  aw_user : std_logic;\n" +
                        "  --! Write Data channel valid flag\n" +
                        "  w_valid : std_logic;\n" +
                        "  --! Write channel data value\n" +
                        "  w_data : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "  --! Write Data channel last address in a burst marker.\n" +
                        "  w_last : std_logic;\n" +
                        "  --! Write Data channel strob signals selecting certain bytes.\n" +
                        "  w_strb : std_logic_vector(CFG_SYSBUS_DATA_BYTES-1 downto 0);\n" +
                        "  --! Optional user defined signal in write channel.\n" +
                        "  w_user : std_logic;\n" +
                        "  --! Write Response channel accepted by master.\n" +
                        "  b_ready : std_logic;\n" +
                        "  --! Read Address Channel data valid.\n" +
                        "  ar_valid : std_logic;\n" +
                        "  --! Read Address channel metadata.\n" +
                        "  ar_bits : axi4_metadata_type;\n" +
                        "  --! Read address ID. Identification tag used for a trasaction ordering.\n" +
                        "  ar_id   : std_logic_vector(CFG_ROCKET_ID_BITS-1 downto 0);\n" +
                        "  --! Optional user defined signal in read address channel.\n" +
                        "  ar_user : std_logic;\n" +
                        "  --! Read Data channel:\n" +
                        "  r_ready : std_logic;\n" +
                        "end record;\n" +
                        "\n" +
                        "--! @brief   Master device empty value.\n" +
                        "--! @warning If the master is not connected to the vector then vector value\n" +
                        "--!          MUST BE initialized by this value.\n" +
                        "constant axi4_master_out_none : axi4_master_out_type := (\n" +
                        "      '0', META_NONE, (others=>'0'), '0',\n" +
                        "      '0', (others=>'0'), '0', (others=>'0'), '0', \n" +
                        "      '0', '0', META_NONE, (others=>'0'), '0', '0');\n" +
                        "\n" +
                        "\n" +
                        "--! @brief Master device input signals.\n" +
                        "type axi4_master_in_type is record\n" +
                        "  --! Write Address channel.\n" +
                        "  aw_ready : std_logic;\n" +
                        "  --! Write Data channel.\n" +
                        "  w_ready : std_logic;\n" +
                        "  --! Write Response channel:\n" +
                        "  b_valid : std_logic;\n" +
                        "  b_resp : std_logic_vector(1 downto 0);\n" +
                        "  b_id   : std_logic_vector(CFG_ROCKET_ID_BITS-1 downto 0);\n" +
                        "  b_user : std_logic;\n" +
                        "  --! Read Address Channel\n" +
                        "  ar_ready : std_logic;\n" +
                        "  --! Read valid.\n" +
                        "  r_valid : std_logic;\n" +
                        "  --! @brief Read response. \n" +
                        "  --! @details This signal indicates the status of the read transfer. \n" +
                        "  --!  The responses are:\n" +
                        "  --!      0b00 OKAY - Normal access success. Indicates that a normal access has\n" +
                        "  --!                  been successful. Can also indicate an exclusive access\n" +
                        "  --!                  has failed.\n" +
                        "  --!      0b01 EXOKAY - Exclusive access okay. Indicates that either the read or\n" +
                        "  --!                  write portion of an exclusive access has been successful.\n" +
                        "  --!      0b10 SLVERR - Slave error. Used when the access has reached the slave \n" +
                        "  --!                  successfully, but the slave wishes to return an error\n" +
                        "  --!                  condition to the originating master.\n" +
                        "  --!      0b11 DECERR - Decode error. Generated, typically by an interconnect \n" +
                        "  --!                  component, to indicate that there is no slave at the\n" +
                        "  --!                  transaction address.\n" +
                        "  r_resp : std_logic_vector(1 downto 0);\n" +
                        "  --! Read data\n" +
                        "  r_data : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "  --! @brief  Read last. \n" +
                        "  --! @details This signal indicates the last transfer in a read burst.\n" +
                        "  r_last : std_logic;\n" +
                        "  --! @brief Read ID tag.\n" +
                        "  --! @details This signal is the identification tag for the read data\n" +
                        "  --!          group of signals generated by the slave.\n" +
                        "  r_id   : std_logic_vector(CFG_ROCKET_ID_BITS-1 downto 0);\n" +
                        "  --! @brief User signal. \n" +
                        "  --! @details Optional User-defined signal in the read channel. Supported \n" +
                        "  --!          only in AXI4.\n" +
                        "  r_user : std_logic;\n" +
                        "end record;\n" +
                        "\n" +
                        "constant axi4_master_in_none : axi4_master_in_type := (\n" +
                        "      '0', '0', '0', AXI_RESP_OKAY, (others=>'0'), '0',\n" +
                        "      '0', '0', AXI_RESP_OKAY, (others=>'0'), '0', (others=>'0'), '0');\n" +
                        "\n" +
                        "\n" +
                        "--! @brief Slave device AMBA AXI input signals.\n" +
                        "type axi4_slave_in_type is record\n" +
                        "  --! Write Address channel:\n" +
                        "  aw_valid : std_logic;\n" +
                        "  aw_bits : axi4_metadata_type;\n" +
                        "  aw_id   : std_logic_vector(CFG_ROCKET_ID_BITS-1 downto 0);\n" +
                        "  aw_user : std_logic;\n" +
                        "  --! Write Data channel:\n" +
                        "  w_valid : std_logic;\n" +
                        "  w_data : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "  w_last : std_logic;\n" +
                        "  w_strb : std_logic_vector(CFG_SYSBUS_DATA_BYTES-1 downto 0);\n" +
                        "  w_user : std_logic;\n" +
                        "  --! Write Response channel:\n" +
                        "  b_ready : std_logic;\n" +
                        "  --! Read Address Channel:\n" +
                        "  ar_valid : std_logic;\n" +
                        "  ar_bits : axi4_metadata_type;\n" +
                        "  ar_id   : std_logic_vector(CFG_ROCKET_ID_BITS-1 downto 0);\n" +
                        "  ar_user : std_logic;\n" +
                        "  --! Read Data channel:\n" +
                        "  r_ready : std_logic;\n" +
                        "end record;\n" +
                        "\n" +
                        "constant axi4_slave_in_none : axi4_slave_in_type := (\n" +
                        "      '0', META_NONE, (others=>'0'), '0', '0',\n" +
                        "      (others=>'0'), '0', (others=>'0'), '0', '0', '0', META_NONE,\n" +
                        "      (others=>'0'), '0', '0');\n" +
                        "\n" +
                        "\n" +
                        "--! @brief Slave device AMBA AXI output signals.\n" +
                        "type axi4_slave_out_type is record\n" +
                        "  --! Write Address channel:\n" +
                        "  aw_ready : std_logic;\n" +
                        "  --! Write Data channel:\n" +
                        "  w_ready : std_logic;\n" +
                        "  --! Write Response channel:\n" +
                        "  b_valid : std_logic;\n" +
                        "  b_resp : std_logic_vector(1 downto 0);\n" +
                        "  b_id   : std_logic_vector(CFG_ROCKET_ID_BITS-1 downto 0);\n" +
                        "  b_user : std_logic;\n" +
                        "  --! Read Address Channel\n" +
                        "  ar_ready : std_logic;\n" +
                        "  --! Read Data channel:\n" +
                        "  r_valid : std_logic;\n" +
                        "  --! @brief Read response.\n" +
                        "  --! @details This signal indicates the status of the read transfer. \n" +
                        "  --!  The responses are:\n" +
                        "  --!      0b00 OKAY - Normal access success. Indicates that a normal access has\n" +
                        "  --!                  been successful. Can also indicate an exclusive access\n" +
                        "  --!                  has failed.\n" +
                        "  --!      0b01 EXOKAY - Exclusive access okay. Indicates that either the read or\n" +
                        "  --!                  write portion of an exclusive access has been successful.\n" +
                        "  --!      0b10 SLVERR - Slave error. Used when the access has reached the slave \n" +
                        "  --!                  successfully, but the slave wishes to return an error\n" +
                        "  --!                  condition to the originating master.\n" +
                        "  --!      0b11 DECERR - Decode error. Generated, typically by an interconnect \n" +
                        "  --!                  component, to indicate that there is no slave at the\n" +
                        "  --!                  transaction address.\n" +
                        "  r_resp : std_logic_vector(1 downto 0);\n" +
                        "  --! Read data\n" +
                        "  r_data : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "  --! Read last. This signal indicates the last transfer in a read burst.\n" +
                        "  r_last : std_logic;\n" +
                        "  --! @brief Read ID tag. \n" +
                        "  --! @details This signal is the identification tag for the read data\n" +
                        "  --!           group of signals generated by the slave.\n" +
                        "  r_id   : std_logic_vector(CFG_ROCKET_ID_BITS-1 downto 0);\n" +
                        "  --! @brief User signal. \n" +
                        "  --! @details Optinal User-defined signal in the read channel. Supported \n" +
                        "  --!          only in AXI4.\n" +
                        "  r_user : std_logic;--_vector(0 downto 0);\n" +
                        "end record;\n" +
                        "\n" +
                        "--! @brief Slave output signals connected to system bus.\n" +
                        "--! @details If the slave is not connected to the vector then vector value\n" +
                        "--! MUST BE initialized by this value.\n" +
                        "constant axi4_slave_out_none : axi4_slave_out_type := (\n" +
                        "      '0', '0', '0', AXI_RESP_EXOKAY,\n" +
                        "      (others=>'0'), '0', '0', '0', AXI_RESP_EXOKAY, (others=>'1'), \n" +
                        "      '0', (others=>'0'), '0');\n" +
                        "\n" +
                        "\n" +
                        "--! Array of addresses providing word aligned access.\n" +
                        "type global_addr_array_type is array (0 to CFG_WORDS_ON_BUS-1) \n" +
                        "       of std_logic_vector(CFG_SYSBUS_ADDR_BITS-1 downto 0);\n" +
                        "\n" +
                        "  type dma_state_type is (\n" +
                        "     DMA_STATE_IDLE,\n" +
                        "     DMA_STATE_R_WAIT_RESP,\n" +
                        "     DMA_STATE_R_WAIT_NEXT,\n" +
                        "     DMA_STATE_W,\n" +
                        "     DMA_STATE_W_WAIT_REQ,\n" +
                        "     DMA_STATE_B\n" +
                        "  );\n" +
                        "\n" +
                        "--! @brief Master device to DMA engine request signals\n" +
                        "  type dma_request_type is record\n" +
                        "    valid : std_logic; -- response is valid\n" +
                        "    ready : std_logic; -- ready to accept response\n" +
                        "    write : std_logic;\n" +
                        "    addr : std_logic_vector(CFG_SYSBUS_ADDR_BITS-1 downto 0);\n" +
                        "    bytes : std_logic_vector(10 downto 0);\n" +
                        "    size  : std_logic_vector(2 downto 0); -- 010=4 bytes; 011=8 bytes\n" +
                        "    wdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "  end record;\n" +
                        "\n" +
                        "--! @brief DMA engine to Master device response signals\n" +
                        "  type dma_response_type is record\n" +
                        "    ready : std_logic;  -- ready to accespt request\n" +
                        "    valid : std_logic;  -- response is valid\n" +
                        "    rdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "  end record;\n" +
                        "\n" +
                        "--! DMA engine registers bank\n" +
                        "  type dma_bank_type is record\n" +
                        "    state : dma_state_type;\n" +
                        "    addr2 : std_logic;	          -- addr[2] bits to select low/high dword\n" +
                        "    len   : integer range 0 to 255; -- burst (length-1)\n" +
                        "    op32  : std_logic;\n" +
                        "    wdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant DMA_BANK_RESET : dma_bank_type := (DMA_STATE_IDLE, '0', 0, '0', (others => '0'));\n" +
                        "\n" +
                        "--! Device's DMA engine template procedure with AXI interface.\n" +
                        "--! @param [in]  i_request Device to DMA engine request.\n" +
                        "--! @param [out] o_response DMA Engine to Device response.\n" +
                        "--! @param [in]  i_bank Bank of registers implemented by master device.\n" +
                        "--! @param [out] o_bank Updated value for the master bank of registers.\n" +
                        "--! @param [in]  i_msti AMBA to AXI master device signal.\n" +
                        "--! @param [out] o_msto AXI master device signal to AMBA controller signals.\n" +
                        "procedure procedureAxi4DMA(\n" +
                        "      i_request : in dma_request_type;\n" +
                        "      o_response : out dma_response_type;\n" +
                        "      i_bank : in dma_bank_type;\n" +
                        "      o_bank : out dma_bank_type;\n" +
                        "      i_msti : in axi4_master_in_type;\n" +
                        "      o_msto : out axi4_master_out_type\n" +
                        ");\n" +
                        "\n" +
                        "--! AXI4 slave interface.\n" +
                        "--! @param [in]  i_xcfg  AXI Slave confguration descriptor defining memory base address.\n" +
                        "--! @param [in]  i_xslvi AXI4 slave input interface.\n" +
                        "--! @param [out] o_xslvo AXI4 slave output interface.\n" +
                        "--! @param [in]  i_ready Memory device is ready to accept request.\n" +
                        "--! @param [in]  i_rdata Read data value\n" +
                        "--! @param [out] o_re Read enable\n" +
                        "--! @param [out] o_rswap Read high word32 from 64-bits bus\n" +
                        "--! @param [out] o_radr Memory interface read address array.\n" +
                        "--! @param [out] o_wadr Memory interface write address array.\n" +
                        "--! @param [in]  o_we Write enable\n" +
                        "--! @param [out] o_wstrb Memory interface per byte write enable strobs.\n" +
                        "--! @param [out] o_wdata Memory interface write data value.\n" +
                        "component axi4_slave is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_xcfg : in axi4_slave_config_type;\n" +
                        "    i_xslvi : in axi4_slave_in_type;\n" +
                        "    o_xslvo : out axi4_slave_out_type;\n" +
                        "    i_ready : in std_logic;\n" +
                        "    i_rdata : in std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "    o_re : out std_logic;\n" +
                        "    o_r32 : out std_logic;\n" +
                        "    o_radr : out global_addr_array_type;\n" +
                        "    o_wadr : out global_addr_array_type;\n" +
                        "    o_we : out std_logic;\n" +
                        "    o_wstrb : out std_logic_vector(CFG_SYSBUS_DATA_BYTES-1 downto 0);\n" +
                        "    o_wdata : out std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0)\n" +
                        "  );\n" +
                        "end component; \n" +
                        "\n" +
                        "component axi4_defslv is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_xslvi : in axi4_slave_in_type;\n" +
                        "    o_xslvo : out axi4_slave_out_type\n" +
                        "  );\n" +
                        "end component; \n" +
                        "\n" +
                        "\n" +
                        "end; -- package declaration\n" +
                        "\n" +
                        "--! Implementation of the declared sub-programs (functions and\n" +
                        "--! procedures).\n" +
                        "package body types_amba4 is\n" +
                        "\n" +
                        "  --! Device's DMA engine template procedure with AXI interface.\n" +
                        "  --! @param [in]  i_request Device to DMA engine request.\n" +
                        "  --! @param [out] o_response DMA Engine to Device response.\n" +
                        "  --! @param [in]  i_bank Bank of registers implemented by master device.\n" +
                        "  --! @param [out] o_bank Updated value for the master bank of registers.\n" +
                        "  --! @param [in]  i_msti AMBA to AXI master device signal.\n" +
                        "  --! @param [out] o_msto AXI master device signal to AMBA controller signals.\n" +
                        "  procedure procedureAxi4DMA(\n" +
                        "      i_request : in dma_request_type;\n" +
                        "      o_response : out dma_response_type;\n" +
                        "      i_bank : in dma_bank_type;\n" +
                        "      o_bank : out dma_bank_type;\n" +
                        "      i_msti : in axi4_master_in_type;\n" +
                        "      o_msto : out axi4_master_out_type\n" +
                        "  ) is\n" +
                        "    variable tmp_len : integer;\n" +
                        "  begin\n" +
                        "    o_bank := i_bank;\n" +
                        "    o_msto := axi4_master_out_none;\n" +
                        "    o_msto.ar_user       := '0';\n" +
                        "    o_msto.ar_id         := conv_std_logic_vector(0, CFG_ROCKET_ID_BITS);\n" +
                        "    o_msto.ar_bits.size  := (others => '0');\n" +
                        "    o_msto.ar_bits.burst := AXI_BURST_INCR;\n" +
                        "    o_msto.aw_user       := '0';\n" +
                        "    o_msto.aw_id         := conv_std_logic_vector(0, CFG_ROCKET_ID_BITS);\n" +
                        "    o_msto.aw_bits.size  := (others => '0');\n" +
                        "    o_msto.aw_bits.burst := AXI_BURST_INCR;\n" +
                        "\n" +
                        "    o_response.ready := '0';\n" +
                        "    o_response.valid := '0';\n" +
                        "    o_response.rdata := (others => '0');\n" +
                        "\n" +
                        "    case i_bank.state is\n" +
                        "    when DMA_STATE_IDLE =>\n" +
                        "        o_msto.ar_valid := i_request.valid and not i_request.write;\n" +
                        "        o_msto.aw_valid := i_request.valid and i_request.write;\n" +
                        "        tmp_len := conv_integer(i_request.bytes(10 downto 2)) - 1;\n" +
                        "        if i_request.valid = '1' and i_request.write = '1' then\n" +
                        "            o_msto.aw_bits.addr  := i_request.addr(CFG_SYSBUS_ADDR_BITS-1 downto 3) & \"000\";\n" +
                        "            o_bank.addr2         := i_request.addr(2);\n" +
                        "            o_bank.len  := tmp_len;\n" +
                        "            o_msto.aw_bits.size  := i_request.size; -- 4/8 bytes\n" +
                        "            o_msto.aw_bits.len := conv_std_logic_vector(tmp_len, 8);\n" +
                        "            o_bank.wdata := i_request.wdata;\n" +
                        "            if i_msti.aw_ready = '1' then\n" +
                        "                o_response.ready := '1';\n" +
                        "                o_bank.state := DMA_STATE_W;\n" +
                        "            end if;\n" +
                        "        elsif i_request.valid = '1' and i_request.write = '0' then\n" +
                        "            o_msto.ar_bits.addr  := i_request.addr;\n" +
                        "            o_bank.addr2         := i_request.addr(2);\n" +
                        "            o_bank.len  := tmp_len;\n" +
                        "            o_msto.ar_bits.size  := i_request.size; -- 4/8 bytes\n" +
                        "            o_msto.ar_bits.len := conv_std_logic_vector(tmp_len, 8);\n" +
                        "            if i_msti.ar_ready = '1' then\n" +
                        "                o_response.ready := '1';\n" +
                        "                o_bank.state := DMA_STATE_R_WAIT_RESP;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "        if i_request.size = \"010\" then\n" +
                        "           o_bank.op32 := '1';\n" +
                        "        else\n" +
                        "           o_bank.op32 := '0';\n" +
                        "        end if;\n" +
                        "      \n" +
                        "    when DMA_STATE_R_WAIT_RESP =>\n" +
                        "        o_msto.r_ready := i_request.ready;\n" +
                        "        o_response.valid := i_msti.r_valid;\n" +
                        "        if (i_request.ready and i_msti.r_valid) = '1' then\n" +
                        "            if i_bank.op32 = '1' and i_bank.addr2 = '1' then\n" +
                        "                o_response.rdata := i_msti.r_data(63 downto 32) & i_msti.r_data(31 downto 0);\n" +
                        "            else\n" +
                        "                o_response.rdata := i_msti.r_data;\n" +
                        "            end if;\n" +
                        "\n" +
                        "            if i_msti.r_last = '1' then\n" +
                        "                o_bank.state := DMA_STATE_IDLE;\n" +
                        "            else\n" +
                        "                if i_request.valid = '1' and i_request.write = '0' then\n" +
                        "                    o_response.ready := '1';\n" +
                        "                else\n" +
                        "                    o_bank.state := DMA_STATE_R_WAIT_NEXT;\n" +
                        "                end if;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "\n" +
                        "    when DMA_STATE_R_WAIT_NEXT =>\n" +
                        "        if i_request.valid = '1' and i_request.write = '0' then\n" +
                        "            o_response.ready := '1';\n" +
                        "            o_bank.state := DMA_STATE_R_WAIT_RESP;\n" +
                        "        end if;\n" +
                        "\n" +
                        "    when DMA_STATE_W =>\n" +
                        "        o_msto.w_valid := '1';\n" +
                        "        if i_bank.op32 = '1' then\n" +
                        "            case i_bank.addr2 is\n" +
                        "            when '0' => o_msto.w_strb := X\"0f\";\n" +
                        "            when '1' => o_msto.w_strb := X\"f0\";\n" +
                        "            when others =>\n" +
                        "            end case;\n" +
                        "        else\n" +
                        "            o_msto.w_strb := X\"ff\";\n" +
                        "        end if;\n" +
                        "        o_msto.w_data := i_bank.wdata;\n" +
                        "        \n" +
                        "        if i_msti.w_ready = '1' then\n" +
                        "            if i_bank.len = 0 then\n" +
                        "                o_bank.state := DMA_STATE_B;\n" +
                        "                o_msto.w_last := '1';\n" +
                        "            elsif i_request.valid = '1' and i_request.write = '1' then\n" +
                        "                o_bank.len := i_bank.len - 1;\n" +
                        "                o_bank.wdata := i_request.wdata;\n" +
                        "                o_response.ready := '1';\n" +
                        "                -- Address will be incremented on slave side\n" +
                        "                --v.waddr2 := not r.waddr2;\n" +
                        "            else\n" +
                        "                o_bank.state := DMA_STATE_W_WAIT_REQ;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "\n" +
                        "    when DMA_STATE_W_WAIT_REQ =>\n" +
                        "        if i_request.valid = '1' and i_request.write = '1' then\n" +
                        "            o_bank.len := i_bank.len - 1;\n" +
                        "            o_bank.wdata := i_request.wdata;\n" +
                        "            o_response.ready := '1';\n" +
                        "            o_bank.state := DMA_STATE_W;\n" +
                        "        end if;\n" +
                        "\n" +
                        "    when DMA_STATE_B =>\n" +
                        "        o_msto.w_last := '0';\n" +
                        "        o_msto.b_ready := '1';\n" +
                        "        if i_msti.b_valid = '1' then\n" +
                        "            o_bank.state := DMA_STATE_IDLE;\n" +
                        "        end if;\n" +
                        "    when others =>\n" +
                        "    end case;\n" +
                        "  end; -- procedure\n" +
                        "\n" +
                        "end; -- package body";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_types_bus0_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "--! Standard library\n" +
                        "library ieee;\n" +
                        "--! Standard signal types import\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--! Common constants and data conversion functions library\n" +
                        "library commonlib;\n" +
                        "--! Import SoC specific types common for all devices\n" +
                        "use commonlib.types_common.all;\n" +
                        "library ambalib;\n" +
                        "use ambalib.types_amba4.all;\n" +
                        "\n" +
                        "package types_bus0 is\n" +
                        "\n" +
                        "--! @defgroup slave_id_group AMBA AXI slaves generic IDs.\n" +
                        "--! @ingroup axi4_config_generic_group\n" +
                        "--! @details Each module in a SoC has to be indexed by unique identificator.\n" +
                        "--!          In current implementation it is used sequential indexing for it.\n" +
                        "--!          Indexes are used to specify a device bus item in a vectors.\n" +
                        "--! @{\n" +
                        "\n" +
                        "--! @brief Configuration index of the Boot ROM module visible by the firmware.\n" +
                        "constant CFG_BUS0_XSLV_BOOTROM  : integer := 0;\n" +
                        "--! Configuration index of the SRAM module visible by the firmware.\n" +
                        "constant CFG_BUS0_XSLV_SRAM     : integer := 1;\n" +
                        "--! Configuration index of the UART module.\n" +
                        "constant CFG_BUS0_XSLV_UART1    : integer := 2;\n" +
                        "--! Configuration index of the GPIO (General Purpose In/Out) module.\n" +
                        "constant CFG_BUS0_XSLV_GPIO     : integer := 3;\n" +
                        "--! Configuration index of the Interrupt Controller module.\n" +
                        "constant CFG_BUS0_XSLV_IRQCTRL  : integer := 4;\n" +
                        "--! Configuration index of the Debug Support Unit module.\n" +
                        "constant CFG_BUS0_XSLV_GPTIMERS : integer := 5;\n" +
                        "--! Configuration index of the Perepherals.\n" +
                        "constant CFG_BUS0_XSLV_TIME_MEASUREMENT : integer := 6;\n";
                        for (int i = 0; ((i < Data.Number_Of_Timers_In_Program) && (Data.Compiling_Type == Data.HW_COMPILING)); i++) {
                            data += "constant CFG_BUS0_XSLV_TON_"+Data.Name_of_Timers[i]+" : integer := "+(7+i)+";\n";
                        }
                        for (int i = 0; ((i < Data.Number_Of_PWMs_In_Program) && (Data.Compiling_Type == Data.HW_COMPILING)); i++) {
                            data += "constant CFG_BUS0_XSLV_PWM_"+Data.Name_of_PWMs[i]+" : integer := "+(Data.Number_Of_Timers_In_Program+7+i)+";\n";
                        }
                        for (int i = 0; ((i < Data.Number_Of_PIDs_In_Program) && (Data.Compiling_Type == Data.HW_COMPILING)); i++) {
                            data += "constant CFG_BUS0_XSLV_PID_"+Data.Name_of_PIDs[i]+" : integer := "+(Data.Number_Of_Timers_In_Program+Data.Number_Of_PWMs_In_Program+7+i)+";\n";
                        }
                        int NumberOfSlaves;
                        if (Data.Compiling_Type == Data.HW_COMPILING) {
                            NumberOfSlaves = (7+Data.Number_Of_Timers_In_Program+Data.Number_Of_PWMs_In_Program+Data.Number_Of_PIDs_In_Program);
                        } else {
                            NumberOfSlaves = 7;
                        }
                data += "--! Total number of the slaves devices.\n" +
                        "constant CFG_BUS0_XSLV_TOTAL   : integer := "+NumberOfSlaves+";  \n" +
                        "---! @}\n" +
                        "\n" +
                        "--! @defgroup master_id_group AXI4 masters generic IDs.\n" +
                        "--! @ingroup axi4_config_generic_group\n" +
                        "--! @details Each master must be assigned to a specific ID that used\n" +
                        "--!          as an index in the vector array of AXI master bus.\n" +
                        "--! @{\n" +
                        "\n" +
                        "--! Cached TileLinkIO bus.\n" +
                        "constant CFG_BUS0_XMST_CPU0     : integer := 0;\n" +
                        "--! Total Number of master devices on system bus.\n" +
                        "constant CFG_BUS0_XMST_TOTAL    : integer := 1;\n" +
                        "--! @}\n" +
                        "\n" +
                        "\n" +
                        "type bus0_xslv_cfg_vector is array (0 to CFG_BUS0_XSLV_TOTAL-1) \n" +
                        "       of axi4_slave_config_type;\n" +
                        "\n" +
                        "type bus0_xmst_cfg_vector is array (0 to CFG_BUS0_XMST_TOTAL-1) \n" +
                        "       of axi4_master_config_type;\n" +
                        "\n" +
                        "type bus0_xmst_out_vector is array (0 to CFG_BUS0_XMST_TOTAL-1) \n" +
                        "       of axi4_master_out_type;\n" +
                        "\n" +
                        "type bus0_xmst_in_vector is array (0 to CFG_BUS0_XMST_TOTAL-1) \n" +
                        "       of axi4_master_in_type;\n" +
                        "\n" +
                        "type bus0_xslv_in_vector is array (0 to CFG_BUS0_XSLV_TOTAL-1) \n" +
                        "       of axi4_slave_in_type;\n" +
                        "\n" +
                        "type bus0_xslv_out_vector is array (0 to CFG_BUS0_XSLV_TOTAL-1) \n" +
                        "       of axi4_slave_out_type;\n" +
                        "\n" +
                        "--! @brief   AXI bus controller. \n" +
                        "--! @param [in] watchdog_memop \n" +
                        "--! @param [in] i_clk System bus clock.\n" +
                        "--! @param [in] i_nrst Reset with active LOW level.\n" +
                        "--! @param [in] i_slvcfg Slaves configuration vector.\n" +
                        "--! @param [in] i_slvo Vector of slaves output signals.\n" +
                        "--! @param [in] i_msto Vector of masters output signals.\n" +
                        "--! @param [out] o_slvi Vector of slave inputs.\n" +
                        "--! @param [out] o_msti Vector of master inputs.\n" +
                        "--! @param [out] o_bus_util_w Write access bus utilization\n" +
                        "--! @param [out] o_bus_util_r Read access bus utilization\n" +
                        "--! @todo    Round-robin priority algorithm.\n" +
                        "component axictrl_bus0 is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk    : in std_logic;\n" +
                        "    i_nrst   : in std_logic;\n" +
                        "    i_slvcfg : in  bus0_xslv_cfg_vector;\n" +
                        "    i_slvo   : in  bus0_xslv_out_vector;\n" +
                        "    i_msto   : in  bus0_xmst_out_vector;\n" +
                        "    o_slvi   : out bus0_xslv_in_vector;\n" +
                        "    o_msti   : out bus0_xmst_in_vector;\n" +
                        "    o_bus_util_w : out std_logic_vector(CFG_BUS0_XMST_TOTAL-1 downto 0);\n" +
                        "    o_bus_util_r : out std_logic_vector(CFG_BUS0_XMST_TOTAL-1 downto 0)\n" +
                        "  );\n" +
                        "end component;\n" +
                        "\n" +
                        "end; -- package body";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_types_common_vhd_file(String Project_Folder_File) {
        String data =   "-----------------------------------------------------------------------------\n" +
                        "--! @file\n" +
                        "--! @copyright Copyright 2015 GNSS Sensor Ltd. All right reserved.\n" +
                        "--! @author    Sergey Khabarov - sergeykhbr@gmail.com\n" +
                        "--! @brief     Declaration and implementation of the types_common package.\n" +
                        "------------------------------------------------------------------------------\n" +
                        "\n" +
                        "--! Standard library\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.numeric_std.all;\n" +
                        "use std.textio.all;\n" +
                        "\n" +
                        "--! @brief   Definition of the generic VHDL methods and constants.\n" +
                        "--! @details This package defines common mathematical methods and\n" +
                        "--!          utility methods for the VHDL types conversions.\n" +
                        "package types_common is\n" +
                        "\n" +
                        "--! @brief Array declaration of the pre-computed log2 values.\n" +
                        "type log2arr is array(0 to 512) of integer;\n" +
                        "\n" +
                        "--! @brief Array definition of the pre-computed log2 values.\n" +
                        "--! @details These values are used as an argument in bus width\n" +
                        "--!          declaration. \n" +
                        "--!\n" +
                        "--! Example usage:\n" +
                        "--! @code \n" +
                        "--!   component foo_component is\n" +
                        "--!   generic (\n" +
                        "--!     max_clients  : integer := 8\n" +
                        "--!   );\n" +
                        "--!   port (\n" +
                        "--!     foo : inout  std_logic_vector(log2(max_clients)-1 downto 0)\n" +
                        "--!   );\n" +
                        "--!   end component;\n" +
                        "--! @endcode \n" +
                        "constant log2   : log2arr := (\n" +
                        "0,0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n" +
                        "  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n" +
                        "  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n" +
                        "  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n" +
                        "  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n" +
                        "  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n" +
                        "  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n" +
                        "  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n" +
                        "  others => 9);\n" +
                        "\n" +
                        "constant log2x  : log2arr := (\n" +
                        "0,1,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n" +
                        "  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n" +
                        "  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n" +
                        "  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n" +
                        "  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n" +
                        "  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n" +
                        "  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n" +
                        "  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n" +
                        "  others => 9);\n" +
                        "  \n" +
                        "constant zero32 : std_logic_vector(31 downto 0) := X\"00000000\";\n" +
                        "constant zero64 : std_logic_vector(63 downto 0) := zero32 & zero32;\n" +
                        "\n" +
                        "\n" +
                        "function \"-\" (i : integer; d : std_logic_vector) return std_logic_vector;\n" +
                        "function \"-\" (d : std_logic_vector; i : integer) return std_logic_vector;\n" +
                        "function \"-\" (a, b : std_logic_vector) return std_logic_vector;\n" +
                        "function \"+\" (d : std_logic_vector; i : integer) return std_logic_vector;\n" +
                        "function \"+\" (a, b : std_logic_vector) return std_logic_vector;\n" +
                        "function \"+\" (d : std_logic_vector; i : std_ulogic) return std_logic_vector;\n" +
                        "function \"*\" (a, b : std_logic_vector) return std_logic_vector;\n" +
                        "\n" +
                        "function conv_integer(v : std_logic_vector) return integer;\n" +
                        "function conv_integer(v : std_logic) return integer;\n" +
                        "function conv_std_logic_vector(i : integer; w : integer) return std_logic_vector;\n" +
                        "function conv_std_logic_vector_signed(i : integer; w : integer) return std_logic_vector;\n" +
                        "function conv_std_logic(b : boolean) return std_ulogic;\n" +
                        "\n" +
                        "end;\n" +
                        "\n" +
                        "\n" +
                        "package body types_common is\n" +
                        "\n" +
                        "\n" +
                        "function conv_integer(v : std_logic_vector) return integer is\n" +
                        "begin\n" +
                        "  if not is_x(v) then return(to_integer(unsigned(v)));\n" +
                        "  else return(0); end if;\n" +
                        "end;\n" +
                        "\n" +
                        "function conv_integer(v : std_logic) return integer is\n" +
                        "begin\n" +
                        "  if not is_x(v) then\n" +
                        "    if v = '1' then return(1);\n" +
                        "    else return(0); end if;\n" +
                        "  else return(0); end if;\n" +
                        "end;\n" +
                        "\n" +
                        "function conv_std_logic_vector(i : integer; w : integer) return std_logic_vector is\n" +
                        "variable tmp : std_logic_vector(w-1 downto 0);\n" +
                        "begin\n" +
                        "  tmp := std_logic_vector(to_unsigned(i, w));\n" +
                        "  return(tmp);\n" +
                        "end;\n" +
                        "\n" +
                        "function conv_std_logic_vector_signed(i : integer; w : integer) return std_logic_vector is\n" +
                        "variable tmp : std_logic_vector(w-1 downto 0);\n" +
                        "begin\n" +
                        "  tmp := std_logic_vector(to_signed(i, w));\n" +
                        "  return(tmp);\n" +
                        "end;\n" +
                        "\n" +
                        "function conv_std_logic(b : boolean) return std_ulogic is\n" +
                        "begin\n" +
                        "  if b then return('1'); else return('0'); end if;\n" +
                        "end;\n" +
                        "\n" +
                        "function \"+\" (d : std_logic_vector; i : integer) return std_logic_vector is\n" +
                        "variable x : std_logic_vector(d'length-1 downto 0);\n" +
                        "begin\n" +
                        "-- pragma translate_off\n" +
                        "  if not is_x(d) then\n" +
                        "-- pragma translate_on\n" +
                        "    return(std_logic_vector(unsigned(d) + i));\n" +
                        "-- pragma translate_off\n" +
                        "  else x := (others =>'X'); return(x);\n" +
                        "  end if;\n" +
                        "-- pragma translate_on\n" +
                        "end;\n" +
                        "\n" +
                        "function \"+\" (a, b : std_logic_vector) return std_logic_vector is\n" +
                        "variable x : std_logic_vector(a'length-1 downto 0);\n" +
                        "variable y : std_logic_vector(b'length-1 downto 0);\n" +
                        "begin\n" +
                        "-- pragma translate_off\n" +
                        "  if not is_x(a&b) then\n" +
                        "-- pragma translate_on\n" +
                        "    return(std_logic_vector(unsigned(a) + unsigned(b)));\n" +
                        "-- pragma translate_off\n" +
                        "  else\n" +
                        "     x := (others =>'X'); y := (others =>'X');\n" +
                        "     if (x'length > y'length) then return(x); else return(y); end if;\n" +
                        "  end if;\n" +
                        "-- pragma translate_on\n" +
                        "end;\n" +
                        "\n" +
                        "function \"+\" (d : std_logic_vector; i : std_ulogic) return std_logic_vector is\n" +
                        "variable x : std_logic_vector(d'length-1 downto 0);\n" +
                        "variable y : std_logic_vector(0 downto 0);\n" +
                        "begin\n" +
                        "  y(0) := i;\n" +
                        "-- pragma translate_off\n" +
                        "  if not is_x(d) then\n" +
                        "-- pragma translate_on\n" +
                        "    return(std_logic_vector(unsigned(d) + unsigned(y)));\n" +
                        "-- pragma translate_off\n" +
                        "  else x := (others =>'X'); return(x); \n" +
                        "  end if;\n" +
                        "-- pragma translate_on\n" +
                        "end;\n" +
                        "\n" +
                        "\n" +
                        "function \"-\" (i : integer; d : std_logic_vector) return std_logic_vector is\n" +
                        "variable x : std_logic_vector(d'length-1 downto 0);\n" +
                        "begin\n" +
                        "-- pragma translate_off\n" +
                        "  if not is_x(d) then\n" +
                        "-- pragma translate_on\n" +
                        "    return(std_logic_vector(i - unsigned(d)));\n" +
                        "-- pragma translate_off\n" +
                        "  else x := (others =>'X'); return(x); \n" +
                        "  end if;\n" +
                        "-- pragma translate_on\n" +
                        "end;\n" +
                        "\n" +
                        "function \"-\" (d : std_logic_vector; i : integer) return std_logic_vector is\n" +
                        "variable x : std_logic_vector(d'length-1 downto 0);\n" +
                        "begin\n" +
                        "-- pragma translate_off\n" +
                        "  if not is_x(d) then\n" +
                        "-- pragma translate_on\n" +
                        "    return(std_logic_vector(unsigned(d) - i));\n" +
                        "-- pragma translate_off\n" +
                        "  else x := (others =>'X'); return(x); \n" +
                        "  end if;\n" +
                        "-- pragma translate_on\n" +
                        "end;\n" +
                        "\n" +
                        "function \"-\" (a, b : std_logic_vector) return std_logic_vector is\n" +
                        "variable x : std_logic_vector(a'length-1 downto 0);\n" +
                        "variable y : std_logic_vector(b'length-1 downto 0);\n" +
                        "begin\n" +
                        "-- pragma translate_off\n" +
                        "  if not is_x(a&b) then\n" +
                        "-- pragma translate_on\n" +
                        "    return(std_logic_vector(unsigned(a) - unsigned(b)));\n" +
                        "-- pragma translate_off\n" +
                        "  else\n" +
                        "     x := (others =>'X'); y := (others =>'X');\n" +
                        "     if (x'length > y'length) then return(x); else return(y); end if; \n" +
                        "  end if;\n" +
                        "-- pragma translate_on\n" +
                        "end;\n" +
                        "\n" +
                        "function \"*\" (a, b : std_logic_vector) return std_logic_vector is\n" +
                        "variable z : std_logic_vector(a'length+b'length-1 downto 0);\n" +
                        "begin\n" +
                        "-- pragma translate_off\n" +
                        "  if not is_x(a&b) then\n" +
                        "-- pragma translate_on\n" +
                        "    return(std_logic_vector(unsigned(a) * unsigned(b)));\n" +
                        "-- pragma translate_off\n" +
                        "  else\n" +
                        "     z := (others =>'X'); return(z);\n" +
                        "  end if;\n" +
                        "-- pragma translate_on\n" +
                        "end;\n" +
                        "\n" +
                        "\n" +
                        "end;\n" +
                        "";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_types_util_vhd_file(String Project_Folder_File) {
        String data =   "-----------------------------------------------------------------------------\n" +
                        "--! @file\n" +
                        "--! @copyright Copyright 2015 GNSS Sensor Ltd. All right reserved.\n" +
                        "--! @author    Sergey Khabarov - sergeykhbr@gmail.com\n" +
                        "--! @brief	    Package for common testbenches implementation.\n" +
                        "------------------------------------------------------------------------------\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.numeric_std.all;\n" +
                        "library std;\n" +
                        "use std.textio.all;\n" +
                        "\n" +
                        "package types_util is\n" +
                        "\n" +
                        "function strlen(s: in string) return integer;\n" +
                        "function StringToUVector(inStr: string) return std_ulogic_vector;\n" +
                        "function StringToSVector(inStr: string) return std_logic_vector;\n" +
                        "function UnsignedToSigned(inUnsigned: std_ulogic_vector) return std_logic_vector;\n" +
                        "function SignalFromString(inStr: string; ind : integer ) return std_logic;\n" +
                        "function SymbolToSVector(inStr: string; idx: integer) return std_logic_vector;\n" +
                        "\n" +
                        "function tost(v:std_logic_vector) return string;\n" +
                        "function tost(v:std_logic) return string;\n" +
                        "function tost(i : integer) return string;\n" +
                        "procedure print(s : string);\n" +
                        "\n" +
                        "end;\n" +
                        "\n" +
                        "package body types_util is\n" +
                        "\n" +
                        "  function strlen(s: in string) return integer is\n" +
                        "    variable n: integer:=0; variable sj: integer:=s'left;\n" +
                        "  begin\n" +
                        "    loop\n" +
                        "      if    sj>s'right then exit;\n" +
                        "      elsif s(sj)=NUL  then exit; --sequential if protects sj > length\n" +
                        "      else                  sj:=sj+1; n:=n+1;\n" +
                        "      end if;\n" +
                        "    end loop;\n" +
                        "    return n;\n" +
                        "  end strlen;\n" +
                        "\n" +
                        "  function SignalFromString(inStr: string; ind : integer ) return std_logic is\n" +
                        "    variable temp: std_logic := 'X';\n" +
                        "  begin\n" +
                        "    if(inStr(inStr'high-ind)='1')    then temp := '1';\n" +
                        "    elsif(inStr(inStr'high-ind)='0') then temp := '0';\n" +
                        "    end if;\n" +
                        "    return temp;\n" +
                        "  end function SignalFromString;\n" +
                        "\n" +
                        "\n" +
                        "  function StringToUVector(inStr: string) return std_ulogic_vector is\n" +
                        "    variable temp: std_ulogic_vector(inStr'range) := (others => 'X');\n" +
                        "  begin\n" +
                        "    for i in inStr'range loop --\n" +
                        "      if(inStr(inStr'high-i+1)='1')    then temp(i) := '1';\n" +
                        "      elsif(inStr(inStr'high-i+1)='0') then temp(i) := '0';\n" +
                        "      end if;\n" +
                        "    end loop;\n" +
                        "    return temp(inStr'high downto 1);\n" +
                        "  end function StringToUVector;\n" +
                        "  -- conversion function\n" +
                        "  \n" +
                        "  function StringToSVector(inStr: string) return std_logic_vector is\n" +
                        "    variable temp: std_logic_vector(inStr'range) := (others => 'X');\n" +
                        "  begin\n" +
                        "    for i in inStr'range loop --\n" +
                        "      if(inStr(inStr'high-i+1)='1')    then temp(i) := '1';\n" +
                        "      elsif(inStr(inStr'high-i+1)='0') then temp(i) := '0';\n" +
                        "      end if;\n" +
                        "    end loop;\n" +
                        "    return temp(inStr'high downto 1);\n" +
                        "  end function StringToSVector;\n" +
                        "\n" +
                        "  function SymbolToSVector(inStr: string; idx: integer) return std_logic_vector is\n" +
                        "    constant ss: string(1 to inStr'length) := inStr;\n" +
                        "    variable c : integer;\n" +
                        "    variable temp: std_logic_vector(7 downto 0) := (others => 'X');\n" +
                        "  begin\n" +
                        "    c := character'pos(ss(idx+1));\n" +
                        "    for i in 0 to 7 loop --\n" +
                        "      temp(i) := to_unsigned(c,8)(i);\n" +
                        "    end loop;\n" +
                        "    return temp;\n" +
                        "  end function SymbolToSVector;\n" +
                        "  \n" +
                        "\n" +
                        "  function UnsignedToSigned(inUnsigned: std_ulogic_vector) \n" +
                        "    return std_logic_vector is\n" +
                        "    variable temp: std_logic_vector(inUnsigned'length-1 downto 0) := (others => 'X');\n" +
                        "    variable i: integer:=0;\n" +
                        "  begin\n" +
                        "    while i < inUnsigned'length loop\n" +
                        "      if(inUnsigned(i)='1')    then temp(i) := '1';\n" +
                        "      elsif(inUnsigned(i)='0') then temp(i) := '0';\n" +
                        "      end if;\n" +
                        "      i := i+1;\n" +
                        "    end loop;\n" +
                        "    return temp;\n" +
                        "  end function UnsignedToSigned;\n" +
                        "\n" +
                        "\n" +
                        "  subtype nibble is std_logic_vector(3 downto 0);\n" +
                        "\n" +
                        "  function todec(i:integer) return character is\n" +
                        "  begin\n" +
                        "    case i is\n" +
                        "    when 0 => return('0');\n" +
                        "    when 1 => return('1');\n" +
                        "    when 2 => return('2');\n" +
                        "    when 3 => return('3');\n" +
                        "    when 4 => return('4');\n" +
                        "    when 5 => return('5');\n" +
                        "    when 6 => return('6');\n" +
                        "    when 7 => return('7');\n" +
                        "    when 8 => return('8');\n" +
                        "    when 9 => return('9');\n" +
                        "    when others => return('0');\n" +
                        "    end case;\n" +
                        "  end;\n" +
                        "\n" +
                        "\n" +
                        "  function tohex(n:nibble) return character is\n" +
                        "  begin\n" +
                        "    case n is\n" +
                        "    when \"0000\" => return('0');\n" +
                        "    when \"0001\" => return('1');\n" +
                        "    when \"0010\" => return('2');\n" +
                        "    when \"0011\" => return('3');\n" +
                        "    when \"0100\" => return('4');\n" +
                        "    when \"0101\" => return('5');\n" +
                        "    when \"0110\" => return('6');\n" +
                        "    when \"0111\" => return('7');\n" +
                        "    when \"1000\" => return('8');\n" +
                        "    when \"1001\" => return('9');\n" +
                        "    when \"1010\" => return('a');\n" +
                        "    when \"1011\" => return('b');\n" +
                        "    when \"1100\" => return('c');\n" +
                        "    when \"1101\" => return('d');\n" +
                        "    when \"1110\" => return('e');\n" +
                        "    when \"1111\" => return('f');\n" +
                        "    when others => return('X');\n" +
                        "    end case;\n" +
                        "  end;\n" +
                        "\n" +
                        "\n" +
                        "  function tost(v:std_logic_vector) return string is\n" +
                        "    constant vlen : natural := v'length; --'\n" +
                        "    constant slen : natural := (vlen+3)/4;\n" +
                        "    variable vv : std_logic_vector(0 to slen*4-1) := (others => '0');\n" +
                        "    variable s : string(1 to slen);\n" +
                        "    variable nz : boolean := false;\n" +
                        "    variable index : integer := -1;\n" +
                        "  begin\n" +
                        "    vv(slen*4-vlen to slen*4-1) := v;\n" +
                        "    for i in 0 to slen-1 loop\n" +
                        "      if (vv(i*4 to i*4+3) = \"0000\") and nz and (i /= (slen-1)) then\n" +
                        "        index := i;\n" +
                        "      else\n" +
                        "        nz := false;\n" +
                        "        s(i+1) := tohex(vv(i*4 to i*4+3));\n" +
                        "      end if;\n" +
                        "    end loop;\n" +
                        "    if ((index +2) = slen) then return(s(slen to slen));\n" +
                        "    else return(string'(\"0x\") & s(index+2 to slen)); end if; --'\n" +
                        "  end;\n" +
                        "\n" +
                        "\n" +
                        "  function tost(v:std_logic) return string is\n" +
                        "  begin\n" +
                        "    if to_x01(v) = '1' then return(\"1\"); else return(\"0\"); end if;\n" +
                        "  end;\n" +
                        "\n" +
                        "\n" +
                        "  function tost(i : integer) return string is\n" +
                        "    variable L : line;\n" +
                        "    variable s, x : string(1 to 128);\n" +
                        "    variable n, tmp : integer := 0;\n" +
                        "  begin\n" +
                        "    tmp := i;\n" +
                        "    if i < 0 then tmp := -i; end if;\n" +
                        "    loop\n" +
                        "      s(128-n) := todec(tmp mod 10);\n" +
                        "      tmp := tmp / 10;\n" +
                        "      n := n+1;\n" +
                        "      if tmp = 0 then exit; end if;\n" +
                        "    end loop;\n" +
                        "    x(1 to n) := s(129-n to 128);\n" +
                        "    if i < 0 then return \"-\" & x(1 to n); end if;\n" +
                        "    return(x(1 to n));\n" +
                        "  end;\n" +
                        "\n" +
                        "  procedure print(s : string) is\n" +
                        "    variable L : line;\n" +
                        "  begin\n" +
                        "    L := new string'(s); writeline(output, L);\n" +
                        "  end;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_types_misc_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2018 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "--! Standard library.\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.numeric_std.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "--! Technology definition library.\n" +
                        "library techmap;\n" +
                        "use techmap.gencomp.all;\n" +
                        "--! CPU, System Bus and common peripheries library.\n" +
                        "library ambalib;\n" +
                        "use ambalib.types_amba4.all;\n" +
                        "use ambalib.types_bus0.all;\n" +
                        "\n" +
                        "--! @brief   Declaration of components visible on SoC top level.\n" +
                        "package types_misc is\n" +
                        "\n" +
                        "--! @defgroup irq_id_group AXI4 interrupt generic IDs.\n" +
                        "--! @ingroup axi4_config_generic_group\n" +
                        "--! @details Unique indentificator of the interrupt pin also used\n" +
                        "--!          as an index in the interrupts bus.\n" +
                        "--! @{\n" +
                        "\n" +
                        "--! Zero interrupt index must be unused.\n" +
                        "constant CFG_IRQ_UNUSED         : integer := 0;\n" +
                        "--! UART_A interrupt pin.\n" +
                        "constant CFG_IRQ_UART1          : integer := 1;\n" +
                        "--! GP Timers interrupt pin\n" +
                        "constant CFG_IRQ_GPTIMERS       : integer := 2;\n" +
                        "--! Total number of used interrupts in a system\n" +
                        "constant CFG_IRQ_TOTAL          : integer := 3;\n" +
                        "--! @}\n" +
                        "\n" +
                        "--! @brief SOC global reset former.\n" +
                        "--! @details This module produces output reset signal in a case if\n" +
                        "--!          button 'Reset' was pushed or PLL isn't a 'lock' state.\n" +
                        "--! param[in]  inSysReset Button generated signal\n" +
                        "--! param[in]  inSysClk Clock from the PLL. Bus clock.\n" +
                        "--! param[out] outReset Output reset signal with active 'High' (1 = reset).\n" +
                        "component reset_global\n" +
                        "port (\n" +
                        "  inSysReset  : in std_ulogic;\n" +
                        "  inSysClk    : in std_ulogic;\n" +
                        "  outReset    : out std_ulogic );\n" +
                        "end component;\n" +
                        "\n" +
                        "\n" +
                        "--! Boot ROM with AXI4 interface declaration.\n" +
                        "component axi4_rom is\n" +
                        "generic (\n" +
                        "    memtech  : integer := inferred;\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr    : integer := 0;\n" +
                        "    xmask    : integer := 16#fffff#;\n" +
                        "    sim_hexfile : string\n" +
                        "  );\n" +
                        "port (\n" +
                        "    clk  : in std_logic;\n" +
                        "    nrst : in std_logic;\n" +
                        "    cfg  : out axi4_slave_config_type;\n" +
                        "    i    : in  axi4_slave_in_type;\n" +
                        "    o    : out axi4_slave_out_type\n" +
                        "  );\n" +
                        "end component; \n" +
                        "\n" +
                        "--! Internal RAM with AXI4 interface declaration.\n" +
                        "component axi4_sram is\n" +
                        "  generic (\n" +
                        "    memtech  : integer := inferred;\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr    : integer := 0;\n" +
                        "    xmask    : integer := 16#fffff#;\n" +
                        "    abits    : integer := 17;\n" +
                        "    init_file : string := \"\" -- only for 'inferred'\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk  : in std_logic;\n" +
                        "    nrst : in std_logic;\n" +
                        "    cfg  : out axi4_slave_config_type;\n" +
                        "    i    : in  axi4_slave_in_type;\n" +
                        "    o    : out axi4_slave_out_type\n" +
                        "  );\n" +
                        "end component; \n" +
                        "\n" +
                        "--! AXI4 to SPI brdige for external Flash IC Micron M25AA1024\n" +
                        "type spi_in_type is record\n" +
                        "    SDI : std_logic;\n" +
                        "end record;\n" +
                        "\n" +
                        "type spi_out_type is record\n" +
                        "    SDO : std_logic;\n" +
                        "    SCK : std_logic;\n" +
                        "    nCS : std_logic;\n" +
                        "    nWP : std_logic;\n" +
                        "    nHOLD : std_logic;\n" +
                        "    RESET : std_logic;\n" +
                        "end record;\n" +
                        "\n" +
                        "constant spi_out_none : spi_out_type := (\n" +
                        "  '0', '0', '1', '1', '1', '0'\n" +
                        ");\n" +
                        "\n" +
                        "component axi4_flashspi is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr   : integer := 0;\n" +
                        "    xmask   : integer := 16#fffff#;\n" +
                        "    wait_while_write : boolean := true  -- hold AXI bus response until end of write cycle\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk    : in  std_logic;\n" +
                        "    nrst   : in  std_logic;\n" +
                        "    cfg    : out axi4_slave_config_type;\n" +
                        "    i_spi  : in  spi_in_type;\n" +
                        "    o_spi  : out spi_out_type;\n" +
                        "    i_axi  : in  axi4_slave_in_type;\n" +
                        "    o_axi  : out axi4_slave_out_type  );\n" +
                        "end component; \n" +
                        "\n" +
                        "--! @brief AXI4 GPIO controller\n" +
                        "component axi4_gpio is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr    : integer := 0;\n" +
                        "    xmask    : integer := 16#fffff#;\n" +
                        "    xirq     : integer := 0\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk  : in std_logic;\n" +
                        "    nrst : in std_logic;\n" +
                        "    cfg  : out axi4_slave_config_type;\n" +
                        "    i    : in  axi4_slave_in_type;\n" +
                        "    o    : out axi4_slave_out_type;\n" +
                        "    KEY			: in std_logic_vector(3 DOWNTO 0);\n" +
                        "	  SW			: in std_logic_vector(9 DOWNTO 0);\n" +
                        "    LEDG			: out std_logic_vector(7 DOWNTO 0);\n" +
                        "    LEDR			: out std_logic_vector(9 DOWNTO 0);\n" +
                        "    GPIO_IN		: in std_logic_vector(17 DOWNTO 0);\n" +
                        "    GPIO_OUT	: out std_logic_vector(17 DOWNTO 0)\n" +
                        "  );\n" +
                        "end component; \n" +
                        "\n" +
                        "type uart_in_type is record\n" +
                        "  rd   	: std_ulogic;\n" +
                        "  cts   : std_ulogic;\n" +
                        "end record;\n" +
                        "\n" +
                        "type uart_out_type is record\n" +
                        "  td   	: std_ulogic;\n" +
                        "  rts   : std_ulogic;\n" +
                        "end record;\n" +
                        "\n" +
                        "--! UART with the AXI4 interface declaration.\n" +
                        "component axi4_uart is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr   : integer := 0;\n" +
                        "    xmask   : integer := 16#fffff#;\n" +
                        "    xirq    : integer := 0;\n" +
                        "    fifosz  : integer := 16\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk    : in  std_logic;\n" +
                        "    nrst   : in  std_logic;\n" +
                        "    cfg    : out axi4_slave_config_type;\n" +
                        "    i_uart : in  uart_in_type;\n" +
                        "    o_uart : out uart_out_type;\n" +
                        "    i_axi  : in  axi4_slave_in_type;\n" +
                        "    o_axi  : out axi4_slave_out_type;\n" +
                        "    o_irq  : out std_logic);\n" +
                        "end component;\n" +
                        "\n" +
                        "\n" +
                        "--! @brief   Interrupt controller with the AXI4 interface declaration.\n" +
                        "--! @details To rise interrupt on certain CPU HostIO interface is used.\n" +
                        "component axi4_irqctrl is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr    : integer := 0;\n" +
                        "    xmask    : integer := 16#fffff#\n" +
                        "  );\n" +
                        "  port \n" +
                        " (\n" +
                        "    clk    : in std_logic;\n" +
                        "    nrst   : in std_logic;\n" +
                        "    i_irqs : in std_logic_vector(CFG_IRQ_TOTAL-1 downto 1);\n" +
                        "    o_cfg  : out axi4_slave_config_type;\n" +
                        "    i_axi  : in axi4_slave_in_type;\n" +
                        "    o_axi  : out axi4_slave_out_type;\n" +
                        "    o_irq_meip : out std_logic\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "  --! @brief   General Purpose Timers with the AXI interface.\n" +
                        "  --! @details This module provides high precision counter and\n" +
                        "  --!          generic number of GP timers.\n" +
                        "  component axi4_gptimers is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr   : integer := 0;\n" +
                        "    xmask   : integer := 16#fffff#;\n" +
                        "    xirq    : integer := 0;\n" +
                        "    tmr_total  : integer := 2\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk    : in  std_logic;\n" +
                        "    nrst   : in  std_logic;\n" +
                        "    cfg    : out axi4_slave_config_type;\n" +
                        "    i_axi  : in  axi4_slave_in_type;\n" +
                        "    o_axi  : out axi4_slave_out_type;\n" +
                        "    o_irq  : out std_logic\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "component axi4_time_measurement is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr    : integer := 0;\n" +
                        "    xmask    : integer := 16#fffff#;\n" +
                        "    xirq     : integer := 0\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk  		: in std_logic;\n" +
                        "    nrst 		: in std_logic;\n" +
                        "    cfg  		: out axi4_slave_config_type;\n" +
                        "    i    		: in  axi4_slave_in_type;\n" +
                        "    o  		  	: out axi4_slave_out_type;\n" +
                        "	 \n" +
                        "	 -- HEX interface\n" +
                        "	 HEX0			: OUT STD_LOGIC_VECTOR(6 DOWNTO 0);\n" +
                        "	 HEX1			: OUT STD_LOGIC_VECTOR(6 DOWNTO 0);\n" +
                        "	 HEX2			: OUT STD_LOGIC_VECTOR(6 DOWNTO 0);\n" +
                        "	 HEX3			: OUT STD_LOGIC_VECTOR(6 DOWNTO 0)\n" +
                        "  );\n" +
                        "end component;\n" +
                        "\n" +
                        "component axi4_ton is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr    : integer := 0;\n" +
                        "    xmask    : integer := 16#fffff#;\n" +
                        "    xirq     : integer := 0\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk  		: in std_logic;\n" +
                        "    nrst 		: in std_logic;\n" +
                        "    cfg  		: out axi4_slave_config_type;\n" +
                        "    i    		: in  axi4_slave_in_type;\n" +
                        "    o  		  	: out axi4_slave_out_type\n" +
                        "  );\n" +
                        "end component;\n" +
                        "\n" +
                        "component axi4_pwm is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr    : integer := 0;\n" +
                        "    xmask    : integer := 16#fffff#;\n" +
                        "    xirq     : integer := 0\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk  		: in std_logic;\n" +
                        "    clk_pwm 	: in std_logic;\n" +
                        "    nrst 		: in std_logic;\n" +
                        "    cfg  		: out axi4_slave_config_type;\n" +
                        "    i    		: in  axi4_slave_in_type;\n" +
                        "    o  		  	: out axi4_slave_out_type\n" +
                        "  );\n" +
                        "end component;\n" +
                        "\n" +
                        "component axi4_pid is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr    : integer := 0;\n" +
                        "    xmask    : integer := 16#fffff#;\n" +
                        "    xirq     : integer := 0\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk  		: in std_logic;\n" +
                        "    nrst 		: in std_logic;\n" +
                        "    cfg  		: out axi4_slave_config_type;\n" +
                        "    i    		: in  axi4_slave_in_type;\n" +
                        "    o  		  : out axi4_slave_out_type\n" +
                        "  );\n" +
                        "end component;\n" +
                        "\n" +
                        "--component axi4_ is\n" +
                        "--  generic (\n" +
                        "  \n" +
                        "--  );\n" +
                        "--  port (\n" +
                        "\n" +
                        "--  );\n" +
                        "--end component;\n" +
                        "\n" +
                        "end; -- package declaration";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_reset_glb_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2018 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "\n" +
                        "--! @brief NoC global reset former.\n" +
                        "--! @details This module produces output reset signal in a case if\n" +
                        "--!          button 'Reset' was pushed or PLL isn't a 'lock' state.\n" +
                        "--! param[in]  inSysReset Button generated signal\n" +
                        "--! param[in]  inSysClk Clock from the PLL. Bus clock.\n" +
                        "--! param[in]  inPllLock PLL status.\n" +
                        "--! param[out] outReset Output reset signal with active 'High' (1 = reset).\n" +
                        "entity reset_global is\n" +
                        "  port (\n" +
                        "    inSysReset  : in std_ulogic;\n" +
                        "    inSysClk    : in std_ulogic;\n" +
                        "    outReset    : out std_ulogic\n" +
                        "    );\n" +
                        "end;\n" +
                        "\n" +
                        "architecture arch_reset_global of reset_global is\n" +
                        "\n" +
                        "  type reg_type is record\n" +
                        "    delay_cnt : std_logic_vector(7 downto 0);\n" +
                        "  end record;\n" +
                        "\n" +
                        "  signal r : reg_type;\n" +
                        "begin\n" +
                        "\n" +
                        "  proc_rst : process (inSysClk, inSysReset, r) \n" +
                        "    variable wb_delay_cnt : std_logic_vector(7 downto 0);\n" +
                        "    variable sys_reset : std_logic;\n" +
                        "  begin\n" +
                        "\n" +
                        "    sys_reset := inSysReset;\n" +
                        "    \n" +
                        "    wb_delay_cnt := r.delay_cnt;\n" +
                        "    if r.delay_cnt(7) = '0' then\n" +
                        "      wb_delay_cnt := r.delay_cnt + 1;\n" +
                        "    end if;\n" +
                        "    \n" +
                        "    if sys_reset = '1' then\n" +
                        "      r.delay_cnt <= (others => '0');\n" +
                        "    elsif rising_edge(inSysClk) then \n" +
                        "      r.delay_cnt  <= wb_delay_cnt;\n" +
                        "    end if;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  outReset <= not r.delay_cnt(7);\n" +
                        "  \n" +
                        "end;  ";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_axi4_uart_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "--! AMBA system bus specific library.\n" +
                        "library ambalib;\n" +
                        "--! AXI4 configuration constants.\n" +
                        "use ambalib.types_amba4.all;\n" +
                        "library misclib;\n" +
                        "use misclib.types_misc.all;\n" +
                        "\n" +
                        "entity axi4_uart is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr   : integer := 0;\n" +
                        "    xmask   : integer := 16#fffff#;\n" +
                        "    xirq    : integer := 0;\n" +
                        "    fifosz  : integer := 16\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk    : in  std_logic;\n" +
                        "    nrst   : in  std_logic;\n" +
                        "    cfg    : out axi4_slave_config_type;\n" +
                        "    i_uart : in  uart_in_type;\n" +
                        "    o_uart : out uart_out_type;\n" +
                        "    i_axi  : in  axi4_slave_in_type;\n" +
                        "    o_axi  : out axi4_slave_out_type;\n" +
                        "    o_irq  : out std_logic\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_axi4_uart of axi4_uart is\n" +
                        "\n" +
                        "  constant xconfig : axi4_slave_config_type := (\n" +
                        "     descrtype => PNP_CFG_TYPE_SLAVE,\n" +
                        "     descrsize => PNP_CFG_SLAVE_DESCR_BYTES,\n" +
                        "     irq_idx => conv_std_logic_vector(xirq, 8),\n" +
                        "     xaddr => conv_std_logic_vector(xaddr, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     xmask => conv_std_logic_vector(xmask, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     vid => VENDOR_GNSSSENSOR,\n" +
                        "     did => GNSSSENSOR_UART\n" +
                        "  );\n" +
                        "\n" +
                        "  constant zero32 : std_logic_vector(31 downto 0) := (others => '0');\n" +
                        "\n" +
                        "  type fifo_mem is array (0 to fifosz-1) of std_logic_vector(7 downto 0);\n" +
                        "  type state_type is (idle, startbit, data, parity, stopbit);\n" +
                        "\n" +
                        "  type fifo_in_type is record\n" +
                        "    raddr : integer range 0 to fifosz-1;\n" +
                        "    waddr : integer range 0 to fifosz-1;\n" +
                        "    we : std_logic;\n" +
                        "    wdata : std_logic_vector(7 downto 0);\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant fifo_in_none : fifo_in_type := (0, 0, '0', X\"00\");\n" +
                        "\n" +
                        "  signal rfifoi : fifo_in_type;\n" +
                        "  signal rx_fifo_rdata : std_logic_vector(7 downto 0);\n" +
                        "  signal rx_fifo : fifo_mem;\n" +
                        "\n" +
                        "  signal tfifoi : fifo_in_type;\n" +
                        "  signal tx_fifo_rdata : std_logic_vector(7 downto 0);\n" +
                        "  signal tx_fifo   : fifo_mem;\n" +
                        "\n" +
                        "  type registers is record\n" +
                        "      tx_state  : state_type;\n" +
                        "      tx_wr_cnt : std_logic_vector(log2(fifosz)-1 downto 0);\n" +
                        "      tx_rd_cnt : std_logic_vector(log2(fifosz)-1 downto 0);\n" +
                        "      tx_byte_cnt : std_logic_vector(log2(fifosz)-1 downto 0);\n" +
                        "      tx_shift  : std_logic_vector(10 downto 0); --! stopbit=1,parity=xor,data[7:0],startbit=0\n" +
                        "      tx_data_cnt : integer range 0 to 11;\n" +
                        "      tx_scaler_cnt : std_logic_vector(31 downto 0);\n" +
                        "      tx_level : std_logic;\n" +
                        "      tx_irq_thresh : std_logic_vector(log2(fifosz)-1 downto 0);\n" +
                        "      tx_more_thresh : std_logic_vector(1 downto 0);\n" +
                        "\n" +
                        "      rx_state  : state_type;\n" +
                        "      rx_wr_cnt : std_logic_vector(log2(fifosz)-1 downto 0);\n" +
                        "      rx_rd_cnt : std_logic_vector(log2(fifosz)-1 downto 0);\n" +
                        "      rx_byte_cnt : std_logic_vector(log2(fifosz)-1 downto 0);\n" +
                        "      rx_shift  : std_logic_vector(7 downto 0);\n" +
                        "      rx_data_cnt : integer range 0 to 7;\n" +
                        "      rx_scaler_cnt : std_logic_vector(31 downto 0);\n" +
                        "      rx_level : std_logic;\n" +
                        "      rx_irq_thresh : std_logic_vector(log2(fifosz)-1 downto 0);\n" +
                        "      rx_more_thresh : std_logic_vector(1 downto 0);\n" +
                        "\n" +
                        "      rdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "      scaler : std_logic_vector(31 downto 0);\n" +
                        "      err_parity : std_logic;\n" +
                        "      err_stopbit : std_logic;\n" +
                        "      parity_bit : std_logic;\n" +
                        "      tx_irq_ena : std_logic;\n" +
                        "      rx_irq_ena : std_logic;\n" +
                        "      fwcpuid : std_logic_vector(31 downto 0);\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : registers := (\n" +
                        "        idle,  -- tx_state\n" +
                        "        (others => '0'), (others => '0'),  -- tx_wr_cnt, tx_rd_cnt\n" +
                        "        (others => '0'),  -- tx_byte_cnt\n" +
                        "        (others => '0'),  -- tx_shift\n" +
                        "        0, -- tx_data_cnt\n" +
                        "        (others => '0'), -- tx_scaler_cnt\n" +
                        "        '0', -- tx_level\n" +
                        "        (others => '0'), -- tx_irq_thresh\n" +
                        "        (others => '0'), -- tx_more_thresh\n" +
                        "        idle, -- rx_state\n" +
                        "        (others => '0'), (others => '0'), -- rx_wr_cnt , rx_rd_cnt\n" +
                        "        (others => '0'), -- rx_byte_cnt\n" +
                        "        (others => '0'), -- rx_shift\n" +
                        "        0, -- rx_data_cnt\n" +
                        "        (others => '0'), -- rx_scaler_cnt\n" +
                        "        '1', -- rx_level\n" +
                        "        (others => '0'), -- rx_irq_thresh\n" +
                        "        (others => '0'), -- rx_more_thresh\n" +
                        "        (others => '0'), -- rdata\n" +
                        "        (others => '0'), -- scaler\n" +
                        "        '0', -- err_parity\n" +
                        "        '0', -- err_stopbit\n" +
                        "        '0', -- parity_bit\n" +
                        "        '1', -- tx_irq_ena\n" +
                        "        '1', -- rx_irq_ena\n" +
                        "        (others => '0')); -- fwcpuid\n" +
                        "\n" +
                        "signal r, rin : registers;\n" +
                        "\n" +
                        "signal wb_bus_raddr : global_addr_array_type;\n" +
                        "signal w_bus_re    : std_logic;\n" +
                        "signal wb_bus_waddr : global_addr_array_type;\n" +
                        "signal w_bus_we    : std_logic;\n" +
                        "signal wb_bus_wstrb : std_logic_vector(CFG_SYSBUS_DATA_BYTES-1 downto 0);\n" +
                        "signal wb_bus_wdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  axi0 :  axi4_slave generic map (\n" +
                        "    async_reset => async_reset\n" +
                        "  ) port map (\n" +
                        "    i_clk => clk,\n" +
                        "    i_nrst => nrst,\n" +
                        "    i_xcfg => xconfig, \n" +
                        "    i_xslvi => i_axi,\n" +
                        "    o_xslvo => o_axi,\n" +
                        "    i_ready => '1',\n" +
                        "    i_rdata => r.rdata,\n" +
                        "    o_re => w_bus_re,\n" +
                        "    o_r32 => open,\n" +
                        "    o_radr => wb_bus_raddr,\n" +
                        "    o_wadr => wb_bus_waddr,\n" +
                        "    o_we => w_bus_we,\n" +
                        "    o_wstrb => wb_bus_wstrb,\n" +
                        "    o_wdata => wb_bus_wdata\n" +
                        "  );\n" +
                        "\n" +
                        "  comblogic : process(nrst, i_uart, r, tx_fifo_rdata, rx_fifo_rdata,\n" +
                        "                      w_bus_re, wb_bus_raddr, wb_bus_waddr, w_bus_we,\n" +
                        "                      wb_bus_wstrb, wb_bus_wdata)\n" +
                        "    variable v : registers;\n" +
                        "    variable tmp : std_logic_vector(31 downto 0);\n" +
                        "\n" +
                        "    variable v_rfifoi : fifo_in_type;\n" +
                        "    variable v_tfifoi : fifo_in_type;\n" +
                        "    variable posedge_flag : std_logic;\n" +
                        "    variable negedge_flag : std_logic;\n" +
                        "    variable tx_fifo_empty : std_logic;\n" +
                        "    variable tx_fifo_full : std_logic;\n" +
                        "    variable rx_fifo_empty : std_logic;\n" +
                        "    variable rx_fifo_full : std_logic;\n" +
                        "    variable t_tx, t_rx : std_logic_vector(7 downto 0);\n" +
                        "    variable par : std_logic;\n" +
                        "    variable irq_ena : std_logic;\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    v_rfifoi := fifo_in_none;\n" +
                        "    v_rfifoi.raddr := conv_integer(r.rx_rd_cnt);\n" +
                        "    v_rfifoi.waddr := conv_integer(r.rx_wr_cnt);\n" +
                        "    v_rfifoi.wdata := r.rx_shift;\n" +
                        "\n" +
                        "    v_tfifoi := fifo_in_none;\n" +
                        "    v_tfifoi.raddr := conv_integer(r.tx_rd_cnt);\n" +
                        "    v_tfifoi.waddr := conv_integer(r.tx_wr_cnt);\n" +
                        "\n" +
                        "    -- Check FIFOs counters with thresholds:\n" +
                        "    v.tx_more_thresh := r.tx_more_thresh(0) & '0';\n" +
                        "    if r.tx_byte_cnt > r.tx_irq_thresh then\n" +
                        "      v.tx_more_thresh(0) := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    v.rx_more_thresh := r.rx_more_thresh(0) & '0';\n" +
                        "    if r.rx_byte_cnt > r.rx_irq_thresh then\n" +
                        "      v.rx_more_thresh(0) := '1';\n" +
                        "    end if;\n" +
                        "    \n" +
                        "    irq_ena := '0';\n" +
                        "    if (r.tx_more_thresh(1) and not r.tx_more_thresh(0)) = '1' then\n" +
                        "       irq_ena := r.tx_irq_ena;\n" +
                        "    end if;\n" +
                        "    if (not r.rx_more_thresh(1) and r.rx_more_thresh(0)) = '1' then\n" +
                        "       irq_ena := irq_ena or r.rx_irq_ena;\n" +
                        "    end if;\n" +
                        "    \n" +
                        "    -- system bus clock scaler to baudrate:\n" +
                        "    posedge_flag := '0';\n" +
                        "    negedge_flag := '0';\n" +
                        "    if r.scaler /= zero32 then\n" +
                        "        if r.tx_scaler_cnt = (r.scaler-1) then\n" +
                        "            v.tx_scaler_cnt := zero32;\n" +
                        "            v.tx_level := not r.tx_level;\n" +
                        "            posedge_flag := not r.tx_level;\n" +
                        "        else\n" +
                        "            v.tx_scaler_cnt := r.tx_scaler_cnt + 1;\n" +
                        "        end if;\n" +
                        "\n" +
                        "        if r.rx_state = idle and i_uart.rd = '1' then\n" +
                        "            v.rx_scaler_cnt := zero32;\n" +
                        "            v.rx_level := '1';\n" +
                        "        elsif r.rx_scaler_cnt = (r.scaler-1) then\n" +
                        "            v.rx_scaler_cnt := zero32;\n" +
                        "            v.rx_level := not r.rx_level;\n" +
                        "            negedge_flag := r.rx_level;\n" +
                        "        else\n" +
                        "            v.rx_scaler_cnt := r.rx_scaler_cnt + 1;\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Transmitter's FIFO:\n" +
                        "    tx_fifo_full := '0';\n" +
                        "    if (r.tx_wr_cnt + 1) = r.tx_rd_cnt then\n" +
                        "        tx_fifo_full := '1';\n" +
                        "    end if;\n" +
                        "    tx_fifo_empty := '0';\n" +
                        "    if r.tx_rd_cnt = r.tx_wr_cnt then\n" +
                        "        tx_fifo_empty := '1';\n" +
                        "        v.tx_byte_cnt := (others => '0');\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Receiver's FIFO:\n" +
                        "    rx_fifo_full := '0';\n" +
                        "    if (r.rx_wr_cnt + 1) = r.rx_rd_cnt then\n" +
                        "        rx_fifo_full := '1';\n" +
                        "    end if;\n" +
                        "    rx_fifo_empty := '0';\n" +
                        "    if r.rx_rd_cnt = r.rx_wr_cnt then\n" +
                        "        rx_fifo_empty := '1';\n" +
                        "        v.rx_byte_cnt := (others => '0');\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Transmitter's state machine:\n" +
                        "    if i_uart.cts = '1' and posedge_flag = '1' then\n" +
                        "        case r.tx_state is\n" +
                        "        when idle =>\n" +
                        "            if tx_fifo_empty = '0' then\n" +
                        "                -- stopbit=1,parity=xor,data[7:0],startbit=0\n" +
                        "                t_tx := tx_fifo_rdata; --r.tx_fifo(conv_integer(r.tx_rd_cnt));\n" +
                        "                if r.parity_bit = '1' then\n" +
                        "                    par := t_tx(7) xor t_tx(6) xor t_tx(5) xor t_tx(4)\n" +
                        "                         xor t_tx(3) xor t_tx(2) xor t_tx(1) xor t_tx(0);\n" +
                        "                    v.tx_shift := '1' & par & t_tx & '0';\n" +
                        "                else\n" +
                        "                    v.tx_shift := \"11\" & t_tx & '0';\n" +
                        "                end if;\n" +
                        "                \n" +
                        "                v.tx_state := startbit;\n" +
                        "                v.tx_rd_cnt := r.tx_rd_cnt + 1;\n" +
                        "                v.tx_byte_cnt := r.tx_byte_cnt - 1;\n" +
                        "                v.tx_data_cnt := 0;\n" +
                        "            end if;\n" +
                        "        when startbit =>\n" +
                        "            v.tx_state := data;\n" +
                        "        when data =>\n" +
                        "            if r.tx_data_cnt = 8 then\n" +
                        "                if r.parity_bit = '1' then\n" +
                        "                    v.tx_state := parity;\n" +
                        "                else\n" +
                        "                    v.tx_state := stopbit;\n" +
                        "                end if;\n" +
                        "            end if;\n" +
                        "        when parity =>\n" +
                        "            v.tx_state := stopbit;\n" +
                        "        when stopbit =>\n" +
                        "            v.tx_state := idle;\n" +
                        "        when others =>\n" +
                        "        end case;\n" +
                        "        \n" +
                        "        if r.tx_state /= idle then\n" +
                        "            v.tx_data_cnt := r.tx_data_cnt + 1;\n" +
                        "            v.tx_shift := '1' & r.tx_shift(10 downto 1);\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    --! Receiver's state machine:\n" +
                        "    if negedge_flag = '1' then\n" +
                        "        case r.rx_state is\n" +
                        "        when idle =>\n" +
                        "            if i_uart.rd = '0' then\n" +
                        "                v.rx_state := data;\n" +
                        "                v.rx_shift := (others => '0');\n" +
                        "                v.rx_data_cnt := 0;\n" +
                        "            end if;\n" +
                        "        when data =>\n" +
                        "            v.rx_shift := i_uart.rd & r.rx_shift(7 downto 1);\n" +
                        "            if r.rx_data_cnt = 7 then\n" +
                        "                if r.parity_bit = '1' then\n" +
                        "                    v.rx_state := parity;\n" +
                        "                else\n" +
                        "                    v.rx_state := stopbit;\n" +
                        "                end if;\n" +
                        "            else\n" +
                        "                v.rx_data_cnt := r.rx_data_cnt + 1;\n" +
                        "            end if;\n" +
                        "        when parity =>\n" +
                        "            t_rx := r.rx_shift;\n" +
                        "            par := t_rx(7) xor t_rx(6) xor t_rx(5) xor t_rx(4)\n" +
                        "               xor t_rx(3) xor t_rx(2) xor t_rx(1) xor t_rx(0);\n" +
                        "            if par = i_uart.rd then\n" +
                        "                v.err_parity := '0';\n" +
                        "            else \n" +
                        "                v.err_parity := '1';\n" +
                        "            end if;\n" +
                        "            v.rx_state := stopbit;\n" +
                        "        when stopbit =>\n" +
                        "            if i_uart.rd = '0' then\n" +
                        "                v.err_stopbit := '1';\n" +
                        "            else\n" +
                        "                v.err_stopbit := '0';\n" +
                        "            end if;\n" +
                        "            if rx_fifo_full = '0' then\n" +
                        "                v_rfifoi.we := '1';\n" +
                        "                --v.rx_fifo(conv_integer(r.rx_wr_cnt)) := r.rx_shift;\n" +
                        "                v.rx_wr_cnt := r.rx_wr_cnt + 1;\n" +
                        "                v.rx_byte_cnt := r.rx_byte_cnt + 1;\n" +
                        "            end if;\n" +
                        "            v.rx_state := idle;\n" +
                        "        when others =>\n" +
                        "        end case;\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    o_uart.rts <= '1';\n" +
                        "    if r.tx_state = idle then\n" +
                        "        o_uart.td <= '1';\n" +
                        "    else\n" +
                        "        o_uart.td <= r.tx_shift(0);\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    for n in 0 to CFG_WORDS_ON_BUS-1 loop\n" +
                        "       tmp := (others => '0');\n" +
                        "       case conv_integer(wb_bus_raddr(n)(11 downto 2)) is\n" +
                        "          when 0 => \n" +
                        "                tmp(1 downto 0) := tx_fifo_empty & tx_fifo_full;\n" +
                        "                tmp(5 downto 4) := rx_fifo_empty & rx_fifo_full;\n" +
                        "                tmp(9 downto 8) := r.err_stopbit & r.err_parity;\n" +
                        "                tmp(13) := r.rx_irq_ena;\n" +
                        "                tmp(14) := r.tx_irq_ena;\n" +
                        "                tmp(15) := r.parity_bit;\n" +
                        "          when 1 => \n" +
                        "                tmp := r.scaler;\n" +
                        "          when 2 => \n" +
                        "                tmp := r.fwcpuid;\n" +
                        "          when 4 => \n" +
                        "                if rx_fifo_empty = '0' and w_bus_re = '1' then\n" +
                        "                    tmp(7 downto 0) := rx_fifo_rdata; \n" +
                        "                    v.rx_rd_cnt := r.rx_rd_cnt + 1;\n" +
                        "                    v.rx_byte_cnt := r.rx_byte_cnt - 1;\n" +
                        "                end if;\n" +
                        "          when others => \n" +
                        "       end case;\n" +
                        "       v.rdata(8*CFG_ALIGN_BYTES*(n+1)-1 downto 8*CFG_ALIGN_BYTES*n) := tmp;\n" +
                        "    end loop;\n" +
                        "\n" +
                        "\n" +
                        "    if w_bus_we = '1' then\n" +
                        "      for n in 0 to CFG_WORDS_ON_BUS-1 loop\n" +
                        "         if conv_integer(wb_bus_wstrb(CFG_ALIGN_BYTES*(n+1)-1 downto CFG_ALIGN_BYTES*n)) /= 0 then\n" +
                        "           tmp := wb_bus_wdata(8*CFG_ALIGN_BYTES*(n+1)-1 downto 8*CFG_ALIGN_BYTES*n);\n" +
                        "           case conv_integer(wb_bus_waddr(n)(11 downto 2)) is\n" +
                        "             when 0 =>\n" +
                        "                    v.parity_bit := tmp(15);\n" +
                        "                    v.tx_irq_ena := tmp(14);\n" +
                        "                    v.rx_irq_ena := tmp(13);\n" +
                        "             when 1 => \n" +
                        "                    v.scaler     := tmp;\n" +
                        "                    v.rx_scaler_cnt := zero32;\n" +
                        "                    v.tx_scaler_cnt := zero32;\n" +
                        "             when 2 => \n" +
                        "                    if r.fwcpuid = X\"00000000\" or tmp = X\"00000000\" then\n" +
                        "                        v.fwcpuid := tmp;\n" +
                        "                    end if;\n" +
                        "             when 4 => \n" +
                        "                    if tx_fifo_full = '0' then\n" +
                        "                        v_tfifoi.we := '1';\n" +
                        "                        v_tfifoi.wdata := tmp(7 downto 0);\n" +
                        "                        v.tx_wr_cnt := r.tx_wr_cnt + 1;\n" +
                        "                        v.tx_byte_cnt := r.tx_byte_cnt + 1;\n" +
                        "                    end if;\n" +
                        "             when others =>\n" +
                        "           end case;\n" +
                        "         end if;\n" +
                        "      end loop;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if not async_reset and nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    rin <= v;\n" +
                        "\n" +
                        "    rfifoi <= v_rfifoi;\n" +
                        "    tfifoi <= v_tfifoi;\n" +
                        "\n" +
                        "    o_irq <= irq_ena;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  cfg <= xconfig;\n" +
                        "\n" +
                        "  -- fifo pseudo memory:\n" +
                        "  tfifo0 : process(clk, tfifoi, tx_fifo)\n" +
                        "  begin \n" +
                        "     if rising_edge(clk) then \n" +
                        "        if tfifoi.we = '1' then\n" +
                        "            tx_fifo(tfifoi.waddr) <= tfifoi.wdata;\n" +
                        "        end if;\n" +
                        "     end if; \n" +
                        "     tx_fifo_rdata <= tx_fifo(tfifoi.raddr);\n" +
                        "  end process;\n" +
                        "\n" +
                        "  rfifo0 : process(clk, rfifoi, rx_fifo)\n" +
                        "  begin \n" +
                        "     if rising_edge(clk) then \n" +
                        "        if rfifoi.we = '1' then\n" +
                        "            rx_fifo(rfifoi.waddr) <= rfifoi.wdata;\n" +
                        "        end if;\n" +
                        "     end if; \n" +
                        "     rx_fifo_rdata <= rx_fifo(rfifoi.raddr);\n" +
                        "  end process;\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(clk, nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_axi4_sram_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "\n" +
                        "library techmap;\n" +
                        "use techmap.gencomp.all;\n" +
                        "use techmap.types_mem.all;\n" +
                        "\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "\n" +
                        "--! AMBA system bus specific library.\n" +
                        "library ambalib;\n" +
                        "--! AXI4 configuration constants.\n" +
                        "use ambalib.types_amba4.all;\n" +
                        "\n" +
                        "\n" +
                        "entity axi4_sram is\n" +
                        "  generic (\n" +
                        "    memtech  : integer := inferred;\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr    : integer := 0;\n" +
                        "    xmask    : integer := 16#fffff#;\n" +
                        "    abits    : integer := 17;\n" +
                        "    init_file : string := \"\" -- only for inferred\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk  : in std_logic;\n" +
                        "    nrst : in std_logic;\n" +
                        "    cfg  : out axi4_slave_config_type;\n" +
                        "    i    : in  axi4_slave_in_type;\n" +
                        "    o    : out axi4_slave_out_type\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_axi4_sram of axi4_sram is\n" +
                        "\n" +
                        "  constant xconfig : axi4_slave_config_type := (\n" +
                        "     descrtype => PNP_CFG_TYPE_SLAVE,\n" +
                        "     descrsize => PNP_CFG_SLAVE_DESCR_BYTES,\n" +
                        "     irq_idx => conv_std_logic_vector(0, 8),\n" +
                        "     xaddr => conv_std_logic_vector(xaddr, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     xmask => conv_std_logic_vector(xmask, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     vid => VENDOR_GNSSSENSOR,\n" +
                        "     did => GNSSSENSOR_SRAM\n" +
                        "  );\n" +
                        "\n" +
                        "  type ram_in_type is record\n" +
                        "    raddr : global_addr_array_type;\n" +
                        "    re    : std_logic;\n" +
                        "    waddr : global_addr_array_type;\n" +
                        "    we    : std_logic;\n" +
                        "    wstrb : std_logic_vector(CFG_SYSBUS_DATA_BYTES-1 downto 0);\n" +
                        "    wdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "  end record;\n" +
                        "\n" +
                        "signal rdata_mux : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "signal rami : ram_in_type;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  cfg  <= xconfig;\n" +
                        "\n" +
                        "  axi0 :  axi4_slave generic map (\n" +
                        "    async_reset => async_reset\n" +
                        "  ) port map (\n" +
                        "    i_clk => clk,\n" +
                        "    i_nrst => nrst,\n" +
                        "    i_xcfg => xconfig, \n" +
                        "    i_xslvi => i,\n" +
                        "    o_xslvo => o,\n" +
                        "    i_ready => '1',\n" +
                        "    i_rdata => rdata_mux,\n" +
                        "    o_re => rami.re,\n" +
                        "    o_r32 => open,\n" +
                        "    o_radr => rami.raddr,\n" +
                        "    o_wadr => rami.waddr,\n" +
                        "    o_we => rami.we,\n" +
                        "    o_wstrb => rami.wstrb,\n" +
                        "    o_wdata => rami.wdata\n" +
                        "  );\n" +
                        "\n" +
                        "  tech0 : srambytes_tech generic map (\n" +
                        "    memtech   => memtech,\n" +
                        "    abits     => abits,\n" +
                        "    init_file => init_file -- only for 'inferred'\n" +
                        "  ) port map (\n" +
                        "    clk     => clk,\n" +
                        "    raddr   => rami.raddr,\n" +
                        "    rdata   => rdata_mux,\n" +
                        "    waddr   => rami.waddr,\n" +
                        "    we      => rami.we,\n" +
                        "    wstrb   => rami.wstrb,\n" +
                        "    wdata   => rami.wdata\n" +
                        "  );\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_axi4_rom_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "\n" +
                        "library techmap;\n" +
                        "use techmap.gencomp.all;\n" +
                        "use techmap.types_mem.all;\n" +
                        "\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "\n" +
                        "--! AMBA system bus specific library\n" +
                        "library ambalib;\n" +
                        "--! AXI4 configuration constants.\n" +
                        "use ambalib.types_amba4.all;\n" +
                        "\n" +
                        "entity axi4_rom is\n" +
                        "  generic (\n" +
                        "    memtech  : integer := inferred;\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr    : integer := 0;\n" +
                        "    xmask    : integer := 16#fffff#;\n" +
                        "    sim_hexfile : string\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk  : in std_logic;\n" +
                        "    nrst : in std_logic;\n" +
                        "    cfg  : out axi4_slave_config_type;\n" +
                        "    i    : in  axi4_slave_in_type;\n" +
                        "    o    : out axi4_slave_out_type\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_axi4_rom of axi4_rom is\n" +
                        "\n" +
                        "  -- To avoid warning 'literal negative value' use -1048576 instead of 16#fff00000#\n" +
                        "  constant size_4kbytes : integer := -(xmask - 1048576); \n" +
                        "  constant abits : integer := 12 + log2(size_4kbytes);\n" +
                        "\n" +
                        "  constant xconfig : axi4_slave_config_type := (\n" +
                        "     descrtype => PNP_CFG_TYPE_SLAVE,\n" +
                        "     descrsize => PNP_CFG_SLAVE_DESCR_BYTES,\n" +
                        "     irq_idx => conv_std_logic_vector(0, 8),\n" +
                        "     xaddr => conv_std_logic_vector(xaddr, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     xmask => conv_std_logic_vector(xmask, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     vid => VENDOR_GNSSSENSOR,\n" +
                        "     did => GNSSSENSOR_ROM\n" +
                        "  );\n" +
                        "\n" +
                        "  signal raddr : global_addr_array_type;\n" +
                        "  signal rdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "  cfg  <= xconfig;\n" +
                        "\n" +
                        "  axi0 :  axi4_slave generic map (\n" +
                        "    async_reset => async_reset\n" +
                        "  ) port map (\n" +
                        "    i_clk => clk,\n" +
                        "    i_nrst => nrst,\n" +
                        "    i_xcfg => xconfig, \n" +
                        "    i_xslvi => i,\n" +
                        "    o_xslvo => o,\n" +
                        "    i_ready => '1',\n" +
                        "    i_rdata => rdata,\n" +
                        "    o_re => open,\n" +
                        "    o_r32 => open,\n" +
                        "    o_radr => raddr,\n" +
                        "    o_wadr => open,\n" +
                        "    o_we => open,\n" +
                        "    o_wstrb => open,\n" +
                        "    o_wdata => open\n" +
                        "  );\n" +
                        "\n" +
                        "  tech0 : Rom_tech generic map (\n" +
                        "    memtech => memtech,\n" +
                        "    abits => abits,\n" +
                        "    sim_hexfile => sim_hexfile\n" +
                        "  ) port map (\n" +
                        "    clk => clk,\n" +
                        "    address => raddr,\n" +
                        "    data => rdata\n" +
                        "  );\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_axi4_irqctrl_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.numeric_std.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "--! AMBA system bus specific library.\n" +
                        "library ambalib;\n" +
                        "--! AXI4 configuration constants.\n" +
                        "use ambalib.types_amba4.all;\n" +
                        "library misclib;\n" +
                        "use misclib.types_misc.all;\n" +
                        "\n" +
                        "entity axi4_irqctrl is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr : integer := 0;\n" +
                        "    xmask : integer := 16#fffff#\n" +
                        "  );\n" +
                        "  port \n" +
                        " (\n" +
                        "    clk    : in std_logic;\n" +
                        "    nrst   : in std_logic;\n" +
                        "    i_irqs : in std_logic_vector(CFG_IRQ_TOTAL-1 downto 1);\n" +
                        "    o_cfg  : out axi4_slave_config_type;\n" +
                        "    i_axi  : in axi4_slave_in_type;\n" +
                        "    o_axi  : out axi4_slave_out_type;\n" +
                        "    o_irq_meip : out std_logic\n" +
                        "  );\n" +
                        "end;\n" +
                        "\n" +
                        "architecture axi4_irqctrl_rtl of axi4_irqctrl is\n" +
                        "\n" +
                        "  constant xconfig : axi4_slave_config_type := (\n" +
                        "     descrtype => PNP_CFG_TYPE_SLAVE,\n" +
                        "     descrsize => PNP_CFG_SLAVE_DESCR_BYTES,\n" +
                        "     irq_idx => conv_std_logic_vector(0, 8),\n" +
                        "     xaddr => conv_std_logic_vector(xaddr, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     xmask => conv_std_logic_vector(xmask, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     vid => VENDOR_GNSSSENSOR,\n" +
                        "     did => GNSSSENSOR_IRQCTRL\n" +
                        "  );\n" +
                        "\n" +
                        "  constant IRQ_ZERO : std_logic_vector(CFG_IRQ_TOTAL-1 downto 1) := (others => '0');\n" +
                        "\n" +
                        "  type registers is record\n" +
                        "    --! interrupt signal delay signal to detect interrupt positive edge\n" +
                        "    irqs_z        : std_logic_vector(CFG_IRQ_TOTAL-1 downto 1);  \n" +
                        "    irqs_zz       : std_logic_vector(CFG_IRQ_TOTAL-1 downto 1);  \n" +
                        "\n" +
                        "    --! mask irq disabled: 1=disabled; 0=enabled\n" +
                        "    irqs_mask     : std_logic_vector(CFG_IRQ_TOTAL-1 downto 1);\n" +
                        "    --! irq pending bit mask\n" +
                        "    irqs_pending  : std_logic_vector(CFG_IRQ_TOTAL-1 downto 1);\n" +
                        "    --! interrupt handler address initialized by FW:\n" +
                        "    isr_table     : std_logic_vector(63 downto 0);\n" +
                        "    --! hold-on generation of interrupt.\n" +
                        "    irq_lock      : std_logic;\n" +
                        "    --! delayed interrupt\n" +
                        "    irq_wait_unlock : std_logic_vector(CFG_IRQ_TOTAL-1 downto 1);\n" +
                        "    irq_cause_idx : std_logic_vector(31 downto 0);\n" +
                        "    --! Function trap_entry copies the values of CSRs into these two regs:\n" +
                        "    dbg_cause    : std_logic_vector(63 downto 0);\n" +
                        "    dbg_epc      : std_logic_vector(63 downto 0);\n" +
                        "    raddr : global_addr_array_type;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : registers := (\n" +
                        "    (others => '0'), (others => '0'),  -- irqs_z, irqs_zz\n" +
                        "    (others => '1'), (others => '0'),  -- irqs_mask, irqs_pending\n" +
                        "    (others => '0'), '0',              -- isr_table, isr_lock\n" +
                        "    (others => '0'), (others => '0'),  -- irq_wait_unlock, irq_cause_idx\n" +
                        "    (others => '0'), (others => '0'),  -- dbg_cause, dbg_epc\n" +
                        "    ((others => '0'), (others => '0'))\n" +
                        "  );\n" +
                        "\n" +
                        "  signal r, rin: registers;\n" +
                        "\n" +
                        "  signal wb_dev_rdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "  signal wb_bus_raddr : global_addr_array_type;\n" +
                        "  signal wb_bus_waddr : global_addr_array_type;\n" +
                        "  signal w_bus_we    : std_logic;\n" +
                        "  signal wb_bus_wstrb : std_logic_vector(CFG_SYSBUS_DATA_BYTES-1 downto 0);\n" +
                        "  signal wb_bus_wdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  axi0 :  axi4_slave generic map (\n" +
                        "    async_reset => async_reset\n" +
                        "  ) port map (\n" +
                        "    i_clk => clk,\n" +
                        "    i_nrst => nrst,\n" +
                        "    i_xcfg => xconfig, \n" +
                        "    i_xslvi => i_axi,\n" +
                        "    o_xslvo => o_axi,\n" +
                        "    i_ready => '1',\n" +
                        "    i_rdata => wb_dev_rdata,\n" +
                        "    o_re => open,\n" +
                        "    o_r32 => open,\n" +
                        "    o_radr => wb_bus_raddr,\n" +
                        "    o_wadr => wb_bus_waddr,\n" +
                        "    o_we => w_bus_we,\n" +
                        "    o_wstrb => wb_bus_wstrb,\n" +
                        "    o_wdata => wb_bus_wdata\n" +
                        "  );\n" +
                        "\n" +
                        "  comblogic : process(nrst, i_irqs, r, wb_bus_raddr, wb_bus_waddr,\n" +
                        "                      w_bus_we, wb_bus_wstrb, wb_bus_wdata)\n" +
                        "    variable v : registers;\n" +
                        "    variable raddr : integer;\n" +
                        "    variable waddr : integer;\n" +
                        "    variable vrdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "    variable tmp : std_logic_vector(31 downto 0);\n" +
                        "    variable wstrb : std_logic_vector(CFG_ALIGN_BYTES-1 downto 0);\n" +
                        "    variable w_generate_ipi : std_logic;\n" +
                        "  begin\n" +
                        "    v := r;\n" +
                        "    v.raddr := wb_bus_raddr;\n" +
                        "    w_generate_ipi := '0';\n" +
                        "\n" +
                        "    vrdata := (others => '0');\n" +
                        "    for n in 0 to CFG_WORDS_ON_BUS-1 loop\n" +
                        "       raddr := conv_integer(r.raddr(n)(11 downto 2));\n" +
                        "       tmp := (others => '0');\n" +
                        "       case raddr is\n" +
                        "         when 0      => tmp(CFG_IRQ_TOTAL-1 downto 1) := r.irqs_mask;     --! [RW]: 1=irq disable; 0=enable\n" +
                        "         when 1      => tmp(CFG_IRQ_TOTAL-1 downto 1) := r.irqs_pending;  --! [RO]: Rised interrupts.\n" +
                        "         when 2      => tmp := (others => '0');                           --! [WO]: Clear interrupts mask.\n" +
                        "         when 3      => tmp := (others => '0');                           --! [WO]: Rise interrupts mask.\n" +
                        "         when 4      => tmp := r.isr_table(31 downto 0);                  --! [RW]: LSB of the function address\n" +
                        "         when 5      => tmp := r.isr_table(63 downto 32);                 --! [RW]: MSB of the function address\n" +
                        "         when 6      => tmp := r.dbg_cause(31 downto 0);                  --! [RW]: Cause of the interrupt\n" +
                        "         when 7      => tmp := r.dbg_cause(63 downto 32);                 --! [RW]: \n" +
                        "         when 8      => tmp := r.dbg_epc(31 downto 0);                    --! [RW]: Instruction pointer\n" +
                        "         when 9      => tmp := r.dbg_epc(63 downto 32);                   --! [RW]: \n" +
                        "         when 10     => tmp(0) := r.irq_lock;\n" +
                        "         when 11     => tmp := r.irq_cause_idx;\n" +
                        "         when others =>\n" +
                        "       end case;\n" +
                        "       vrdata(8*CFG_ALIGN_BYTES*(n+1)-1 downto 8*CFG_ALIGN_BYTES*n) := tmp;\n" +
                        "    end loop;\n" +
                        "\n" +
                        "    if w_bus_we = '1' then\n" +
                        "      for n in 0 to CFG_WORDS_ON_BUS-1 loop\n" +
                        "         if conv_integer(wb_bus_wstrb(CFG_ALIGN_BYTES*(n+1)-1 downto CFG_ALIGN_BYTES*n)) /= 0 then\n" +
                        "             waddr := conv_integer(wb_bus_waddr(n)(11 downto 2));\n" +
                        "             tmp := wb_bus_wdata(32*(n+1)-1 downto 32*n);\n" +
                        "\n" +
                        "             case waddr is\n" +
                        "             when 0 => v.irqs_mask := tmp(CFG_IRQ_TOTAL-1 downto 1);\n" +
                        "             when 1 =>     --! Read only\n" +
                        "             when 2 => \n" +
                        "                v.irqs_pending := r.irqs_pending and (not tmp(CFG_IRQ_TOTAL-1 downto 1));\n" +
                        "             when 3 => \n" +
                        "                w_generate_ipi := '1';\n" +
                        "                v.irqs_pending := (not r.irqs_mask) and tmp(CFG_IRQ_TOTAL-1 downto 1);\n" +
                        "             when 4 => v.isr_table(31 downto 0) := tmp;\n" +
                        "             when 5 => v.isr_table(63 downto 32) := tmp;\n" +
                        "             when 6 => v.dbg_cause(31 downto 0) := tmp;\n" +
                        "             when 7 => v.dbg_cause(63 downto 32) := tmp;\n" +
                        "             when 8 => v.dbg_epc(31 downto 0) := tmp;\n" +
                        "             when 9 => v.dbg_epc(63 downto 32) := tmp;\n" +
                        "             when 10 => v.irq_lock := tmp(0);\n" +
                        "             when 11 => v.irq_cause_idx := tmp;\n" +
                        "             when others =>\n" +
                        "             end case;\n" +
                        "         end if;\n" +
                        "      end loop;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    v.irqs_z := i_irqs;\n" +
                        "    v.irqs_zz := r.irqs_z;\n" +
                        "    for n in 1 to CFG_IRQ_TOTAL-1 loop\n" +
                        "      if (r.irqs_z(n) = '1' and r.irqs_zz(n) = '0') or r.irq_wait_unlock(n) = '1' then\n" +
                        "         if r.irq_lock = '0' then\n" +
                        "             v.irq_wait_unlock(n) := '0';\n" +
                        "             v.irqs_pending(n) := not r.irqs_mask(n);\n" +
                        "             w_generate_ipi := w_generate_ipi or (not r.irqs_mask(n));\n" +
                        "         else\n" +
                        "             v.irq_wait_unlock(n) := '1';\n" +
                        "         end if;\n" +
                        "      end if;\n" +
                        "    end loop;\n" +
                        "\n" +
                        "\n" +
                        "    if r.irqs_pending = IRQ_ZERO or r.irq_lock = '1' then\n" +
                        "      o_irq_meip <= '0';\n" +
                        "    else\n" +
                        "      o_irq_meip <= '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if not async_reset and nrst = '0' then \n" +
                        "       v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    rin <= v;\n" +
                        "    wb_dev_rdata <= vrdata;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  o_cfg  <= xconfig;\n" +
                        "\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(clk, nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_axi4_gptimers_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "--! AMBA system bus specific library.\n" +
                        "library ambalib;\n" +
                        "--! AXI4 configuration constants.\n" +
                        "use ambalib.types_amba4.all;\n" +
                        "library misclib;\n" +
                        "use misclib.types_misc.all;\n" +
                        "\n" +
                        "entity axi4_gptimers is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr   : integer := 0;\n" +
                        "    xmask   : integer := 16#fffff#;\n" +
                        "    xirq    : integer := 0;\n" +
                        "    tmr_total  : integer := 2\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk    : in  std_logic;\n" +
                        "    nrst   : in  std_logic;\n" +
                        "    cfg    : out axi4_slave_config_type;\n" +
                        "    i_axi  : in  axi4_slave_in_type;\n" +
                        "    o_axi  : out axi4_slave_out_type;\n" +
                        "    o_irq  : out std_logic\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_axi4_gptimers of axi4_gptimers is\n" +
                        "\n" +
                        "  constant xconfig : axi4_slave_config_type := (\n" +
                        "     descrtype => PNP_CFG_TYPE_SLAVE,\n" +
                        "     descrsize => PNP_CFG_SLAVE_DESCR_BYTES,\n" +
                        "     irq_idx => conv_std_logic_vector(xirq, 8),\n" +
                        "     xaddr => conv_std_logic_vector(xaddr, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     xmask => conv_std_logic_vector(xmask, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     vid => VENDOR_GNSSSENSOR,\n" +
                        "     did => GNSSSENSOR_GPTIMERS\n" +
                        "  );\n" +
                        "\n" +
                        "  constant zero64 : std_logic_vector(63 downto 0) := (others => '0');\n" +
                        "\n" +
                        "  type timer_type is record\n" +
                        "      count_ena : std_logic;\n" +
                        "      irq_ena   : std_logic;\n" +
                        "		overflow  : std_logic;\n" +
                        "      value : std_logic_vector(63 downto 0);\n" +
                        "      init_value : std_logic_vector(63 downto 0);\n" +
                        "  end record;\n" +
                        "  \n" +
                        "  constant timer_type_reset : timer_type := \n" +
                        "     ('0', '0', '0',(others => '0'), (others => '0'));\n" +
                        "\n" +
                        "  type vector_timer_type is array (0 to tmr_total-1) of timer_type;\n" +
                        "\n" +
                        "  type registers is record\n" +
                        "    tmr  : vector_timer_type;\n" +
                        "    highcnt : std_logic_vector(63 downto 0);\n" +
                        "    pending : std_logic_vector(tmr_total-1 downto 0);\n" +
                        "    raddr : global_addr_array_type;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : registers := (\n" +
                        "      (others => timer_type_reset), (others => '0'), (others => '0'),\n" +
                        "      ((others => '0'), (others => '0'))\n" +
                        "  );\n" +
                        "\n" +
                        "  signal r, rin : registers;\n" +
                        "\n" +
                        "  signal wb_dev_rdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "  signal wb_bus_raddr : global_addr_array_type;\n" +
                        "  signal wb_bus_waddr : global_addr_array_type;\n" +
                        "  signal w_bus_we    : std_logic;\n" +
                        "  signal wb_bus_wstrb : std_logic_vector(CFG_SYSBUS_DATA_BYTES-1 downto 0);\n" +
                        "  signal wb_bus_wdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  axi0 :  axi4_slave generic map (\n" +
                        "    async_reset => async_reset\n" +
                        "  ) port map (\n" +
                        "    i_clk => clk,\n" +
                        "    i_nrst => nrst,\n" +
                        "    i_xcfg => xconfig, \n" +
                        "    i_xslvi => i_axi,\n" +
                        "    o_xslvo => o_axi,\n" +
                        "    i_ready => '1',\n" +
                        "    i_rdata => wb_dev_rdata,\n" +
                        "    o_re => open,\n" +
                        "    o_r32 => open,\n" +
                        "    o_radr => wb_bus_raddr,\n" +
                        "    o_wadr => wb_bus_waddr,\n" +
                        "    o_we => w_bus_we,\n" +
                        "    o_wstrb => wb_bus_wstrb,\n" +
                        "    o_wdata => wb_bus_wdata\n" +
                        "  );\n" +
                        "\n" +
                        "  comblogic : process(nrst, r, wb_bus_raddr, wb_bus_waddr,\n" +
                        "                      w_bus_we, wb_bus_wstrb, wb_bus_wdata)\n" +
                        "    variable v : registers;\n" +
                        "    variable raddr : integer;\n" +
                        "    variable waddr : integer;\n" +
                        "    variable vrdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "    variable tmp : std_logic_vector(31 downto 0);\n" +
                        "    variable irq_ena : std_logic;\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    v.raddr := wb_bus_raddr;\n" +
                        "\n" +
                        "    v.highcnt := r.highcnt + 1;\n" +
                        "\n" +
                        "    irq_ena := '0';\n" +
                        "    for n in 0 to tmr_total-1 loop\n" +
                        "        if r.tmr(n).count_ena = '1' then \n" +
                        "           if r.tmr(n).value = zero64 then\n" +
                        "               irq_ena := irq_ena or r.tmr(n).irq_ena;\n" +
                        "               v.pending(n) := r.tmr(n).irq_ena;\n" +
                        "               v.tmr(n).value := r.tmr(n).init_value;\n" +
                        "					v.tmr(n).overflow := '1';\n" +
                        "           else\n" +
                        "               v.tmr(n).value := r.tmr(n).value - 1;\n" +
                        "           end if;\n" +
                        "        else\n" +
                        "           v.tmr(n).value := r.tmr(n).init_value;\n" +
                        "        end if;\n" +
                        "    end loop;\n" +
                        "\n" +
                        "\n" +
                        "    for n in 0 to CFG_WORDS_ON_BUS-1 loop\n" +
                        "       tmp := (others => '0');\n" +
                        "       raddr := conv_integer(r.raddr(n)(11 downto 2));\n" +
                        "       case raddr is\n" +
                        "          when 0 => \n" +
                        "                tmp := r.highcnt(31 downto 0);\n" +
                        "          when 1 => \n" +
                        "                tmp := r.highcnt(63 downto 32);\n" +
                        "          when 2 => \n" +
                        "                tmp(tmr_total-1 downto 0) := r.pending;\n" +
                        "          when others => \n" +
                        "                for k in 0 to tmr_total-1 loop\n" +
                        "                   if raddr = (16 + 8*k) then\n" +
                        "                      tmp(0) := r.tmr(k).count_ena;\n" +
                        "                      tmp(1) := r.tmr(k).irq_ena;\n" +
                        "							 tmp(2) := r.tmr(k).overflow;\n" +
                        "                   elsif raddr = (16 + 8*k + 2) then\n" +
                        "                      tmp := r.tmr(k).value(31 downto 0);\n" +
                        "                   elsif raddr = (16 + 8*k + 3) then\n" +
                        "                      tmp := r.tmr(k).value(63 downto 32);\n" +
                        "                   elsif raddr = (16 + 8*k + 4) then\n" +
                        "                      tmp := r.tmr(k).init_value(31 downto 0);\n" +
                        "                   elsif raddr = (16 + 8*k + 5) then\n" +
                        "                      tmp := r.tmr(k).init_value(63 downto 32);\n" +
                        "                   end if;\n" +
                        "                end loop;\n" +
                        "       end case;\n" +
                        "       vrdata(8*CFG_ALIGN_BYTES*(n+1)-1 downto 8*CFG_ALIGN_BYTES*n) := tmp;\n" +
                        "    end loop;\n" +
                        "\n" +
                        "\n" +
                        "    if w_bus_we = '1' then\n" +
                        "      for n in 0 to CFG_WORDS_ON_BUS-1 loop\n" +
                        "\n" +
                        "         if conv_integer(wb_bus_wstrb(CFG_ALIGN_BYTES*(n+1)-1 downto CFG_ALIGN_BYTES*n)) /= 0 then\n" +
                        "           tmp := wb_bus_wdata(8*CFG_ALIGN_BYTES*(n+1)-1 downto 8*CFG_ALIGN_BYTES*n);\n" +
                        "           waddr := conv_integer(wb_bus_waddr(n)(11 downto 2));\n" +
                        "           case waddr is\n" +
                        "             when 2 => \n" +
                        "                v.pending := tmp(tmr_total-1 downto 0);\n" +
                        "             when others =>\n" +
                        "                for k in 0 to tmr_total-1 loop\n" +
                        "                   if waddr = (16 + 8*k) then\n" +
                        "                      v.tmr(k).count_ena := tmp(0);\n" +
                        "                      v.tmr(k).irq_ena := tmp(1);\n" +
                        "							 v.tmr(k).overflow := tmp(2);\n" +
                        "                   elsif waddr = (16 + 8*k + 2) then\n" +
                        "                      v.tmr(k).value(31 downto 0) := tmp;\n" +
                        "                   elsif waddr = (16 + 8*k + 3) then\n" +
                        "                      v.tmr(k).value(63 downto 32) := tmp;\n" +
                        "                   elsif waddr = (16 + 8*k + 4) then\n" +
                        "                      v.tmr(k).init_value(31 downto 0) := tmp;\n" +
                        "                   elsif waddr = (16 + 8*k + 5) then\n" +
                        "                      v.tmr(k).init_value(63 downto 32) := tmp;\n" +
                        "                   end if;\n" +
                        "                end loop;\n" +
                        "           end case;\n" +
                        "         end if;\n" +
                        "      end loop;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if not async_reset and nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "    rin <= v;\n" +
                        "\n" +
                        "    o_irq <= irq_ena;\n" +
                        "    wb_dev_rdata <= vrdata;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  cfg <= xconfig;\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(clk, nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_axi4_gpio_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.numeric_std.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "--! AMBA system bus specific library.\n" +
                        "library ambalib;\n" +
                        "--! AXI4 configuration constants.\n" +
                        "use ambalib.types_amba4.all;\n" +
                        "\n" +
                        "entity axi4_gpio is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr    : integer := 0;\n" +
                        "    xmask    : integer := 16#fffff#;\n" +
                        "    xirq     : integer := 0\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk  		: in std_logic;\n" +
                        "    nrst 		: in std_logic;\n" +
                        "    cfg  		: out axi4_slave_config_type;\n" +
                        "    i    		: in  axi4_slave_in_type;\n" +
                        "    o  		  	: out axi4_slave_out_type;\n" +
                        "    KEY			: in std_logic_vector(3 DOWNTO 0);\n" +
                        "	 SW			: in std_logic_vector(9 DOWNTO 0);\n" +
                        "    LEDG			: out std_logic_vector(7 DOWNTO 0);\n" +
                        "    LEDR			: out std_logic_vector(9 DOWNTO 0);\n" +
                        "    GPIO_IN		: in std_logic_vector(17 DOWNTO 0);\n" +
                        "    GPIO_OUT	: out std_logic_vector(17 DOWNTO 0)\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_axi4_gpio of axi4_gpio is\n" +
                        "\n" +
                        "  constant xconfig : axi4_slave_config_type := (\n" +
                        "     descrtype => PNP_CFG_TYPE_SLAVE,\n" +
                        "     descrsize => PNP_CFG_SLAVE_DESCR_BYTES,\n" +
                        "     irq_idx => conv_std_logic_vector(xirq, 8),\n" +
                        "     xaddr => conv_std_logic_vector(xaddr, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     xmask => conv_std_logic_vector(xmask, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     vid => VENDOR_GNSSSENSOR,\n" +
                        "     did => GNSSSENSOR_GPIO\n" +
                        "  );\n" +
                        "\n" +
                        "  signal wb_dev_rdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "  signal wb_bus_raddr : global_addr_array_type;\n" +
                        "  signal w_bus_re    : std_logic;\n" +
                        "  signal wb_bus_waddr : global_addr_array_type;\n" +
                        "  signal w_bus_we    : std_logic;\n" +
                        "  signal wb_bus_wstrb : std_logic_vector(CFG_SYSBUS_DATA_BYTES-1 downto 0);\n" +
                        "  signal wb_bus_wdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "\n" +
                        "  signal address_w		: STD_LOGIC_VECTOR(31 DOWNTO 0);\n" +
                        "  signal wstrb				: global_addr_array_type;\n" +
                        "  \n" +
                        "  signal register_in		: STD_LOGIC_VECTOR(63 DOWNTO 0);   -- 32 - 0\n" +
                        "  signal register_out	: STD_LOGIC_VECTOR(63 DOWNTO 0);   -- 36 - 0\n" +
                        "  signal OUT_Data_1		: STD_LOGIC;\n" +
                        "  signal OUT_Data_2		: STD_LOGIC;\n" +
                        "	\n" +
                        "begin\n" +
                        "\n" +
                        "  axi0 :  axi4_slave generic map (\n" +
                        "    async_reset => async_reset\n" +
                        "  ) port map (\n" +
                        "    i_clk => clk,\n" +
                        "    i_nrst => nrst,\n" +
                        "    i_xcfg => xconfig, \n" +
                        "    i_xslvi => i,\n" +
                        "    o_xslvo => o,\n" +
                        "    i_ready => '1',\n" +
                        "    i_rdata => wb_dev_rdata,\n" +
                        "    o_re => w_bus_re,\n" +
                        "    o_r32 => open,\n" +
                        "    o_radr => wb_bus_raddr,\n" +
                        "    o_wadr => wb_bus_waddr,\n" +
                        "    o_we => w_bus_we,\n" +
                        "    o_wstrb => wb_bus_wstrb,\n" +
                        "    o_wdata => wb_bus_wdata\n" +
                        "  );\n" +
                        "\n" +
                        "  wb_dev_rdata <= \"0000000000000000000000000000000\" & OUT_Data_2 &\"0000000000000000000000000000000\" & OUT_Data_1;\n" +
                        "  cfg  <= xconfig;\n" +
                        "  \n" +
                        "  wstrb(0) <= (others => wb_bus_wstrb(0));\n" +
                        "  wstrb(1) <= (others => wb_bus_wstrb(4));\n" +
                        "  address_w <= ((wb_bus_waddr(0) and wstrb(0)) or (wb_bus_waddr(1) and wstrb(1)));\n" +
                        "  \n" +
                        "  -- registers:\n" +
                        "  regs : process(clk, nrst)\n" +
                        "  begin \n" +
                        "     if not(async_reset) and nrst = '0' then\n" +
                        "        register_in	<= (OTHERS => '0');\n" +
                        "		  register_out	<= (OTHERS => '0');\n" +
                        "		  GPIO_OUT		<= (OTHERS => '0');\n" +
                        "		  LEDR			<= (OTHERS => '0');\n" +
                        "		  LEDG			<= (OTHERS => '0');\n" +
                        "		  OUT_Data_1	<= '0';\n" +
                        "		  OUT_Data_2	<= '0';\n" +
                        "     elsif rising_edge(clk) then \n" +
                        "        if w_bus_we = '1' then   -- write\n" +
                        "				if address_w(8 downto 2) = \"1111111\" then\n" +
                        "					register_in        <= \"00000000000000000000000000000000\" & KEY & SW & GPIO_IN;\n" +
                        "					GPIO_OUT           <= register_out(17 downto 0);\n" +
                        "					LEDR               <= register_out(27 downto 18);\n" +
                        "					LEDG               <= register_out(35 downto 28);\n" +
                        "				else\n" +
                        "					register_out(to_integer(unsigned(address_w(7 downto 2)))) <= wb_bus_wdata(0);\n" +
                        "				end if;\n" +
                        "			elsif w_bus_re = '1' then -- read\n" +
                        "				if wb_bus_raddr(0)(8) = '0' then   -- read inputs\n" +
                        "					OUT_Data_1 <= register_in(to_integer(unsigned(wb_bus_raddr(0)(7 downto 2))));\n" +
                        "				else                       -- read outputs\n" +
                        "					OUT_Data_1 <= register_out(to_integer(unsigned(wb_bus_raddr(0)(7 downto 2))));\n" +
                        "				end if;\n" +
                        "				if wb_bus_raddr(1)(8) = '0' then   -- read inputs\n" +
                        "					OUT_Data_2 <= register_in(to_integer(unsigned(wb_bus_raddr(1)(7 downto 2))));\n" +
                        "				else                       -- read outputs\n" +
                        "					OUT_Data_2 <= register_out(to_integer(unsigned(wb_bus_raddr(1)(7 downto 2))));\n" +
                        "				end if;\n" +
                        "		   end if;\n" +
                        "     end if; \n" +
                        "  end process;  \n" +
                        "  \n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_axi4_time_measurement_vhd_file(String Project_Folder_File) {
        String data =   "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.numeric_std.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "--! AMBA system bus specific library.\n" +
                        "library ambalib;\n" +
                        "--! AXI4 configuration constants.\n" +
                        "use ambalib.types_amba4.all;\n" +
                        "\n" +
                        "--! The following registers are defined:\n" +
                        "--! |---------|-------------------|\n" +
                        "--! | Address | Description       |\n" +
                        "--! |---------|-------------------|\n" +
                        "--! | 0b00    | START_STOP_A      |\n" +
                        "--! | 0b10    | MICRO_NANO_A      |\n" +
                        "--! | 0b00    | READ_TIME_A       |\n" +
                        "--! | 0b11    |                   |\n" +
                        "--! |---------|-------------------|\n" +
                        "\n" +
                        "entity axi4_time_measurement is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr    : integer := 0;\n" +
                        "    xmask    : integer := 16#fffff#;\n" +
                        "    xirq     : integer := 0\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk  		: in std_logic;\n" +
                        "    nrst 		: in std_logic;\n" +
                        "    cfg  		: out axi4_slave_config_type;\n" +
                        "    i    		: in  axi4_slave_in_type;\n" +
                        "    o  		  	: out axi4_slave_out_type;\n" +
                        "	 \n" +
                        "	 -- HEX interface\n" +
                        "	 HEX0			: OUT STD_LOGIC_VECTOR(6 DOWNTO 0);\n" +
                        "	 HEX1			: OUT STD_LOGIC_VECTOR(6 DOWNTO 0);\n" +
                        "	 HEX2			: OUT STD_LOGIC_VECTOR(6 DOWNTO 0);\n" +
                        "	 HEX3			: OUT STD_LOGIC_VECTOR(6 DOWNTO 0)\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_axi4_time_measurement  of axi4_time_measurement is\n" +
                        "\n" +
                        "  constant xconfig : axi4_slave_config_type := (\n" +
                        "     descrtype => PNP_CFG_TYPE_SLAVE,\n" +
                        "     descrsize => PNP_CFG_SLAVE_DESCR_BYTES,\n" +
                        "     irq_idx => conv_std_logic_vector(xirq, 8),\n" +
                        "     xaddr => conv_std_logic_vector(xaddr, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     xmask => conv_std_logic_vector(xmask, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     vid => VENDOR_GNSSSENSOR,\n" +
                        "     did => GNSSSENSOR_GPIO\n" +
                        "  );\n" +
                        "\n" +
                        "  signal wb_dev_rdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "  signal wb_bus_waddr : global_addr_array_type;\n" +
                        "  signal w_bus_we    : std_logic;\n" +
                        "  signal wb_bus_wdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "	\n" +
                        "  \n" +
                        "  signal Micro_Nano				: std_logic := '0'; -- Micro = 1, Nano = 0\n" +
                        "  signal Start_Stop				: std_logic := '0'; -- Start = 1, Stop = 0\n" +
                        "begin\n" +
                        "\n" +
                        "  axi0 :  axi4_slave generic map (\n" +
                        "    async_reset => async_reset\n" +
                        "  ) port map (\n" +
                        "    i_clk => clk,\n" +
                        "    i_nrst => nrst,\n" +
                        "    i_xcfg => xconfig, \n" +
                        "    i_xslvi => i,\n" +
                        "    o_xslvo => o,\n" +
                        "    i_ready => '1',\n" +
                        "    i_rdata => wb_dev_rdata,\n" +
                        "    o_re => open,\n" +
                        "    o_r32 => open,\n" +
                        "    o_radr => open,\n" +
                        "    o_wadr => wb_bus_waddr,\n" +
                        "    o_we => w_bus_we,\n" +
                        "    o_wstrb => open,\n" +
                        "    o_wdata => wb_bus_wdata\n" +
                        "  );\n" +
                        "  \n" +
                        "  cfg  <= xconfig;\n" +
                        "  \n" +
                        "  -- registers:\n" +
                        "  regs : process(clk, nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and nrst = '0' then\n" +
                        "			\n" +
                        "			\n" +
                        "     elsif rising_edge(clk) then \n" +
                        "			if w_bus_we = '1' then --write\n" +
                        "				IF (wb_bus_waddr(0)(4 downto 2) = \"000\") THEN\n" +
                        "					if wb_bus_wdata(7 downto 0) = X\"71\" then\n" +
                        "						Start_Stop <= '1';\n" +
                        "					elsif wb_bus_wdata(7 downto 0) = X\"53\" then\n" +
                        "						Start_Stop <= '0';\n" +
                        "					end if;\n" +
                        "				ELSIF (wb_bus_waddr(0)(4 downto 2) = \"010\") THEN\n" +
                        "					if wb_bus_wdata(7 downto 0) = X\"36\" then\n" +
                        "						Micro_Nano <= '1';\n" +
                        "					elsif wb_bus_wdata(7 downto 0) = X\"42\" then\n" +
                        "						Micro_Nano <= '0';\n" +
                        "					end if;\n" +
                        "				END IF;\n" +
                        "			end if;\n" +
                        "     end if;\n" +
                        "  end process;\n" +
                        "  \n" +
                        "  TimeCalculation: entity work.Time_Calculation\n" +
                        "		port map(\n" +
                        "			clk 			=> clk,\n" +
                        "			nrst 			=> nrst,\n" +
                        "			\n" +
                        "			-- Time Signals\n" +
                        "			Time_Micro_Nano	=> open,\n" +
                        "			Micro_Nano			=> Micro_Nano,\n" +
                        "			Start_Stop			=> Start_Stop,\n" +
                        "			\n" +
                        "			-- HEX interface\n" +
                        "			HEX0					=> HEX0,\n" +
                        "			HEX1					=> HEX1,\n" +
                        "			HEX2					=> HEX2,\n" +
                        "			HEX3					=> HEX3\n" +
                        "		);\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_axi4_ton_vhd_file(String Project_Folder_File) {
        String data =   "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.numeric_std.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "--! AMBA system bus specific library.\n" +
                        "library ambalib;\n" +
                        "--! AXI4 configuration constants.\n" +
                        "use ambalib.types_amba4.all;\n" +
                        "\n" +
                        "--! The following registers are defined:\n" +
                        "--! |---------|-------------------|\n" +
                        "--! | Address | Description       |\n" +
                        "--! |---------|-------------------|\n" +
                        "--! | 0x00 r  | Elapsed Time (64) |\n" +
                        "--! | 0x08 r  | Q                 |\n" +
                        "--! | 0x00 w  | Preset  Time (64) |\n" +
                        "--! | 0x08 w  | IN                |\n" +
                        "--! |---------|-------------------|\n" +
                        "\n" +
                        "entity axi4_ton is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr    : integer := 0;\n" +
                        "    xmask    : integer := 16#fffff#;\n" +
                        "    xirq     : integer := 0\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk  		: in std_logic;\n" +
                        "    nrst 		: in std_logic;\n" +
                        "    cfg  		: out axi4_slave_config_type;\n" +
                        "    i    		: in  axi4_slave_in_type;\n" +
                        "    o  		  	: out axi4_slave_out_type\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_axi4_ton  of axi4_ton is\n" +
                        "\n" +
                        "  constant xconfig : axi4_slave_config_type := (\n" +
                        "     descrtype => PNP_CFG_TYPE_SLAVE,\n" +
                        "     descrsize => PNP_CFG_SLAVE_DESCR_BYTES,\n" +
                        "     irq_idx => conv_std_logic_vector(xirq, 8),\n" +
                        "     xaddr => conv_std_logic_vector(xaddr, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     xmask => conv_std_logic_vector(xmask, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     vid => VENDOR_GNSSSENSOR,\n" +
                        "     did => GNSSSENSOR_GPIO\n" +
                        "  );\n" +
                        "\n" +
                        "  signal wb_dev_rdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "  signal wb_bus_raddr : global_addr_array_type;\n" +
                        "  signal w_bus_re    : std_logic;\n" +
                        "  signal wb_bus_waddr : global_addr_array_type;\n" +
                        "  signal w_bus_we    : std_logic;\n" +
                        "  signal wb_bus_wstrb : std_logic_vector(CFG_SYSBUS_DATA_BYTES-1 downto 0);\n" +
                        "  signal wb_bus_wdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "  \n" +
                        "  signal IN_T, Q   : std_logic;\n" +
                        "  signal PT, ET    : std_logic_vector(63 DOWNTO 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  axi0 :  axi4_slave generic map (\n" +
                        "    async_reset => async_reset\n" +
                        "  ) port map (\n" +
                        "    i_clk => clk,\n" +
                        "    i_nrst => nrst,\n" +
                        "    i_xcfg => xconfig, \n" +
                        "    i_xslvi => i,\n" +
                        "    o_xslvo => o,\n" +
                        "    i_ready => '1',\n" +
                        "    i_rdata => wb_dev_rdata,\n" +
                        "    o_re => w_bus_re,\n" +
                        "    o_r32 => open,\n" +
                        "    o_radr => wb_bus_raddr,\n" +
                        "    o_wadr => wb_bus_waddr,\n" +
                        "    o_we => w_bus_we,\n" +
                        "    o_wstrb => wb_bus_wstrb,\n" +
                        "    o_wdata => wb_bus_wdata\n" +
                        "  );\n" +
                        "  \n" +
                        "  Counter: entity work.Counter_Down_64_bit_Cin  PORT MAP(clk, nrst, IN_T, PT, Q, ET);\n" +
                        "\n" +
                        "  cfg  <= xconfig;\n" +
                        "  \n" +
                        "  -- registers:\n" +
                        "  regs : process(clk, nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and nrst = '0' then\n" +
                        "			wb_dev_rdata<= (OTHERS => '0');\n" +
                        "			PT       <= (OTHERS => '0');\n" +
                        "			IN_T     <= '0';\n" +
                        "     elsif rising_edge(clk) then \n" +
                        "			if w_bus_we = '1' then --write\n" +
                        "				IF (wb_bus_waddr(0)(3 downto 2) = \"00\") THEN\n" +
                        "					PT  <= wb_bus_wdata;\n" +
                        "				ELSIF (wb_bus_waddr(0)(3 downto 2) = \"10\") THEN\n" +
                        "					IN_T <= wb_bus_wdata(0);\n" +
                        "				END IF;\n" +
                        "			elsif w_bus_re = '1' then -- read\n" +
                        "				IF (wb_bus_raddr(0)(3 downto 2) = \"00\") THEN\n" +
                        "					wb_dev_rdata  <= ET;\n" +
                        "				ELSIF (wb_bus_raddr(0)(3 downto 2) = \"10\") THEN\n" +
                        "					wb_dev_rdata(0) <= Q;\n" +
                        "				ELSE\n" +
                        "					wb_dev_rdata <= (others => '0');\n" +
                        "				END IF;\n" +
                        "			end if;\n" +
                        "     end if;\n" +
                        "	  \n" +
                        "  end process;  \n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_axi4_pwm_vhd_file(String Project_Folder_File) {
        String data =   "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.numeric_std.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "--! AMBA system bus specific library.\n" +
                        "library ambalib;\n" +
                        "--! AXI4 configuration constants.\n" +
                        "use ambalib.types_amba4.all;\n" +
                        "\n" +
                        "--! The following registers are defined:\n" +
                        "--! |---------|-------------------|\n" +
                        "--! | Address | Description       |\n" +
                        "--! |---------|-------------------|\n" +
                        "--! | 0x00 r  | Q                 |\n" +
                        "--! | 0x00 w  | Frequency         |\n" +
                        "--! | 0x04 w  | Duty Cycle        |\n" +
                        "--! |---------|-------------------|\n" +
                        "\n" +
                        "entity axi4_pwm is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr    : integer := 0;\n" +
                        "    xmask    : integer := 16#fffff#;\n" +
                        "    xirq     : integer := 0\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk  		: in std_logic;\n" +
                        "    clk_pwm 	: in std_logic;\n" +
                        "    nrst 		: in std_logic;\n" +
                        "    cfg  		: out axi4_slave_config_type;\n" +
                        "    i    		: in  axi4_slave_in_type;\n" +
                        "    o  		  	: out axi4_slave_out_type\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_axi4_pwm  of axi4_pwm is\n" +
                        "  \n" +
                        "  constant xconfig : axi4_slave_config_type := (\n" +
                        "     descrtype => PNP_CFG_TYPE_SLAVE,\n" +
                        "     descrsize => PNP_CFG_SLAVE_DESCR_BYTES,\n" +
                        "     irq_idx => conv_std_logic_vector(xirq, 8),\n" +
                        "     xaddr => conv_std_logic_vector(xaddr, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     xmask => conv_std_logic_vector(xmask, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     vid => VENDOR_GNSSSENSOR,\n" +
                        "     did => GNSSSENSOR_GPIO\n" +
                        "  );\n" +
                        "\n" +
                        "  signal wb_dev_rdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "  signal w_bus_re    : std_logic;\n" +
                        "  signal w_bus_we    : std_logic;\n" +
                        "  signal wb_bus_wdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "  \n" +
                        "  SIGNAL EN 		: std_logic;\n" +
                        "  SIGNAL i_Q, o_Q	: std_logic_vector(0 DOWNTO 0);\n" +
                        "  SIGNAL i_DC		: std_logic_vector(6 DOWNTO 0);\n" +
                        "  SIGNAL o_DC		: std_logic_vector(6 DOWNTO 0);\n" +
                        "  SIGNAL i_Frq		: std_logic_vector(16 DOWNTO 0);\n" +
                        "  SIGNAL o_Frq		: std_logic_vector(16 DOWNTO 0);\n" +
                        "	\n" +
                        "  SIGNAL T_Count, Comp_Count	: STD_LOGIC_VECTOR(19 downto 0);\n" +
                        "  \n" +
                        "  signal rst     : STD_LOGIC;\n" +
                        "  signal rdreq   : STD_LOGIC;\n" +
                        "  signal wrreq   : STD_LOGIC;\n" +
                        "  signal rdempty : STD_LOGIC;\n" +
                        "  signal wrempty : STD_LOGIC;\n" +
                        " \n" +
                        "  signal rdreq_Q   : STD_LOGIC;\n" +
                        "  signal wrreq_Q   : STD_LOGIC;\n" +
                        "  signal rdempty_Q : STD_LOGIC;\n" +
                        "  signal wrempty_Q : STD_LOGIC; \n" +
                        "  \n" +
                        "begin\n" +
                        "\n" +
                        "  axi0 :  axi4_slave generic map (\n" +
                        "    async_reset => async_reset\n" +
                        "  ) port map (\n" +
                        "    i_clk => clk,\n" +
                        "    i_nrst => nrst,\n" +
                        "    i_xcfg => xconfig, \n" +
                        "    i_xslvi => i,\n" +
                        "    o_xslvo => o,\n" +
                        "    i_ready => '1',\n" +
                        "    i_rdata => wb_dev_rdata,\n" +
                        "    o_re => w_bus_re,\n" +
                        "    o_r32 => open,\n" +
                        "    o_radr => open,\n" +
                        "    o_wadr => open,\n" +
                        "    o_we => w_bus_we,\n" +
                        "    o_wstrb => open,\n" +
                        "    o_wdata => wb_bus_wdata\n" +
                        "  );\n" +
                        "  \n" +
                        "  PWM			: entity work.PWM_32_bit	PORT MAP(clk_pwm, nrst, EN, T_Count, Comp_Count, i_Q(0));\n" +
                        "  \n" +
                        "  CDC_Frq_I : entity work.CDC_Frq      PORT MAP(rst, i_Frq, clk_pwm, rdreq,   clk,     wrreq,   o_Frq, rdempty,   wrempty  );\n" +
                        "  CDC_DC_I  : entity work.CDC_DC       PORT MAP(rst, i_DC,  clk_pwm, rdreq,   clk,     wrreq,   o_DC,  open,      open     );\n" +
                        "  CDC_Q_I   : entity work.CDC_Q        PORT MAP(rst, i_Q,   clk,     rdreq_Q, clk_pwm, wrreq_Q, o_Q,   rdempty_Q, wrempty_Q);\n" +
                        "  \n" +
                        "  PWM_Sig	: entity work.PWM_Signal	PORT MAP(nrst, o_Frq, o_DC, T_Count, Comp_Count);\n" +
                        "\n" +
                        "  EN      <= '1';\n" +
                        "  cfg     <= xconfig;\n" +
                        "  rst     <= not nrst;\n" +
                        "  rdreq   <= not rdempty;\n" +
                        "  rdreq_Q <= not rdempty_Q;\n" +
                        "  \n" +
                        "  -- registers:\n" +
                        "  regs : process(clk, nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and nrst = '0' then\n" +
                        "			wb_dev_rdata<= (OTHERS => '0');\n" +
                        "			i_Frq			<= (OTHERS => '1');\n" +
                        "			i_DC			<= (OTHERS => '0');\n" +
                        "			wrreq       <= '0';\n" +
                        "     elsif rising_edge(clk) then \n" +
                        "         if nrst = '0' then\n" +
                        "				wb_dev_rdata<= (OTHERS => '0');\n" +
                        "				i_Frq			<= (OTHERS => '1');\n" +
                        "				i_DC			<= (OTHERS => '0');\n" +
                        "				wrreq       <= '0';\n" +
                        "			else\n" +
                        "				if w_bus_we = '1' then --write\n" +
                        "					i_Frq	<= wb_bus_wdata(16 downto 0);\n" +
                        "					i_DC	<= wb_bus_wdata(38 downto 32);\n" +
                        "				elsif w_bus_re = '1' then -- read\n" +
                        "					wb_dev_rdata(0) <= o_Q(0);\n" +
                        "				end if;\n" +
                        "				\n" +
                        "				if wrempty = '1' and rdempty = '1' then\n" +
                        "					wrreq <= '1';\n" +
                        "				else \n" +
                        "					wrreq <= '0';\n" +
                        "				end if;\n" +
                        "				\n" +
                        "				if wrempty_Q = '1' and rdempty_Q = '1' then\n" +
                        "					wrreq_Q <= '1';\n" +
                        "				else \n" +
                        "					wrreq_Q <= '0';\n" +
                        "				end if;\n" +
                        "				\n" +
                        "			end if;\n" +
                        "     end if;\n" +
                        "  end process;\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_axi4_pid_vhd_file(String Project_Folder_File) {
        String data =   "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.numeric_std.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "--! AMBA system bus specific library.\n" +
                        "library ambalib;\n" +
                        "--! AXI4 configuration constants.\n" +
                        "use ambalib.types_amba4.all;\n" +
                        "\n" +
                        "--! The following registers are defined:\n" +
                        "--! |---------|-------------------|\n" +
                        "--! | Address | Description       |\n" +
                        "--! |---------|-------------------|\n" +
                        "--! | 0x00 W  | TS     (64)       |\n" +
                        "--! | 0x08 W  | PV, SP (64)       |\n" +
                        "--! | 0x10 w  | b0, b1 (64)       |\n" +
                        "--! | 0x18 w  | b2     (32)       |\n" +
                        "--! | 0x00 r  | XOUT   (32)       |\n" +
                        "--! | 0x08 r  | XOUT_R (32)       |\n" +
                        "--! |---------|-------------------|\n" +
                        "\n" +
                        "entity axi4_pid is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr    : integer := 0;\n" +
                        "    xmask    : integer := 16#fffff#;\n" +
                        "    xirq     : integer := 0\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk  		: in std_logic;\n" +
                        "    nrst 		: in std_logic;\n" +
                        "    cfg  		: out axi4_slave_config_type;\n" +
                        "    i    		: in  axi4_slave_in_type;\n" +
                        "    o  		 	: out axi4_slave_out_type\n" +
                        "  );\n" +
                        "end;\n" +
                        " \n" +
                        "architecture arch_axi4_pid  of axi4_pid is\n" +
                        "\n" +
                        "  constant xconfig : axi4_slave_config_type := (\n" +
                        "     descrtype => PNP_CFG_TYPE_SLAVE,\n" +
                        "     descrsize => PNP_CFG_SLAVE_DESCR_BYTES,\n" +
                        "     irq_idx => conv_std_logic_vector(xirq, 8),\n" +
                        "     xaddr => conv_std_logic_vector(xaddr, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     xmask => conv_std_logic_vector(xmask, CFG_SYSBUS_CFG_ADDR_BITS),\n" +
                        "     vid => VENDOR_GNSSSENSOR,\n" +
                        "     did => GNSSSENSOR_GPIO\n" +
                        "  );\n" +
                        "\n" +
                        "  signal wb_dev_rdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "  signal wb_bus_raddr : global_addr_array_type;\n" +
                        "  signal w_bus_re    : std_logic;\n" +
                        "  signal wb_bus_waddr : global_addr_array_type;\n" +
                        "  signal w_bus_we    : std_logic;\n" +
                        "  signal wb_bus_wdata : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "  \n" +
                        "  signal TS		: std_logic_vector(63 DOWNTO 0) := X\"0000000000989680\"; -- 100 ms\n" +
                        "  signal PV		: std_logic_vector(31 DOWNTO 0) := X\"41A1999A\";\n" +
                        "  signal SP		: std_logic_vector(31 DOWNTO 0) := X\"4272CCCD\";\n" +
                        "  signal b0		: std_logic_vector(31 DOWNTO 0) := X\"4204CCCD\";\n" +
                        "  signal b1		: std_logic_vector(31 DOWNTO 0) := X\"41DE6666\";\n" +
                        "  signal b2		: std_logic_vector(31 DOWNTO 0) := X\"425EE148\";\n" +
                        "  signal XOUT		: std_logic_vector(31 DOWNTO 0) := X\"00000000\";\n" +
                        "  signal XOUT_R	: std_logic;\n" +
                        "  signal T_XOUT_R	: std_logic;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  axi0 :  axi4_slave generic map (\n" +
                        "    async_reset => async_reset\n" +
                        "  ) port map (\n" +
                        "    i_clk => clk,\n" +
                        "    i_nrst => nrst,\n" +
                        "    i_xcfg => xconfig, \n" +
                        "    i_xslvi => i,\n" +
                        "    o_xslvo => o,\n" +
                        "    i_ready => '1',\n" +
                        "    i_rdata => wb_dev_rdata,\n" +
                        "    o_re => w_bus_re,\n" +
                        "    o_r32 => open,\n" +
                        "    o_radr => wb_bus_raddr,\n" +
                        "    o_wadr => wb_bus_waddr,\n" +
                        "    o_we => w_bus_we,\n" +
                        "    o_wstrb => open,\n" +
                        "    o_wdata => wb_bus_wdata\n" +
                        "  );\n" +
                        "  \n" +
                        "  PID: entity work.PID_Top\n" +
                        "  port map (\n" +
                        "    clk	=> clk,\n" +
                        "    nrst	=> nrst,\n" +
                        "\n" +
                        "    TS	=> TS,\n" +
                        "\n" +
                        "    PV	=> PV,\n" +
                        "    SP	=> SP,\n" +
                        "\n" +
                        "    b0	=> b0,\n" +
                        "    b1	=> b1,\n" +
                        "    b2	=> b2,\n" +
                        "\n" +
                        "    XOUT	=> XOUT,\n" +
                        "    XOUT_R=> XOUT_R\n" +
                        "  );\n" +
                        "  \n" +
                        "  cfg  <= xconfig;\n" +
                        "  \n" +
                        "  -- registers:\n" +
                        "  regs : process(clk, nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and nrst = '0' then\n" +
                        "			wb_dev_rdata<= (OTHERS => '0');\n" +
                        "			TS       <= (OTHERS => '0');\n" +
                        "			PV       <= (OTHERS => '0');\n" +
                        "			SP       <= (OTHERS => '0');\n" +
                        "			b0       <= (OTHERS => '0');\n" +
                        "			b1       <= (OTHERS => '0');\n" +
                        "			b2       <= (OTHERS => '0');\n" +
                        "			T_XOUT_R <= '0';\n" +
                        "     elsif rising_edge(clk) then\n" +
                        "			if nrst = '0' then\n" +
                        "				wb_dev_rdata<= (OTHERS => '0');\n" +
                        "				TS       <= (OTHERS => '0');\n" +
                        "				PV       <= (OTHERS => '0');\n" +
                        "				SP       <= (OTHERS => '0');\n" +
                        "				b0       <= (OTHERS => '0');\n" +
                        "				b1       <= (OTHERS => '0');\n" +
                        "				b2       <= (OTHERS => '0');\n" +
                        "				T_XOUT_R <= '0';\n" +
                        "			else\n" +
                        "				if w_bus_we = '1' then --write\n" +
                        "					IF (wb_bus_waddr(0)(4 downto 3) = \"00\") THEN\n" +
                        "						TS  <= wb_bus_wdata;\n" +
                        "					ELSIF (wb_bus_waddr(0)(4 downto 3) = \"01\") THEN\n" +
                        "						PV <= wb_bus_wdata(31 downto 0);\n" +
                        "						SP <= wb_bus_wdata(63 downto 32);\n" +
                        "					ELSIF (wb_bus_waddr(0)(4 downto 3) = \"10\") THEN\n" +
                        "						b0 <= wb_bus_wdata(31 downto 0);\n" +
                        "						b1 <= wb_bus_wdata(63 downto 32);\n" +
                        "					ELSIF (wb_bus_waddr(0)(4 downto 3) = \"11\") THEN\n" +
                        "						b2 <= wb_bus_wdata(31 downto 0);\n" +
                        "					END IF;\n" +
                        "				elsif w_bus_re = '1' then -- read\n" +
                        "					IF (wb_bus_raddr(0)(3) = '0') THEN\n" +
                        "						wb_dev_rdata(31 downto 0)  <= XOUT;\n" +
                        "						T_XOUT_R <= '0';\n" +
                        "					ELSIF (wb_bus_raddr(0)(3) = '1') THEN\n" +
                        "						wb_dev_rdata(63 downto 0) <= (others => '0');\n" +
                        "						wb_dev_rdata(0) <= T_XOUT_R;\n" +
                        "					ELSE\n" +
                        "						wb_dev_rdata <= (others => '0');\n" +
                        "					END IF;\n" +
                        "				end if;\n" +
                        "				if XOUT_R = '1' then\n" +
                        "					T_XOUT_R <= '1';\n" +
                        "				end if;\n" +
                        "			end if;\n" +
                        "     end if;\n" +
                        "	  \n" +
                        "  end process;  \n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_Counter_Down_64_bit_Cin_vhd_file(String Project_Folder_File) {
        String data =   "--\n" +
                        "-- VHDL Architecture Hossameldin_VHDL.Counter_Up_Down_4_bit_Cin_2_to_13.rtl\n" +
                        "--\n" +
                        "-- Created:\n" +
                        "--          by - Hossameldin.UNKNOWN (HOSSAMELDIN-PC)\n" +
                        "--          at - 13:34:57 11/20/2016\n" +
                        "--\n" +
                        "-- using Mentor Graphics HDL Designer(TM) 2007.1 (Build 19)\n" +
                        "--\n" +
                        "LIBRARY ieee;\n" +
                        "USE ieee.std_logic_1164.ALL;\n" +
                        "USE IEEE.STD_LOGIC_ARITH.ALL;\n" +
                        "\n" +
                        "ENTITY Counter_Down_64_bit_Cin IS\n" +
                        "	port(clk      : in std_logic;\n" +
                        "		  nrst     : in std_logic;\n" +
                        "		  En       : in std_logic;\n" +
                        "        C_in     : in std_logic_vector(63 downto 0);\n" +
                        "        ov       : out std_logic;    -- over flow\n" +
                        "        C_Out    : out std_logic_vector(63 downto 0)\n" +
                        "	); \n" +
                        "END ENTITY Counter_Down_64_bit_Cin;\n" +
                        "\n" +
                        "--\n" +
                        "ARCHITECTURE rtl OF Counter_Down_64_bit_Cin IS\n" +
                        "signal C_Tmp, C_O_Tmp, C_in_un : unsigned(63 downto 0);\n" +
                        "BEGIN\n" +
                        "	process(clk, nrst, En)\n" +
                        "	begin\n" +
                        "		C_in_un <= unsigned(C_in);\n" +
                        "		if En = '0' or nrst = '0' then \n" +
                        "			C_Tmp   <= C_in_un;\n" +
                        "			C_O_Tmp <= (others => '0'); \n" +
                        "			ov <='0';\n" +
                        "		elsif rising_edge(clk) then\n" +
                        "			if C_Tmp < 1 then \n" +
                        "				C_Tmp   <= (others => '0'); \n" +
                        "				ov <='1';\n" +
                        "			else \n" +
                        "				C_Tmp   <= C_Tmp - 1;\n" +
                        "				C_O_Tmp <= C_O_Tmp + 1;\n" +
                        "				ov <='0';\n" +
                        "			end if;\n" +
                        "		end if;\n" +
                        "	end process;\n" +
                        "	C_Out <= std_logic_vector(C_O_Tmp);\n" +
                        "END ARCHITECTURE rtl;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_PID_Top_vhd_file(String Project_Folder_File) {
        String data =   "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "USE ieee.std_logic_unsigned.ALL;\n" +
                        "USE ieee.numeric_std.ALL;\n" +
                        "\n" +
                        "entity PID_Top is\n" +
                        "	port(\n" +
                        "		clk	:  in std_logic;\n" +
                        "		nrst	:  in std_logic;\n" +
                        "		\n" +
                        "		TS		:  in std_logic_vector(63 DOWNTO 0);\n" +
                        "		\n" +
                        "		PV		:  in std_logic_vector(31 DOWNTO 0);\n" +
                        "		SP		:  in std_logic_vector(31 DOWNTO 0);\n" +
                        "		\n" +
                        "		b0		:  in std_logic_vector(31 DOWNTO 0);\n" +
                        "		b1		:  in std_logic_vector(31 DOWNTO 0);\n" +
                        "		b2		:  in std_logic_vector(31 DOWNTO 0);\n" +
                        "		\n" +
                        "		XOUT	: out std_logic_vector(31 DOWNTO 0);\n" +
                        "		XOUT_R: out std_logic								-- The output is ready\n" +
                        "	);\n" +
                        "end entity PID_Top;\n" +
                        "\n" +
                        "architecture behaviour of PID_Top is\n" +
                        "	\n" +
                        "	component FP_ADD_32 is\n" +
                        "		port (\n" +
                        "			clk    : in  std_logic                     := 'X';             -- clk\n" +
                        "			areset : in  std_logic                     := 'X';             -- reset\n" +
                        "			a      : in  std_logic_vector(31 downto 0) := (others => 'X'); -- a\n" +
                        "			b      : in  std_logic_vector(31 downto 0) := (others => 'X'); -- b\n" +
                        "			q      : out std_logic_vector(31 downto 0)                     -- q\n" +
                        "		);\n" +
                        "	end component FP_ADD_32;\n" +
                        "	\n" +
                        "	component FP_SUB_32 is\n" +
                        "		port (\n" +
                        "			clk    : in  std_logic                     := 'X';             -- clk\n" +
                        "			areset : in  std_logic                     := 'X';             -- reset\n" +
                        "			a      : in  std_logic_vector(31 downto 0) := (others => 'X'); -- a\n" +
                        "			b      : in  std_logic_vector(31 downto 0) := (others => 'X'); -- b\n" +
                        "			q      : out std_logic_vector(31 downto 0)                     -- q\n" +
                        "		);\n" +
                        "	end component FP_SUB_32;\n" +
                        "	\n" +
                        "	component FP_MUL_32 is\n" +
                        "		port (\n" +
                        "			clk    : in  std_logic                     := 'X';             -- clk\n" +
                        "			areset : in  std_logic                     := 'X';             -- reset\n" +
                        "			a      : in  std_logic_vector(31 downto 0) := (others => 'X'); -- a\n" +
                        "			b      : in  std_logic_vector(31 downto 0) := (others => 'X'); -- b\n" +
                        "			q      : out std_logic_vector(31 downto 0)                     -- q\n" +
                        "		);\n" +
                        "	end component FP_MUL_32;\n" +
                        "\n" +
                        "	signal T_XOUT, T_XOUT_1		: std_logic_vector(31 DOWNTO 0) := X\"00000000\";\n" +
                        "	signal S_XOUT, S_XOUT_1		: std_logic_vector(31 DOWNTO 0) := X\"00000000\";\n" +
                        "	\n" +
                        "	signal T_E, T_E_1, T_E_2	: std_logic_vector(31 DOWNTO 0) := X\"00000000\";\n" +
                        "	signal S_E, S_E_1, S_E_2	: std_logic_vector(31 DOWNTO 0) := X\"00000000\";\n" +
                        "	\n" +
                        "	signal MUL_1, MUL_2, MUL_3	: std_logic_vector(31 DOWNTO 0) := X\"00000000\";\n" +
                        "	\n" +
                        "	signal ADD_1, ADD_2			: std_logic_vector(31 DOWNTO 0) := X\"00000000\";\n" +
                        "	\n" +
                        "	signal Stage_Counter			: std_logic_vector(4  DOWNTO 0) := \"00000\";\n" +
                        "	signal clk_Counter			: std_logic_vector(63 DOWNTO 0) := X\"0000000000000000\";\n" +
                        "	signal Start_Calculating	: std_logic := '0';\n" +
                        "	\n" +
                        "	signal rst	: std_logic := '0';\n" +
                        "\n" +
                        "\n" +
                        "begin\n" +
                        "	\n" +
                        "	--------------------------------------------------\n" +
                        "	-- Stage 1 (Error calculation)\n" +
                        "	--------------------------------------------------\n" +
                        "	-- e(n) = SP - PV\n" +
                        "	Error_Calc : FP_SUB_32\n" +
                        "	port map (\n" +
                        "		clk    => clk,\n" +
                        "		areset => rst,\n" +
                        "		a      => SP,\n" +
                        "		b      => PV,\n" +
                        "		q      => T_E\n" +
                        "	);\n" +
                        "	\n" +
                        "	\n" +
                        "	\n" +
                        "	--------------------------------------------------\n" +
                        "	-- Stage 2 (PID calculation)\n" +
                        "	--------------------------------------------------\n" +
                        "	-- mul_1 = b0 * e(n)\n" +
                        "	MUL_1_Calc : FP_MUL_32\n" +
                        "	port map (\n" +
                        "		clk    => clk,\n" +
                        "		areset => rst,\n" +
                        "		a      => b0,\n" +
                        "		b      => S_E,\n" +
                        "		q      => MUL_1\n" +
                        "	);\n" +
                        "	-- mul_2 = b1 * e(n-1)\n" +
                        "	MUL_2_Calc : FP_MUL_32\n" +
                        "	port map (\n" +
                        "		clk    => clk,\n" +
                        "		areset => rst,\n" +
                        "		a      => b1,\n" +
                        "		b      => S_E_1,\n" +
                        "		q      => MUL_2\n" +
                        "	);\n" +
                        "	-- mul_3 = b2 * e(n-2)\n" +
                        "	MUL_3_Calc : FP_MUL_32\n" +
                        "	port map (\n" +
                        "		clk    => clk,\n" +
                        "		areset => rst,\n" +
                        "		a      => b2,\n" +
                        "		b      => S_E_2,\n" +
                        "		q      => MUL_3\n" +
                        "	);\n" +
                        "	\n" +
                        "	\n" +
                        "	\n" +
                        "	--------------------------------------------------\n" +
                        "	-- Stage 3 (Adding PID values)\n" +
                        "	--------------------------------------------------\n" +
                        "	-- add_1 = mul_1 + mul_2\n" +
                        "	ADD_1_Calc : FP_ADD_32\n" +
                        "	port map (\n" +
                        "		clk    => clk,\n" +
                        "		areset => rst,\n" +
                        "		a      => MUL_1,\n" +
                        "		b      => MUL_2,\n" +
                        "		q      => ADD_1\n" +
                        "	);\n" +
                        "	-- add_2 = mul_3 + u(n-1)\n" +
                        "	ADD_2_Calc : FP_ADD_32\n" +
                        "	port map (\n" +
                        "		clk    => clk,\n" +
                        "		areset => rst,\n" +
                        "		a      => MUL_3,\n" +
                        "		b      => S_XOUT_1,\n" +
                        "		q      => ADD_2\n" +
                        "	);\n" +
                        "	\n" +
                        "	--------------------------------------------------\n" +
                        "	-- Stage 4 (Adding PID values)\n" +
                        "	--------------------------------------------------\n" +
                        "	-- add_all = add_1 + add_2\n" +
                        "	XOUT_Calc : FP_ADD_32\n" +
                        "	port map (\n" +
                        "		clk    => clk,\n" +
                        "		areset => rst,\n" +
                        "		a      => ADD_1,\n" +
                        "		b      => ADD_2,\n" +
                        "		q      => T_XOUT\n" +
                        "	);\n" +
                        "	\n" +
                        "	\n" +
                        "	\n" +
                        "	--------------------------------------------------\n" +
                        "	-- Stage Controller\n" +
                        "	--------------------------------------------------\n" +
                        "	process(clk, nrst, TS)\n" +
                        "	begin\n" +
                        "		if (nrst = '0') or (TS =  X\"0000000000000000\") then\n" +
                        "			rst      <= '1';\n" +
                        "			XOUT_R	<= '0';\n" +
                        "			S_XOUT	<= X\"00000000\";\n" +
                        "			S_XOUT_1	<= X\"00000000\";\n" +
                        "			\n" +
                        "			S_E		<= X\"00000000\";\n" +
                        "			S_E_1		<= X\"00000000\";\n" +
                        "			S_E_2		<= X\"00000000\";\n" +
                        "			\n" +
                        "			Stage_Counter		<= \"00000\";\n" +
                        "			clk_Counter			<= X\"0000000000000000\";\n" +
                        "			Start_Calculating	<= '0';\n" +
                        "		elsif rising_edge(clk) then\n" +
                        "			rst      <= '0';\n" +
                        "			if TS /=  X\"0000000000000000\" then\n" +
                        "				clk_Counter		<= clk_Counter + X\"0000000000000001\";\n" +
                        "			end if;\n" +
                        "			\n" +
                        "			if clk_Counter = TS and TS /=  X\"0000000000000000\" then\n" +
                        "				Start_Calculating	<= '1';\n" +
                        "				XOUT_R 				<= '0';\n" +
                        "				Stage_Counter		<= \"00000\";\n" +
                        "				clk_Counter			<= X\"0000000000000000\";\n" +
                        "			end if;\n" +
                        "			\n" +
                        "			if Start_Calculating = '1' then\n" +
                        "				Stage_Counter	<= Stage_Counter + \"00001\";\n" +
                        "			end if;\n" +
                        "				\n" +
                        "			if Stage_Counter = \"00101\" then -- 5\n" +
                        "				S_E	<= T_E;		-- e(n)\n" +
                        "				S_E_1	<= S_E;		-- e(n-1) = e(0)\n" +
                        "				S_E_2	<= S_E_1;	-- e(n-2) = e(n-1)\n" +
                        "			elsif stage_counter = \"10100\" then -- 20\n" +
                        "				S_XOUT	<= T_XOUT;\n" +
                        "				S_XOUT_1	<= T_XOUT;\n" +
                        "				XOUT_R	<= '1';\n" +
                        "			elsif stage_counter = \"10101\" then -- 21\n" +
                        "				XOUT_R	<= '0';\n" +
                        "				Start_Calculating <= '0';\n" +
                        "			end if;\n" +
                        "		end if;\n" +
                        "		\n" +
                        "	end process;\n" +
                        "	\n" +
                        "	XOUT <= S_XOUT;\n" +
                        "end architecture;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_PWM_32_bit_vhd_file(String Project_Folder_File) {
        String data =   "library IEEE;\n" +
                        "USE IEEE.STD_LOGIC_1164.ALL;\n" +
                        "USE IEEE.STD_LOGIC_UNSIGNED.ALL;\n" +
                        "use ieee.numeric_std.all;\n" +
                        "\n" +
                        "entity PWM_32_bit is\n" +
                        "port( clk, nrst	: in STD_LOGIC;\n" +
                        "		EN				: in STD_LOGIC;\n" +
                        "		T_Count		: in STD_LOGIC_VECTOR(19 downto 0);\n" +
                        "		Comp_Count	: in STD_LOGIC_VECTOR(19 downto 0);\n" +
                        "		Y_OUT			: out STD_LOGIC\n" +
                        "		);\n" +
                        "end;\n" +
                        "\n" +
                        "architecture RTL of PWM_32_bit is\n" +
                        "	SIGNAL T_Count_T, Comp_Count_T	: STD_LOGIC_VECTOR(19 downto 0);\n" +
                        "	\n" +
                        "	begin\n" +
                        "	\n" +
                        "	process(clk, nrst)\n" +
                        "		begin\n" +
                        "		if nrst = '0' then \n" +
                        "			T_Count_T		<= (others => '0');\n" +
                        "			Comp_Count_T	<= (others => '0');\n" +
                        "			Y_OUT				<= '0';\n" +
                        "		elsif (rising_edge(clk) and EN = '1') then\n" +
                        "			if T_Count_T = \"00000000000000000000\" then\n" +
                        "				T_Count_T		<= T_Count;\n" +
                        "				Comp_Count_T	<= Comp_Count;\n" +
                        "				Y_OUT				<= '0';\n" +
                        "			else\n" +
                        "				T_Count_T	<= T_Count_T - \"00000000000000000001\";\n" +
                        "				if unsigned(T_Count_T) < unsigned(Comp_Count_T) then\n" +
                        "					Y_OUT <= '1';\n" +
                        "				else\n" +
                        "					Y_OUT <= '0';\n" +
                        "				end if;\n" +
                        "			end if;\n" +
                        "		end if;\n" +
                        "	end process;\n" +
                        "	\n" +
                        "end RTL;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_PWM_Signal_vhd_file(String Project_Folder_File) {
        String data =   "library IEEE;\n" +
                        "USE IEEE.STD_LOGIC_1164.ALL;\n" +
                        "\n" +
                        "--------------------------------\n" +
                        "-- T_Count = clk_Hz / Frq\n" +
                        "-- Comp_Count_0 = (T_Count/100)\n" +
                        "-- Comp_Count = Comp_Count_0 * DC\n" +
                        "--------------------------------\n" +
                        "\n" +
                        "entity PWM_Signal is\n" +
                        "port( nrst			: in STD_LOGIC;\n" +
                        "		Frq			: in STD_LOGIC_VECTOR(16 downto 0);\n" +
                        "		DC				: in STD_LOGIC_VECTOR(6 downto 0);\n" +
                        "		T_Count		: out STD_LOGIC_VECTOR(19 downto 0);\n" +
                        "		Comp_Count	: out STD_LOGIC_VECTOR(19 downto 0)\n" +
                        "		);\n" +
                        "end;\n" +
                        "\n" +
                        "architecture RTL of PWM_Signal is\n" +
                        "	\n" +
                        "	signal T_Count_T, Comp_Count_0	: std_logic_vector(19 downto 0);\n" +
                        "	signal Frq_T	: std_logic_vector(16 downto 0);\n" +
                        "	signal result			: std_logic_vector(26 downto 0);\n" +
                        "	\n" +
                        "	begin\n" +
                        "	\n" +
                        "	Comp_Count	<= result(19 downto 0);\n" +
                        "	T_Count	<= T_Count_T;\n" +
                        "	\n" +
                        "	Div1: entity work.div_int_20_17_speed	PORT MAP(Frq_T, X\"F4240\", T_Count_T, open);	-- T_Count = clk_Hz / Frq\n" +
                        "	Div2: entity work.div_int_20_7_speed	PORT MAP(\"1100100\", T_Count_T, Comp_Count_0, open);	-- Comp_Count_0 = (T_Count/100)\n" +
                        "	--Div: 	entity work.div_int_32_t	PORT MAP(denom, numer, result_div, open);\n" +
                        "	Mult: entity work.mul_int_20_7	PORT MAP(Comp_Count_0, DC, result);							-- Comp_Count = Comp_Count_0 * DC\n" +
                        "	\n" +
                        "	process(Frq)\n" +
                        "	begin\n" +
                        "		if( Frq = \"00000000000000000\") or (nrst = '0') then\n" +
                        "			Frq_T <= (others => '1');\n" +
                        "		else\n" +
                        "			Frq_T <= Frq;\n" +
                        "		end if;\n" +
                        "	end process;\n" +
                        "end RTL;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_CDC_Frq_vhd_file(String Project_Folder_File) {
        String data =   "-- megafunction wizard: %FIFO%\n" +
                        "-- GENERATION: STANDARD\n" +
                        "-- VERSION: WM1.0\n" +
                        "-- MODULE: dcfifo \n" +
                        "\n" +
                        "-- ============================================================\n" +
                        "-- File Name: CDC_Frq.vhd\n" +
                        "-- Megafunction Name(s):\n" +
                        "-- 			dcfifo\n" +
                        "--\n" +
                        "-- Simulation Library Files(s):\n" +
                        "-- 			altera_mf\n" +
                        "-- ============================================================\n" +
                        "-- ************************************************************\n" +
                        "-- THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!\n" +
                        "--\n" +
                        "-- 18.0.0 Build 614 04/24/2018 SJ Lite Edition\n" +
                        "-- ************************************************************\n" +
                        "\n" +
                        "\n" +
                        "--Copyright (C) 2018  Intel Corporation. All rights reserved.\n" +
                        "--Your use of Intel Corporation's design tools, logic functions \n" +
                        "--and other software and tools, and its AMPP partner logic \n" +
                        "--functions, and any output files from any of the foregoing \n" +
                        "--(including device programming or simulation files), and any \n" +
                        "--associated documentation or information are expressly subject \n" +
                        "--to the terms and conditions of the Intel Program License \n" +
                        "--Subscription Agreement, the Intel Quartus Prime License Agreement,\n" +
                        "--the Intel FPGA IP License Agreement, or other applicable license\n" +
                        "--agreement, including, without limitation, that your use is for\n" +
                        "--the sole purpose of programming logic devices manufactured by\n" +
                        "--Intel and sold by Intel or its authorized distributors.  Please\n" +
                        "--refer to the applicable agreement for further details.\n" +
                        "\n" +
                        "\n" +
                        "LIBRARY ieee;\n" +
                        "USE ieee.std_logic_1164.all;\n" +
                        "\n" +
                        "LIBRARY altera_mf;\n" +
                        "USE altera_mf.all;\n" +
                        "\n" +
                        "ENTITY CDC_Frq IS\n" +
                        "	PORT\n" +
                        "	(\n" +
                        "		aclr		: IN STD_LOGIC  := '0';\n" +
                        "		data		: IN STD_LOGIC_VECTOR (16 DOWNTO 0);\n" +
                        "		rdclk		: IN STD_LOGIC ;\n" +
                        "		rdreq		: IN STD_LOGIC ;\n" +
                        "		wrclk		: IN STD_LOGIC ;\n" +
                        "		wrreq		: IN STD_LOGIC ;\n" +
                        "		q		: OUT STD_LOGIC_VECTOR (16 DOWNTO 0);\n" +
                        "		rdempty		: OUT STD_LOGIC ;\n" +
                        "		wrempty		: OUT STD_LOGIC \n" +
                        "	);\n" +
                        "END CDC_Frq;\n" +
                        "\n" +
                        "\n" +
                        "ARCHITECTURE SYN OF cdc_frq IS\n" +
                        "\n" +
                        "	SIGNAL sub_wire0	: STD_LOGIC_VECTOR (16 DOWNTO 0);\n" +
                        "	SIGNAL sub_wire1	: STD_LOGIC ;\n" +
                        "	SIGNAL sub_wire2	: STD_LOGIC ;\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "	COMPONENT dcfifo\n" +
                        "	GENERIC (\n" +
                        "		intended_device_family		: STRING;\n" +
                        "		lpm_numwords		: NATURAL;\n" +
                        "		lpm_showahead		: STRING;\n" +
                        "		lpm_type		: STRING;\n" +
                        "		lpm_width		: NATURAL;\n" +
                        "		lpm_widthu		: NATURAL;\n" +
                        "		overflow_checking		: STRING;\n" +
                        "		rdsync_delaypipe		: NATURAL;\n" +
                        "		read_aclr_synch		: STRING;\n" +
                        "		underflow_checking		: STRING;\n" +
                        "		use_eab		: STRING;\n" +
                        "		write_aclr_synch		: STRING;\n" +
                        "		wrsync_delaypipe		: NATURAL\n" +
                        "	);\n" +
                        "	PORT (\n" +
                        "			aclr	: IN STD_LOGIC ;\n" +
                        "			data	: IN STD_LOGIC_VECTOR (16 DOWNTO 0);\n" +
                        "			rdclk	: IN STD_LOGIC ;\n" +
                        "			rdreq	: IN STD_LOGIC ;\n" +
                        "			wrclk	: IN STD_LOGIC ;\n" +
                        "			wrreq	: IN STD_LOGIC ;\n" +
                        "			q	: OUT STD_LOGIC_VECTOR (16 DOWNTO 0);\n" +
                        "			rdempty	: OUT STD_LOGIC ;\n" +
                        "			wrempty	: OUT STD_LOGIC \n" +
                        "	);\n" +
                        "	END COMPONENT;\n" +
                        "\n" +
                        "BEGIN\n" +
                        "	q    <= sub_wire0(16 DOWNTO 0);\n" +
                        "	rdempty    <= sub_wire1;\n" +
                        "	wrempty    <= sub_wire2;\n" +
                        "\n" +
                        "	dcfifo_component : dcfifo\n" +
                        "	GENERIC MAP (\n" +
                        "		intended_device_family => \"Cyclone V\",\n" +
                        "		lpm_numwords => 32,\n" +
                        "		lpm_showahead => \"OFF\",\n" +
                        "		lpm_type => \"dcfifo\",\n" +
                        "		lpm_width => 17,\n" +
                        "		lpm_widthu => 5,\n" +
                        "		overflow_checking => \"ON\",\n" +
                        "		rdsync_delaypipe => 4,\n" +
                        "		read_aclr_synch => \"OFF\",\n" +
                        "		underflow_checking => \"ON\",\n" +
                        "		use_eab => \"ON\",\n" +
                        "		write_aclr_synch => \"OFF\",\n" +
                        "		wrsync_delaypipe => 4\n" +
                        "	)\n" +
                        "	PORT MAP (\n" +
                        "		aclr => aclr,\n" +
                        "		data => data,\n" +
                        "		rdclk => rdclk,\n" +
                        "		rdreq => rdreq,\n" +
                        "		wrclk => wrclk,\n" +
                        "		wrreq => wrreq,\n" +
                        "		q => sub_wire0,\n" +
                        "		rdempty => sub_wire1,\n" +
                        "		wrempty => sub_wire2\n" +
                        "	);\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "END SYN;\n" +
                        "\n" +
                        "-- ============================================================\n" +
                        "-- CNX file retrieval info\n" +
                        "-- ============================================================\n" +
                        "-- Retrieval info: PRIVATE: AlmostEmpty NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: AlmostEmptyThr NUMERIC \"-1\"\n" +
                        "-- Retrieval info: PRIVATE: AlmostFull NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: AlmostFullThr NUMERIC \"-1\"\n" +
                        "-- Retrieval info: PRIVATE: CLOCKS_ARE_SYNCHRONIZED NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: Clock NUMERIC \"4\"\n" +
                        "-- Retrieval info: PRIVATE: Depth NUMERIC \"32\"\n" +
                        "-- Retrieval info: PRIVATE: Empty NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: Full NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: INTENDED_DEVICE_FAMILY STRING \"Cyclone V\"\n" +
                        "-- Retrieval info: PRIVATE: LE_BasedFIFO NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: LegacyRREQ NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: MAX_DEPTH_BY_9 NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: OVERFLOW_CHECKING NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: Optimize NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: RAM_BLOCK_TYPE NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: SYNTH_WRAPPER_GEN_POSTFIX STRING \"0\"\n" +
                        "-- Retrieval info: PRIVATE: UNDERFLOW_CHECKING NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: UsedW NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: Width NUMERIC \"17\"\n" +
                        "-- Retrieval info: PRIVATE: dc_aclr NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: diff_widths NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: msb_usedw NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: output_width NUMERIC \"17\"\n" +
                        "-- Retrieval info: PRIVATE: rsEmpty NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: rsFull NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: rsUsedW NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: sc_aclr NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: sc_sclr NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: wsEmpty NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: wsFull NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: wsUsedW NUMERIC \"0\"\n" +
                        "-- Retrieval info: LIBRARY: altera_mf altera_mf.altera_mf_components.all\n" +
                        "-- Retrieval info: CONSTANT: INTENDED_DEVICE_FAMILY STRING \"Cyclone V\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_NUMWORDS NUMERIC \"32\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_SHOWAHEAD STRING \"OFF\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_TYPE STRING \"dcfifo\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_WIDTH NUMERIC \"17\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_WIDTHU NUMERIC \"5\"\n" +
                        "-- Retrieval info: CONSTANT: OVERFLOW_CHECKING STRING \"ON\"\n" +
                        "-- Retrieval info: CONSTANT: RDSYNC_DELAYPIPE NUMERIC \"4\"\n" +
                        "-- Retrieval info: CONSTANT: READ_ACLR_SYNCH STRING \"OFF\"\n" +
                        "-- Retrieval info: CONSTANT: UNDERFLOW_CHECKING STRING \"ON\"\n" +
                        "-- Retrieval info: CONSTANT: USE_EAB STRING \"ON\"\n" +
                        "-- Retrieval info: CONSTANT: WRITE_ACLR_SYNCH STRING \"OFF\"\n" +
                        "-- Retrieval info: CONSTANT: WRSYNC_DELAYPIPE NUMERIC \"4\"\n" +
                        "-- Retrieval info: USED_PORT: aclr 0 0 0 0 INPUT GND \"aclr\"\n" +
                        "-- Retrieval info: USED_PORT: data 0 0 17 0 INPUT NODEFVAL \"data[16..0]\"\n" +
                        "-- Retrieval info: USED_PORT: q 0 0 17 0 OUTPUT NODEFVAL \"q[16..0]\"\n" +
                        "-- Retrieval info: USED_PORT: rdclk 0 0 0 0 INPUT NODEFVAL \"rdclk\"\n" +
                        "-- Retrieval info: USED_PORT: rdempty 0 0 0 0 OUTPUT NODEFVAL \"rdempty\"\n" +
                        "-- Retrieval info: USED_PORT: rdreq 0 0 0 0 INPUT NODEFVAL \"rdreq\"\n" +
                        "-- Retrieval info: USED_PORT: wrclk 0 0 0 0 INPUT NODEFVAL \"wrclk\"\n" +
                        "-- Retrieval info: USED_PORT: wrempty 0 0 0 0 OUTPUT NODEFVAL \"wrempty\"\n" +
                        "-- Retrieval info: USED_PORT: wrreq 0 0 0 0 INPUT NODEFVAL \"wrreq\"\n" +
                        "-- Retrieval info: CONNECT: @aclr 0 0 0 0 aclr 0 0 0 0\n" +
                        "-- Retrieval info: CONNECT: @data 0 0 17 0 data 0 0 17 0\n" +
                        "-- Retrieval info: CONNECT: @rdclk 0 0 0 0 rdclk 0 0 0 0\n" +
                        "-- Retrieval info: CONNECT: @rdreq 0 0 0 0 rdreq 0 0 0 0\n" +
                        "-- Retrieval info: CONNECT: @wrclk 0 0 0 0 wrclk 0 0 0 0\n" +
                        "-- Retrieval info: CONNECT: @wrreq 0 0 0 0 wrreq 0 0 0 0\n" +
                        "-- Retrieval info: CONNECT: q 0 0 17 0 @q 0 0 17 0\n" +
                        "-- Retrieval info: CONNECT: rdempty 0 0 0 0 @rdempty 0 0 0 0\n" +
                        "-- Retrieval info: CONNECT: wrempty 0 0 0 0 @wrempty 0 0 0 0\n" +
                        "-- Retrieval info: GEN_FILE: TYPE_NORMAL CDC_Frq.vhd TRUE\n" +
                        "-- Retrieval info: GEN_FILE: TYPE_NORMAL CDC_Frq.inc FALSE\n" +
                        "-- Retrieval info: GEN_FILE: TYPE_NORMAL CDC_Frq.cmp FALSE\n" +
                        "-- Retrieval info: GEN_FILE: TYPE_NORMAL CDC_Frq.bsf FALSE\n" +
                        "-- Retrieval info: GEN_FILE: TYPE_NORMAL CDC_Frq_inst.vhd FALSE\n" +
                        "-- Retrieval info: LIB_FILE: altera_mf";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_CDC_Frq_qip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -name IP_TOOL_NAME \"FIFO\"\n" +
                        "set_global_assignment -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -name IP_GENERATED_DEVICE_FAMILY \"{Cyclone V}\"\n" +
                        "set_global_assignment -name VHDL_FILE [file join $::quartus(qip_path) \"CDC_Frq.vhd\"]";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_CDC_DC_vhd_file(String Project_Folder_File) {
        String data =   "-- megafunction wizard: %FIFO%\n" +
                        "-- GENERATION: STANDARD\n" +
                        "-- VERSION: WM1.0\n" +
                        "-- MODULE: dcfifo \n" +
                        "\n" +
                        "-- ============================================================\n" +
                        "-- File Name: CDC_DC.vhd\n" +
                        "-- Megafunction Name(s):\n" +
                        "-- 			dcfifo\n" +
                        "--\n" +
                        "-- Simulation Library Files(s):\n" +
                        "-- 			altera_mf\n" +
                        "-- ============================================================\n" +
                        "-- ************************************************************\n" +
                        "-- THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!\n" +
                        "--\n" +
                        "-- 18.0.0 Build 614 04/24/2018 SJ Lite Edition\n" +
                        "-- ************************************************************\n" +
                        "\n" +
                        "\n" +
                        "--Copyright (C) 2018  Intel Corporation. All rights reserved.\n" +
                        "--Your use of Intel Corporation's design tools, logic functions \n" +
                        "--and other software and tools, and its AMPP partner logic \n" +
                        "--functions, and any output files from any of the foregoing \n" +
                        "--(including device programming or simulation files), and any \n" +
                        "--associated documentation or information are expressly subject \n" +
                        "--to the terms and conditions of the Intel Program License \n" +
                        "--Subscription Agreement, the Intel Quartus Prime License Agreement,\n" +
                        "--the Intel FPGA IP License Agreement, or other applicable license\n" +
                        "--agreement, including, without limitation, that your use is for\n" +
                        "--the sole purpose of programming logic devices manufactured by\n" +
                        "--Intel and sold by Intel or its authorized distributors.  Please\n" +
                        "--refer to the applicable agreement for further details.\n" +
                        "\n" +
                        "\n" +
                        "LIBRARY ieee;\n" +
                        "USE ieee.std_logic_1164.all;\n" +
                        "\n" +
                        "LIBRARY altera_mf;\n" +
                        "USE altera_mf.all;\n" +
                        "\n" +
                        "ENTITY CDC_DC IS\n" +
                        "	PORT\n" +
                        "	(\n" +
                        "		aclr		: IN STD_LOGIC  := '0';\n" +
                        "		data		: IN STD_LOGIC_VECTOR (6 DOWNTO 0);\n" +
                        "		rdclk		: IN STD_LOGIC ;\n" +
                        "		rdreq		: IN STD_LOGIC ;\n" +
                        "		wrclk		: IN STD_LOGIC ;\n" +
                        "		wrreq		: IN STD_LOGIC ;\n" +
                        "		q		: OUT STD_LOGIC_VECTOR (6 DOWNTO 0);\n" +
                        "		rdempty		: OUT STD_LOGIC ;\n" +
                        "		wrempty		: OUT STD_LOGIC \n" +
                        "	);\n" +
                        "END CDC_DC;\n" +
                        "\n" +
                        "\n" +
                        "ARCHITECTURE SYN OF cdc_dc IS\n" +
                        "\n" +
                        "	SIGNAL sub_wire0	: STD_LOGIC_VECTOR (6 DOWNTO 0);\n" +
                        "	SIGNAL sub_wire1	: STD_LOGIC ;\n" +
                        "	SIGNAL sub_wire2	: STD_LOGIC ;\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "	COMPONENT dcfifo\n" +
                        "	GENERIC (\n" +
                        "		intended_device_family		: STRING;\n" +
                        "		lpm_numwords		: NATURAL;\n" +
                        "		lpm_showahead		: STRING;\n" +
                        "		lpm_type		: STRING;\n" +
                        "		lpm_width		: NATURAL;\n" +
                        "		lpm_widthu		: NATURAL;\n" +
                        "		overflow_checking		: STRING;\n" +
                        "		rdsync_delaypipe		: NATURAL;\n" +
                        "		read_aclr_synch		: STRING;\n" +
                        "		underflow_checking		: STRING;\n" +
                        "		use_eab		: STRING;\n" +
                        "		write_aclr_synch		: STRING;\n" +
                        "		wrsync_delaypipe		: NATURAL\n" +
                        "	);\n" +
                        "	PORT (\n" +
                        "			aclr	: IN STD_LOGIC ;\n" +
                        "			data	: IN STD_LOGIC_VECTOR (6 DOWNTO 0);\n" +
                        "			rdclk	: IN STD_LOGIC ;\n" +
                        "			rdreq	: IN STD_LOGIC ;\n" +
                        "			wrclk	: IN STD_LOGIC ;\n" +
                        "			wrreq	: IN STD_LOGIC ;\n" +
                        "			q	: OUT STD_LOGIC_VECTOR (6 DOWNTO 0);\n" +
                        "			rdempty	: OUT STD_LOGIC ;\n" +
                        "			wrempty	: OUT STD_LOGIC \n" +
                        "	);\n" +
                        "	END COMPONENT;\n" +
                        "\n" +
                        "BEGIN\n" +
                        "	q    <= sub_wire0(6 DOWNTO 0);\n" +
                        "	rdempty    <= sub_wire1;\n" +
                        "	wrempty    <= sub_wire2;\n" +
                        "\n" +
                        "	dcfifo_component : dcfifo\n" +
                        "	GENERIC MAP (\n" +
                        "		intended_device_family => \"Cyclone V\",\n" +
                        "		lpm_numwords => 32,\n" +
                        "		lpm_showahead => \"OFF\",\n" +
                        "		lpm_type => \"dcfifo\",\n" +
                        "		lpm_width => 7,\n" +
                        "		lpm_widthu => 5,\n" +
                        "		overflow_checking => \"OFF\",\n" +
                        "		rdsync_delaypipe => 4,\n" +
                        "		read_aclr_synch => \"OFF\",\n" +
                        "		underflow_checking => \"OFF\",\n" +
                        "		use_eab => \"ON\",\n" +
                        "		write_aclr_synch => \"OFF\",\n" +
                        "		wrsync_delaypipe => 4\n" +
                        "	)\n" +
                        "	PORT MAP (\n" +
                        "		aclr => aclr,\n" +
                        "		data => data,\n" +
                        "		rdclk => rdclk,\n" +
                        "		rdreq => rdreq,\n" +
                        "		wrclk => wrclk,\n" +
                        "		wrreq => wrreq,\n" +
                        "		q => sub_wire0,\n" +
                        "		rdempty => sub_wire1,\n" +
                        "		wrempty => sub_wire2\n" +
                        "	);\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "END SYN;\n" +
                        "\n" +
                        "-- ============================================================\n" +
                        "-- CNX file retrieval info\n" +
                        "-- ============================================================\n" +
                        "-- Retrieval info: PRIVATE: AlmostEmpty NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: AlmostEmptyThr NUMERIC \"-1\"\n" +
                        "-- Retrieval info: PRIVATE: AlmostFull NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: AlmostFullThr NUMERIC \"-1\"\n" +
                        "-- Retrieval info: PRIVATE: CLOCKS_ARE_SYNCHRONIZED NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: Clock NUMERIC \"4\"\n" +
                        "-- Retrieval info: PRIVATE: Depth NUMERIC \"32\"\n" +
                        "-- Retrieval info: PRIVATE: Empty NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: Full NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: INTENDED_DEVICE_FAMILY STRING \"Cyclone V\"\n" +
                        "-- Retrieval info: PRIVATE: LE_BasedFIFO NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: LegacyRREQ NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: MAX_DEPTH_BY_9 NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: OVERFLOW_CHECKING NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: Optimize NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: RAM_BLOCK_TYPE NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: SYNTH_WRAPPER_GEN_POSTFIX STRING \"0\"\n" +
                        "-- Retrieval info: PRIVATE: UNDERFLOW_CHECKING NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: UsedW NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: Width NUMERIC \"7\"\n" +
                        "-- Retrieval info: PRIVATE: dc_aclr NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: diff_widths NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: msb_usedw NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: output_width NUMERIC \"7\"\n" +
                        "-- Retrieval info: PRIVATE: rsEmpty NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: rsFull NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: rsUsedW NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: sc_aclr NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: sc_sclr NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: wsEmpty NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: wsFull NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: wsUsedW NUMERIC \"0\"\n" +
                        "-- Retrieval info: LIBRARY: altera_mf altera_mf.altera_mf_components.all\n" +
                        "-- Retrieval info: CONSTANT: INTENDED_DEVICE_FAMILY STRING \"Cyclone V\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_NUMWORDS NUMERIC \"32\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_SHOWAHEAD STRING \"OFF\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_TYPE STRING \"dcfifo\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_WIDTH NUMERIC \"7\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_WIDTHU NUMERIC \"5\"\n" +
                        "-- Retrieval info: CONSTANT: OVERFLOW_CHECKING STRING \"OFF\"\n" +
                        "-- Retrieval info: CONSTANT: RDSYNC_DELAYPIPE NUMERIC \"4\"\n" +
                        "-- Retrieval info: CONSTANT: READ_ACLR_SYNCH STRING \"OFF\"\n" +
                        "-- Retrieval info: CONSTANT: UNDERFLOW_CHECKING STRING \"OFF\"\n" +
                        "-- Retrieval info: CONSTANT: USE_EAB STRING \"ON\"\n" +
                        "-- Retrieval info: CONSTANT: WRITE_ACLR_SYNCH STRING \"OFF\"\n" +
                        "-- Retrieval info: CONSTANT: WRSYNC_DELAYPIPE NUMERIC \"4\"\n" +
                        "-- Retrieval info: USED_PORT: aclr 0 0 0 0 INPUT GND \"aclr\"\n" +
                        "-- Retrieval info: USED_PORT: data 0 0 7 0 INPUT NODEFVAL \"data[6..0]\"\n" +
                        "-- Retrieval info: USED_PORT: q 0 0 7 0 OUTPUT NODEFVAL \"q[6..0]\"\n" +
                        "-- Retrieval info: USED_PORT: rdclk 0 0 0 0 INPUT NODEFVAL \"rdclk\"\n" +
                        "-- Retrieval info: USED_PORT: rdempty 0 0 0 0 OUTPUT NODEFVAL \"rdempty\"\n" +
                        "-- Retrieval info: USED_PORT: rdreq 0 0 0 0 INPUT NODEFVAL \"rdreq\"\n" +
                        "-- Retrieval info: USED_PORT: wrclk 0 0 0 0 INPUT NODEFVAL \"wrclk\"\n" +
                        "-- Retrieval info: USED_PORT: wrempty 0 0 0 0 OUTPUT NODEFVAL \"wrempty\"\n" +
                        "-- Retrieval info: USED_PORT: wrreq 0 0 0 0 INPUT NODEFVAL \"wrreq\"\n" +
                        "-- Retrieval info: CONNECT: @aclr 0 0 0 0 aclr 0 0 0 0\n" +
                        "-- Retrieval info: CONNECT: @data 0 0 7 0 data 0 0 7 0\n" +
                        "-- Retrieval info: CONNECT: @rdclk 0 0 0 0 rdclk 0 0 0 0\n" +
                        "-- Retrieval info: CONNECT: @rdreq 0 0 0 0 rdreq 0 0 0 0\n" +
                        "-- Retrieval info: CONNECT: @wrclk 0 0 0 0 wrclk 0 0 0 0\n" +
                        "-- Retrieval info: CONNECT: @wrreq 0 0 0 0 wrreq 0 0 0 0\n" +
                        "-- Retrieval info: CONNECT: q 0 0 7 0 @q 0 0 7 0\n" +
                        "-- Retrieval info: CONNECT: rdempty 0 0 0 0 @rdempty 0 0 0 0\n" +
                        "-- Retrieval info: CONNECT: wrempty 0 0 0 0 @wrempty 0 0 0 0\n" +
                        "-- Retrieval info: LIB_FILE: altera_mf";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_CDC_DC_qip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -name IP_TOOL_NAME \"FIFO\"\n" +
                        "set_global_assignment -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -name IP_GENERATED_DEVICE_FAMILY \"{Cyclone V}\"\n" +
                        "set_global_assignment -name VHDL_FILE [file join $::quartus(qip_path) \"CDC_DC.vhd\"]";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_CDC_Q_vhd_file(String Project_Folder_File) {
        String data =   "-- megafunction wizard: %FIFO%\n" +
                        "-- GENERATION: STANDARD\n" +
                        "-- VERSION: WM1.0\n" +
                        "-- MODULE: dcfifo \n" +
                        "\n" +
                        "-- ============================================================\n" +
                        "-- File Name: CDC_Q.vhd\n" +
                        "-- Megafunction Name(s):\n" +
                        "-- 			dcfifo\n" +
                        "--\n" +
                        "-- Simulation Library Files(s):\n" +
                        "-- 			altera_mf\n" +
                        "-- ============================================================\n" +
                        "-- ************************************************************\n" +
                        "-- THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!\n" +
                        "--\n" +
                        "-- 18.0.0 Build 614 04/24/2018 SJ Lite Edition\n" +
                        "-- ************************************************************\n" +
                        "\n" +
                        "\n" +
                        "--Copyright (C) 2018  Intel Corporation. All rights reserved.\n" +
                        "--Your use of Intel Corporation's design tools, logic functions \n" +
                        "--and other software and tools, and its AMPP partner logic \n" +
                        "--functions, and any output files from any of the foregoing \n" +
                        "--(including device programming or simulation files), and any \n" +
                        "--associated documentation or information are expressly subject \n" +
                        "--to the terms and conditions of the Intel Program License \n" +
                        "--Subscription Agreement, the Intel Quartus Prime License Agreement,\n" +
                        "--the Intel FPGA IP License Agreement, or other applicable license\n" +
                        "--agreement, including, without limitation, that your use is for\n" +
                        "--the sole purpose of programming logic devices manufactured by\n" +
                        "--Intel and sold by Intel or its authorized distributors.  Please\n" +
                        "--refer to the applicable agreement for further details.\n" +
                        "\n" +
                        "\n" +
                        "LIBRARY ieee;\n" +
                        "USE ieee.std_logic_1164.all;\n" +
                        "\n" +
                        "LIBRARY altera_mf;\n" +
                        "USE altera_mf.all;\n" +
                        "\n" +
                        "ENTITY CDC_Q IS\n" +
                        "	PORT\n" +
                        "	(\n" +
                        "		aclr		: IN STD_LOGIC  := '0';\n" +
                        "		data		: IN STD_LOGIC_VECTOR (0 DOWNTO 0);\n" +
                        "		rdclk		: IN STD_LOGIC ;\n" +
                        "		rdreq		: IN STD_LOGIC ;\n" +
                        "		wrclk		: IN STD_LOGIC ;\n" +
                        "		wrreq		: IN STD_LOGIC ;\n" +
                        "		q		: OUT STD_LOGIC_VECTOR (0 DOWNTO 0);\n" +
                        "		rdempty		: OUT STD_LOGIC ;\n" +
                        "		wrempty		: OUT STD_LOGIC \n" +
                        "	);\n" +
                        "END CDC_Q;\n" +
                        "\n" +
                        "\n" +
                        "ARCHITECTURE SYN OF cdc_q IS\n" +
                        "\n" +
                        "	SIGNAL sub_wire0	: STD_LOGIC_VECTOR (0 DOWNTO 0);\n" +
                        "	SIGNAL sub_wire1	: STD_LOGIC ;\n" +
                        "	SIGNAL sub_wire2	: STD_LOGIC ;\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "	COMPONENT dcfifo\n" +
                        "	GENERIC (\n" +
                        "		intended_device_family		: STRING;\n" +
                        "		lpm_numwords		: NATURAL;\n" +
                        "		lpm_showahead		: STRING;\n" +
                        "		lpm_type		: STRING;\n" +
                        "		lpm_width		: NATURAL;\n" +
                        "		lpm_widthu		: NATURAL;\n" +
                        "		overflow_checking		: STRING;\n" +
                        "		rdsync_delaypipe		: NATURAL;\n" +
                        "		read_aclr_synch		: STRING;\n" +
                        "		underflow_checking		: STRING;\n" +
                        "		use_eab		: STRING;\n" +
                        "		write_aclr_synch		: STRING;\n" +
                        "		wrsync_delaypipe		: NATURAL\n" +
                        "	);\n" +
                        "	PORT (\n" +
                        "			aclr	: IN STD_LOGIC ;\n" +
                        "			data	: IN STD_LOGIC_VECTOR (0 DOWNTO 0);\n" +
                        "			rdclk	: IN STD_LOGIC ;\n" +
                        "			rdreq	: IN STD_LOGIC ;\n" +
                        "			wrclk	: IN STD_LOGIC ;\n" +
                        "			wrreq	: IN STD_LOGIC ;\n" +
                        "			q	: OUT STD_LOGIC_VECTOR (0 DOWNTO 0);\n" +
                        "			rdempty	: OUT STD_LOGIC ;\n" +
                        "			wrempty	: OUT STD_LOGIC \n" +
                        "	);\n" +
                        "	END COMPONENT;\n" +
                        "\n" +
                        "BEGIN\n" +
                        "	q    <= sub_wire0(0 DOWNTO 0);\n" +
                        "	rdempty    <= sub_wire1;\n" +
                        "	wrempty    <= sub_wire2;\n" +
                        "\n" +
                        "	dcfifo_component : dcfifo\n" +
                        "	GENERIC MAP (\n" +
                        "		intended_device_family => \"Cyclone V\",\n" +
                        "		lpm_numwords => 32,\n" +
                        "		lpm_showahead => \"OFF\",\n" +
                        "		lpm_type => \"dcfifo\",\n" +
                        "		lpm_width => 1,\n" +
                        "		lpm_widthu => 5,\n" +
                        "		overflow_checking => \"OFF\",\n" +
                        "		rdsync_delaypipe => 4,\n" +
                        "		read_aclr_synch => \"OFF\",\n" +
                        "		underflow_checking => \"OFF\",\n" +
                        "		use_eab => \"ON\",\n" +
                        "		write_aclr_synch => \"OFF\",\n" +
                        "		wrsync_delaypipe => 4\n" +
                        "	)\n" +
                        "	PORT MAP (\n" +
                        "		aclr => aclr,\n" +
                        "		data => data,\n" +
                        "		rdclk => rdclk,\n" +
                        "		rdreq => rdreq,\n" +
                        "		wrclk => wrclk,\n" +
                        "		wrreq => wrreq,\n" +
                        "		q => sub_wire0,\n" +
                        "		rdempty => sub_wire1,\n" +
                        "		wrempty => sub_wire2\n" +
                        "	);\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "END SYN;\n" +
                        "\n" +
                        "-- ============================================================\n" +
                        "-- CNX file retrieval info\n" +
                        "-- ============================================================\n" +
                        "-- Retrieval info: PRIVATE: AlmostEmpty NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: AlmostEmptyThr NUMERIC \"-1\"\n" +
                        "-- Retrieval info: PRIVATE: AlmostFull NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: AlmostFullThr NUMERIC \"-1\"\n" +
                        "-- Retrieval info: PRIVATE: CLOCKS_ARE_SYNCHRONIZED NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: Clock NUMERIC \"4\"\n" +
                        "-- Retrieval info: PRIVATE: Depth NUMERIC \"32\"\n" +
                        "-- Retrieval info: PRIVATE: Empty NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: Full NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: INTENDED_DEVICE_FAMILY STRING \"Cyclone V\"\n" +
                        "-- Retrieval info: PRIVATE: LE_BasedFIFO NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: LegacyRREQ NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: MAX_DEPTH_BY_9 NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: OVERFLOW_CHECKING NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: Optimize NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: RAM_BLOCK_TYPE NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: SYNTH_WRAPPER_GEN_POSTFIX STRING \"0\"\n" +
                        "-- Retrieval info: PRIVATE: UNDERFLOW_CHECKING NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: UsedW NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: Width NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: dc_aclr NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: diff_widths NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: msb_usedw NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: output_width NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: rsEmpty NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: rsFull NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: rsUsedW NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: sc_aclr NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: sc_sclr NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: wsEmpty NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: wsFull NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: wsUsedW NUMERIC \"0\"\n" +
                        "-- Retrieval info: LIBRARY: altera_mf altera_mf.altera_mf_components.all\n" +
                        "-- Retrieval info: CONSTANT: INTENDED_DEVICE_FAMILY STRING \"Cyclone V\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_NUMWORDS NUMERIC \"32\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_SHOWAHEAD STRING \"OFF\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_TYPE STRING \"dcfifo\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_WIDTH NUMERIC \"1\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_WIDTHU NUMERIC \"5\"\n" +
                        "-- Retrieval info: CONSTANT: OVERFLOW_CHECKING STRING \"OFF\"\n" +
                        "-- Retrieval info: CONSTANT: RDSYNC_DELAYPIPE NUMERIC \"4\"\n" +
                        "-- Retrieval info: CONSTANT: READ_ACLR_SYNCH STRING \"OFF\"\n" +
                        "-- Retrieval info: CONSTANT: UNDERFLOW_CHECKING STRING \"OFF\"\n" +
                        "-- Retrieval info: CONSTANT: USE_EAB STRING \"ON\"\n" +
                        "-- Retrieval info: CONSTANT: WRITE_ACLR_SYNCH STRING \"OFF\"\n" +
                        "-- Retrieval info: CONSTANT: WRSYNC_DELAYPIPE NUMERIC \"4\"\n" +
                        "-- Retrieval info: USED_PORT: aclr 0 0 0 0 INPUT GND \"aclr\"\n" +
                        "-- Retrieval info: USED_PORT: data 0 0 1 0 INPUT NODEFVAL \"data[0..0]\"\n" +
                        "-- Retrieval info: USED_PORT: q 0 0 1 0 OUTPUT NODEFVAL \"q[0..0]\"\n" +
                        "-- Retrieval info: USED_PORT: rdclk 0 0 0 0 INPUT NODEFVAL \"rdclk\"\n" +
                        "-- Retrieval info: USED_PORT: rdempty 0 0 0 0 OUTPUT NODEFVAL \"rdempty\"\n" +
                        "-- Retrieval info: USED_PORT: rdreq 0 0 0 0 INPUT NODEFVAL \"rdreq\"\n" +
                        "-- Retrieval info: USED_PORT: wrclk 0 0 0 0 INPUT NODEFVAL \"wrclk\"\n" +
                        "-- Retrieval info: USED_PORT: wrempty 0 0 0 0 OUTPUT NODEFVAL \"wrempty\"\n" +
                        "-- Retrieval info: USED_PORT: wrreq 0 0 0 0 INPUT NODEFVAL \"wrreq\"\n" +
                        "-- Retrieval info: CONNECT: @aclr 0 0 0 0 aclr 0 0 0 0\n" +
                        "-- Retrieval info: CONNECT: @data 0 0 1 0 data 0 0 1 0\n" +
                        "-- Retrieval info: CONNECT: @rdclk 0 0 0 0 rdclk 0 0 0 0\n" +
                        "-- Retrieval info: CONNECT: @rdreq 0 0 0 0 rdreq 0 0 0 0\n" +
                        "-- Retrieval info: CONNECT: @wrclk 0 0 0 0 wrclk 0 0 0 0\n" +
                        "-- Retrieval info: CONNECT: @wrreq 0 0 0 0 wrreq 0 0 0 0\n" +
                        "-- Retrieval info: CONNECT: q 0 0 1 0 @q 0 0 1 0\n" +
                        "-- Retrieval info: CONNECT: rdempty 0 0 0 0 @rdempty 0 0 0 0\n" +
                        "-- Retrieval info: CONNECT: wrempty 0 0 0 0 @wrempty 0 0 0 0\n" +
                        "-- Retrieval info: GEN_FILE: TYPE_NORMAL CDC_Q.vhd TRUE\n" +
                        "-- Retrieval info: GEN_FILE: TYPE_NORMAL CDC_Q.inc FALSE\n" +
                        "-- Retrieval info: GEN_FILE: TYPE_NORMAL CDC_Q.cmp FALSE\n" +
                        "-- Retrieval info: GEN_FILE: TYPE_NORMAL CDC_Q.bsf FALSE\n" +
                        "-- Retrieval info: GEN_FILE: TYPE_NORMAL CDC_Q_inst.vhd FALSE\n" +
                        "-- Retrieval info: LIB_FILE: altera_mf";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_CDC_Q_qip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -name IP_TOOL_NAME \"FIFO\"\n" +
                        "set_global_assignment -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -name IP_GENERATED_DEVICE_FAMILY \"{Cyclone V}\"\n" +
                        "set_global_assignment -name VHDL_FILE [file join $::quartus(qip_path) \"CDC_Q.vhd\"]";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_Time_Calculation_vhd_file(String Project_Folder_File) {
        String data =   "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.numeric_std.all;\n" +
                        "\n" +
                        "entity Time_Calculation is\n" +
                        "	port(\n" +
                        "		clk 			: in std_logic;\n" +
                        "		nrst 		: in std_logic;\n" +
                        "		\n" +
                        "		-- Time Signals\n" +
                        "		Time_Micro_Nano	: out std_logic_vector(31 downto 0);\n" +
                        "		Micro_Nano			: in std_logic; -- Micro = 1, Nano = 0\n" +
                        "		Start_Stop			: in std_logic; -- Start = 1, Stop = 0\n" +
                        "		\n" +
                        "		-- HEX interface\n" +
                        "		HEX0					: OUT STD_LOGIC_VECTOR(6 DOWNTO 0);\n" +
                        "		HEX1					: OUT STD_LOGIC_VECTOR(6 DOWNTO 0);\n" +
                        "		HEX2					: OUT STD_LOGIC_VECTOR(6 DOWNTO 0);\n" +
                        "		HEX3					: OUT STD_LOGIC_VECTOR(6 DOWNTO 0)\n" +
                        "	);\n" +
                        "end entity Time_Calculation;\n" +
                        "\n" +
                        "architecture behaviour of Time_Calculation is\n" +
                        "\n" +
                        "signal counter 					: unsigned(31 downto 0);\n" +
                        "signal Time_Micro_Nano_S		: unsigned(31 downto 0);\n" +
                        "signal Time_Micro_Nano_S_64	: unsigned(63 downto 0);\n" +
                        "signal Time_Micro_Nano_S_std	: std_logic_vector(31 downto 0);\n" +
                        "signal write_data					: std_logic;\n" +
                        "\n" +
                        "begin\n" +
                        "	process(clk, nrst, Micro_Nano, Start_Stop)\n" +
                        "	begin\n" +
                        "		if rising_edge(clk) then\n" +
                        "			if nrst = '0' then\n" +
                        "				counter <= (others => '0');\n" +
                        "				Time_Micro_Nano_S <= (others => '0');\n" +
                        "				write_data <= '1';\n" +
                        "			else\n" +
                        "				if Start_Stop = '1' then -- Starting or started\n" +
                        "					write_data <= '0';\n" +
                        "					counter <= counter + 1;\n" +
                        "					--if Micro_Nano = '1' then -- Micro\n" +
                        "						--Time_Micro_Nano_S	<= counter / 100;\n" +
                        "						Time_Micro_Nano_S	<= counter; -- mult and div take time (will not used)\n" +
                        "					--else -- Nano\n" +
                        "						--Time_Micro_Nano_S_64	<= counter * 10;\n" +
                        "						--Time_Micro_Nano_S		<= Time_Micro_Nano_S_64(31 downto 0);\n" +
                        "						--Time_Micro_Nano_S	<= counter; -- mult and div take time (will not used)\n" +
                        "					--end if;\n" +
                        "				else -- Stopping or stop\n" +
                        "					counter <= (others => '0');\n" +
                        "					write_data <= '1';\n" +
                        "				end if;\n" +
                        "			end if;\n" +
                        "		end if;\n" +
                        "	end process;\n" +
                        "	\n" +
                        "	Time_Micro_Nano_S_std <= std_logic_vector(Time_Micro_Nano_S);\n" +
                        "	--Time_Micro_Nano <= Time_Micro_Nano_S_std;\n" +
                        "	\n" +
                        "	WriteToHexa: entity work.Write_To_Hexa\n" +
                        "		port map(\n" +
                        "			clk					=> clk,\n" +
                        "			nrst					=> nrst,\n" +
                        "			\n" +
                        "			-- Time Signals\n" +
                        "			Time_micro_Nano	=> Time_Micro_Nano_S_std,\n" +
                        "			write_data			=> write_data,\n" +
                        "			\n" +
                        "			-- HEX interface\n" +
                        "			HEX0					=> HEX0,\n" +
                        "			HEX1					=> HEX1,\n" +
                        "			HEX2					=> HEX2,\n" +
                        "			HEX3					=> HEX3\n" +
                        "		);\n" +
                        "		\n" +
                        "end architecture behaviour;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_Write_To_Hexa_vhd_file(String Project_Folder_File) {
        String data =   "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.numeric_std.all;\n" +
                        "\n" +
                        "entity Write_To_Hexa is\n" +
                        "	port(\n" +
                        "		clk					: in std_logic;\n" +
                        "		nrst					: in std_logic;\n" +
                        "		\n" +
                        "		-- Time Signals\n" +
                        "		Time_micro_Nano	: in std_logic_vector(31 downto 0);\n" +
                        "		write_data			: in std_logic;\n" +
                        "		\n" +
                        "		-- HEX interface\n" +
                        "		HEX0					: OUT STD_LOGIC_VECTOR(6 DOWNTO 0);\n" +
                        "		HEX1					: OUT STD_LOGIC_VECTOR(6 DOWNTO 0);\n" +
                        "		HEX2					: OUT STD_LOGIC_VECTOR(6 DOWNTO 0);\n" +
                        "		HEX3					: OUT STD_LOGIC_VECTOR(6 DOWNTO 0)\n" +
                        "	);\n" +
                        "end entity Write_To_Hexa;\n" +
                        "\n" +
                        "architecture behaviour of Write_To_Hexa is\n" +
                        "\n" +
                        "component SEG7_LUT_4 is\n" +
                        "		port(\n" +
                        "			iDIG	: in  std_logic_vector(31 downto 0);\n" +
                        "			\n" +
                        "			oSEG0	: out std_logic_vector(6 downto 0);\n" +
                        "			oSEG1	: out std_logic_vector(6 downto 0);\n" +
                        "			oSEG2	: out std_logic_vector(6 downto 0);\n" +
                        "			oSEG3	: out std_logic_vector(6 downto 0)\n" +
                        "		);\n" +
                        "	end component;\n" +
                        "	\n" +
                        "signal Time_micro_Nano_S	: std_logic_vector(31 downto 0);\n" +
                        "signal count					: unsigned(31 downto 0) := (others => '0');\n" +
                        "signal ovf						: std_logic;\n" +
                        "\n" +
                        "begin\n" +
                        "	process(clk, nrst)\n" +
                        "	begin\n" +
                        "		if rising_edge(clk) then\n" +
                        "			if nrst = '0' then\n" +
                        "				Time_micro_Nano_S <= (others => '0');\n" +
                        "			else\n" +
                        "				if ((write_data = '1') and (ovf = '1')) then\n" +
                        "					Time_micro_Nano_S <= Time_micro_Nano;\n" +
                        "				end if;\n" +
                        "				if (count >= 10000000) then\n" +
                        "					ovf <= '1';\n" +
                        "					if write_data = '1' then\n" +
                        "						count <= (others => '0');\n" +
                        "					end if;\n" +
                        "				else\n" +
                        "					count <= count + 1;\n" +
                        "					ovf <= '0';\n" +
                        "				end if;\n" +
                        "			end if;\n" +
                        "		end if;\n" +
                        "	end process;\n" +
                        "	\n" +
                        "	lut_4: SEG7_LUT_4\n" +
                        "		port map(\n" +
                        "			iDIG => Time_micro_Nano_S,\n" +
                        "			oSEG0 => HEX0,\n" +
                        "			oSEG1 => HEX1,\n" +
                        "			oSEG2 => HEX2,\n" +
                        "			oSEG3 => HEX3\n" +
                        "		);\n" +
                        "		\n" +
                        "end architecture behaviour;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_SEG7_LUT_4_v_file(String Project_Folder_File) {
        String data =   "module SEG7_LUT_4 (	oSEG0,oSEG1,oSEG2,oSEG3,iDIG );\n" +
                        "input	[31:0]	iDIG;\n" +
                        "output	[6:0]	oSEG0,oSEG1,oSEG2,oSEG3;\n" +
                        "\n" +
                        "SEG7_LUT	u0	(	oSEG0,iDIG[3:0]		);\n" +
                        "SEG7_LUT	u1	(	oSEG1,iDIG[7:4]		);\n" +
                        "SEG7_LUT	u2	(	oSEG2,iDIG[11:8]	);\n" +
                        "SEG7_LUT	u3	(	oSEG3,iDIG[15:12]	);\n" +
                        "\n" +
                        "\n" +
                        "endmodule";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_SEG7_LUT_v_file(String Project_Folder_File) {
        String data =   "module SEG7_LUT	(	oSEG,iDIG	);\n" +
                        "input	[3:0]	iDIG;\n" +
                        "output	[6:0]	oSEG;\n" +
                        "reg		[6:0]	oSEG;\n" +
                        "\n" +
                        "always @(iDIG)\n" +
                        "begin\n" +
                        "		case(iDIG)\n" +
                        "		4'h1: oSEG = 7'b1111001;	// ---t----\n" +
                        "		4'h2: oSEG = 7'b0100100; 	// |	  |\n" +
                        "		4'h3: oSEG = 7'b0110000; 	// lt	 rt\n" +
                        "		4'h4: oSEG = 7'b0011001; 	// |	  |\n" +
                        "		4'h5: oSEG = 7'b0010010; 	// ---m----\n" +
                        "		4'h6: oSEG = 7'b0000010; 	// |	  |\n" +
                        "		4'h7: oSEG = 7'b1111000; 	// lb	 rb\n" +
                        "		4'h8: oSEG = 7'b0000000; 	// |	  |\n" +
                        "		4'h9: oSEG = 7'b0011000; 	// ---b----\n" +
                        "		4'ha: oSEG = 7'b0001000;\n" +
                        "		4'hb: oSEG = 7'b0000011;\n" +
                        "		4'hc: oSEG = 7'b1000110;\n" +
                        "		4'hd: oSEG = 7'b0100001;\n" +
                        "		4'he: oSEG = 7'b0000110;\n" +
                        "		4'hf: oSEG = 7'b0001110;\n" +
                        "		4'h0: oSEG = 7'b1000000;\n" +
                        "		endcase\n" +
                        "end\n" +
                        "\n" +
                        "endmodule";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_gencomp_vhd_file(String Project_Folder_File) {
        String data =   "-----------------------------------------------------------------------------\n" +
                        "--! @file\n" +
                        "--! @copyright Copyright 2015 GNSS Sensor Ltd. All right reserved.\n" +
                        "--! @author    Sergey Khabarov - sergeykhbr@gmail.com\n" +
                        "--! @brief     Definition of the gencomp package.\n" +
                        "--! @details   This file defines constants that are used to enable/disable\n" +
                        "--!            target dependable modules.\n" +
                        "--!            This file inherits values from the \\e grlib library that\n" +
                        "--!            that are published under GPL license. All unused values may\n" +
                        "--!            freely removed or reassigned on others values.\n" +
                        "------------------------------------------------------------------------------\n" +
                        "\n" +
                        "--! Standard library\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "\n" +
                        "--! @brief   Technologies names definition\n" +
                        "--! @details This package must be built first in a case of manual compilation\n" +
                        "--!          order (\\e ModelSim).\n" +
                        "package gencomp is\n" +
                        "\n" +
                        "--! @brief   Total number of the known technologies.\n" +
                        "--! @details These values was inherited from the \\e grlib library.\n" +
                        "constant NTECH : integer := 54;\n" +
                        "\n" +
                        "--! Prototype of the data type for mapping name on certain index.\n" +
                        "type tech_ability_type is array (0 to NTECH) of integer;\n" +
                        "\n" +
                        "--! @name  Techologies names.\n" +
                        "--! @brief Set of the predefined technology names.\n" +
                        "--! @{\n" +
                        "constant inferred    : integer := 0;  --! Behaviour simulation target.\n" +
                        "constant virtex      : integer := 1;  --! Not implemented.\n" +
                        "constant virtex2     : integer := 2;  --! Not implemented.\n" +
                        "constant memvirage   : integer := 3;  --! Not implemented.\n" +
                        "constant axcel       : integer := 4;  --! Not implemented.\n" +
                        "constant proasic     : integer := 5;  --! Not implemented.\n" +
                        "constant atc18s      : integer := 6;  --! Not implemented.\n" +
                        "constant altera      : integer := 7;  --! Not implemented.\n" +
                        "constant umc         : integer := 8;  --! Not implemented.\n" +
                        "constant rhumc       : integer := 9;  --! Not implemented.\n" +
                        "constant apa3        : integer := 10; --! Not implemented.\n" +
                        "constant spartan3    : integer := 11; --! Not implemented.\n" +
                        "constant ihp25       : integer := 12; --! Not implemented.\n" +
                        "constant rhlib18t    : integer := 13; --! Not implemented.\n" +
                        "constant virtex4     : integer := 14; --! Not implemented.\n" +
                        "constant lattice     : integer := 15; --! Not implemented.\n" +
                        "constant ut25        : integer := 16; --! Not implemented.\n" +
                        "constant spartan3e   : integer := 17; --! Not implemented.\n" +
                        "constant peregrine   : integer := 18; --! Not implemented.\n" +
                        "constant memartisan  : integer := 19; --! Not implemented.\n" +
                        "constant virtex5     : integer := 20; --! Not implemented.\n" +
                        "constant custom1     : integer := 21; --! Not implemented.\n" +
                        "constant ihp25rh     : integer := 22; --! Not implemented.\n" +
                        "constant stratix1    : integer := 23; --! Not implemented.\n" +
                        "constant stratix2    : integer := 24; --! Not implemented.\n" +
                        "constant eclipse     : integer := 25; --! Not implemented.\n" +
                        "constant stratix3    : integer := 26; --! Not implemented.\n" +
                        "constant cyclone3    : integer := 27; --! Not implemented.\n" +
                        "constant memvirage90 : integer := 28; --! Not implemented.\n" +
                        "constant tsmc90      : integer := 29; --! Not implemented.\n" +
                        "constant easic90     : integer := 30; --! Not implemented.\n" +
                        "constant atc18rha    : integer := 31; --! Not implemented.\n" +
                        "constant smic013     : integer := 32; --! Not implemented.\n" +
                        "constant tm65gpl     : integer := 33; --! Not implemented.\n" +
                        "constant axdsp       : integer := 34; --! Not implemented.\n" +
                        "constant spartan6    : integer := 35; --! Supported. Use files with the '_s6' suffix.\n" +
                        "constant virtex6     : integer := 36; --! Supported. Use files with the '_v6' suffix.\n" +
                        "constant actfus      : integer := 37; --! Not implemented.\n" +
                        "constant stratix4    : integer := 38; --! Not implemented.\n" +
                        "constant st65lp      : integer := 39; --! Not implemented.\n" +
                        "constant st65gp      : integer := 40; --! Not implemented.\n" +
                        "constant easic45     : integer := 41; --! Not implemented.\n" +
                        "constant cmos9sf     : integer := 42; --! Not implemented.\n" +
                        "constant apa3e       : integer := 43; --! Not implemented.\n" +
                        "constant apa3l       : integer := 44; --! Not implemented.\n" +
                        "constant ut130       : integer := 45; --! Not implemented.\n" +
                        "constant ut90        : integer := 46; --! Not implemented.\n" +
                        "constant gf65        : integer := 47; --! Not implemented.\n" +
                        "constant virtex7     : integer := 48; --! Not implemented.\n" +
                        "constant kintex7     : integer := 49; --! Supported. Use files with the '_k7' suffix.\n" +
                        "constant artix7      : integer := 50; --! Not implemented.\n" +
                        "constant zynq7000    : integer := 51; --! Not implemented.\n" +
                        "constant rhlib13t    : integer := 52; --! Not implemented.\n" +
                        "constant mikron180   : integer := 53; --! Mikron 180nm. Use files with the '_micron180' suffix.\n" +
                        "constant cyclonevc5g : integer := 54; --! Supported. Use files with the '_c5g' suffix.\n" +
                        "\n" +
                        "--! @}\n" +
                        "\n" +
                        "--! @name    FPGAs technologies group.\n" +
                        "--! @details It is convinient sometimes to implement one module for a group of\n" +
                        "--!          technologies, this array specifies FPGA group.\n" +
                        "constant is_fpga : tech_ability_type :=\n" +
                        "	(inferred => 1, virtex => 1, virtex2 => 1, axcel => 1,\n" +
                        "	 proasic => 1, altera => 1, apa3 => 1, spartan3 => 1,\n" +
                        "         virtex4 => 1, lattice => 1, spartan3e => 1, virtex5 => 1,\n" +
                        "	 stratix1 => 1, stratix2 => 1, eclipse => 1,\n" +
                        "	 stratix3 => 1, cyclone3 => 1, axdsp => 1,\n" +
                        "	 spartan6 => 1, virtex6 => 1, actfus => 1,\n" +
                        "	 stratix4 => 1, apa3e => 1, apa3l => 1, virtex7 => 1, kintex7 => 1,\n" +
                        "	 artix7 => 1, zynq7000 => 1, cyclonevc5g => 1,\n" +
                        "	 others => 0);\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_types_mem_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "--! Standard library\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "--! Provide common generic log() function\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "--! AMBA system bus specific library.\n" +
                        "library ambalib;\n" +
                        "--! AXI4 configuration constants.\n" +
                        "use ambalib.types_amba4.all;\n" +
                        "\n" +
                        "--! @brief      Declaration of 'virtual' Memory components.\n" +
                        "package types_mem is\n" +
                        "\n" +
                        "  --! @brief   Declaration of the \"virtual\" BootROM component.\n" +
                        "  --! @details BootRom start address must implements address matching to the\n" +
                        "  --!          CPU reset vector (0x200) and all processing after power-on is\n" +
                        "  --!          using this memory block. BootRom size depends of the configuration\n" +
                        "  --!          and size of the generated hex file. \n" +
                        "  --!          Component implements one-clock access to the\n" +
                        "  --!          ROM without wait-staits. Datawidth depends of the AXI4 bus\n" +
                        "  --!          configuration.\n" +
                        "  --! @param[in] tech    Generic technology selector.\n" +
                        "  --! @param[in] hex_filename     Generic argument defining hex-file location.\n" +
                        "  --! @param[in] clk     System bus clock.\n" +
                        "  --! @param[in] address Input address.\n" +
                        "  --! @param[out] data   Output data value.\n" +
                        "  component Rom_tech is\n" +
                        "  generic (\n" +
                        "    memtech : integer := 0;\n" +
                        "    abits : integer;\n" +
                        "    sim_hexfile : string\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk       : in std_logic;\n" +
                        "    address   : in global_addr_array_type;\n" +
                        "    data      : out std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0)\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "  --! @brief   Declaration of the \"virtual\" SRAM component with unaligned access.\n" +
                        "  --! @details This module implements internal SRAM and support unaligned access \n" +
                        "  --!          without wait-states. For example it allows to read 4 bytes from\n" +
                        "  --!          address 0x3 for one clock.\n" +
                        "  --!          Component implements one-clock access without wait-staits. \n" +
                        "  --!          Datawidth depends of the AXI4 bus configuration.\n" +
                        "  --! @param[in] memtech Generic technology selector.\n" +
                        "  --! @param[in] abits   Generic argument defining SRAM size as 2**abits.\n" +
                        "  --! @param[in] clk     System bus clock.\n" +
                        "  --! @param[in] raddr   Read address.\n" +
                        "  --! @param[out] rdata  Output data value.\n" +
                        "  --! @param[in] waddr   Write address.\n" +
                        "  --! @param[in] we      Write enable.\n" +
                        "  --! @param[in] wstrb   Byte selector to form write only for the specified bytes.\n" +
                        "  --! @param[in] wdata   Write data.\n" +
                        "  component srambytes_tech is\n" +
                        "  generic (\n" +
                        "    memtech : integer := 0;\n" +
                        "    abits   : integer := 16;\n" +
                        "    init_file : string := \"\"\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk       : in std_logic;\n" +
                        "    raddr     : in global_addr_array_type;\n" +
                        "    rdata     : out std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "    waddr     : in global_addr_array_type;\n" +
                        "    we        : in std_logic;\n" +
                        "    wstrb     : in std_logic_vector(CFG_SYSBUS_DATA_BYTES-1 downto 0);\n" +
                        "    wdata     : in std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0)\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "  component dpram_tech is\n" +
                        "  generic (\n" +
                        "    memtech : integer := 0;\n" +
                        "    abits   : integer := 12;\n" +
                        "    dbits   : integer := 64\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk   : in std_logic;\n" +
                        "    i_raddr : in std_logic_vector(abits-1 downto 0);\n" +
                        "    o_rdata : out std_logic_vector(dbits-1 downto 0);\n" +
                        "    i_waddr : in std_logic_vector(abits-1 downto 0);\n" +
                        "    i_wena  : in std_logic;\n" +
                        "    i_wdata : in std_logic_vector(dbits-1 downto 0)\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "  component ram_tech is generic (\n" +
                        "    memtech : integer := 0;\n" +
                        "    abits   : integer := 12;\n" +
                        "    dbits   : integer := 64\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk   : in std_logic;\n" +
                        "    i_addr  : in std_logic_vector(abits-1 downto 0);\n" +
                        "    o_rdata : out std_logic_vector(dbits-1 downto 0);\n" +
                        "    i_wena  : in std_logic;\n" +
                        "    i_wdata : in std_logic_vector(dbits-1 downto 0)\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_rom_tech_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library techmap;\n" +
                        "use techmap.gencomp.all;\n" +
                        "use techmap.types_mem.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "--! AMBA system bus specific library\n" +
                        "library ambalib;\n" +
                        "--! AXI4 configuration constants.\n" +
                        "use ambalib.types_amba4.all;\n" +
                        "\n" +
                        "entity Rom_tech is\n" +
                        "generic (\n" +
                        "    memtech : integer := 0;\n" +
                        "    abits : integer;\n" +
                        "    sim_hexfile : string\n" +
                        ");\n" +
                        "port (\n" +
                        "    clk       : in std_logic;\n" +
                        "    address   : in global_addr_array_type;\n" +
                        "    data      : out std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0)\n" +
                        ");\n" +
                        "end;\n" +
                        "\n" +
                        "architecture rtl of Rom_tech is\n" +
                        "\n" +
                        "  component Rom_inferred is\n" +
                        "  generic (\n" +
                        "    abits : integer;\n" +
                        "    hex_filename : string\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk     : in  std_ulogic;\n" +
                        "    address : in global_addr_array_type;\n" +
                        "    data    : out std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0)\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "  \n" +
                        "  component Rom_c5g is\n" +
                        "  generic (\n" +
                        "    abits : integer;\n" +
                        "    cyc_miffile : string\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk     : in  std_ulogic;\n" +
                        "    address : in global_addr_array_type;\n" +
                        "    data    : out std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0)\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  genrom0 : if memtech = inferred or (is_fpga(memtech) /= 0 and memtech /= cyclonevc5g) generate\n" +
                        "      infer0 : Rom_inferred  generic map (abits, sim_hexfile)\n" +
                        "               port map (clk, address, data);\n" +
                        "	end generate;\n" +
                        "  \n" +
                        "	genrom1 : if memtech = inferred or (is_fpga(memtech) /= 0 and memtech = cyclonevc5g) generate\n" +
                        "		infer0 : Rom_c5g  generic map (abits, sim_hexfile)\n" +
                        "               port map (clk, address, data);\n" +
                        "	end generate;\n" +
                        "\n" +
                        "end; \n" +
                        "";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_ram_tech_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "\n" +
                        "library techmap;\n" +
                        "use techmap.gencomp.all;\n" +
                        "use techmap.types_mem.all;\n" +
                        "\n" +
                        "entity ram_tech is generic (\n" +
                        "    memtech : integer := 0;\n" +
                        "    abits   : integer := 12;\n" +
                        "    dbits   : integer := 64\n" +
                        ");\n" +
                        "port (\n" +
                        "    i_clk   : in std_logic;\n" +
                        "    i_addr : in std_logic_vector(abits-1 downto 0);\n" +
                        "    o_rdata : out std_logic_vector(dbits-1 downto 0);\n" +
                        "    i_wena  : in std_logic;\n" +
                        "    i_wdata : in std_logic_vector(dbits-1 downto 0)\n" +
                        ");\n" +
                        "end;\n" +
                        "\n" +
                        "architecture rtl of ram_tech is\n" +
                        "\n" +
                        "  component ram_inferred is\n" +
                        "  generic (\n" +
                        "     abits : integer := 12;\n" +
                        "     dbits : integer := 64\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk   : in std_logic;\n" +
                        "    i_addr : in std_logic_vector(abits-1 downto 0);\n" +
                        "    o_rdata : out std_logic_vector(dbits-1 downto 0);\n" +
                        "    i_wena  : in std_logic;\n" +
                        "    i_wdata : in std_logic_vector(dbits-1 downto 0)\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  inf0 : if memtech = inferred or is_fpga(memtech) /= 0 generate\n" +
                        "      x0 : ram_inferred generic map \n" +
                        "      (\n" +
                        "          abits => abits,\n" +
                        "          dbits => dbits\n" +
                        "      ) port map (\n" +
                        "          i_clk   => i_clk,\n" +
                        "          i_addr  => i_addr,\n" +
                        "          o_rdata => o_rdata,\n" +
                        "          i_wena  => i_wena,\n" +
                        "          i_wdata => i_wdata\n" +
                        "      );\n" +
                        "  end generate;\n" +
                        "\n" +
                        "end; \n" +
                        "";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_dpram_tech_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "\n" +
                        "library techmap;\n" +
                        "use techmap.gencomp.all;\n" +
                        "use techmap.types_mem.all;\n" +
                        "\n" +
                        "entity dpram_tech is\n" +
                        "generic (\n" +
                        "    memtech : integer := 0;\n" +
                        "    abits   : integer := 12;\n" +
                        "    dbits   : integer := 64\n" +
                        ");\n" +
                        "port (\n" +
                        "    i_clk   : in std_logic;\n" +
                        "    i_raddr : in std_logic_vector(abits-1 downto 0);\n" +
                        "    o_rdata : out std_logic_vector(dbits-1 downto 0);\n" +
                        "    i_waddr : in std_logic_vector(abits-1 downto 0);\n" +
                        "    i_wena  : in std_logic;\n" +
                        "    i_wdata : in std_logic_vector(dbits-1 downto 0)\n" +
                        ");\n" +
                        "end;\n" +
                        "\n" +
                        "architecture rtl of dpram_tech is\n" +
                        "\n" +
                        "  component dpram_inferred is\n" +
                        "  generic (\n" +
                        "     abits : integer := 12;\n" +
                        "     dbits : integer := 64\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk   : in std_logic;\n" +
                        "    i_raddr : in std_logic_vector(abits-1 downto 0);\n" +
                        "    o_rdata : out std_logic_vector(dbits-1 downto 0);\n" +
                        "    i_waddr : in  std_logic_vector(abits-1 downto 0);\n" +
                        "    i_wena  : in std_logic;\n" +
                        "    i_wdata : in std_logic_vector(dbits-1 downto 0)\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  inf0 : if memtech = inferred or is_fpga(memtech) /= 0 generate\n" +
                        "      x0 : dpram_inferred generic map \n" +
                        "      (\n" +
                        "          abits => abits,\n" +
                        "          dbits => dbits\n" +
                        "      ) port map (\n" +
                        "          i_clk   => i_clk,\n" +
                        "          i_raddr => i_raddr,\n" +
                        "          o_rdata => o_rdata,\n" +
                        "          i_waddr => i_waddr,\n" +
                        "          i_wena  => i_wena,\n" +
                        "          i_wdata => i_wdata\n" +
                        "      );\n" +
                        "  end generate;\n" +
                        "\n" +
                        "end; \n" +
                        "";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_rom_c5g_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.numeric_std.ALL;\n" +
                        "use IEEE.STD_LOGIC_TEXTIO.ALL;\n" +
                        "use std.textio.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "--! AMBA system bus specific library.\n" +
                        "library ambalib;\n" +
                        "--! AXI4 configuration constants.\n" +
                        "use ambalib.types_amba4.all;\n" +
                        "--! ALTERA altsyncram\n" +
                        "library altera_mf;\n" +
                        "use altera_mf.altera_mf_components.all;\n" +
                        "\n" +
                        "entity Rom_c5g is\n" +
                        "  generic (\n" +
                        "    abits : integer;\n" +
                        "    cyc_miffile : string\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk     : in  std_ulogic;\n" +
                        "    address : in global_addr_array_type;\n" +
                        "    data    : out std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0)\n" +
                        "  );\n" +
                        "end;\n" +
                        "\n" +
                        "architecture rtl of Rom_c5g is\n" +
                        "\n" +
                        "begin\n" +
                        "    \n" +
                        "  altsyncram_component : altsyncram\n" +
                        "  GENERIC MAP (\n" +
                        "    address_aclr_a => \"NONE\",\n" +
                        "    clock_enable_input_a => \"BYPASS\",\n" +
                        "    clock_enable_output_a => \"BYPASS\",\n" +
                        "    init_file => cyc_miffile,\n" +
                        "    intended_device_family => \"Cyclone V\",\n" +
                        "    lpm_hint => \"ENABLE_RUNTIME_MOD=NO\",\n" +
                        "    lpm_type => \"altsyncram\",\n" +
                        "    numwords_a => 2**(abits-3),\n" +
                        "    operation_mode => \"ROM\",\n" +
                        "    outdata_aclr_a => \"NONE\",\n" +
                        "    outdata_reg_a => \"UNREGISTERED\",\n" +
                        "    widthad_a => abits-3,\n" +
                        "    width_a => CFG_SYSBUS_DATA_BITS,\n" +
                        "    width_byteena_a => 1\n" +
                        "  )\n" +
                        "  PORT MAP (\n" +
                        "    address_a => address(0)(abits-1 downto 3),\n" +
                        "    clock0 => clk,\n" +
                        "    q_a => data\n" +
                        "  );\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_dpram_inferred_tech_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.numeric_std.ALL;\n" +
                        "use IEEE.STD_LOGIC_TEXTIO.ALL;\n" +
                        "use std.textio.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "\n" +
                        "entity dpram_inferred is\n" +
                        "  generic (\n" +
                        "    abits : integer := 12;\n" +
                        "    dbits : integer := 64\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk   : in std_logic;\n" +
                        "    i_raddr : in std_logic_vector(abits-1 downto 0);\n" +
                        "    o_rdata : out std_logic_vector(dbits-1 downto 0);\n" +
                        "    i_waddr : in std_logic_vector(abits-1 downto 0);\n" +
                        "    i_wena  : in std_logic;\n" +
                        "    i_wdata : in std_logic_vector(dbits-1 downto 0)\n" +
                        "  );\n" +
                        "end;\n" +
                        "\n" +
                        "architecture arch_dpram_inferred of dpram_inferred is\n" +
                        "\n" +
                        "constant SRAM_LENGTH : integer := 2**abits;\n" +
                        "type ram_type is array (0 to SRAM_LENGTH-1) of std_logic_vector(dbits-1 downto 0);\n" +
                        "\n" +
                        "signal ram : ram_type;\n" +
                        "signal radr : std_logic_vector(abits-1 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  reg : process (i_clk) begin\n" +
                        "    if rising_edge(i_clk) then \n" +
                        "      radr <= i_raddr;\n" +
                        "      if i_wena = '1' then\n" +
                        "        ram(conv_integer(i_waddr)) <= i_wdata;\n" +
                        "      end if;\n" +
                        "    end if;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  o_rdata <= ram(conv_integer(radr));\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_srambytes_tech_vhd_file(String Project_Folder_File) {
        String data =   "----------------------------------------------------------------------------\n" +
                        "--! @file\n" +
                        "--! @copyright  Copyright 2015 GNSS Sensor Ltd. All right reserved.\n" +
                        "--! @author     Sergey Khabarov\n" +
                        "--! @brief      Internal SRAM implementation with the byte access.\n" +
                        "------------------------------------------------------------------------------\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "\n" +
                        "library techmap;\n" +
                        "use techmap.gencomp.all;\n" +
                        "use techmap.types_mem.all;\n" +
                        "\n" +
                        "--! AMBA system bus specific library.\n" +
                        "library ambalib;\n" +
                        "--! AXI4 configuration constants.\n" +
                        "use ambalib.types_amba4.all;\n" +
                        "\n" +
                        "entity srambytes_tech is\n" +
                        "generic (\n" +
                        "    memtech : integer := 0;\n" +
                        "    abits   : integer := 16;\n" +
                        "    init_file : string := \"\"\n" +
                        ");\n" +
                        "port (\n" +
                        "    clk       : in std_logic;\n" +
                        "    raddr     : in global_addr_array_type;\n" +
                        "    rdata     : out std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "    waddr     : in global_addr_array_type;\n" +
                        "    we        : in std_logic;\n" +
                        "    wstrb     : in std_logic_vector(CFG_SYSBUS_DATA_BYTES-1 downto 0);\n" +
                        "    wdata     : in std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0)\n" +
                        ");\n" +
                        "end;\n" +
                        "\n" +
                        "architecture rtl of srambytes_tech is\n" +
                        "\n" +
                        "--! reduced name of configuration constant:\n" +
                        "constant dw : integer := CFG_SYSBUS_ADDR_OFFSET;\n" +
                        "\n" +
                        "type local_addr_type is array (0 to CFG_SYSBUS_DATA_BYTES-1) of\n" +
                        "   std_logic_vector(abits-dw-1 downto 0);\n" +
                        "\n" +
                        "signal address : local_addr_type;\n" +
                        "signal wr_ena : std_logic_vector(CFG_SYSBUS_DATA_BYTES-1 downto 0);\n" +
                        "\n" +
                        "  --! @brief   Declaration of the one-byte SRAM element.\n" +
                        "  --! @details This component is used for the FPGA implementation.\n" +
                        "  component sram8_inferred is\n" +
                        "  generic (\n" +
                        "     abits : integer := 12;\n" +
                        "     byte_idx : integer := 0\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk     : in  std_ulogic;\n" +
                        "    address : in  std_logic_vector(abits-1 downto 0);\n" +
                        "    rdata   : out std_logic_vector(7 downto 0);\n" +
                        "    we      : in  std_logic;\n" +
                        "    wdata   : in  std_logic_vector(7 downto 0)\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "  --! @brief   Declaration of the one-byte SRAM element with init function.\n" +
                        "  --! @details This component is used for the RTL simulation.\n" +
                        "  component sram8_inferred_init is\n" +
                        "  generic (\n" +
                        "     abits     : integer := 12;\n" +
                        "     byte_idx  : integer := 0;\n" +
                        "     init_file : string\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk     : in  std_ulogic;\n" +
                        "    address : in  std_logic_vector(abits-1 downto 0);\n" +
                        "    rdata   : out std_logic_vector(7 downto 0);\n" +
                        "    we      : in  std_logic;\n" +
                        "    wdata   : in  std_logic_vector(7 downto 0)\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "     \n" +
                        "  --! Instantiate component for RTL simulation\n" +
                        "  rtlsim0 : if memtech = inferred generate\n" +
                        "    rx : for n in 0 to CFG_SYSBUS_DATA_BYTES-1 generate\n" +
                        "\n" +
                        "      wr_ena(n) <= we and wstrb(n);\n" +
                        "      address(n) <= waddr(n / CFG_ALIGN_BYTES)(abits-1 downto dw) when we = '1'\n" +
                        "                else raddr(n / CFG_ALIGN_BYTES)(abits-1 downto dw);\n" +
                        "                  \n" +
                        "      x0 : sram8_inferred_init generic map \n" +
                        "      (\n" +
                        "          abits => abits-dw,\n" +
                        "          byte_idx => n,\n" +
                        "          init_file => init_file\n" +
                        "      ) port map (\n" +
                        "          clk, \n" +
                        "          address => address(n),\n" +
                        "          rdata => rdata(8*(n+1)-1 downto 8*n),\n" +
                        "          we => wr_ena(n), \n" +
                        "          wdata => wdata(8*(n+1)-1 downto 8*n)\n" +
                        "      );\n" +
                        "    end generate; -- cycle\n" +
                        "  end generate; -- tech=inferred\n" +
                        "\n" +
                        "\n" +
                        "  --! Instantiate component for FPGA (checked with Xilinx)\n" +
                        "  fpgasim0 : if memtech /= inferred and is_fpga(memtech) /= 0 generate\n" +
                        "    rx : for n in 0 to CFG_SYSBUS_DATA_BYTES-1 generate\n" +
                        "\n" +
                        "      wr_ena(n) <= we and wstrb(n);\n" +
                        "      address(n) <= waddr(n / CFG_ALIGN_BYTES)(abits-1 downto dw) when we = '1'\n" +
                        "                else raddr(n / CFG_ALIGN_BYTES)(abits-1 downto dw);\n" +
                        "\n" +
                        "      x0 : sram8_inferred generic map \n" +
                        "      (\n" +
                        "          abits => abits-dw,\n" +
                        "          byte_idx => n\n" +
                        "      ) port map (\n" +
                        "          clk, \n" +
                        "          address => address(n),\n" +
                        "          rdata => rdata(8*(n+1)-1 downto 8*n),\n" +
                        "          we => wr_ena(n), \n" +
                        "          wdata => wdata(8*(n+1)-1 downto 8*n)\n" +
                        "      );\n" +
                        "    end generate; -- cycle\n" +
                        "  end generate; -- tech=inferred\n" +
                        "  \n" +
                        "end; \n" +
                        "";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_sram8_inferred_vhd_file(String Project_Folder_File) {
        String data =   "----------------------------------------------------------------------------\n" +
                        "--! @file\n" +
                        "--! @copyright  Copyright 2015 GNSS Sensor Ltd. All right reserved.\n" +
                        "--! @author     Sergey Khabarov\n" +
                        "--! @brief      8-bits memory block with the generic data size parameter.\n" +
                        "------------------------------------------------------------------------------\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.numeric_std.ALL;\n" +
                        "use IEEE.STD_LOGIC_TEXTIO.ALL;\n" +
                        "use std.textio.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "\n" +
                        "entity sram8_inferred is\n" +
                        "  generic (\n" +
                        "    abits : integer := 12;\n" +
                        "    byte_idx : integer := 0\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk     : in  std_ulogic;\n" +
                        "    address : in  std_logic_vector(abits-1 downto 0);\n" +
                        "    rdata   : out std_logic_vector(7 downto 0);\n" +
                        "    we      : in  std_logic;\n" +
                        "    wdata   : in  std_logic_vector(7 downto 0)\n" +
                        "  );\n" +
                        "end;\n" +
                        "\n" +
                        "architecture arch_sram8_inferred of sram8_inferred is\n" +
                        "\n" +
                        "constant SRAM_LENGTH : integer := 2**abits;\n" +
                        "type ram_type is array (0 to SRAM_LENGTH-1) of std_logic_vector(7 downto 0);\n" +
                        "\n" +
                        "signal ram : ram_type;\n" +
                        "signal adr : std_logic_vector(abits-1 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  reg : process (clk, address, wdata) begin\n" +
                        "    if rising_edge(clk) then \n" +
                        "      if we = '1' then\n" +
                        "        ram(conv_integer(address)) <= wdata;\n" +
                        "      end if;\n" +
                        "      adr <= address;\n" +
                        "    end if;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  rdata <= ram(conv_integer(adr));\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_sram8_inferred_init_vhd_file(String Project_Folder_File) {
        String data =   "----------------------------------------------------------------------------\n" +
                        "--! @file\n" +
                        "--! @copyright  Copyright 2015 GNSS Sensor Ltd. All right reserved.\n" +
                        "--! @author     Sergey Khabarov\n" +
                        "--! @brief      8-bits memory block with the generic data size parameter.\n" +
                        "--! @details    This module absolutely similar to the 'inferred' implementation\n" +
                        "--!             but it support initialization of the SRAM.\n" +
                        "--!             This feature is very useful during RTL simulation so that\n" +
                        "--!             current FW supports skipping of the copying FwImage state.\n" +
                        "------------------------------------------------------------------------------\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.numeric_std.ALL;\n" +
                        "use IEEE.STD_LOGIC_TEXTIO.ALL;\n" +
                        "use std.textio.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "--! AMBA system bus specific library.\n" +
                        "library ambalib;\n" +
                        "--! AXI4 configuration constants.\n" +
                        "use ambalib.types_amba4.all;\n" +
                        "\n" +
                        "entity sram8_inferred_init is\n" +
                        "  generic (\n" +
                        "    abits     : integer := 12;\n" +
                        "    byte_idx  : integer := 0;\n" +
                        "    init_file : string\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    clk     : in  std_ulogic;\n" +
                        "    address : in  std_logic_vector(abits-1 downto 0);\n" +
                        "    rdata   : out std_logic_vector(7 downto 0);\n" +
                        "    we      : in  std_logic;\n" +
                        "    wdata   : in  std_logic_vector(7 downto 0)\n" +
                        "  );\n" +
                        "end;\n" +
                        "\n" +
                        "architecture arch_sram8_inferred_init of sram8_inferred_init is\n" +
                        "\n" +
                        "\n" +
                        "constant SRAM_LENGTH : integer := 2**abits;\n" +
                        "-- romimage only 256 KB, but SRAM is 512 KB so we initialize one\n" +
                        "-- half of sram = 32768 * 8 = 256 KB\n" +
                        "constant FILE_IMAGE_LINES_TOTAL : integer := 32768;\n" +
                        "type ram_type is array (0 to SRAM_LENGTH-1) of std_logic_vector(7 downto 0);\n" +
                        "\n" +
                        "impure function init_ram(file_name : in string) return ram_type is\n" +
                        "    file ram_file : text open read_mode is file_name;\n" +
                        "    variable ram_line : line;\n" +
                        "    variable temp_bv : std_logic_vector(CFG_SYSBUS_DATA_BITS-1 downto 0);\n" +
                        "    variable temp_mem : ram_type;\n" +
                        "begin\n" +
                        "    for i in 0 to (FILE_IMAGE_LINES_TOTAL-1) loop\n" +
                        "        readline(ram_file, ram_line);\n" +
                        "        hread(ram_line, temp_bv);\n" +
                        "        temp_mem(i) := temp_bv((byte_idx+1)*8-1 downto 8*byte_idx);\n" +
                        "    end loop;\n" +
                        "    return temp_mem;\n" +
                        "end function;\n" +
                        "\n" +
                        "--! @warning SIMULATION INITIALIZATION\n" +
                        "signal ram : ram_type := init_ram(init_file);\n" +
                        "signal adr : std_logic_vector(abits-1 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  reg : process (clk, address, wdata) begin\n" +
                        "    if rising_edge(clk) then \n" +
                        "      if we = '1' then\n" +
                        "        ram(conv_integer(address)) <= wdata;\n" +
                        "      end if;\n" +
                        "      adr <= address;\n" +
                        "    end if;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  rdata <= ram(conv_integer(adr));\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_ram_inferred_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.numeric_std.ALL;\n" +
                        "use std.textio.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "\n" +
                        "entity ram_inferred is generic (\n" +
                        "    abits : integer := 12;\n" +
                        "    dbits : integer := 64\n" +
                        ");\n" +
                        "port (\n" +
                        "    i_clk   : in std_logic;\n" +
                        "    i_addr : in std_logic_vector(abits-1 downto 0);\n" +
                        "    o_rdata : out std_logic_vector(dbits-1 downto 0);\n" +
                        "    i_wena  : in std_logic;\n" +
                        "    i_wdata : in std_logic_vector(dbits-1 downto 0)\n" +
                        ");\n" +
                        "end;\n" +
                        "\n" +
                        "architecture rtl of ram_inferred is\n" +
                        "\n" +
                        "constant SRAM_LENGTH : integer := 2**abits;\n" +
                        "type ram_type is array (0 to SRAM_LENGTH-1) of std_logic_vector(dbits-1 downto 0);\n" +
                        "\n" +
                        "signal ram : ram_type;\n" +
                        "signal radr : std_logic_vector(abits-1 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  reg : process (i_clk) begin\n" +
                        "    if rising_edge(i_clk) then \n" +
                        "      radr <= i_addr;\n" +
                        "      if i_wena = '1' then\n" +
                        "        ram(conv_integer(i_addr)) <= i_wdata;\n" +
                        "      end if;\n" +
                        "    end if;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  o_rdata <= ram(conv_integer(radr));\n" +
                        "\n" +
                        "end; \n" +
                        "";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_SysPLL_inferred_vhd_file(String Project_Folder_File) {
        String data =   "-----------------------------------------------------------------------------\n" +
                        "--! @file\n" +
                        "--! @copyright Copyright 2015 GNSS Sensor Ltd. All right reserved.\n" +
                        "--! @author    Sergey Khabarov - sergeykhbr@gmail.com\n" +
                        "--! @details  	PLL instance for the behaviour simulation\n" +
                        "--!\n" +
                        "--! \"Output    Output      Phase     Duty      Pk-to-Pk        Phase\"\n" +
                        "--! \"Clock    Freq (MHz) (degrees) Cycle (%) Jitter (ps)  Error (ps)\"\n" +
                        "--!\n" +
                        "--! CLK_OUT1____70.000\n" +
                        "-----------------------------------------------------------------------------\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "\n" +
                        "--library unisim;\n" +
                        "--use unisim.vcomponents.all;\n" +
                        "\n" +
                        "entity SysPLL_inferred is\n" +
                        "port\n" +
                        " (-- Clock in ports\n" +
                        "  CLK_IN            : in     std_logic;\n" +
                        "  -- Clock out ports\n" +
                        "  CLK_OUT1          : out    std_logic;\n" +
                        "  -- Status and control signals\n" +
                        "  RESET             : in     std_logic;\n" +
                        "  LOCKED            : out    std_logic\n" +
                        " );\n" +
                        "end SysPLL_inferred;\n" +
                        "\n" +
                        "architecture rtl of SysPLL_inferred is\n" +
                        " \n" +
                        "begin\n" +
                        "\n" +
                        "  CLK_OUT1 <= CLK_IN;\n" +
                        "  LOCKED <= not RESET;\n" +
                        "\n" +
                        "end rtl;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_SysPLL_tech_vhd_file(String Project_Folder_File) {
        String data =   "-----------------------------------------------------------------------------\n" +
                        "--! @file\n" +
                        "--! @copyright Copyright 2015 GNSS Sensor Ltd. All right reserved.\n" +
                        "--! @author    Sergey Khabarov - sergeykhbr@gmail.com\n" +
                        "--! @brief     Implementation of the SysPLL_tech entity\n" +
                        "--! @details   This module file be included in all projects.\n" +
                        "------------------------------------------------------------------------------\n" +
                        "\n" +
                        "--! Standard library\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "\n" +
                        "--! \"Virtual\" components declarations library.\n" +
                        "library techmap;\n" +
                        "use techmap.gencomp.all;\n" +
                        "\n" +
                        "--! @brief   SysPLL_tech entity declaration (\"Virtual\" PLL).\n" +
                        "--! @details This module instantiates the certain PLL implementation\n" +
                        "--!          depending generic technology argument.\n" +
                        "entity SysPLL_tech is\n" +
                        "  generic (\n" +
                        "    tech    : integer range 0 to NTECH := 0 --! PLL implementation selector\n" +
                        "  );\n" +
                        "  port\n" +
                        "  (\n" +
                        "    --! Reset value. Active high.\n" +
                        "    i_reset           : in     std_logic;\n" +
                        "    --! Input clock from the external oscillator (default 200 MHz)\n" +
                        "    i_clk_tcxo        : in     std_logic;\n" +
                        "    --! System Bus clock 100MHz/40MHz (Virtex6/Spartan6)\n" +
                        "    o_clk_bus         : out    std_logic;\n" +
                        "	 o_clk_pwm         : out    std_logic;\n" +
                        "    --! PLL locked status.\n" +
                        "    o_locked          : out    std_logic\n" +
                        "  );\n" +
                        "end SysPLL_tech;\n" +
                        "\n" +
                        "--! SysPLL_tech architecture declaration.\n" +
                        "architecture rtl of SysPLL_tech is\n" +
                        "  component SysPLL_inferred is\n" +
                        "  port (\n" +
                        "    CLK_IN      : in     std_logic;\n" +
                        "    CLK_OUT1    : out    std_logic;\n" +
                        "    RESET       : in     std_logic;\n" +
                        "    LOCKED      : out    std_logic );\n" +
                        "  end component;\n" +
                        "\n" +
                        "  component SysPLL_v6 is \n" +
                        "  port (\n" +
                        "    CLK_IN      : in     std_logic;\n" +
                        "    CLK_OUT1	: out    std_logic;\n" +
                        "    RESET	: in std_logic;\n" +
                        "    LOCKED	: out std_logic );\n" +
                        "  end component;\n" +
                        "\n" +
                        "  component SysPLL_k7 is\n" +
                        "  port (\n" +
                        "    CLK_IN      : in     std_logic;\n" +
                        "    CLK_OUT1    : out    std_logic;\n" +
                        "    RESET     : in     std_logic;\n" +
                        "    LOCKED    : out    std_logic );\n" +
                        "  end component;\n" +
                        "  \n" +
                        "  component SysPLL_zynq is\n" +
                        "  port\n" +
                        "   (\n" +
                        "    CLK_IN           : in     std_logic;\n" +
                        "    CLK_OUT1          : out    std_logic;\n" +
                        "    RESET             : in     std_logic;\n" +
                        "    LOCKED            : out    std_logic\n" +
                        "   );\n" +
                        "  end component;\n" +
                        "\n" +
                        "  component SysPLL_micron180 is\n" +
                        "  port (\n" +
                        "    CLK_IN      : in     std_logic;\n" +
                        "    CLK_OUT1    : out    std_logic;\n" +
                        "    RESET       : in     std_logic;\n" +
                        "    LOCKED      : out    std_logic );\n" +
                        "  end component;\n" +
                        "  \n" +
                        "  component SysPLL_c5g is\n" +
                        "  port (\n" +
                        "    refclk   : in  std_logic := 'X'; -- clk\n" +
                        "    rst      : in  std_logic := 'X'; -- reset\n" +
                        "    outclk_0 : out std_logic;        -- clk\n" +
                        "	 outclk_1 : out std_logic;        -- outclk1.clk\n" +
                        "    locked   : out std_logic         -- export\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "   xv6 : if tech = virtex6 generate\n" +
                        "     pll0 : SysPLL_v6 port map (i_clk_tcxo, o_clk_bus, i_reset, o_locked);\n" +
                        "   end generate;\n" +
                        "\n" +
                        "   xv7 : if tech = kintex7 generate\n" +
                        "     pll0 : SysPLL_k7 port map (i_clk_tcxo, o_clk_bus, i_reset, o_locked);\n" +
                        "   end generate;\n" +
                        "\n" +
                        "   xz7 : if tech = zynq7000 generate\n" +
                        "     pll0 : SysPLL_zynq port map (i_clk_tcxo, o_clk_bus, i_reset, o_locked);\n" +
                        "   end generate;\n" +
                        "   \n" +
                        "   inf : if tech = inferred generate\n" +
                        "     pll0 : SysPLL_inferred port map (i_clk_tcxo, o_clk_bus, i_reset, o_locked);\n" +
                        "   end generate;\n" +
                        "   \n" +
                        "   m180 : if tech = mikron180 generate\n" +
                        "     pll0 : SysPLL_micron180 port map (i_clk_tcxo, o_clk_bus, i_reset, o_locked);\n" +
                        "   end generate;\n" +
                        "	\n" +
                        "	c5g : if tech = cyclonevc5g generate\n" +
                        "     pll0 : SysPLL_c5g port map (i_clk_tcxo, i_reset, o_clk_bus, o_clk_pwm, o_locked);\n" +
                        "   end generate;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_types_pll_vhd_file(String Project_Folder_File) {
        String data =   "-----------------------------------------------------------------------------\n" +
                        "--! @file\n" +
                        "--! @copyright Copyright 2015 GNSS Sensor Ltd. All right reserved.\n" +
                        "--! @author    Sergey Khabarov - sergeykhbr@gmail.com\n" +
                        "--! @brief     Components declaration of the types_pll package.\n" +
                        "------------------------------------------------------------------------------\n" +
                        "\n" +
                        "--! Standard library\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.numeric_std.all;\n" +
                        "--! Target names declaration\n" +
                        "library techmap;\n" +
                        "use techmap.gencomp.all;\n" +
                        "\n" +
                        "--! @brief Declaration of 'virtual' PLL components\n" +
                        "package types_pll is\n" +
                        "\n" +
                        "  --! @brief   Declaration of the \"virtual\" PLL component.\n" +
                        "  --! @details This module instantiates the certain PLL implementation\n" +
                        "  --!          depending generic argument.\n" +
                        "  --! @param[in] tech Generic PLL implementation selector\n" +
                        "  --! @param[in] i_reset Reset value. Active high.\n" +
                        "  --! @param[in] i_clk_tcxo Input clock from the external oscillator (default 200 MHz)\n" +
                        "  --! @param[out] o_clk_bus System Bus clock 100MHz/40MHz (Virtex6/Spartan6)\n" +
                        "  --! @param[out] o_locked PLL locked status.\n" +
                        "  component SysPLL_tech is\n" +
                        "    generic(\n" +
                        "      tech    : integer range 0 to NTECH := 0\n" +
                        "    );\n" +
                        "    port (\n" +
                        "    i_reset           : in     std_logic;\n" +
                        "    i_clk_tcxo        : in     std_logic;\n" +
                        "    o_clk_bus         : out    std_logic;\n" +
                        "    o_clk_pwm         : out    std_logic;\n" +
                        "    o_locked          : out    std_logic );\n" +
                        "  end component;\n" +
                        "\n" +
                        "\n" +
                        "  --! @}\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_SysPLL_c5g_qip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -entity \"SysPLL_c5g\" -library \"SysPLL_c5g\" -name IP_TOOL_NAME \"altera_pll\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g\" -library \"SysPLL_c5g\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g\" -library \"SysPLL_c5g\" -name IP_TOOL_ENV \"mwpim\"\n" +
                        "set_global_assignment -library \"SysPLL_c5g\" -name MISC_FILE [file join $::quartus(qip_path) \"SysPLL_c5g.cmp\"]\n" +
                        "set_global_assignment -entity \"SysPLL_c5g\" -library \"SysPLL_c5g\" -name IP_TARGETED_DEVICE_FAMILY \"Cyclone V\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g\" -library \"SysPLL_c5g\" -name IP_GENERATED_DEVICE_FAMILY \"{Cyclone V}\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g\" -library \"SysPLL_c5g\" -name IP_QSYS_MODE \"UNKNOWN\"\n" +
                        "set_global_assignment -name SYNTHESIS_ONLY_QIP ON\n" +
                        "set_global_assignment -entity \"SysPLL_c5g\" -library \"SysPLL_c5g\" -name IP_COMPONENT_NAME \"U3lzUExMX2M1Zw==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g\" -library \"SysPLL_c5g\" -name IP_COMPONENT_DISPLAY_NAME \"UExMIEludGVsIEZQR0EgSVA=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g\" -library \"SysPLL_c5g\" -name IP_COMPONENT_REPORT_HIERARCHY \"Off\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g\" -library \"SysPLL_c5g\" -name IP_COMPONENT_INTERNAL \"Off\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g\" -library \"SysPLL_c5g\" -name IP_COMPONENT_AUTHOR \"SW50ZWwgQ29ycG9yYXRpb24=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g\" -library \"SysPLL_c5g\" -name IP_COMPONENT_VERSION \"MTguMA==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g\" -library \"SysPLL_c5g\" -name IP_COMPONENT_DESCRIPTION \"SW50ZWwgUGhhc2UtTG9ja2VkIExvb3A=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_NAME \"U3lzUExMX2M1Z18wMDAy\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_DISPLAY_NAME \"UExMIEludGVsIEZQR0EgSVA=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_REPORT_HIERARCHY \"Off\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_INTERNAL \"Off\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_AUTHOR \"SW50ZWwgQ29ycG9yYXRpb24=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_VERSION \"MTguMA==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_DESCRIPTION \"SW50ZWwgUGhhc2UtTG9ja2VkIExvb3A=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"ZGVidWdfcHJpbnRfb3V0cHV0::ZmFsc2U=::ZGVidWdfcHJpbnRfb3V0cHV0\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"ZGVidWdfdXNlX3JiY190YWZfbWV0aG9k::ZmFsc2U=::ZGVidWdfdXNlX3JiY190YWZfbWV0aG9k\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"ZGV2aWNl::NUNFQkEyRjE3QTc=::ZGV2aWNl\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BsbF9tb2Rl::SW50ZWdlci1OIFBMTA==::UExMIE1vZGU=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"ZnJhY3Rpb25hbF92Y29fbXVsdGlwbGllcg==::ZmFsc2U=::ZnJhY3Rpb25hbF92Y29fbXVsdGlwbGllcg==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3JlZmVyZW5jZV9jbG9ja19mcmVxdWVuY3k=::MTI1LjA=::UmVmZXJlbmNlIENsb2NrIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"cmVmZXJlbmNlX2Nsb2NrX2ZyZXF1ZW5jeQ==::MTI1LjAgTUh6::cmVmZXJlbmNlX2Nsb2NrX2ZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2NoYW5uZWxfc3BhY2luZw==::MC4w::Q2hhbm5lbCBTcGFjaW5n\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX29wZXJhdGlvbl9tb2Rl::ZGlyZWN0::T3BlcmF0aW9uIE1vZGU=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2ZlZWRiYWNrX2Nsb2Nr::R2xvYmFsIENsb2Nr::RmVlZGJhY2sgQ2xvY2s=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2ZyYWN0aW9uYWxfY291dA==::MzI=::RnJhY3Rpb25hbCBjYXJyeSBvdXQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RzbV9vdXRfc2Vs::MXN0X29yZGVy::RFNNIE9yZGVy\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"b3BlcmF0aW9uX21vZGU=::ZGlyZWN0::b3BlcmF0aW9uX21vZGU=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3VzZV9sb2NrZWQ=::dHJ1ZQ==::RW5hYmxlIGxvY2tlZCBvdXRwdXQgcG9ydA==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2VuX2Fkdl9wYXJhbXM=::ZmFsc2U=::RW5hYmxlIHBoeXNpY2FsIG91dHB1dCBjbG9jayBwYXJhbWV0ZXJz\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX251bWJlcl9vZl9jbG9ja3M=::Mg==::TnVtYmVyIE9mIENsb2Nrcw==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"bnVtYmVyX29mX2Nsb2Nrcw==::Mg==::bnVtYmVyX29mX2Nsb2Nrcw==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX211bHRpcGx5X2ZhY3Rvcg==::MQ==::TXVsdGlwbHkgRmFjdG9yIChNLUNvdW50ZXIp\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2ZyYWNfbXVsdGlwbHlfZmFjdG9y::MQ==::RnJhY3Rpb25hbCBNdWx0aXBseSBGYWN0b3IgKEsp\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3Jfbg==::MQ==::RGl2aWRlIEZhY3RvciAoTi1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjA=::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3kw::NjUuMA==::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzA=::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3Iw::MTM=::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3RvcjA=::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yMA==::MjU=::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5MA==::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzMA==::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0MA==::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzA=::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDA=::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGUw::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjE=::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3kx::MS4w::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzE=::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3Ix::MTM=::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3RvcjE=::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yMQ==::MTYyNQ==::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5MQ==::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzMQ==::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0MQ==::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzE=::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDE=::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGUx::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjI=::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3ky::MTAwLjA=::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzI=::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3Iy::MQ==::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3RvcjI=::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yMg==::MQ==::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5Mg==::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzMg==::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0Mg==::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzI=::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDI=::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGUy::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjM=::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3kz::MTAwLjA=::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzM=::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3Iz::MQ==::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3RvcjM=::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yMw==::MQ==::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5Mw==::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzMw==::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0Mw==::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzM=::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDM=::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGUz::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjQ=::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3k0::MTAwLjA=::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzQ=::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3I0::MQ==::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3RvcjQ=::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yNA==::MQ==::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5NA==::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzNA==::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0NA==::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzQ=::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDQ=::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGU0::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjU=::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3k1::MTAwLjA=::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzU=::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3I1::MQ==::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3RvcjU=::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yNQ==::MQ==::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5NQ==::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzNQ==::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0NQ==::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzU=::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDU=::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGU1::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjY=::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3k2::MTAwLjA=::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzY=::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3I2::MQ==::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3RvcjY=::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yNg==::MQ==::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5Ng==::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzNg==::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0Ng==::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzY=::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDY=::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGU2::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjc=::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3k3::MTAwLjA=::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzc=::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3I3::MQ==::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3Rvcjc=::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yNw==::MQ==::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5Nw==::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzNw==::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0Nw==::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzc=::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDc=::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGU3::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjg=::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3k4::MTAwLjA=::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzg=::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3I4::MQ==::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3Rvcjg=::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yOA==::MQ==::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5OA==::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzOA==::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0OA==::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzg=::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDg=::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGU4::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjk=::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3k5::MTAwLjA=::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzk=::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3I5::MQ==::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3Rvcjk=::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yOQ==::MQ==::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5OQ==::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzOQ==::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0OQ==::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzk=::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDk=::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGU5::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjEw::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3kxMA==::MTAwLjA=::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzEw::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3IxMA==::MQ==::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3RvcjEw::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yMTA=::MQ==::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5MTA=::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzMTA=::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0MTA=::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzEw::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDEw::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGUxMA==::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjEx::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3kxMQ==::MTAwLjA=::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzEx::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3IxMQ==::MQ==::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3RvcjEx::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yMTE=::MQ==::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5MTE=::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzMTE=::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0MTE=::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzEx::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDEx::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGUxMQ==::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjEy::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3kxMg==::MTAwLjA=::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzEy::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3IxMg==::MQ==::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3RvcjEy::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yMTI=::MQ==::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5MTI=::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzMTI=::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0MTI=::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzEy::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDEy::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGUxMg==::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjEz::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3kxMw==::MTAwLjA=::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzEz::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3IxMw==::MQ==::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3RvcjEz::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yMTM=::MQ==::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5MTM=::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzMTM=::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0MTM=::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzEz::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDEz::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGUxMw==::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjE0::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3kxNA==::MTAwLjA=::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzE0::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3IxNA==::MQ==::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3RvcjE0::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yMTQ=::MQ==::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5MTQ=::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzMTQ=::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0MTQ=::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzE0::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDE0::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGUxNA==::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjE1::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3kxNQ==::MTAwLjA=::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzE1::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3IxNQ==::MQ==::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3RvcjE1::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yMTU=::MQ==::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5MTU=::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzMTU=::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0MTU=::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzE1::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDE1::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGUxNQ==::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjE2::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3kxNg==::MTAwLjA=::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzE2::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3IxNg==::MQ==::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3RvcjE2::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yMTY=::MQ==::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5MTY=::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzMTY=::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0MTY=::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzE2::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDE2::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGUxNg==::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Nhc2NhZGVfY291bnRlcjE3::ZmFsc2U=::TWFrZSB0aGlzIGEgY2FzY2FkZSBjb3VudGVy\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX291dHB1dF9jbG9ja19mcmVxdWVuY3kxNw==::MTAwLjA=::RGVzaXJlZCBGcmVxdWVuY3k=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2RpdmlkZV9mYWN0b3JfYzE3::MQ==::RGl2aWRlIEZhY3RvciAoQy1Db3VudGVyKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9tdWx0aXBseV9mYWN0b3IxNw==::MQ==::QWN0dWFsIE11bHRpcGx5IEZhY3Rvcg==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9mcmFjX211bHRpcGx5X2ZhY3RvcjE3::MQ==::QWN0dWFsIEZyYWN0aW9uYWwgTXVsdGlwbHkgRmFjdG9yIChLKQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9kaXZpZGVfZmFjdG9yMTc=::MQ==::QWN0dWFsIERpdmlkZSBGYWN0b3I=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9vdXRwdXRfY2xvY2tfZnJlcXVlbmN5MTc=::MCBNSHo=::QWN0dWFsIEZyZXF1ZW5jeQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BzX3VuaXRzMTc=::cHM=::UGhhc2UgU2hpZnQgdW5pdHM=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0MTc=::MA==::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BoYXNlX3NoaWZ0X2RlZzE3::MC4w::UGhhc2UgU2hpZnQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2FjdHVhbF9waGFzZV9zaGlmdDE3::MA==::QWN0dWFsIFBoYXNlIFNoaWZ0\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2R1dHlfY3ljbGUxNw==::NTA=::RHV0eSBDeWNsZQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTA=::NjUuMDAwMDAwIE1Ieg==::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTA=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQw::MCBwcw==::cGhhc2Vfc2hpZnQw\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTA=::NTA=::ZHV0eV9jeWNsZTA=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTE=::MS4wMDAwMDAgTUh6::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTE=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQx::MCBwcw==::cGhhc2Vfc2hpZnQx\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTE=::NTA=::ZHV0eV9jeWNsZTE=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTI=::MCBNSHo=::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTI=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQy::MCBwcw==::cGhhc2Vfc2hpZnQy\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTI=::NTA=::ZHV0eV9jeWNsZTI=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTM=::MCBNSHo=::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTM=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQz::MCBwcw==::cGhhc2Vfc2hpZnQz\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTM=::NTA=::ZHV0eV9jeWNsZTM=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTQ=::MCBNSHo=::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQ0::MCBwcw==::cGhhc2Vfc2hpZnQ0\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTQ=::NTA=::ZHV0eV9jeWNsZTQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTU=::MCBNSHo=::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTU=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQ1::MCBwcw==::cGhhc2Vfc2hpZnQ1\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTU=::NTA=::ZHV0eV9jeWNsZTU=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTY=::MCBNSHo=::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTY=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQ2::MCBwcw==::cGhhc2Vfc2hpZnQ2\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTY=::NTA=::ZHV0eV9jeWNsZTY=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTc=::MCBNSHo=::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTc=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQ3::MCBwcw==::cGhhc2Vfc2hpZnQ3\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTc=::NTA=::ZHV0eV9jeWNsZTc=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTg=::MCBNSHo=::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTg=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQ4::MCBwcw==::cGhhc2Vfc2hpZnQ4\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTg=::NTA=::ZHV0eV9jeWNsZTg=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTk=::MCBNSHo=::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTk=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQ5::MCBwcw==::cGhhc2Vfc2hpZnQ5\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTk=::NTA=::ZHV0eV9jeWNsZTk=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTEw::MCBNSHo=::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTEw\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQxMA==::MCBwcw==::cGhhc2Vfc2hpZnQxMA==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTEw::NTA=::ZHV0eV9jeWNsZTEw\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTEx::MCBNSHo=::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTEx\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQxMQ==::MCBwcw==::cGhhc2Vfc2hpZnQxMQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTEx::NTA=::ZHV0eV9jeWNsZTEx\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTEy::MCBNSHo=::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTEy\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQxMg==::MCBwcw==::cGhhc2Vfc2hpZnQxMg==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTEy::NTA=::ZHV0eV9jeWNsZTEy\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTEz::MCBNSHo=::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTEz\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQxMw==::MCBwcw==::cGhhc2Vfc2hpZnQxMw==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTEz::NTA=::ZHV0eV9jeWNsZTEz\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTE0::MCBNSHo=::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTE0\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQxNA==::MCBwcw==::cGhhc2Vfc2hpZnQxNA==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTE0::NTA=::ZHV0eV9jeWNsZTE0\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTE1::MCBNSHo=::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTE1\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQxNQ==::MCBwcw==::cGhhc2Vfc2hpZnQxNQ==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTE1::NTA=::ZHV0eV9jeWNsZTE1\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTE2::MCBNSHo=::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTE2\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQxNg==::MCBwcw==::cGhhc2Vfc2hpZnQxNg==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTE2::NTA=::ZHV0eV9jeWNsZTE2\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTE3::MCBNSHo=::b3V0cHV0X2Nsb2NrX2ZyZXF1ZW5jeTE3\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"cGhhc2Vfc2hpZnQxNw==::MCBwcw==::cGhhc2Vfc2hpZnQxNw==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"ZHV0eV9jeWNsZTE3::NTA=::ZHV0eV9jeWNsZTE3\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BsbF9hdXRvX3Jlc2V0::T2Zm::UExMIEF1dG8gUmVzZXQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BsbF9iYW5kd2lkdGhfcHJlc2V0::QXV0bw==::UExMIEJhbmR3aWR0aCBQcmVzZXQ=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2VuX3JlY29uZg==::ZmFsc2U=::RW5hYmxlIGR5bmFtaWMgcmVjb25maWd1cmF0aW9uIG9mIFBMTA==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2VuX2Rwc19wb3J0cw==::ZmFsc2U=::RW5hYmxlIGFjY2VzcyB0byBkeW5hbWljIHBoYXNlIHNoaWZ0IHBvcnRz\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2VuX3Bob3V0X3BvcnRz::ZmFsc2U=::RW5hYmxlIGFjY2VzcyB0byBQTEwgRFBBIG91dHB1dCBwb3J0\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"cGxsX3R5cGU=::R2VuZXJhbA==::UExMIFRZUEU=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"cGxsX3N1YnR5cGU=::R2VuZXJhbA==::UExMIFNVQlRZUEU=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BhcmFtZXRlcl9saXN0::TS1Db3VudGVyIEhpIERpdmlkZSxNLUNvdW50ZXIgTG93IERpdmlkZSxOLUNvdW50ZXIgSGkgRGl2aWRlLE4tQ291bnRlciBMb3cgRGl2aWRlLE0tQ291bnRlciBCeXBhc3MgRW5hYmxlLE4tQ291bnRlciBCeXBhc3MgRW5hYmxlLE0tQ291bnRlciBPZGQgRGl2aWRlIEVuYWJsZSxOLUNvdW50ZXIgT2RkIERpdmlkZSBFbmFibGUsQy1Db3VudGVyLTAgSGkgRGl2aWRlLEMtQ291bnRlci0wIExvdyBEaXZpZGUsQy1Db3VudGVyLTAgQ29hcnNlIFBoYXNlIFNoaWZ0LEMtQ291bnRlci0wIFZDTyBQaGFzZSBUYXAsQy1Db3VudGVyLTAgSW5wdXQgU291cmNlLEMtQ291bnRlci0wIEJ5cGFzcyBFbmFibGUsQy1Db3VudGVyLTAgT2RkIERpdmlkZSBFbmFibGUsQy1Db3VudGVyLTEgSGkgRGl2aWRlLEMtQ291bnRlci0xIExvdyBEaXZpZGUsQy1Db3VudGVyLTEgQ29hcnNlIFBoYXNlIFNoaWZ0LEMtQ291bnRlci0xIFZDTyBQaGFzZSBUYXAsQy1Db3VudGVyLTEgSW5wdXQgU291cmNlLEMtQ291bnRlci0xIEJ5cGFzcyBFbmFibGUsQy1Db3VudGVyLTEgT2RkIERpdmlkZSBFbmFibGUsVkNPIFBvc3QgRGl2aWRlIENvdW50ZXIgRW5hYmxlLENoYXJnZSBQdW1wIGN1cnJlbnQgKHVBKSxMb29wIEZpbHRlciBCYW5kd2lkdGggUmVzaXN0b3IgKE9obXMpICxQTEwgT3V0cHV0IFZDTyBGcmVxdWVuY3ksSy1GcmFjdGlvbmFsIERpdmlzaW9uIFZhbHVlIChEU00pLEZlZWRiYWNrIENsb2NrIFR5cGUsRmVlZGJhY2sgQ2xvY2sgTVVYIDEsRmVlZGJhY2sgQ2xvY2sgTVVYIDIsTSBDb3VudGVyIFNvdXJjZSBNVVgsUExMIEF1dG8gUmVzZXQ=::UGFyYW1ldGVyIE5hbWVz\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3BhcmFtZXRlcl92YWx1ZXM=::Nyw2LDMsMixmYWxzZSxmYWxzZSx0cnVlLHRydWUsMywyLDEsMCxwaF9tdXhfY2xrLGZhbHNlLHRydWUsMTYzLDE2MiwxLDAscGhfbXV4X2NsayxmYWxzZSx0cnVlLDIsMjAsNDAwMCwzMjUuMCBNSHosMSxub25lLGdsYixtX2NudCxwaF9tdXhfY2xrLGZhbHNl::UGFyYW1ldGVyIFZhbHVlcw==\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX21pZl9nZW5lcmF0ZQ==::ZmFsc2U=::R2VuZXJhdGUgTUlGIGZpbGU=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2VuYWJsZV9taWZfZHBz::ZmFsc2U=::RW5hYmxlIER5bmFtaWMgUGhhc2UgU2hpZnQgZm9yIE1JRiBzdHJlYW1pbmc=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Rwc19jbnRy::QzA=::RFBTIENvdW50ZXIgU2VsZWN0aW9u\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Rwc19udW0=::MQ==::TnVtYmVyIG9mIER5bmFtaWMgUGhhc2UgU2hpZnRz\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2Rwc19kaXI=::UG9zaXRpdmU=::RHluYW1pYyBQaGFzZSBTaGlmdCBEaXJlY3Rpb24=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX3JlZmNsa19zd2l0Y2g=::ZmFsc2U=::Q3JlYXRlIGEgc2Vjb25kIGlucHV0IGNsayAncmVmY2xrMSc=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2VuYWJsZV9jYXNjYWRlX291dA==::ZmFsc2U=::Q3JlYXRlIGEgJ2Nhc2NhZGVfb3V0JyBzaWduYWwgdG8gY29ubmVjdCB3aXRoIGEgZG93bnN0cmVhbSBQTEw=\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_COMPONENT_PARAMETER \"Z3VpX2VuYWJsZV9jYXNjYWRlX2lu::ZmFsc2U=::Q3JlYXRlIGFuIGFkanBsbGluIG9yIGNjbGsgc2lnbmFsIHRvIGNvbm5lY3Qgd2l0aCBhbiB1cHN0cmVhbSBQTEw=\"\n" +
                        "\n" +
                        "set_global_assignment -library \"SysPLL_c5g\" -name VHDL_FILE [file join $::quartus(qip_path) \"SysPLL_c5g.vhd\"]\n" +
                        "set_global_assignment -library \"SysPLL_c5g\" -name VERILOG_FILE [file join $::quartus(qip_path) \"SysPLL_c5g/SysPLL_c5g_0002.v\"]\n" +
                        "set_global_assignment -library \"SysPLL_c5g\" -name QIP_FILE [file join $::quartus(qip_path) \"SysPLL_c5g/SysPLL_c5g_0002.qip\"]\n" +
                        "\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_TOOL_NAME \"altera_pll\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g_0002\" -library \"SysPLL_c5g\" -name IP_TOOL_ENV \"mwpim\"";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_SysPLL_c5g_sip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -entity \"SysPLL_c5g\" -library \"lib_SysPLL_c5g\" -name IP_TOOL_NAME \"altera_pll\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g\" -library \"lib_SysPLL_c5g\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"SysPLL_c5g\" -library \"lib_SysPLL_c5g\" -name IP_TOOL_ENV \"mwpim\"\n" +
                        "set_global_assignment -library \"lib_SysPLL_c5g\" -name SPD_FILE [file join $::quartus(sip_path) \"SysPLL_c5g.spd\"]\n" +
                        "\n" +
                        "set_global_assignment -library \"lib_SysPLL_c5g\" -name MISC_FILE [file join $::quartus(sip_path) \"SysPLL_c5g_sim/SysPLL_c5g.vho\"]";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_SysPLL_c5g_spd_file(String Project_Folder_File) {
        String data =   "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" +
                        "<simPackage>\n" +
                        " <file path=\"SysPLL_c5g_sim/SysPLL_c5g.vho\" type=\"VHDL\" />\n" +
                        " <topLevel name=\"SysPLL_c5g\" />\n" +
                        " <deviceFamily name=\"cyclonev\" />\n" +
                        "</simPackage>";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_SysPLL_c5g_vhd_file(String Project_Folder_File) {
        String data =   "-- megafunction wizard: %PLL Intel FPGA IP v18.0%\n" +
                        "-- GENERATION: XML\n" +
                        "-- SysPLL_c5g.vhd\n" +
                        "\n" +
                        "-- Generated using ACDS version 18.0 614\n" +
                        "\n" +
                        "library IEEE;\n" +
                        "use IEEE.std_logic_1164.all;\n" +
                        "use IEEE.numeric_std.all;\n" +
                        "\n" +
                        "entity SysPLL_c5g is\n" +
                        "	port (\n" +
                        "		refclk   : in  std_logic := '0'; --  refclk.clk\n" +
                        "		rst      : in  std_logic := '0'; --   reset.reset\n" +
                        "		outclk_0 : out std_logic;        -- outclk0.clk\n" +
                        "		outclk_1 : out std_logic;        -- outclk1.clk\n" +
                        "		locked   : out std_logic         --  locked.export\n" +
                        "	);\n" +
                        "end entity SysPLL_c5g;\n" +
                        "\n" +
                        "architecture rtl of SysPLL_c5g is\n" +
                        "	component SysPLL_c5g_0002 is\n" +
                        "		port (\n" +
                        "			refclk   : in  std_logic := 'X'; -- clk\n" +
                        "			rst      : in  std_logic := 'X'; -- reset\n" +
                        "			outclk_0 : out std_logic;        -- clk\n" +
                        "			outclk_1 : out std_logic;        -- clk\n" +
                        "			locked   : out std_logic         -- export\n" +
                        "		);\n" +
                        "	end component SysPLL_c5g_0002;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "	syspll_c5g_inst : component SysPLL_c5g_0002\n" +
                        "		port map (\n" +
                        "			refclk   => refclk,   --  refclk.clk\n" +
                        "			rst      => rst,      --   reset.reset\n" +
                        "			outclk_0 => outclk_0, -- outclk0.clk\n" +
                        "			outclk_1 => outclk_1, -- outclk1.clk\n" +
                        "			locked   => locked    --  locked.export\n" +
                        "		);\n" +
                        "\n" +
                        "end architecture rtl; -- of SysPLL_c5g\n" +
                        "-- Retrieval info: <?xml version=\"1.0\"?>\n" +
                        "--<!--\n" +
                        "--	Generated by Altera MegaWizard Launcher Utility version 1.0\n" +
                        "--	************************************************************\n" +
                        "--	THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!\n" +
                        "--	************************************************************\n" +
                        "--	Copyright (C) 1991-2020 Altera Corporation\n" +
                        "--	Any megafunction design, and related net list (encrypted or decrypted),\n" +
                        "--	support information, device programming or simulation file, and any other\n" +
                        "--	associated documentation or information provided by Altera or a partner\n" +
                        "--	under Altera's Megafunction Partnership Program may be used only to\n" +
                        "--	program PLD devices (but not masked PLD devices) from Altera.  Any other\n" +
                        "--	use of such megafunction design, net list, support information, device\n" +
                        "--	programming or simulation file, or any other related documentation or\n" +
                        "--	information is prohibited for any other purpose, including, but not\n" +
                        "--	limited to modification, reverse engineering, de-compiling, or use with\n" +
                        "--	any other silicon devices, unless such use is explicitly licensed under\n" +
                        "--	a separate agreement with Altera or a megafunction partner.  Title to\n" +
                        "--	the intellectual property, including patents, copyrights, trademarks,\n" +
                        "--	trade secrets, or maskworks, embodied in any such megafunction design,\n" +
                        "--	net list, support information, device programming or simulation file, or\n" +
                        "--	any other related documentation or information provided by Altera or a\n" +
                        "--	megafunction partner, remains with Altera, the megafunction partner, or\n" +
                        "--	their respective licensors.  No other licenses, including any licenses\n" +
                        "--	needed under any third party's intellectual property, are provided herein.\n" +
                        "---->\n" +
                        "-- Retrieval info: <instance entity-name=\"altera_pll\" version=\"18.0\" >\n" +
                        "-- Retrieval info: 	<generic name=\"debug_print_output\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"debug_use_rbc_taf_method\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"device_family\" value=\"Cyclone V\" />\n" +
                        "-- Retrieval info: 	<generic name=\"device\" value=\"5CEBA2F17A7\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_device_speed_grade\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_pll_mode\" value=\"Integer-N PLL\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_reference_clock_frequency\" value=\"125.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_channel_spacing\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_operation_mode\" value=\"direct\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_feedback_clock\" value=\"Global Clock\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_fractional_cout\" value=\"32\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_dsm_out_sel\" value=\"1st_order\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_use_locked\" value=\"true\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_en_adv_params\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_number_of_clocks\" value=\"2\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_multiply_factor\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_frac_multiply_factor\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_n\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter0\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency0\" value=\"65.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c0\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency0\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units0\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift0\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg0\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift0\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle0\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter1\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency1\" value=\"1.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c1\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency1\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units1\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift1\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg1\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift1\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle1\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter2\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency2\" value=\"100.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c2\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency2\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units2\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift2\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg2\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift2\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle2\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter3\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency3\" value=\"100.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c3\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency3\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units3\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift3\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg3\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift3\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle3\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter4\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency4\" value=\"100.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c4\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency4\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units4\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift4\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg4\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift4\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle4\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter5\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency5\" value=\"100.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c5\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency5\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units5\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift5\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg5\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift5\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle5\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter6\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency6\" value=\"100.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c6\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency6\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units6\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift6\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg6\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift6\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle6\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter7\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency7\" value=\"100.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c7\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency7\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units7\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift7\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg7\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift7\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle7\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter8\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency8\" value=\"100.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c8\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency8\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units8\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift8\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg8\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift8\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle8\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter9\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency9\" value=\"100.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c9\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency9\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units9\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift9\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg9\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift9\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle9\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter10\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency10\" value=\"100.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c10\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency10\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units10\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift10\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg10\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift10\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle10\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter11\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency11\" value=\"100.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c11\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency11\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units11\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift11\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg11\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift11\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle11\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter12\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency12\" value=\"100.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c12\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency12\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units12\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift12\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg12\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift12\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle12\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter13\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency13\" value=\"100.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c13\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency13\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units13\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift13\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg13\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift13\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle13\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter14\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency14\" value=\"100.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c14\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency14\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units14\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift14\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg14\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift14\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle14\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter15\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency15\" value=\"100.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c15\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency15\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units15\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift15\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg15\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift15\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle15\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter16\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency16\" value=\"100.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c16\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency16\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units16\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift16\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg16\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift16\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle16\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_counter17\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_output_clock_frequency17\" value=\"100.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_divide_factor_c17\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_output_clock_frequency17\" value=\"0 MHz\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_ps_units17\" value=\"ps\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift17\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phase_shift_deg17\" value=\"0.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_actual_phase_shift17\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_duty_cycle17\" value=\"50\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_pll_auto_reset\" value=\"Off\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_pll_bandwidth_preset\" value=\"Auto\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_en_reconf\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_en_dps_ports\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_en_phout_ports\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_phout_division\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_mif_generate\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_enable_mif_dps\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_dps_cntr\" value=\"C0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_dps_num\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_dps_dir\" value=\"Positive\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_refclk_switch\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_refclk1_frequency\" value=\"100.0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_switchover_mode\" value=\"Automatic Switchover\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_switchover_delay\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_active_clk\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_clk_bad\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_enable_cascade_out\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_cascade_outclk_index\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_enable_cascade_in\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gui_pll_cascading_mode\" value=\"Create an adjpllin signal to connect with an upstream PLL\" />\n" +
                        "-- Retrieval info: </instance>\n" +
                        "-- IPFS_FILES : SysPLL_c5g.vho\n" +
                        "-- RELATED_FILES: SysPLL_c5g.vhd, SysPLL_c5g_0002.v";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_SysPLL_c5g_0002_qip_file(String Project_Folder_File) {
        String data =   "set_instance_assignment -name PLL_COMPENSATION_MODE DIRECT -to \"*SysPLL_c5g_0002*|altera_pll:altera_pll_i*|*\"\n" +
                        " \n" +
                        "set_instance_assignment -name PLL_AUTO_RESET OFF -to \"*SysPLL_c5g_0002*|altera_pll:altera_pll_i*|*\"\n" +
                        "set_instance_assignment -name PLL_BANDWIDTH_PRESET AUTO -to \"*SysPLL_c5g_0002*|altera_pll:altera_pll_i*|*\"";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_SysPLL_c5g_0002_v_file(String Project_Folder_File) {
        String data =   "`timescale 1ns/10ps\n" +
                        "module  SysPLL_c5g_0002(\n" +
                        "\n" +
                        "	// interface 'refclk'\n" +
                        "	input wire refclk,\n" +
                        "\n" +
                        "	// interface 'reset'\n" +
                        "	input wire rst,\n" +
                        "\n" +
                        "	// interface 'outclk0'\n" +
                        "	output wire outclk_0,\n" +
                        "\n" +
                        "	// interface 'outclk1'\n" +
                        "	output wire outclk_1,\n" +
                        "\n" +
                        "	// interface 'locked'\n" +
                        "	output wire locked\n" +
                        ");\n" +
                        "\n" +
                        "	altera_pll #(\n" +
                        "		.fractional_vco_multiplier(\"false\"),\n" +
                        "		.reference_clock_frequency(\"125.0 MHz\"),\n" +
                        "		.operation_mode(\"direct\"),\n" +
                        "		.number_of_clocks(2),\n" +
                        "		.output_clock_frequency0(\""+(Data.CPU_RV64_Freq/1000000)+" MHz\"),\n" +
                        "		.phase_shift0(\"0 ps\"),\n" +
                        "		.duty_cycle0(50),\n" +
                        "		.output_clock_frequency1(\""+(Data.PWM_RV64_HW_Freq/1000000)+" MHz\"),\n" +
                        "		.phase_shift1(\"0 ps\"),\n" +
                        "		.duty_cycle1(50),\n" +
                        "		.output_clock_frequency2(\"0 MHz\"),\n" +
                        "		.phase_shift2(\"0 ps\"),\n" +
                        "		.duty_cycle2(50),\n" +
                        "		.output_clock_frequency3(\"0 MHz\"),\n" +
                        "		.phase_shift3(\"0 ps\"),\n" +
                        "		.duty_cycle3(50),\n" +
                        "		.output_clock_frequency4(\"0 MHz\"),\n" +
                        "		.phase_shift4(\"0 ps\"),\n" +
                        "		.duty_cycle4(50),\n" +
                        "		.output_clock_frequency5(\"0 MHz\"),\n" +
                        "		.phase_shift5(\"0 ps\"),\n" +
                        "		.duty_cycle5(50),\n" +
                        "		.output_clock_frequency6(\"0 MHz\"),\n" +
                        "		.phase_shift6(\"0 ps\"),\n" +
                        "		.duty_cycle6(50),\n" +
                        "		.output_clock_frequency7(\"0 MHz\"),\n" +
                        "		.phase_shift7(\"0 ps\"),\n" +
                        "		.duty_cycle7(50),\n" +
                        "		.output_clock_frequency8(\"0 MHz\"),\n" +
                        "		.phase_shift8(\"0 ps\"),\n" +
                        "		.duty_cycle8(50),\n" +
                        "		.output_clock_frequency9(\"0 MHz\"),\n" +
                        "		.phase_shift9(\"0 ps\"),\n" +
                        "		.duty_cycle9(50),\n" +
                        "		.output_clock_frequency10(\"0 MHz\"),\n" +
                        "		.phase_shift10(\"0 ps\"),\n" +
                        "		.duty_cycle10(50),\n" +
                        "		.output_clock_frequency11(\"0 MHz\"),\n" +
                        "		.phase_shift11(\"0 ps\"),\n" +
                        "		.duty_cycle11(50),\n" +
                        "		.output_clock_frequency12(\"0 MHz\"),\n" +
                        "		.phase_shift12(\"0 ps\"),\n" +
                        "		.duty_cycle12(50),\n" +
                        "		.output_clock_frequency13(\"0 MHz\"),\n" +
                        "		.phase_shift13(\"0 ps\"),\n" +
                        "		.duty_cycle13(50),\n" +
                        "		.output_clock_frequency14(\"0 MHz\"),\n" +
                        "		.phase_shift14(\"0 ps\"),\n" +
                        "		.duty_cycle14(50),\n" +
                        "		.output_clock_frequency15(\"0 MHz\"),\n" +
                        "		.phase_shift15(\"0 ps\"),\n" +
                        "		.duty_cycle15(50),\n" +
                        "		.output_clock_frequency16(\"0 MHz\"),\n" +
                        "		.phase_shift16(\"0 ps\"),\n" +
                        "		.duty_cycle16(50),\n" +
                        "		.output_clock_frequency17(\"0 MHz\"),\n" +
                        "		.phase_shift17(\"0 ps\"),\n" +
                        "		.duty_cycle17(50),\n" +
                        "		.pll_type(\"General\"),\n" +
                        "		.pll_subtype(\"General\")\n" +
                        "	) altera_pll_i (\n" +
                        "		.rst	(rst),\n" +
                        "		.outclk	({outclk_1, outclk_0}),\n" +
                        "		.locked	(locked),\n" +
                        "		.fboutclk	( ),\n" +
                        "		.fbclk	(1'b0),\n" +
                        "		.refclk	(refclk)\n" +
                        "	);\n" +
                        "endmodule";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_SysPLL_c5g_vho_file(String Project_Folder_File) {
        String data =   "--IP Functional Simulation Model\n" +
                        "--VERSION_BEGIN 18.0 cbx_mgl 2018:04:18:07:37:08:SJ cbx_simgen 2018:04:18:06:50:44:SJ  VERSION_END\n" +
                        "\n" +
                        "\n" +
                        "-- Copyright (C) 2018  Intel Corporation. All rights reserved.\n" +
                        "-- Your use of Intel Corporation's design tools, logic functions \n" +
                        "-- and other software and tools, and its AMPP partner logic \n" +
                        "-- functions, and any output files from any of the foregoing \n" +
                        "-- (including device programming or simulation files), and any \n" +
                        "-- associated documentation or information are expressly subject \n" +
                        "-- to the terms and conditions of the Intel Program License \n" +
                        "-- Subscription Agreement, the Intel Quartus Prime License Agreement,\n" +
                        "-- the Intel FPGA IP License Agreement, or other applicable license\n" +
                        "-- agreement, including, without limitation, that your use is for\n" +
                        "-- the sole purpose of programming logic devices manufactured by\n" +
                        "-- Intel and sold by Intel or its authorized distributors.  Please\n" +
                        "-- refer to the applicable agreement for further details.\n" +
                        "\n" +
                        "-- You may only use these simulation model output files for simulation\n" +
                        "-- purposes and expressly not for synthesis or any other purposes (in which\n" +
                        "-- event Intel disclaims all warranties of any kind).\n" +
                        "\n" +
                        "\n" +
                        "--synopsys translate_off\n" +
                        "\n" +
                        " LIBRARY altera_lnsim;\n" +
                        " USE altera_lnsim.altera_lnsim_components.all;\n" +
                        "\n" +
                        "--synthesis_resources = altera_pll 1 \n" +
                        " LIBRARY ieee;\n" +
                        " USE ieee.std_logic_1164.all;\n" +
                        "\n" +
                        " ENTITY  SysPLL_c5g IS \n" +
                        "	 PORT \n" +
                        "	 ( \n" +
                        "		 locked	:	OUT  STD_LOGIC;\n" +
                        "		 outclk_0	:	OUT  STD_LOGIC;\n" +
                        "		 outclk_1	:	OUT  STD_LOGIC;\n" +
                        "		 refclk	:	IN  STD_LOGIC;\n" +
                        "		 rst	:	IN  STD_LOGIC\n" +
                        "	 ); \n" +
                        " END SysPLL_c5g;\n" +
                        "\n" +
                        " ARCHITECTURE RTL OF SysPLL_c5g IS\n" +
                        "\n" +
                        "	 ATTRIBUTE synthesis_clearbox : natural;\n" +
                        "	 ATTRIBUTE synthesis_clearbox OF RTL : ARCHITECTURE IS 1;\n" +
                        "	 SIGNAL  wire_gnd	:	STD_LOGIC;\n" +
                        "	 SIGNAL  wire_syspll_c5g_altera_pll_altera_pll_i_1098_locked	:	STD_LOGIC;\n" +
                        "	 SIGNAL  wire_syspll_c5g_altera_pll_altera_pll_i_1098_outclk	:	STD_LOGIC_VECTOR (1 DOWNTO 0);\n" +
                        " BEGIN\n" +
                        "\n" +
                        "	wire_gnd <= '0';\n" +
                        "	locked <= wire_syspll_c5g_altera_pll_altera_pll_i_1098_locked;\n" +
                        "	outclk_0 <= wire_syspll_c5g_altera_pll_altera_pll_i_1098_outclk(0);\n" +
                        "	outclk_1 <= wire_syspll_c5g_altera_pll_altera_pll_i_1098_outclk(1);\n" +
                        "	syspll_c5g_altera_pll_altera_pll_i_1098 :  altera_pll\n" +
                        "	  GENERIC MAP (\n" +
                        "		c_cnt_bypass_en0 => \"false\",\n" +
                        "		c_cnt_bypass_en1 => \"false\",\n" +
                        "		c_cnt_bypass_en10 => \"false\",\n" +
                        "		c_cnt_bypass_en11 => \"false\",\n" +
                        "		c_cnt_bypass_en12 => \"false\",\n" +
                        "		c_cnt_bypass_en13 => \"false\",\n" +
                        "		c_cnt_bypass_en14 => \"false\",\n" +
                        "		c_cnt_bypass_en15 => \"false\",\n" +
                        "		c_cnt_bypass_en16 => \"false\",\n" +
                        "		c_cnt_bypass_en17 => \"false\",\n" +
                        "		c_cnt_bypass_en2 => \"false\",\n" +
                        "		c_cnt_bypass_en3 => \"false\",\n" +
                        "		c_cnt_bypass_en4 => \"false\",\n" +
                        "		c_cnt_bypass_en5 => \"false\",\n" +
                        "		c_cnt_bypass_en6 => \"false\",\n" +
                        "		c_cnt_bypass_en7 => \"false\",\n" +
                        "		c_cnt_bypass_en8 => \"false\",\n" +
                        "		c_cnt_bypass_en9 => \"false\",\n" +
                        "		c_cnt_hi_div0 => 1,\n" +
                        "		c_cnt_hi_div1 => 1,\n" +
                        "		c_cnt_hi_div10 => 1,\n" +
                        "		c_cnt_hi_div11 => 1,\n" +
                        "		c_cnt_hi_div12 => 1,\n" +
                        "		c_cnt_hi_div13 => 1,\n" +
                        "		c_cnt_hi_div14 => 1,\n" +
                        "		c_cnt_hi_div15 => 1,\n" +
                        "		c_cnt_hi_div16 => 1,\n" +
                        "		c_cnt_hi_div17 => 1,\n" +
                        "		c_cnt_hi_div2 => 1,\n" +
                        "		c_cnt_hi_div3 => 1,\n" +
                        "		c_cnt_hi_div4 => 1,\n" +
                        "		c_cnt_hi_div5 => 1,\n" +
                        "		c_cnt_hi_div6 => 1,\n" +
                        "		c_cnt_hi_div7 => 1,\n" +
                        "		c_cnt_hi_div8 => 1,\n" +
                        "		c_cnt_hi_div9 => 1,\n" +
                        "		c_cnt_in_src0 => \"ph_mux_clk\",\n" +
                        "		c_cnt_in_src1 => \"ph_mux_clk\",\n" +
                        "		c_cnt_in_src10 => \"ph_mux_clk\",\n" +
                        "		c_cnt_in_src11 => \"ph_mux_clk\",\n" +
                        "		c_cnt_in_src12 => \"ph_mux_clk\",\n" +
                        "		c_cnt_in_src13 => \"ph_mux_clk\",\n" +
                        "		c_cnt_in_src14 => \"ph_mux_clk\",\n" +
                        "		c_cnt_in_src15 => \"ph_mux_clk\",\n" +
                        "		c_cnt_in_src16 => \"ph_mux_clk\",\n" +
                        "		c_cnt_in_src17 => \"ph_mux_clk\",\n" +
                        "		c_cnt_in_src2 => \"ph_mux_clk\",\n" +
                        "		c_cnt_in_src3 => \"ph_mux_clk\",\n" +
                        "		c_cnt_in_src4 => \"ph_mux_clk\",\n" +
                        "		c_cnt_in_src5 => \"ph_mux_clk\",\n" +
                        "		c_cnt_in_src6 => \"ph_mux_clk\",\n" +
                        "		c_cnt_in_src7 => \"ph_mux_clk\",\n" +
                        "		c_cnt_in_src8 => \"ph_mux_clk\",\n" +
                        "		c_cnt_in_src9 => \"ph_mux_clk\",\n" +
                        "		c_cnt_lo_div0 => 1,\n" +
                        "		c_cnt_lo_div1 => 1,\n" +
                        "		c_cnt_lo_div10 => 1,\n" +
                        "		c_cnt_lo_div11 => 1,\n" +
                        "		c_cnt_lo_div12 => 1,\n" +
                        "		c_cnt_lo_div13 => 1,\n" +
                        "		c_cnt_lo_div14 => 1,\n" +
                        "		c_cnt_lo_div15 => 1,\n" +
                        "		c_cnt_lo_div16 => 1,\n" +
                        "		c_cnt_lo_div17 => 1,\n" +
                        "		c_cnt_lo_div2 => 1,\n" +
                        "		c_cnt_lo_div3 => 1,\n" +
                        "		c_cnt_lo_div4 => 1,\n" +
                        "		c_cnt_lo_div5 => 1,\n" +
                        "		c_cnt_lo_div6 => 1,\n" +
                        "		c_cnt_lo_div7 => 1,\n" +
                        "		c_cnt_lo_div8 => 1,\n" +
                        "		c_cnt_lo_div9 => 1,\n" +
                        "		c_cnt_odd_div_duty_en0 => \"false\",\n" +
                        "		c_cnt_odd_div_duty_en1 => \"false\",\n" +
                        "		c_cnt_odd_div_duty_en10 => \"false\",\n" +
                        "		c_cnt_odd_div_duty_en11 => \"false\",\n" +
                        "		c_cnt_odd_div_duty_en12 => \"false\",\n" +
                        "		c_cnt_odd_div_duty_en13 => \"false\",\n" +
                        "		c_cnt_odd_div_duty_en14 => \"false\",\n" +
                        "		c_cnt_odd_div_duty_en15 => \"false\",\n" +
                        "		c_cnt_odd_div_duty_en16 => \"false\",\n" +
                        "		c_cnt_odd_div_duty_en17 => \"false\",\n" +
                        "		c_cnt_odd_div_duty_en2 => \"false\",\n" +
                        "		c_cnt_odd_div_duty_en3 => \"false\",\n" +
                        "		c_cnt_odd_div_duty_en4 => \"false\",\n" +
                        "		c_cnt_odd_div_duty_en5 => \"false\",\n" +
                        "		c_cnt_odd_div_duty_en6 => \"false\",\n" +
                        "		c_cnt_odd_div_duty_en7 => \"false\",\n" +
                        "		c_cnt_odd_div_duty_en8 => \"false\",\n" +
                        "		c_cnt_odd_div_duty_en9 => \"false\",\n" +
                        "		c_cnt_ph_mux_prst0 => 0,\n" +
                        "		c_cnt_ph_mux_prst1 => 0,\n" +
                        "		c_cnt_ph_mux_prst10 => 0,\n" +
                        "		c_cnt_ph_mux_prst11 => 0,\n" +
                        "		c_cnt_ph_mux_prst12 => 0,\n" +
                        "		c_cnt_ph_mux_prst13 => 0,\n" +
                        "		c_cnt_ph_mux_prst14 => 0,\n" +
                        "		c_cnt_ph_mux_prst15 => 0,\n" +
                        "		c_cnt_ph_mux_prst16 => 0,\n" +
                        "		c_cnt_ph_mux_prst17 => 0,\n" +
                        "		c_cnt_ph_mux_prst2 => 0,\n" +
                        "		c_cnt_ph_mux_prst3 => 0,\n" +
                        "		c_cnt_ph_mux_prst4 => 0,\n" +
                        "		c_cnt_ph_mux_prst5 => 0,\n" +
                        "		c_cnt_ph_mux_prst6 => 0,\n" +
                        "		c_cnt_ph_mux_prst7 => 0,\n" +
                        "		c_cnt_ph_mux_prst8 => 0,\n" +
                        "		c_cnt_ph_mux_prst9 => 0,\n" +
                        "		c_cnt_prst0 => 1,\n" +
                        "		c_cnt_prst1 => 1,\n" +
                        "		c_cnt_prst10 => 1,\n" +
                        "		c_cnt_prst11 => 1,\n" +
                        "		c_cnt_prst12 => 1,\n" +
                        "		c_cnt_prst13 => 1,\n" +
                        "		c_cnt_prst14 => 1,\n" +
                        "		c_cnt_prst15 => 1,\n" +
                        "		c_cnt_prst16 => 1,\n" +
                        "		c_cnt_prst17 => 1,\n" +
                        "		c_cnt_prst2 => 1,\n" +
                        "		c_cnt_prst3 => 1,\n" +
                        "		c_cnt_prst4 => 1,\n" +
                        "		c_cnt_prst5 => 1,\n" +
                        "		c_cnt_prst6 => 1,\n" +
                        "		c_cnt_prst7 => 1,\n" +
                        "		c_cnt_prst8 => 1,\n" +
                        "		c_cnt_prst9 => 1,\n" +
                        "		clock_name_0 => \"UNUSED\",\n" +
                        "		clock_name_1 => \"UNUSED\",\n" +
                        "		clock_name_2 => \"UNUSED\",\n" +
                        "		clock_name_3 => \"UNUSED\",\n" +
                        "		clock_name_4 => \"UNUSED\",\n" +
                        "		clock_name_5 => \"UNUSED\",\n" +
                        "		clock_name_6 => \"UNUSED\",\n" +
                        "		clock_name_7 => \"UNUSED\",\n" +
                        "		clock_name_8 => \"UNUSED\",\n" +
                        "		clock_name_global_0 => \"false\",\n" +
                        "		clock_name_global_1 => \"false\",\n" +
                        "		clock_name_global_2 => \"false\",\n" +
                        "		clock_name_global_3 => \"false\",\n" +
                        "		clock_name_global_4 => \"false\",\n" +
                        "		clock_name_global_5 => \"false\",\n" +
                        "		clock_name_global_6 => \"false\",\n" +
                        "		clock_name_global_7 => \"false\",\n" +
                        "		clock_name_global_8 => \"false\",\n" +
                        "		data_rate => 0,\n" +
                        "		deserialization_factor => 4,\n" +
                        "		duty_cycle0 => 50,\n" +
                        "		duty_cycle1 => 50,\n" +
                        "		duty_cycle10 => 50,\n" +
                        "		duty_cycle11 => 50,\n" +
                        "		duty_cycle12 => 50,\n" +
                        "		duty_cycle13 => 50,\n" +
                        "		duty_cycle14 => 50,\n" +
                        "		duty_cycle15 => 50,\n" +
                        "		duty_cycle16 => 50,\n" +
                        "		duty_cycle17 => 50,\n" +
                        "		duty_cycle2 => 50,\n" +
                        "		duty_cycle3 => 50,\n" +
                        "		duty_cycle4 => 50,\n" +
                        "		duty_cycle5 => 50,\n" +
                        "		duty_cycle6 => 50,\n" +
                        "		duty_cycle7 => 50,\n" +
                        "		duty_cycle8 => 50,\n" +
                        "		duty_cycle9 => 50,\n" +
                        "		fractional_vco_multiplier => \"false\",\n" +
                        "		m_cnt_bypass_en => \"false\",\n" +
                        "		m_cnt_hi_div => 1,\n" +
                        "		m_cnt_lo_div => 1,\n" +
                        "		m_cnt_odd_div_duty_en => \"false\",\n" +
                        "		mimic_fbclk_type => \"gclk\",\n" +
                        "		n_cnt_bypass_en => \"false\",\n" +
                        "		n_cnt_hi_div => 1,\n" +
                        "		n_cnt_lo_div => 1,\n" +
                        "		n_cnt_odd_div_duty_en => \"false\",\n" +
                        "		number_of_clocks => 2,\n" +
                        "		operation_mode => \"direct\",\n" +
                        "		output_clock_frequency0 => \"65.000000 MHz\",\n" +
                        "		output_clock_frequency1 => \"1.000000 MHz\",\n" +
                        "		output_clock_frequency10 => \"0 MHz\",\n" +
                        "		output_clock_frequency11 => \"0 MHz\",\n" +
                        "		output_clock_frequency12 => \"0 MHz\",\n" +
                        "		output_clock_frequency13 => \"0 MHz\",\n" +
                        "		output_clock_frequency14 => \"0 MHz\",\n" +
                        "		output_clock_frequency15 => \"0 MHz\",\n" +
                        "		output_clock_frequency16 => \"0 MHz\",\n" +
                        "		output_clock_frequency17 => \"0 MHz\",\n" +
                        "		output_clock_frequency2 => \"0 MHz\",\n" +
                        "		output_clock_frequency3 => \"0 MHz\",\n" +
                        "		output_clock_frequency4 => \"0 MHz\",\n" +
                        "		output_clock_frequency5 => \"0 MHz\",\n" +
                        "		output_clock_frequency6 => \"0 MHz\",\n" +
                        "		output_clock_frequency7 => \"0 MHz\",\n" +
                        "		output_clock_frequency8 => \"0 MHz\",\n" +
                        "		output_clock_frequency9 => \"0 MHz\",\n" +
                        "		phase_shift0 => \"0 ps\",\n" +
                        "		phase_shift1 => \"0 ps\",\n" +
                        "		phase_shift10 => \"0 ps\",\n" +
                        "		phase_shift11 => \"0 ps\",\n" +
                        "		phase_shift12 => \"0 ps\",\n" +
                        "		phase_shift13 => \"0 ps\",\n" +
                        "		phase_shift14 => \"0 ps\",\n" +
                        "		phase_shift15 => \"0 ps\",\n" +
                        "		phase_shift16 => \"0 ps\",\n" +
                        "		phase_shift17 => \"0 ps\",\n" +
                        "		phase_shift2 => \"0 ps\",\n" +
                        "		phase_shift3 => \"0 ps\",\n" +
                        "		phase_shift4 => \"0 ps\",\n" +
                        "		phase_shift5 => \"0 ps\",\n" +
                        "		phase_shift6 => \"0 ps\",\n" +
                        "		phase_shift7 => \"0 ps\",\n" +
                        "		phase_shift8 => \"0 ps\",\n" +
                        "		phase_shift9 => \"0 ps\",\n" +
                        "		pll_auto_clk_sw_en => \"false\",\n" +
                        "		pll_bw_sel => \"low\",\n" +
                        "		pll_bwctrl => 0,\n" +
                        "		pll_clk_loss_sw_en => \"false\",\n" +
                        "		pll_clk_sw_dly => 0,\n" +
                        "		pll_clkin_0_src => \"clk_0\",\n" +
                        "		pll_clkin_1_src => \"clk_0\",\n" +
                        "		pll_cp_current => 0,\n" +
                        "		pll_dsm_out_sel => \"1st_order\",\n" +
                        "		pll_extclk_0_cnt_src => \"pll_extclk_cnt_src_vss\",\n" +
                        "		pll_extclk_1_cnt_src => \"pll_extclk_cnt_src_vss\",\n" +
                        "		pll_fbclk_mux_1 => \"glb\",\n" +
                        "		pll_fbclk_mux_2 => \"fb_1\",\n" +
                        "		pll_fractional_cout => 24,\n" +
                        "		pll_fractional_division => 1,\n" +
                        "		pll_m_cnt_in_src => \"ph_mux_clk\",\n" +
                        "		pll_manu_clk_sw_en => \"false\",\n" +
                        "		pll_output_clk_frequency => \"0 MHz\",\n" +
                        "		pll_slf_rst => \"false\",\n" +
                        "		pll_subtype => \"General\",\n" +
                        "		pll_type => \"General\",\n" +
                        "		pll_vco_div => 1,\n" +
                        "		pll_vcoph_div => 1,\n" +
                        "		refclk1_frequency => \"0 MHz\",\n" +
                        "		reference_clock_frequency => \"125.0 MHz\",\n" +
                        "		sim_additional_refclk_cycles_to_lock => 0\n" +
                        "	  )\n" +
                        "	  PORT MAP ( \n" +
                        "		fbclk => wire_gnd,\n" +
                        "		locked => wire_syspll_c5g_altera_pll_altera_pll_i_1098_locked,\n" +
                        "		outclk => wire_syspll_c5g_altera_pll_altera_pll_i_1098_outclk,\n" +
                        "		refclk => refclk,\n" +
                        "		rst => rst\n" +
                        "	  );\n" +
                        "\n" +
                        " END RTL; --SysPLL_c5g\n" +
                        "--synopsys translate_on\n" +
                        "--VALID FILE";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_types_river_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2018 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "--! Standard library.\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.numeric_std.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "--! AMBA system bus specific library.\n" +
                        "library ambalib;\n" +
                        "--! AXI4 configuration constants.\n" +
                        "use ambalib.types_amba4.all;\n" +
                        "use ambalib.types_bus0.all; -- TODO: REMOVE ME when update dsu\n" +
                        "\n" +
                        "--! RIVER CPU specific library.\n" +
                        "library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use riverlib.river_cfg.all;\n" +
                        "\n" +
                        "--! @brief   Declaration of components visible on SoC top level.\n" +
                        "package types_river is\n" +
                        "\n" +
                        "constant CFG_CORES_PER_DSU_MAX : integer := 1;\n" +
                        "\n" +
                        "type dport_in_type is record\n" +
                        "    valid : std_logic;\n" +
                        "    write : std_logic;\n" +
                        "    region : std_logic_vector(1 downto 0);\n" +
                        "    addr : std_logic_vector(11 downto 0);\n" +
                        "    wdata : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "end record;\n" +
                        "\n" +
                        "constant dport_in_none : dport_in_type := (\n" +
                        "  '0', '0', (others => '0'), (others => '0'), (others => '0'));\n" +
                        "\n" +
                        "type dport_in_vector is array (0 to CFG_CORES_PER_DSU_MAX-1) \n" +
                        "       of dport_in_type;\n" +
                        "\n" +
                        "\n" +
                        "type dport_out_type is record\n" +
                        "    halted : std_logic;\n" +
                        "    ready : std_logic;\n" +
                        "    rdata : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "end record;\n" +
                        "\n" +
                        "constant dport_out_none : dport_out_type := (\n" +
                        "    '0', '1', (others => '0'));\n" +
                        "\n" +
                        "type dport_out_vector is array (0 to CFG_CORES_PER_DSU_MAX-1) \n" +
                        "     of dport_out_type;\n" +
                        "\n" +
                        "  --! @brief   Declaration of the Debug Support Unit with the AXI interface.\n" +
                        "  --! @details This module provides access to processors CSRs via HostIO bus.\n" +
                        "  --! @param[in] clk           System clock (BUS/CPU clock).\n" +
                        "  --! @param[in] rstn          Reset signal with active LOW level.\n" +
                        "  --! @param[in] i_axi         Slave slot input signals.\n" +
                        "  --! @param[out] o_axi        Slave slot output signals.\n" +
                        "  --! @param[out] o_dporti     Debug port output signals connected to River CPU.\n" +
                        "  --! @param[in] i_dporto      River CPU debug port response signals.\n" +
                        "  --! @param[out] o_soft_rstn  Software reset CPU and interrupt controller. Active HIGH\n" +
                        "  --! @param[in] i_bus_util_w  Write bus access utilization per master statistic\n" +
                        "  --! @param[in] i_bus_util_r  Write bus access utilization per master statistic\n" +
                        "  component axi_dsu is\n" +
                        "  generic (\n" +
                        "    async_reset : boolean := false;\n" +
                        "    xaddr    : integer := 0;\n" +
                        "    xmask    : integer := 16#fffff#\n" +
                        "  );\n" +
                        "  port \n" +
                        "  (\n" +
                        "    clk    : in std_logic;\n" +
                        "    nrst   : in std_logic;\n" +
                        "    o_cfg  : out axi4_slave_config_type;\n" +
                        "    i_axi  : in axi4_slave_in_type;\n" +
                        "    o_axi  : out axi4_slave_out_type;\n" +
                        "    o_dporti : out dport_in_vector;\n" +
                        "    i_dporto : in dport_out_vector;\n" +
                        "    o_soft_rst : out std_logic;\n" +
                        "    i_bus_util_w : in std_logic_vector(CFG_BUS0_XMST_TOTAL-1 downto 0);\n" +
                        "    i_bus_util_r : in std_logic_vector(CFG_BUS0_XMST_TOTAL-1 downto 0)\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "\n" +
                        "--! @brief   RIVER CPU component declaration.\n" +
                        "--! @details This module implements Risc-V CPU Core named as\n" +
                        "--!          \"RIVER\" with AXI interface.\n" +
                        "--! @param[in] xindex AXI master index\n" +
                        "--! @param[in] i_rstn     Reset signal with active LOW level.\n" +
                        "--! @param[in] i_clk      System clock (BUS/CPU clock).\n" +
                        "--! @param[in] i_msti     Bus-to-Master device signals.\n" +
                        "--! @param[out] o_msto    CachedTile-to-Bus request signals.\n" +
                        "--! @param[in] i_ext_irq  Interrupts line supported by Rocket chip.\n" +
                        "component river_amba is \n" +
                        "  generic (\n" +
                        "    memtech : integer;\n" +
                        "    hartid : integer;\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port ( \n" +
                        "    i_nrst   : in std_logic;\n" +
                        "    i_clk    : in std_logic;\n" +
                        "    i_msti   : in axi4_master_in_type;\n" +
                        "    o_msto   : out axi4_master_out_type;\n" +
                        "    o_mstcfg : out axi4_master_config_type;\n" +
                        "    i_dport  : in dport_in_type;\n" +
                        "    o_dport  : out dport_out_type;\n" +
                        "    i_ext_irq : in std_logic\n" +
                        "  );\n" +
                        "end component;\n" +
                        "\n" +
                        "end; -- package body";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_river_top_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2018 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use riverlib.river_cfg.all;\n" +
                        "\n" +
                        "entity RiverTop is\n" +
                        "  generic (\n" +
                        "    memtech : integer := 0;\n" +
                        "    hartid : integer := 0;\n" +
                        "    async_reset : boolean := false\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;                                             -- CPU clock\n" +
                        "    i_nrst : in std_logic;                                            -- Reset. Active LOW.\n" +
                        "    -- Memory interface:\n" +
                        "    i_req_mem_ready : in std_logic;                                   -- AXI request was accepted\n" +
                        "    o_req_mem_valid : out std_logic;                                  -- AXI memory request is valid\n" +
                        "    o_req_mem_write : out std_logic;                                  -- AXI memory request is write type\n" +
                        "    o_req_mem_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0); -- AXI memory request address\n" +
                        "    o_req_mem_strob : out std_logic_vector(BUS_DATA_BYTES-1 downto 0);-- Writing strob. 1 bit per Byte\n" +
                        "    o_req_mem_data : out std_logic_vector(BUS_DATA_WIDTH-1 downto 0); -- Writing data\n" +
                        "    o_req_mem_len : out std_logic_vector(7 downto 0);                 -- burst length\n" +
                        "    o_req_mem_burst : out std_logic_vector(1 downto 0);               -- burst type: \"00\" FIX; \"01\" INCR; \"10\" WRAP\n" +
                        "    i_resp_mem_data_valid : in std_logic;                             -- AXI response is valid\n" +
                        "    i_resp_mem_data : in std_logic_vector(BUS_DATA_WIDTH-1 downto 0); -- Read data\n" +
                        "    i_resp_mem_load_fault : in std_logic;                             -- Bus response with SLVERR or DECERR on read\n" +
                        "    i_resp_mem_store_fault : in std_logic;                            -- Bus response with SLVERR or DECERR on write\n" +
                        "    i_resp_mem_store_fault_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    -- Interrupt line from external interrupts controller (PLIC).\n" +
                        "    i_ext_irq : in std_logic;\n" +
                        "    o_time : out std_logic_vector(63 downto 0);                       -- Timer. Clock counter except halt state.\n" +
                        "    -- Debug interface:\n" +
                        "    i_dport_valid : in std_logic;                                     -- Debug access from DSU is valid\n" +
                        "    i_dport_write : in std_logic;                                     -- Write command flag\n" +
                        "    i_dport_region : in std_logic_vector(1 downto 0);                 -- Registers region ID: 0=CSR; 1=IREGS; 2=Control\n" +
                        "    i_dport_addr : in std_logic_vector(11 downto 0);                  -- Register idx\n" +
                        "    i_dport_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0);       -- Write value\n" +
                        "    o_dport_ready : out std_logic;                                    -- Response is ready\n" +
                        "    o_dport_rdata : out std_logic_vector(RISCV_ARCH-1 downto 0);      -- Response value\n" +
                        "    o_halted : out std_logic\n" +
                        "  );\n" +
                        "end;\n" +
                        " \n" +
                        "architecture arch_RiverTop of RiverTop is\n" +
                        "\n" +
                        "  -- Control path:\n" +
                        "  signal w_req_ctrl_ready : std_logic;\n" +
                        "  signal w_req_ctrl_valid : std_logic;\n" +
                        "  signal wb_req_ctrl_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "  signal w_resp_ctrl_valid : std_logic;\n" +
                        "  signal wb_resp_ctrl_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "  signal wb_resp_ctrl_data : std_logic_vector(31 downto 0);\n" +
                        "  signal w_resp_ctrl_load_fault : std_logic;\n" +
                        "  signal w_resp_ctrl_ready : std_logic;\n" +
                        "  -- Data path:\n" +
                        "  signal w_req_data_ready : std_logic;\n" +
                        "  signal w_req_data_valid : std_logic;\n" +
                        "  signal w_req_data_write : std_logic;\n" +
                        "  signal wb_req_data_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "  signal wb_req_data_size : std_logic_vector(1 downto 0);\n" +
                        "  signal wb_req_data_data : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "  signal w_resp_data_valid : std_logic;\n" +
                        "  signal wb_resp_data_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "  signal wb_resp_data_data : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "  signal w_resp_data_load_fault : std_logic;\n" +
                        "  signal w_resp_data_store_fault : std_logic;\n" +
                        "  signal wb_resp_data_store_fault_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "  signal w_resp_data_ready : std_logic;\n" +
                        "  signal wb_flush_address : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "  signal w_flush_valid : std_logic;\n" +
                        "  signal wb_istate : std_logic_vector(1 downto 0);\n" +
                        "  signal wb_dstate : std_logic_vector(1 downto 0);\n" +
                        "  signal wb_cstate : std_logic_vector(1 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "    proc0 : Processor generic map (\n" +
                        "        hartid => hartid,\n" +
                        "        async_reset => async_reset\n" +
                        "      ) port map (\n" +
                        "        i_clk => i_clk,\n" +
                        "        i_nrst => i_nrst,\n" +
                        "        i_req_ctrl_ready => w_req_ctrl_ready,\n" +
                        "        o_req_ctrl_valid => w_req_ctrl_valid,\n" +
                        "        o_req_ctrl_addr => wb_req_ctrl_addr,\n" +
                        "        i_resp_ctrl_valid => w_resp_ctrl_valid,\n" +
                        "        i_resp_ctrl_addr => wb_resp_ctrl_addr,\n" +
                        "        i_resp_ctrl_data => wb_resp_ctrl_data,\n" +
                        "        i_resp_ctrl_load_fault => w_resp_ctrl_load_fault,\n" +
                        "        o_resp_ctrl_ready => w_resp_ctrl_ready,\n" +
                        "        i_req_data_ready => w_req_data_ready,\n" +
                        "        o_req_data_valid => w_req_data_valid,\n" +
                        "        o_req_data_write => w_req_data_write,\n" +
                        "        o_req_data_addr => wb_req_data_addr,\n" +
                        "        o_req_data_size => wb_req_data_size,\n" +
                        "        o_req_data_data => wb_req_data_data,\n" +
                        "        i_resp_data_valid => w_resp_data_valid,\n" +
                        "        i_resp_data_addr => wb_resp_data_addr,\n" +
                        "        i_resp_data_data => wb_resp_data_data,\n" +
                        "        i_resp_data_load_fault => w_resp_data_load_fault,\n" +
                        "        i_resp_data_store_fault => w_resp_data_store_fault,\n" +
                        "        i_resp_data_store_fault_addr => wb_resp_data_store_fault_addr,\n" +
                        "        o_resp_data_ready => w_resp_data_ready,\n" +
                        "        i_ext_irq => i_ext_irq,\n" +
                        "        o_time => o_time,\n" +
                        "        i_dport_valid => i_dport_valid,\n" +
                        "        i_dport_write => i_dport_write,\n" +
                        "        i_dport_region => i_dport_region,\n" +
                        "        i_dport_addr => i_dport_addr,\n" +
                        "        i_dport_wdata => i_dport_wdata,\n" +
                        "        o_dport_ready => o_dport_ready,\n" +
                        "        o_dport_rdata => o_dport_rdata,\n" +
                        "        o_halted => o_halted,\n" +
                        "        o_flush_address => wb_flush_address,\n" +
                        "        o_flush_valid => w_flush_valid,\n" +
                        "        i_istate => wb_istate,\n" +
                        "        i_dstate => wb_dstate,\n" +
                        "        i_cstate => wb_cstate);\n" +
                        "\n" +
                        "    cache0 :  CacheTop generic map (\n" +
                        "        memtech => memtech,\n" +
                        "        async_reset => async_reset\n" +
                        "     ) port map (\n" +
                        "        i_clk => i_clk,\n" +
                        "        i_nrst => i_nrst,\n" +
                        "        i_req_ctrl_valid => w_req_ctrl_valid,\n" +
                        "        i_req_ctrl_addr => wb_req_ctrl_addr,\n" +
                        "        o_req_ctrl_ready => w_req_ctrl_ready,\n" +
                        "        o_resp_ctrl_valid => w_resp_ctrl_valid,\n" +
                        "        o_resp_ctrl_addr => wb_resp_ctrl_addr,\n" +
                        "        o_resp_ctrl_data => wb_resp_ctrl_data,\n" +
                        "        o_resp_ctrl_load_fault => w_resp_ctrl_load_fault,\n" +
                        "        i_resp_ctrl_ready => w_resp_ctrl_ready,\n" +
                        "        i_req_data_valid => w_req_data_valid,\n" +
                        "        i_req_data_write => w_req_data_write,\n" +
                        "        i_req_data_addr => wb_req_data_addr,\n" +
                        "        i_req_data_size => wb_req_data_size,\n" +
                        "        i_req_data_data => wb_req_data_data,\n" +
                        "        o_req_data_ready => w_req_data_ready,\n" +
                        "        o_resp_data_valid => w_resp_data_valid,\n" +
                        "        o_resp_data_addr => wb_resp_data_addr,\n" +
                        "        o_resp_data_data => wb_resp_data_data,\n" +
                        "        o_resp_data_load_fault => w_resp_data_load_fault,\n" +
                        "        o_resp_data_store_fault => w_resp_data_store_fault,\n" +
                        "        o_resp_data_store_fault_addr => wb_resp_data_store_fault_addr,\n" +
                        "        i_resp_data_ready => w_resp_data_ready,\n" +
                        "        i_req_mem_ready => i_req_mem_ready,\n" +
                        "        o_req_mem_valid => o_req_mem_valid,\n" +
                        "        o_req_mem_write => o_req_mem_write,\n" +
                        "        o_req_mem_addr => o_req_mem_addr,\n" +
                        "        o_req_mem_strob => o_req_mem_strob,\n" +
                        "        o_req_mem_data => o_req_mem_data,\n" +
                        "        o_req_mem_len => o_req_mem_len,\n" +
                        "        o_req_mem_burst => o_req_mem_burst,\n" +
                        "        i_resp_mem_data_valid => i_resp_mem_data_valid,\n" +
                        "        i_resp_mem_data => i_resp_mem_data,\n" +
                        "        i_resp_mem_load_fault => i_resp_mem_load_fault,\n" +
                        "        i_resp_mem_store_fault => i_resp_mem_store_fault,\n" +
                        "        i_resp_mem_store_fault_addr => i_resp_mem_store_fault_addr,\n" +
                        "        i_flush_address => wb_flush_address,\n" +
                        "        i_flush_valid => w_flush_valid,\n" +
                        "        o_istate => wb_istate,\n" +
                        "        o_dstate => wb_dstate,\n" +
                        "        o_cstate => wb_cstate);\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_river_cfg_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2018 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "--! Standard library.\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.numeric_std.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "\n" +
                        "--! @brief   Library global parameters.\n" +
                        "package river_cfg is\n" +
                        "\n" +
                        "  constant CFG_VENDOR_ID : std_logic_vector(31 downto 0) := X\"000000F1\";\n" +
                        "  constant CFG_IMPLEMENTATION_ID : std_logic_vector(31 downto 0) := X\"20191108\";\n" +
                        "\n" +
                        "  -- When false use Dual-port memory banks\n" +
                        "  constant CFG_SINGLEPORT_CACHE : boolean := true;\n" +
                        "\n" +
                        "  -- [13:6]  8: index: 8 KB per odd/even ways (64 KB total: ways=4)\n" +
                        "  -- [12:6]  7: index: 4 KB per odd/even ways (32 KB total: ways=4)\n" +
                        "  -- [11:6]  6: index: 2 KB per odd/even ways (16 KB total: ways=4)\n" +
                        "  constant CFG_IINDEX_WIDTH : integer := 6;    -- log2(LINES_PER_WAY)\n" +
                        "\n" +
                        "  --! Architecture size difinition.\n" +
                        "  constant RISCV_ARCH : integer := 64;\n" +
                        "\n" +
                        "  --! @name System bus parameters\n" +
                        "  --! @brief Constants specify AXI bus global settigns\n" +
                        "  --! @{\n" +
                        "\n" +
                        "  --! @brief   Address bus bit-size.\n" +
                        "  constant BUS_ADDR_WIDTH : integer := 32;\n" +
                        "  --! @brief   Data bus bit-size.\n" +
                        "  constant BUS_DATA_WIDTH : integer := 64;\n" +
                        "  --! @brief   Num of data bytes per transaction.\n" +
                        "  constant BUS_DATA_BYTES : integer := BUS_DATA_WIDTH / 8;\n" +
                        "  --! @}\n" +
                        "\n" +
                        "  --! @name   Encoded Memory operation size values\n" +
                        "  --! @{\n" +
                        "\n" +
                        "  constant MEMOP_8B : std_logic_vector(1 downto 0) := \"11\";\n" +
                        "  constant MEMOP_4B : std_logic_vector(1 downto 0) := \"10\";\n" +
                        "  constant MEMOP_2B : std_logic_vector(1 downto 0) := \"01\";\n" +
                        "  constant MEMOP_1B : std_logic_vector(1 downto 0) := \"00\";\n" +
                        "  --! @}\n" +
                        "  \n" +
                        "  --! Non-maskable interrupts (exceptions) table.\n" +
                        "  --!  It can be freely changed to optimize memory consumption/performance\n" +
                        "  --!\n" +
                        "  constant CFG_NMI_RESET_VECTOR         : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0) := X\"00000000\";\n" +
                        "  constant CFG_NMI_INSTR_UNALIGNED_ADDR : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0) := X\"00000008\";\n" +
                        "  constant CFG_NMI_INSTR_FAULT_ADDR     : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0) := X\"00000010\";\n" +
                        "  constant CFG_NMI_INSTR_ILLEGAL_ADDR   : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0) := X\"00000018\";\n" +
                        "  constant CFG_NMI_BREAKPOINT_ADDR      : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0) := X\"00000020\";\n" +
                        "  constant CFG_NMI_LOAD_UNALIGNED_ADDR  : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0) := X\"00000028\";\n" +
                        "  constant CFG_NMI_LOAD_FAULT_ADDR      : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0) := X\"00000030\";\n" +
                        "  constant CFG_NMI_STORE_UNALIGNED_ADDR : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0) := X\"00000038\";\n" +
                        "  constant CFG_NMI_STORE_FAULT_ADDR     : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0) := X\"00000040\";\n" +
                        "  constant CFG_NMI_CALL_FROM_UMODE_ADDR : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0) := X\"00000048\";\n" +
                        "  constant CFG_NMI_CALL_FROM_SMODE_ADDR : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0) := X\"00000050\";\n" +
                        "  constant CFG_NMI_CALL_FROM_HMODE_ADDR : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0) := X\"00000058\";\n" +
                        "  constant CFG_NMI_CALL_FROM_MMODE_ADDR : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0) := X\"00000060\";\n" +
                        "  constant CFG_NMI_INSTR_PAGE_FAULT_ADDR: std_logic_vector(BUS_ADDR_WIDTH-1 downto 0) := X\"00000068\";\n" +
                        "  constant CFG_NMI_LOAD_PAGE_FAULT_ADDR : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0) := X\"00000070\";\n" +
                        "  constant CFG_NMI_STORE_PAGE_FAULT_ADDR: std_logic_vector(BUS_ADDR_WIDTH-1 downto 0) := X\"00000078\";\n" +
                        "  constant CFG_NMI_STACK_OVERFLOW_ADDR  : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0) := X\"00000080\";\n" +
                        "  constant CFG_NMI_STACK_UNDERFLOW_ADDR : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0) := X\"00000088\";\n" +
                        "\n" +
                        "  --! Number of elements each 2*CFG_ADDR_WIDTH in stack trace buffer, 0 = disabled\n" +
                        "  constant CFG_STACK_TRACE_BUF_SIZE : integer := 32;\n" +
                        "\n" +
                        "  --! @name   Integer Registers specified by ISA\n" +
                        "  --! @{\n" +
                        "    constant Reg_Zero : integer := 0;\n" +
                        "    constant Reg_ra : integer := 1;       -- [1] Return address\n" +
                        "    constant Reg_sp : integer := 2;       -- [2] Stack pointer\n" +
                        "    constant Reg_gp : integer := 3;       -- [3] Global pointer\n" +
                        "    constant Reg_tp : integer := 4;       -- [4] Thread pointer\n" +
                        "    constant Reg_t0 : integer := 5;       -- [5] Temporaries 0 s3\n" +
                        "    constant Reg_t1 : integer := 6;       -- [6] Temporaries 1 s4\n" +
                        "    constant Reg_t2 : integer := 7;       -- [7] Temporaries 2 s5\n" +
                        "    constant Reg_s0 : integer := 8;       -- [8] s0/fp Saved register/frame pointer\n" +
                        "    constant Reg_s1 : integer := 9;       -- [9] Saved register 1\n" +
                        "    constant Reg_a0 : integer := 10;      -- [10] Function argumentes 0\n" +
                        "    constant Reg_a1 : integer := 11;      -- [11] Function argumentes 1\n" +
                        "    constant Reg_a2 : integer := 12;      -- [12] Function argumentes 2\n" +
                        "    constant Reg_a3 : integer := 13;      -- [13] Function argumentes 3\n" +
                        "    constant Reg_a4 : integer := 14;      -- [14] Function argumentes 4\n" +
                        "    constant Reg_a5 : integer := 15;      -- [15] Function argumentes 5\n" +
                        "    constant Reg_a6 : integer := 16;      -- [16] Function argumentes 6\n" +
                        "    constant Reg_a7 : integer := 17;      -- [17] Function argumentes 7\n" +
                        "    constant Reg_s2 : integer := 18;      -- [18] Saved register 2\n" +
                        "    constant Reg_s3 : integer := 19;      -- [19] Saved register 3\n" +
                        "    constant Reg_s4 : integer := 20;      -- [20] Saved register 4\n" +
                        "    constant Reg_s5 : integer := 21;      -- [21] Saved register 5\n" +
                        "    constant Reg_s6 : integer := 22;      -- [22] Saved register 6\n" +
                        "    constant Reg_s7 : integer := 23;      -- [23] Saved register 7\n" +
                        "    constant Reg_s8 : integer := 24;      -- [24] Saved register 8\n" +
                        "    constant Reg_s9 : integer := 25;      -- [25] Saved register 9\n" +
                        "    constant Reg_s10 : integer := 26;     -- [26] Saved register 10\n" +
                        "    constant Reg_s11 : integer := 27;     -- [27] Saved register 11\n" +
                        "    constant Reg_t3 : integer := 28;      -- [28] \n" +
                        "    constant Reg_t4 : integer := 29;      -- [29] \n" +
                        "    constant Reg_t5 : integer := 30;      -- [30] \n" +
                        "    constant Reg_t6 : integer := 31;      -- [31] \n" +
                        "    constant Reg_Total : integer := 32;\n" +
                        "  --! @}\n" +
                        "\n" +
                        "  --! @name   Floating Point Unit Registers specified by ISA\n" +
                        "  --! @{\n" +
                        "    constant Reg_f0 : integer := 0;      -- ft0 temporary register\n" +
                        "    constant Reg_f1 : integer := 1;      -- ft1\n" +
                        "    constant Reg_f2 : integer := 2;      -- ft2\n" +
                        "    constant Reg_f3 : integer := 3;      -- ft3\n" +
                        "    constant Reg_f4 : integer := 4;      -- ft4\n" +
                        "    constant Reg_f5 : integer := 5;      -- ft5\n" +
                        "    constant Reg_f6 : integer := 6;      -- ft6\n" +
                        "    constant Reg_f7 : integer := 7;      -- ft7\n" +
                        "    constant Reg_f8 : integer := 8;      -- fs0 saved register\n" +
                        "    constant Reg_f9 : integer := 9;      -- fs1\n" +
                        "    constant Reg_f10 : integer := 10;    -- fa0 argument/return value\n" +
                        "    constant Reg_f11 : integer := 11;    -- fa1 argument/return value\n" +
                        "    constant Reg_f12 : integer := 12;    -- fa2 argument register\n" +
                        "    constant Reg_f13 : integer := 13;    -- fa3\n" +
                        "    constant Reg_f14 : integer := 14;    -- fa4\n" +
                        "    constant Reg_f15 : integer := 15;    -- fa5\n" +
                        "    constant Reg_f16 : integer := 16;    -- fa6\n" +
                        "    constant Reg_f17 : integer := 17;    -- fa7\n" +
                        "    constant Reg_f18 : integer := 18;    -- fs2 saved register\n" +
                        "    constant Reg_f19 : integer := 19;    -- fs3\n" +
                        "    constant Reg_f20 : integer := 20;    -- fs4\n" +
                        "    constant Reg_f21 : integer := 21;    -- fs5\n" +
                        "    constant Reg_f22 : integer := 22;    -- fs6\n" +
                        "    constant Reg_f23 : integer := 23;    -- fs7\n" +
                        "    constant Reg_f24 : integer := 24;    -- fs8\n" +
                        "    constant Reg_f25 : integer := 25;    -- fs9\n" +
                        "    constant Reg_f26 : integer := 26;    -- fs10\n" +
                        "    constant Reg_f27 : integer := 27;    -- fs11\n" +
                        "    constant Reg_f28 : integer := 28;    -- ft8 temporary register\n" +
                        "    constant Reg_f29 : integer := 29;    -- ft9\n" +
                        "    constant Reg_f30 : integer := 30;    -- ft10\n" +
                        "    constant Reg_f31 : integer := 31;    -- ft11\n" +
                        "    constant RegFpu_Total  : integer := 32;\n" +
                        "  --! @}\n" +
                        "\n" +
                        "  --! @name   Instruction formats specified by ISA specification\n" +
                        "  --! @{\n" +
                        "  constant ISA_R_type : integer := 0;\n" +
                        "  constant ISA_I_type : integer := 1;\n" +
                        "  constant ISA_S_type : integer := 2;\n" +
                        "  constant ISA_SB_type : integer := 3;\n" +
                        "  constant ISA_U_type : integer := 4;\n" +
                        "  constant ISA_UJ_type : integer := 5;\n" +
                        "  constant ISA_Total : integer := 6;\n" +
                        "  --! @}\n" +
                        "\n" +
                        "\n" +
                        "  --! @name   Implemented instruction list and its indexes\n" +
                        "  --! @{\n" +
                        "  constant Instr_ADD : integer := 0;\n" +
                        "  constant Instr_ADDI : integer := 1;\n" +
                        "  constant Instr_ADDIW : integer := 2;\n" +
                        "  constant Instr_ADDW : integer := 3;\n" +
                        "  constant Instr_AND : integer := 4;\n" +
                        "  constant Instr_ANDI : integer := 5;\n" +
                        "  constant Instr_AUIPC : integer := 6;\n" +
                        "  constant Instr_BEQ : integer := 7;\n" +
                        "  constant Instr_BGE : integer := 8;\n" +
                        "  constant Instr_BGEU : integer := 9;\n" +
                        "  constant Instr_BLT : integer := 10;\n" +
                        "  constant Instr_BLTU : integer := 11;\n" +
                        "  constant Instr_BNE : integer := 12;\n" +
                        "  constant Instr_JAL : integer := 13;\n" +
                        "  constant Instr_JALR : integer := 14;\n" +
                        "  constant Instr_LB : integer := 15;\n" +
                        "  constant Instr_LH : integer := 16;\n" +
                        "  constant Instr_LW : integer := 17;\n" +
                        "  constant Instr_LD : integer := 18;\n" +
                        "  constant Instr_LBU : integer := 19;\n" +
                        "  constant Instr_LHU : integer := 20;\n" +
                        "  constant Instr_LWU : integer := 21;\n" +
                        "  constant Instr_LUI : integer := 22;\n" +
                        "  constant Instr_OR : integer := 23;\n" +
                        "  constant Instr_ORI : integer := 24;\n" +
                        "  constant Instr_SLLI : integer := 25;\n" +
                        "  constant Instr_SLT : integer := 26;\n" +
                        "  constant Instr_SLTI : integer := 27;\n" +
                        "  constant Instr_SLTU : integer := 28;\n" +
                        "  constant Instr_SLTIU : integer := 29;\n" +
                        "  constant Instr_SLL : integer := 30;\n" +
                        "  constant Instr_SLLW : integer := 31;\n" +
                        "  constant Instr_SLLIW : integer := 32;\n" +
                        "  constant Instr_SRA : integer := 33;\n" +
                        "  constant Instr_SRAW : integer := 34;\n" +
                        "  constant Instr_SRAI : integer := 35;\n" +
                        "  constant Instr_SRAIW : integer := 36;\n" +
                        "  constant Instr_SRL : integer := 37;\n" +
                        "  constant Instr_SRLI : integer := 38;\n" +
                        "  constant Instr_SRLIW : integer := 39;\n" +
                        "  constant Instr_SRLW : integer := 40;\n" +
                        "  constant Instr_SB : integer := 41;\n" +
                        "  constant Instr_SH : integer := 42;\n" +
                        "  constant Instr_SW : integer := 43;\n" +
                        "  constant Instr_SD : integer := 44;\n" +
                        "  constant Instr_SUB : integer := 45;\n" +
                        "  constant Instr_SUBW : integer := 46;\n" +
                        "  constant Instr_XOR : integer := 47;\n" +
                        "  constant Instr_XORI : integer := 48;\n" +
                        "  constant Instr_CSRRW : integer := 49;\n" +
                        "  constant Instr_CSRRS : integer := 50;\n" +
                        "  constant Instr_CSRRC : integer := 51;\n" +
                        "  constant Instr_CSRRWI : integer := 52;\n" +
                        "  constant Instr_CSRRCI : integer := 53;\n" +
                        "  constant Instr_CSRRSI : integer := 54;\n" +
                        "  constant Instr_URET : integer := 55;\n" +
                        "  constant Instr_SRET : integer := 56;\n" +
                        "  constant Instr_HRET : integer := 57;\n" +
                        "  constant Instr_MRET : integer := 58;\n" +
                        "  constant Instr_FENCE : integer := 59;\n" +
                        "  constant Instr_FENCE_I : integer := 60;\n" +
                        "  constant Instr_DIV : integer := 61;\n" +
                        "  constant Instr_DIVU : integer := 62;\n" +
                        "  constant Instr_DIVW : integer := 63;\n" +
                        "  constant Instr_DIVUW : integer := 64;\n" +
                        "  constant Instr_MUL : integer := 65;\n" +
                        "  constant Instr_MULW : integer := 66;\n" +
                        "  constant Instr_REM : integer := 67;\n" +
                        "  constant Instr_REMU : integer := 68;\n" +
                        "  constant Instr_REMW : integer := 69;\n" +
                        "  constant Instr_REMUW : integer := 70;\n" +
                        "  constant Instr_ECALL : integer := 71;\n" +
                        "  constant Instr_EBREAK : integer := 72;\n" +
                        "  constant Instr_FADD_D : integer := 73;\n" +
                        "  constant Instr_FCVT_D_W : integer := 74;\n" +
                        "  constant Instr_FCVT_D_WU : integer := 75;\n" +
                        "  constant Instr_FCVT_D_L : integer := 76;\n" +
                        "  constant Instr_FCVT_D_LU : integer := 77;\n" +
                        "  constant Instr_FCVT_D_S : integer := 78;\n" +
                        "  constant Instr_FCVT_S_D : integer := 79;\n" +
                        "  constant Instr_FCVT_W_D : integer := 80;\n" +
                        "  constant Instr_FCVT_WU_D : integer := 81;\n" +
                        "  constant Instr_FCVT_L_D : integer := 82;\n" +
                        "  constant Instr_FCVT_LU_D : integer := 83;\n" +
                        "  constant Instr_FDIV_D : integer := 84;\n" +
                        "  constant Instr_FEQ_D : integer := 85;\n" +
                        "  constant Instr_FLD : integer := 86;\n" +
                        "  constant Instr_FLE_D : integer := 87;\n" +
                        "  constant Instr_FLT_D : integer := 88;\n" +
                        "  constant Instr_FMAX_D : integer := 89;\n" +
                        "  constant Instr_FMIN_D : integer := 90;\n" +
                        "  constant Instr_FMOV_D_X : integer := 91;\n" +
                        "  constant Instr_FMOV_W_X : integer := 92;\n" +
                        "  constant Instr_FMOV_X_D : integer := 93;\n" +
                        "  constant Instr_FMOV_X_W : integer := 94;\n" +
                        "  constant Instr_FMUL_D : integer := 95;\n" +
                        "  constant Instr_FSD : integer := 96;\n" +
                        "  constant Instr_FSUB_D : integer := 97;\n" +
                        "  constant Instr_FSGNJ_D : integer := 98;\n" +
                        "  constant Instr_Total : integer := 99;\n" +
                        "\n" +
                        "  constant Instr_FPU_Total : integer := Instr_FSGNJ_D - Instr_FADD_D + 1;\n" +
                        "  --! @}\n" +
                        "\n" +
                        "  --! @name PRV bits possible values:\n" +
                        "  --!\n" +
                        "  --! @{\n" +
                        "  --! User-mode\n" +
                        "  constant PRV_U : std_logic_vector(1 downto 0) := \"00\";\n" +
                        "  --! super-visor mode\n" +
                        "  constant PRV_S : std_logic_vector(1 downto 0) := \"01\";\n" +
                        "  --! hyper-visor mode\n" +
                        "  constant PRV_H : std_logic_vector(1 downto 0) := \"10\";\n" +
                        "  --! machine mode\n" +
                        "  constant PRV_M : std_logic_vector(1 downto 0) := \"11\";\n" +
                        "  --! @}\n" +
                        "\n" +
                        "\n" +
                        "  --! @name CSR registers.\n" +
                        "  --!\n" +
                        "  --! @{\n" +
                        "  \n" +
                        "  -- FPU Accrued Exceptions fields from FCSR\n" +
                        "  constant CSR_fflags            : std_logic_vector(11 downto 0) := X\"001\";\n" +
                        "  -- FPU dynamic Rounding Mode fields from FCSR\n" +
                        "  constant CSR_frm               : std_logic_vector(11 downto 0) := X\"002\";\n" +
                        "  -- FPU Control and Status register (frm + fflags)\n" +
                        "  constant CSR_fcsr              : std_logic_vector(11 downto 0) := X\"003\";\n" +
                        "  -- ISA and extensions supported.\n" +
                        "  constant CSR_misa              : std_logic_vector(11 downto 0) := X\"f10\";\n" +
                        "  -- Vendor ID.\n" +
                        "  constant CSR_mvendorid         : std_logic_vector(11 downto 0) := X\"f11\";\n" +
                        "  -- Architecture ID.\n" +
                        "  constant CSR_marchid           : std_logic_vector(11 downto 0) := X\"f12\";\n" +
                        "  -- Vendor ID.\n" +
                        "  constant CSR_mimplementationid : std_logic_vector(11 downto 0) := X\"f13\";\n" +
                        "  -- Thread id (the same as core).\n" +
                        "  constant CSR_mhartid           : std_logic_vector(11 downto 0) := X\"f14\";\n" +
                        "  -- Machine wall-clock time\n" +
                        "  constant CSR_mtime         : std_logic_vector(11 downto 0) := X\"701\";\n" +
                        "  -- Software reset.\n" +
                        "  constant CSR_mreset        : std_logic_vector(11 downto 0) := X\"782\";\n" +
                        "\n" +
                        "  -- machine mode status read/write register.\n" +
                        "  constant CSR_mstatus       : std_logic_vector(11 downto 0) := X\"300\";\n" +
                        "  -- Machine exception delegation\n" +
                        "  constant CSR_medeleg       : std_logic_vector(11 downto 0) := X\"302\";\n" +
                        "  -- Machine interrupt delegation\n" +
                        "  constant CSR_mideleg       : std_logic_vector(11 downto 0) := X\"303\";\n" +
                        "  -- Machine interrupt enable\n" +
                        "  constant CSR_mie           : std_logic_vector(11 downto 0) := X\"304\";\n" +
                        "  -- The base address of the M-mode trap vector.\n" +
                        "  constant CSR_mtvec         : std_logic_vector(11 downto 0) := X\"305\";\n" +
                        "  -- Machine wall-clock timer compare value.\n" +
                        "  constant CSR_mtimecmp      : std_logic_vector(11 downto 0) := X\"321\";\n" +
                        "  -- Scratch register for machine trap handlers.\n" +
                        "  constant CSR_mscratch      : std_logic_vector(11 downto 0) := X\"340\";\n" +
                        "  -- Exception program counters.\n" +
                        "  constant CSR_uepc          : std_logic_vector(11 downto 0) := X\"041\";\n" +
                        "  constant CSR_sepc          : std_logic_vector(11 downto 0) := X\"141\";\n" +
                        "  constant CSR_hepc          : std_logic_vector(11 downto 0) := X\"241\";\n" +
                        "  constant CSR_mepc          : std_logic_vector(11 downto 0) := X\"341\";\n" +
                        "  -- Machine trap cause\n" +
                        "  constant CSR_mcause        : std_logic_vector(11 downto 0) := X\"342\";\n" +
                        "  -- Machine bad address.\n" +
                        "  constant CSR_mbadaddr      : std_logic_vector(11 downto 0) := X\"343\";\n" +
                        "  -- Machine interrupt pending\n" +
                        "  constant CSR_mip           : std_logic_vector(11 downto 0) := X\"344\";\n" +
                        "  -- Machine stack overflow\n" +
                        "  constant CSR_mstackovr     : std_logic_vector(11 downto 0) := X\"350\";\n" +
                        "  -- Machine stack underflow\n" +
                        "  constant CSR_mstackund     : std_logic_vector(11 downto 0) := X\"351\";\n" +
                        "  --! @}\n" +
                        "\n" +
                        "  --! @name   Exceptions\n" +
                        "  --! @{\n" +
                        "  -- Instruction address misaligned\n" +
                        "  constant EXCEPTION_InstrMisalign   : std_logic_vector(4 downto 0) := \"00000\";\n" +
                        "  -- Instruction access fault\n" +
                        "  constant EXCEPTION_InstrFault      : std_logic_vector(4 downto 0) := \"00001\";\n" +
                        "  -- Illegal instruction\n" +
                        "  constant EXCEPTION_InstrIllegal    : std_logic_vector(4 downto 0) := \"00010\";\n" +
                        "  -- Breakpoint\n" +
                        "  constant EXCEPTION_Breakpoint      : std_logic_vector(4 downto 0) := \"00011\";\n" +
                        "  -- Load address misaligned\n" +
                        "  constant EXCEPTION_LoadMisalign    : std_logic_vector(4 downto 0) := \"00100\";\n" +
                        "  -- Load access fault\n" +
                        "  constant EXCEPTION_LoadFault       : std_logic_vector(4 downto 0) := \"00101\";\n" +
                        "  -- Store/AMO address misaligned\n" +
                        "  constant EXCEPTION_StoreMisalign   : std_logic_vector(4 downto 0) := \"00110\";\n" +
                        "  -- Store/AMO access fault\n" +
                        "  constant EXCEPTION_StoreFault      : std_logic_vector(4 downto 0) := \"00111\";\n" +
                        "  -- Environment call from U-mode\n" +
                        "  constant EXCEPTION_CallFromUmode   : std_logic_vector(4 downto 0) := \"01000\";\n" +
                        "  -- Environment call from S-mode\n" +
                        "  constant EXCEPTION_CallFromSmode   : std_logic_vector(4 downto 0) := \"01001\";\n" +
                        "  -- Environment call from H-mode\n" +
                        "  constant EXCEPTION_CallFromHmode   : std_logic_vector(4 downto 0) := \"01010\";\n" +
                        "  -- Environment call from M-mode\n" +
                        "  constant EXCEPTION_CallFromMmode   : std_logic_vector(4 downto 0) := \"01011\";\n" +
                        "  -- Instruction page fault\n" +
                        "  constant EXCEPTION_InstrPageFault  : std_logic_vector(4 downto 0) := \"01100\";\n" +
                        "  -- Load page fault\n" +
                        "  constant EXCEPTION_LoadPageFault   : std_logic_vector(4 downto 0) := \"01101\";\n" +
                        "  -- reserved\n" +
                        "  constant EXCEPTION_rsrv14          : std_logic_vector(4 downto 0) := \"01110\";\n" +
                        "  -- Store/AMO page fault\n" +
                        "  constant EXCEPTION_StorePageFault  : std_logic_vector(4 downto 0) := \"01111\";\n" +
                        "  -- Stack overflow\n" +
                        "  constant EXCEPTION_StackOverflow   : std_logic_vector(4 downto 0) := \"10000\";\n" +
                        "  -- Stack underflow\n" +
                        "  constant EXCEPTION_StackUnderflow  : std_logic_vector(4 downto 0) := \"10001\";\n" +
                        "  --! @}\n" +
                        "\n" +
                        "  --! @name   Interrupts\n" +
                        "  --! @{\n" +
                        "  -- User software interrupt\n" +
                        "  constant INTERRUPT_USoftware       : std_logic_vector(4 downto 0) := \"00000\";\n" +
                        "  -- Superuser software interrupt\n" +
                        "  constant INTERRUPT_SSoftware       : std_logic_vector(4 downto 0) := \"00001\";\n" +
                        "  -- Hypervisor software itnerrupt\n" +
                        "  constant INTERRUPT_HSoftware       : std_logic_vector(4 downto 0) := \"00010\";\n" +
                        "  -- Machine software interrupt\n" +
                        "  constant INTERRUPT_MSoftware       : std_logic_vector(4 downto 0) := \"00011\";\n" +
                        "  -- User timer interrupt\n" +
                        "  constant INTERRUPT_UTimer          : std_logic_vector(4 downto 0) := \"00100\";\n" +
                        "  -- Superuser timer interrupt\n" +
                        "  constant INTERRUPT_STimer          : std_logic_vector(4 downto 0) := \"00101\";\n" +
                        "  -- Hypervisor timer interrupt\n" +
                        "  constant INTERRUPT_HTimer          : std_logic_vector(4 downto 0) := \"00110\";\n" +
                        "  -- Machine timer interrupt\n" +
                        "  constant INTERRUPT_MTimer          : std_logic_vector(4 downto 0) := \"00111\";\n" +
                        "  -- User external interrupt\n" +
                        "  constant INTERRUPT_UExternal       : std_logic_vector(4 downto 0) := \"01000\";\n" +
                        "  -- Superuser external interrupt\n" +
                        "  constant INTERRUPT_SExternal       : std_logic_vector(4 downto 0) := \"01001\";\n" +
                        "  -- Hypervisor external interrupt\n" +
                        "  constant INTERRUPT_HExternal       : std_logic_vector(4 downto 0) := \"01010\";\n" +
                        "  -- Machine external interrupt (from PLIC)\n" +
                        "  constant INTERRUPT_MExternal       : std_logic_vector(4 downto 0) := \"01011\";\n" +
                        "  --! @}\n" +
                        "\n" +
                        "\n" +
                        "  --! @param[in] i_clk             CPU clock\n" +
                        "  --! @param[in] i_nrst            Reset. Active LOW.\n" +
                        "  --! @param[in] i_req_mem_fire    Memory request was accepted\n" +
                        "  --! @param[in] i_resp_mem_valid  Memory response from ICache is valid\n" +
                        "  --! @param[in] i_resp_mem_addr   Memory response address\n" +
                        "  --! @param[in] i_resp_mem_data   Memory response value\n" +
                        "  --! @param[in] i_e_npc           Valid instruction value awaited by 'Executor'\n" +
                        "  --! @param[in] i_ra              Return address register value\n" +
                        "  --! @param[out] o_npc_predic     Predicted next instruction address\n" +
                        "  --! @param[out] o_predict        Mark requested address as predicted\n" +
                        "  component BranchPredictor is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_req_mem_fire : in std_logic;\n" +
                        "    i_resp_mem_valid : in std_logic;\n" +
                        "    i_resp_mem_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_resp_mem_data : in std_logic_vector(31 downto 0);\n" +
                        "    i_e_npc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_ra : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_npc_predict : out std_logic_vector(31 downto 0)\n" +
                        "  );\n" +
                        "  end component; \n" +
                        "\n" +
                        "  --! @param[in] i_clk          CPU clock\n" +
                        "  --! @param[in] i_nrst         Reset. Active LOW.\n" +
                        "  --! @param[in] i_xret         XRet instruction signals mode switching\n" +
                        "  --! @param[in] i_addr         CSR address, if xret=1 switch mode accordingly\n" +
                        "  --! @param[in] i_wena         Write enable\n" +
                        "  --! @param[in] i_wdata        CSR writing value\n" +
                        "  --! @param[out] o_rdata       CSR read value\n" +
                        "  --! @param[in] i_trap_ready   Trap branch request was accepted\n" +
                        "  --! @param[in] i_ex_data_addr    Data path: address must be equal to the latest request address\n" +
                        "  --! @param[in] i_ex_data_load_fault Data path: Bus response with SLVERR or DECERR on read\n" +
                        "  --! @param[in] i_ex_data_store_fault Data path: Bus response with SLVERR or DECERR on write\n" +
                        "  --! @param[in] i_break_mode   Behaviour on EBREAK instruction: 0 = halt; 1 = generate trap\n" +
                        "  --! @param[out] o_break_event ebreak detected1 clock event\n" +
                        "  --! @param[in] i_dport_ena    Debug port request is enabled\n" +
                        "  --! @param[in] i_dport_write  Debug port Write enable\n" +
                        "  --! @param[in] i_dport_addr   Debug port CSR address\n" +
                        "  --! @param[in] i_dport_wdata  Debug port CSR writing value\n" +
                        "  --! @param[out] o_dport_rdata Debug port CSR read value\n" +
                        "  component CsrRegs is\n" +
                        "  generic (\n" +
                        "    hartid : integer;\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_mret : in std_logic;\n" +
                        "    i_uret : in std_logic;\n" +
                        "    i_sp : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    i_addr : in std_logic_vector(11 downto 0);\n" +
                        "    i_wena : in std_logic;\n" +
                        "    i_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_rdata : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    i_trap_ready : in std_logic;\n" +
                        "    i_ex_pc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_ex_npc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_ex_data_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_ex_data_load_fault : in std_logic;\n" +
                        "    i_ex_data_store_fault : in std_logic;\n" +
                        "    i_ex_data_store_fault_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_ex_instr_load_fault : in std_logic;\n" +
                        "    i_ex_illegal_instr : in std_logic;\n" +
                        "    i_ex_unalign_store : in std_logic;\n" +
                        "    i_ex_unalign_load : in std_logic;\n" +
                        "    i_ex_breakpoint : in std_logic;\n" +
                        "    i_ex_ecall : in std_logic;\n" +
                        "    i_ex_fpu_invalidop : in std_logic;\n" +
                        "    i_ex_fpu_divbyzero : in std_logic;\n" +
                        "    i_ex_fpu_overflow : in std_logic;\n" +
                        "    i_ex_fpu_underflow : in std_logic;\n" +
                        "    i_ex_fpu_inexact : in std_logic;\n" +
                        "    i_fpu_valid : in std_logic;\n" +
                        "    i_irq_external : in std_logic;\n" +
                        "    o_trap_valid : out std_logic;\n" +
                        "    o_trap_pc : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_break_mode : in std_logic;\n" +
                        "    o_break_event : out std_logic;\n" +
                        "    i_dport_ena : in std_logic;\n" +
                        "    i_dport_write : in std_logic;\n" +
                        "    i_dport_addr : in std_logic_vector(11 downto 0);\n" +
                        "    i_dport_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_dport_rdata : out std_logic_vector(RISCV_ARCH-1 downto 0)\n" +
                        "  );\n" +
                        "  end component; \n" +
                        "\n" +
                        "  --! @param[in] i_clk CPU clock\n" +
                        "  --! @param[in] i_nrst Reset. Active LOW.\n" +
                        "  --! @param[in] i_any_hold Hold pipeline by any reason\n" +
                        "  --! @param[in] i_f_valid Fetch input valid\n" +
                        "  --! @param[in] i_f_pc Fetched pc\n" +
                        "  --! @param[in] i_f_instr Fetched instruction value\n" +
                        "  --! @param[in] i_instr_load_fault Instruction fetched from fault address\n" +
                        "  --! @param[out] o_valid Current output values are valid\n" +
                        "  --! @param[out] o_pc Current instruction pointer value\n" +
                        "  --! @param[out] o_instr Current instruction value\n" +
                        "  --! @param[out] o_memop_store Store to memory operation\n" +
                        "  --! @param[out] o_memop_load Load from memoru operation\n" +
                        "  --! @param[out] o_memop_sign_ext Load memory value with sign extending\n" +
                        "  --! @param[out] o_memop_size Memory transaction size\n" +
                        "  --! @param[out] o_rv32 32-bits instruction\n" +
                        "  --! @param[out] o_f64  64-bits FPU (D-extension)\n" +
                        "  --! @param[out] o_compressed 16-bits instruction (C-extension)\n" +
                        "  --! @param[out] o_insigned_op Unsigned operands\n" +
                        "  --! @param[out] o_isa_type Instruction format accordingly with ISA\n" +
                        "  --! @param[out] o_instr_vec One bit per decoded instruction bus\n" +
                        "  --! @param[out] o_exception Unimplemented instruction\n" +
                        "  --! @param[out] o_instr_load_fault Instruction fetched from fault address\n" +
                        "  component InstrDecoder is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk  : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_any_hold : in std_logic;\n" +
                        "    i_f_valid : in std_logic;\n" +
                        "    i_f_pc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_f_instr : in std_logic_vector(31 downto 0);\n" +
                        "    i_instr_load_fault : in std_logic;\n" +
                        "    o_valid : out std_logic;\n" +
                        "    o_pc : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_instr : out std_logic_vector(31 downto 0);\n" +
                        "    o_memop_store : out std_logic;\n" +
                        "    o_memop_load : out std_logic;\n" +
                        "    o_memop_sign_ext : out std_logic;\n" +
                        "    o_memop_size : out std_logic_vector(1 downto 0);\n" +
                        "    o_rv32 : out std_logic;\n" +
                        "    o_f64 : out std_logic;\n" +
                        "    o_compressed : out std_logic;\n" +
                        "    o_unsigned_op : out std_logic;\n" +
                        "    o_isa_type : out std_logic_vector(ISA_Total-1 downto 0);\n" +
                        "    o_instr_vec : out std_logic_vector(Instr_Total-1 downto 0);\n" +
                        "    o_exception : out std_logic;\n" +
                        "    o_instr_load_fault : out std_logic\n" +
                        "  );\n" +
                        "  end component; \n" +
                        "\n" +
                        "\n" +
                        "  --! @param[in] i_clk  \n" +
                        "  --! @param[in] i_nrst Reset active LOW\n" +
                        "  --! @param[in] i_pipeline_hold Hold execution by any reason\n" +
                        "  --! @param[in] i_d_valid Decoded instruction is valid\n" +
                        "  --! @param[in] i_d_pc Instruction pointer on decoded instruction\n" +
                        "  --! @param[in] i_d_instr Decoded instruction value\n" +
                        "  --! @param[in] i_wb_done write back done (Used to clear hazardness)\n" +
                        "  --! @param[in] i_memop_store Store to memory operation\n" +
                        "  --! @param[in] i_memop_load Load from memoru operation\n" +
                        "  --! @param[in] i_memop_sign_ext Load memory value with sign extending\n" +
                        "  --! @param[in] i_memop_size Memory transaction size\n" +
                        "  --! @param[in] i_unsigned_op Unsigned operands\n" +
                        "  --! @param[in] i_rv32 32-bits instruction\n" +
                        "  --! @param[in] i_compressed 16-bits instruction (C-extension)\n" +
                        "  --! @param[in] i_f64        D-extension (FPU)\n" +
                        "  --! @param[in] i_isa_type   Type of the instruction's structure (ISA spec.)\n" +
                        "  --! @param[in] i_break_mode        Behaviour on EBREAK instruction: 0 = halt; 1 = generate trap\n" +
                        "  --! @param[in] i_unsup_exception   Unsupported instruction exception\n" +
                        "  --! @param[in] i_instr_load_fault  Instruction fetched from fault address\n" +
                        "  --! @param[in] i_ext_irq           External interrupt from PLIC (todo: timer & software interrupts)\n" +
                        "  --! @param[in] i_dport_npc_write   Write npc value from debug port\n" +
                        "  --! @param[in] i_dport_npc         Debug port npc value to write\n" +
                        "  --! @param[out] o_radr1 Integer/float register index 1\n" +
                        "  --! @param[in] i_rdata1 Integer register value 1\n" +
                        "  --! @param[out] o_radr2 Integer/float register index 2\n" +
                        "  --! @param[in] i_rdata2 Integer register value 2\n" +
                        "  --! @param[in] i_rfdata1   Float register value 1\n" +
                        "  --! @param[in] i_rfdata2   Float register value 2\n" +
                        "  --! @param[out] o_res_addr Address to store result of the instruction (0=do not store)\n" +
                        "  --! @param[out] o_res_data Value to store\n" +
                        "  --! @param[out] o_pipeline_hold Hold pipeline while 'writeback' not done or multi-clock instruction.\n" +
                        "  --! @param[out] o_csr_addr CSR address. 0 if not a CSR instruction with xret signals mode switching\n" +
                        "  --! @param[out] o_csr_wena Write new CSR value\n" +
                        "  --! @param[in] i_csr_rdata CSR current value\n" +
                        "  --! @param[out] o_csr_wdata CSR new value\n" +
                        "  --! @param[out] o_ex_npc    exception npc\n" +
                        "  --! @param[out] o_ex_instr_load_fault Instruction fetched from fault address\n" +
                        "  --! @param[out] o_ex_illegal_instr Exception: illegal instruction\n" +
                        "  --! @param[out] o_ex_unalign_store Exception: Unaligned store\n" +
                        "  --! @param[out] o_ex_unalign_load  Exception: Unaligned load\n" +
                        "  --! @param[out] o_ex_breakpoint    Exception: BREAK\n" +
                        "  --! @param[out] o_ex_ecall         Exception: ECALL\n" +
                        "  --! @param[out] o_ex_fpu_invalidop FPU Exception: invalid operation\n" +
                        "  --! @param[out] o_ex_fpu_divbyzero FPU Exception: divide by zero\n" +
                        "  --! @param[out] o_ex_fpu_overflow  FPU Exception: overflow\n" +
                        "  --! @param[out] o_ex_fpu_underflow FPU Exception: underflow\n" +
                        "  --! @param[out] o_ex_fpu_inexact   FPU Exception: inexact\n" +
                        "  --! @param[out] o_fpu_valid        FPU output is valid\n" +
                        "  --! @param[out] o_memop_sign_ext Load data with sign extending\n" +
                        "  --! @param[out] o_memop_load Load data instruction\n" +
                        "  --! @param[out] o_memop_store Store data instruction\n" +
                        "  --! @param[out] o_memop_size 0=1bytes; 1=2bytes; 2=4bytes; 3=8bytes\n" +
                        "  --! @param[out] o_memop_addr  Memory access address\n" +
                        "  --! @param[out] o_trap_ready  Trap branch request was accepted\n" +
                        "  --! @param[out] o_valid       Output is valid\n" +
                        "  --! @param[out] o_pc          Valid instruction pointer\n" +
                        "  --! @param[out] o_npc         Next instruction pointer. Next decoded pc must match to this value or will be ignored.\n" +
                        "  --! @param[out] o_instr       Valid instruction value\n" +
                        "  --! @param[out] o_call        CALL pseudo instruction detected\n" +
                        "  --! @param[out] o_ret         RET pseudoinstruction detected\n" +
                        "  --! @param[out] o_mret        MRET detected\n" +
                        "  --! @param[out] o_uret        URET detected\n" +
                        "  component InstrExecute is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk  : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_pipeline_hold : in std_logic;\n" +
                        "    i_d_valid : in std_logic;\n" +
                        "    i_d_pc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_d_instr : in std_logic_vector(31 downto 0);\n" +
                        "    i_wb_ready : in std_logic;\n" +
                        "    i_memop_store : in std_logic;\n" +
                        "    i_memop_load : in std_logic;\n" +
                        "    i_memop_sign_ext : in std_logic;\n" +
                        "    i_memop_size : in std_logic_vector(1 downto 0);\n" +
                        "    i_unsigned_op : in std_logic;\n" +
                        "    i_rv32 : in std_logic;\n" +
                        "    i_compressed : in std_logic;\n" +
                        "    i_f64 : in std_logic;\n" +
                        "    i_isa_type : in std_logic_vector(ISA_Total-1 downto 0);\n" +
                        "    i_ivec : in std_logic_vector(Instr_Total-1 downto 0);\n" +
                        "    i_unsup_exception : in std_logic;\n" +
                        "    i_instr_load_fault : in std_logic;\n" +
                        "    i_dport_npc_write : in std_logic;\n" +
                        "    i_dport_npc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_radr1 : out std_logic_vector(5 downto 0);\n" +
                        "    i_rdata1 : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_radr2 : out std_logic_vector(5 downto 0);\n" +
                        "    i_rdata2 : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    i_rfdata1 : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    i_rfdata2 : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_res_addr : out std_logic_vector(5 downto 0);\n" +
                        "    o_res_data : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_pipeline_hold : out std_logic;\n" +
                        "    o_csr_addr : out std_logic_vector(11 downto 0);\n" +
                        "    o_csr_wena : out std_logic;\n" +
                        "    i_csr_rdata : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_csr_wdata : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    i_trap_valid : in std_logic;\n" +
                        "    i_trap_pc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_ex_npc : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_ex_instr_load_fault : out std_logic;\n" +
                        "    o_ex_illegal_instr : out std_logic;\n" +
                        "    o_ex_unalign_store : out std_logic;\n" +
                        "    o_ex_unalign_load : out std_logic;\n" +
                        "    o_ex_breakpoint : out std_logic;\n" +
                        "    o_ex_ecall : out std_logic;\n" +
                        "    o_ex_fpu_invalidop : out std_logic;\n" +
                        "    o_ex_fpu_divbyzero : out std_logic;\n" +
                        "    o_ex_fpu_overflow : out std_logic;\n" +
                        "    o_ex_fpu_underflow : out std_logic;\n" +
                        "    o_ex_fpu_inexact : out std_logic;\n" +
                        "    o_fpu_valid : out std_logic;\n" +
                        "    o_memop_sign_ext : out std_logic;\n" +
                        "    o_memop_load : out std_logic;\n" +
                        "    o_memop_store : out std_logic;\n" +
                        "    o_memop_size : out std_logic_vector(1 downto 0);\n" +
                        "    o_memop_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_trap_ready : out std_logic;\n" +
                        "    o_valid : out std_logic;\n" +
                        "    o_pc : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_npc : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_instr : out std_logic_vector(31 downto 0);\n" +
                        "    o_call : out std_logic;\n" +
                        "    o_ret : out std_logic;\n" +
                        "    o_mret : out std_logic;\n" +
                        "    o_uret : out std_logic\n" +
                        "  );\n" +
                        "  end component; \n" +
                        "\n" +
                        "  --! @param[in] i_clk\n" +
                        "  --! @param[in] i_nrst\n" +
                        "  --! @param[in] i_pipeline_hold\n" +
                        "  --! @param[in] i_mem_ready\n" +
                        "  --! @param[out] o_mem_addr_valid\n" +
                        "  --! @param[out] o_mem_addr\n" +
                        "  --! @param[in] i_mem_data_valid\n" +
                        "  --! @param[in] i_mem_data_addr\n" +
                        "  --! @param[in] i_mem_data\n" +
                        "  --! @param[out] o_mem_ready\n" +
                        "  --! @param[in] i_predict_npc\n" +
                        "  --! @param[out] o_mem_req_fire    Used by branch predictor to form new npc value\n" +
                        "  --! @param[out] o_valid\n" +
                        "  --! @param[out] o_pc\n" +
                        "  --! @param[out] o_instr\n" +
                        "  --! @param[out] o_hold            Hold due no response from icache yet\n" +
                        "  --! @param[in] i_br_fetch_valid   Fetch injection address/instr are valid\n" +
                        "  --! @param[in] i_br_address_fetch Fetch injection address to skip ebreak instruciton only once\n" +
                        "  --! @param[in] i_br_instr_fetch   Real instruction value that was replaced by ebreak\n" +
                        "  component InstrFetch is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk  : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_pipeline_hold : in std_logic;\n" +
                        "    i_mem_req_ready : in std_logic;\n" +
                        "    o_mem_addr_valid : out std_logic;\n" +
                        "    o_mem_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_mem_data_valid : in std_logic;\n" +
                        "    i_mem_data_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_mem_data : in std_logic_vector(31 downto 0);\n" +
                        "    i_mem_load_fault : in std_logic;\n" +
                        "    o_mem_resp_ready : out std_logic;\n" +
                        "    i_predict_npc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "\n" +
                        "    o_mem_req_fire : out std_logic;\n" +
                        "    o_instr_load_fault : out std_logic;\n" +
                        "    o_valid : out std_logic;\n" +
                        "    o_pc : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_instr : out std_logic_vector(31 downto 0);\n" +
                        "    o_hold : out std_logic;\n" +
                        "    i_br_fetch_valid : in std_logic;\n" +
                        "    i_br_address_fetch : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_br_instr_fetch : in std_logic_vector(31 downto 0)\n" +
                        "  );\n" +
                        "  end component; \n" +
                        "\n" +
                        "  --! @param[in] i_clk\n" +
                        "  --! @param[in] i_nrst\n" +
                        "  --! @param[in] i_e_valid Execution stage outputs are valid\n" +
                        "  --! @param[in] i_e_pc Execution stage instruction pointer\n" +
                        "  --! @param[in] i_e_instr Execution stage instruction value\n" +
                        "  --! @param[in] i_res_addr Register address to be written (0=no writing)\n" +
                        "  --! @param[in] i_res_data Register value to be written\n" +
                        "  --! @param[in] i_memop_sign_ext Load data with sign extending (if less than 8 Bytes)\n" +
                        "  --! @param[in] i_memop_load Load data from memory and write to i_res_addr\n" +
                        "  --! @param[in] i_memop_store Store i_res_data value into memory\n" +
                        "  --! @param[in] i_memop_size Encoded memory transaction size in bytes:\n" +
                        "  --!                         0=1B; 1=2B; 2=4B; 3=8B\n" +
                        "  --! @param[in] i_memop_addr Memory access address\n" +
                        "  --! @param[out] o_wena Write enable signal\n" +
                        "  --! @param[out] o_waddr Output register address (0 = x0 = no write)\n" +
                        "  --! @param[out] o_wdata Register value\n" +
                        "  --! @param[in] i_mem_req_read Memory request is acceptable\n" +
                        "  --! @param[out] o_mem_valid Memory request is valid\n" +
                        "  --! @param[out] o_mem_write Memory write request\n" +
                        "  --! @param[out] o_mem_sz Encoded data size in bytes: 0=1B; 1=2B; 2=4B; 3=8B\n" +
                        "  --! @param[out] o_mem_addr Data path requested address\n" +
                        "  --! @param[out] o_mem_data Data path requested data (write transaction)\n" +
                        "  --! @param[in] i_mem_data_valid Data path memory response is valid\n" +
                        "  --! @param[in] i_mem_data_addr Data path memory response address\n" +
                        "  --! @param[in] i_mem_data Data path memory response value\n" +
                        "  --! @param[out] o_mem_resp_ready Data from DCache was accepted\n" +
                        "  --! @param[out] o_hold Hold-on pipeline while memory operation not finished\n" +
                        "  --! @param[out] o_valid Output is valid\n" +
                        "  --! @param[out] o_pc Valid instruction pointer\n" +
                        "  --! @param[out] o_instr Valid instruction value\n" +
                        "  component MemAccess is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk  : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_e_valid : in std_logic;\n" +
                        "    i_e_pc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_e_instr : in std_logic_vector(31 downto 0);\n" +
                        "    i_res_addr : in std_logic_vector(5 downto 0);\n" +
                        "    i_res_data : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    i_memop_sign_ext : in std_logic;\n" +
                        "    i_memop_load : in std_logic;\n" +
                        "    i_memop_store : in std_logic;\n" +
                        "    i_memop_size : in std_logic_vector(1 downto 0);\n" +
                        "    i_memop_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_wena : out std_logic;\n" +
                        "    o_waddr : out std_logic_vector(5 downto 0);\n" +
                        "    o_wdata : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    i_mem_req_ready : in std_logic;\n" +
                        "    o_mem_valid : out std_logic;\n" +
                        "    o_mem_write : out std_logic;\n" +
                        "    o_mem_sz : out std_logic_vector(1 downto 0);\n" +
                        "    o_mem_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_mem_data : out std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    i_mem_data_valid : in std_logic;\n" +
                        "    i_mem_data_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_mem_data : in std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    o_mem_resp_ready : out std_logic;\n" +
                        "    o_hold : out std_logic;\n" +
                        "    o_valid : out std_logic;\n" +
                        "    o_pc : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_instr : out std_logic_vector(31 downto 0)\n" +
                        "  );\n" +
                        "  end component; \n" +
                        "\n" +
                        "  --! @param[in] i_clk CPU clock\n" +
                        "  --! @param[in] i_nrst Reset. Active LOW.\n" +
                        "  --! @param[in] i_radr1 Port 1 read address\n" +
                        "  --! @param[out] o_rdata1 Port 1 read value\n" +
                        "  --! @param[in] i_radr2 Port 2 read address\n" +
                        "  --! @param[out] o_rdata2 Port 2 read value\n" +
                        "  --! @param[in] i_waddr Writing value\n" +
                        "  --! @param[in] i_wena Writing is enabled\n" +
                        "  --! @param[in] i_wdata Writing value\n" +
                        "  --! @param[in] i_dport_addr    Debug port address\n" +
                        "  --! @param[in] i_dport_ena     Debug port is enabled\n" +
                        "  --! @param[in] i_dport_write   Debug port write is enabled\n" +
                        "  --! @param[in] i_dport_wdata   Debug port write value\n" +
                        "  --! @param[out] o_dport_rdata  Debug port read value\n" +
                        "  --! @param[out] o_ra           Return address for branch predictor\n" +
                        "  --! @param[out] o_sp           Stack Pointer for the borders control\n" +
                        "  component RegIntBank is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_radr1 : in std_logic_vector(5 downto 0);\n" +
                        "    o_rdata1 : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    i_radr2 : in std_logic_vector(5 downto 0);\n" +
                        "    o_rdata2 : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    i_waddr : in std_logic_vector(5 downto 0);\n" +
                        "    i_wena : in std_logic;\n" +
                        "    i_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    i_dport_addr : in std_logic_vector(4 downto 0);\n" +
                        "    i_dport_ena : in std_logic;\n" +
                        "    i_dport_write : in std_logic;\n" +
                        "    i_dport_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_dport_rdata : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_ra : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_sp : out std_logic_vector(RISCV_ARCH-1 downto 0)\n" +
                        "  );\n" +
                        "  end component; \n" +
                        "\n" +
                        "  component RegFloatBank is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;                                   -- CPU clock\n" +
                        "    i_nrst : in std_logic;                                  -- Reset. Active LOW.\n" +
                        "\n" +
                        "    i_radr1 : in std_logic_vector(5 downto 0);              -- Port 1 read address\n" +
                        "    o_rdata1 : out std_logic_vector(RISCV_ARCH-1 downto 0); -- Port 1 read value\n" +
                        "\n" +
                        "    i_radr2 : in std_logic_vector(5 downto 0);              -- Port 2 read address\n" +
                        "    o_rdata2 : out std_logic_vector(RISCV_ARCH-1 downto 0); -- Port 2 read value\n" +
                        "\n" +
                        "    i_waddr : in std_logic_vector(5 downto 0);              -- Writing value\n" +
                        "    i_wena : in std_logic;                                  -- Writing is enabled\n" +
                        "    i_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0);   -- Writing value\n" +
                        "\n" +
                        "    i_dport_addr : in std_logic_vector(4 downto 0);         -- Debug port address\n" +
                        "    i_dport_ena : in std_logic;                             -- Debug port is enabled\n" +
                        "    i_dport_write : in std_logic;                           -- Debug port write is enabled\n" +
                        "    i_dport_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0); -- Debug port write value\n" +
                        "    o_dport_rdata : out std_logic_vector(RISCV_ARCH-1 downto 0)-- Debug port read value\n" +
                        "  );\n" +
                        "  end component; \n" +
                        "\n" +
                        "  --! @param[in] i_clk            CPU clock\n" +
                        "  --! @param[in] i_nrst           Reset. Active LOW.\n" +
                        "  --! @param[in] i_dport_valid    Debug access from DSU is valid\n" +
                        "  --! @param[in] i_dport_write    Write command flag\n" +
                        "  --! @param[in] i_dport_region   Registers region ID: 0=CSR; 1=IREGS; 2=Control\n" +
                        "  --! @param[in] i_dport_addr     Register idx\n" +
                        "  --! @param[in] i_dport_wdata    Write value\n" +
                        "  --! @param[out] o_dport_ready   Response is ready\n" +
                        "  --! @param[out] o_dport_rdata   Response value\n" +
                        "  --! @param[out] o_core_addr     Address of the sub-region register\n" +
                        "  --! @param[out] o_core_wdata    Write data\n" +
                        "  --! @param[out] o_csr_ena       Region 0: Access to CSR bank is enabled.\n" +
                        "  --! @param[out] o_csr_write     Region 0: CSR write enable\n" +
                        "  --! @param[in] i_csr_rdata      Region 0: CSR read value\n" +
                        "  --! @param[out] o_ireg_ena      Region 1: Access to integer register bank is enabled\n" +
                        "  --! @param[out] o_ireg_write    Region 1: Integer registers bank write pulse\n" +
                        "  --! @param[out] o_freg_ena      Region 1: Access to float register bank is enabled\n" +
                        "  --! @param[out] o_freg_write    Region 1: Float registers bank write pulse\n" +
                        "  --! @param[out] o_npc_write     Region 1: npc write enable\n" +
                        "  --! @param[in] i_ireg_rdata     Region 1: Integer register read value\n" +
                        "  --! @param[in] i_freg_rdata  Region 1: Float register read value\n" +
                        "  --! @param[in] i_pc             Region 1: Instruction pointer\n" +
                        "  --! @param[in] i_npc            Region 1: Next Instruction pointer\n" +
                        "  --! @param[in] i_e_valid        Stepping control signal\n" +
                        "  --! @param[in] i_e_call         Pseudo-instruction CALL\n" +
                        "  --! @param[in] i_e_ret          Pseudo-instruction RET\n" +
                        "  --! @param[in] i_m_valid        To compute number of valid executed instruction\n" +
                        "  --! @param[out] o_clock_cnt     Number of clocks excluding halt state\n" +
                        "  --! @param[out] o_executed_cnt  Number of executed instructions\n" +
                        "  --! @param[out] o_halt          Halt signal is equal to hold pipeline\n" +
                        "  --! @param[in] i_ebreak            ebreak instruction decoded\n" +
                        "  --! @param[out] o_break_mode       Behaviour on EBREAK instruction: 0 = halt; 1 = generate trap\n" +
                        "  --! @param[out] o_br_fetch_valid   Fetch injection address/instr are valid\n" +
                        "  --! @param[out] o_br_address_fetch Fetch injection address to skip ebreak instruciton only once\n" +
                        "  --! @param[out] o_br_instr_fetch   Real instruction value that was replaced by ebreak\n" +
                        "  --! @param[out] o_flush_address    Address of instruction to remove from ICache\n" +
                        "  --! @param[out] o_flush_valid      Remove address from ICache is valid\n" +
                        "  --! @param[in] i_istate            ICache state machine value\n" +
                        "  --! @param[in] i_dstate            DCache state machine value\n" +
                        "  component DbgPort is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_dport_valid : in std_logic;\n" +
                        "    i_dport_write : in std_logic;\n" +
                        "    i_dport_region : in std_logic_vector(1 downto 0);\n" +
                        "    i_dport_addr : in std_logic_vector(11 downto 0);\n" +
                        "    i_dport_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_dport_ready : out std_logic;\n" +
                        "    o_dport_rdata : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_core_addr : out std_logic_vector(11 downto 0);\n" +
                        "    o_core_wdata : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_csr_ena : out std_logic;\n" +
                        "    o_csr_write : out std_logic;\n" +
                        "    i_csr_rdata : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_ireg_ena : out std_logic;\n" +
                        "    o_ireg_write : out std_logic;\n" +
                        "    o_freg_ena : out std_logic;\n" +
                        "    o_freg_write : out std_logic;\n" +
                        "    o_npc_write : out std_logic;\n" +
                        "    i_ireg_rdata : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    i_freg_rdata : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    i_pc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_npc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_e_valid : in std_logic;\n" +
                        "    i_e_call : in std_logic;\n" +
                        "    i_e_ret : in std_logic;\n" +
                        "    i_m_valid : in std_logic;\n" +
                        "    o_clock_cnt : out std_logic_vector(63 downto 0);\n" +
                        "    o_executed_cnt : out std_logic_vector(63 downto 0);\n" +
                        "    o_halt : out std_logic;\n" +
                        "    i_ebreak : in std_logic;\n" +
                        "    o_break_mode : out std_logic;\n" +
                        "    o_br_fetch_valid : out std_logic;\n" +
                        "    o_br_address_fetch : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_br_instr_fetch : out std_logic_vector(31 downto 0);\n" +
                        "    o_flush_address : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_flush_valid : out std_logic;\n" +
                        "    i_istate : in std_logic_vector(1 downto 0);\n" +
                        "    i_dstate : in std_logic_vector(1 downto 0);\n" +
                        "    i_cstate : in std_logic_vector(1 downto 0)\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "\n" +
                        "  --! @brief CPU 5-stages pipeline top-level\n" +
                        "  --! @param[in] i_clk             CPU clock\n" +
                        "  --! @param[in] i_nrst            Reset. Active LOW.\n" +
                        "  --! @param[in] i_req_ctrl_ready  ICache is ready to accept request\n" +
                        "  --! @param[out] o_req_ctrl_valid Request to ICache is valid\n" +
                        "  --! @param[out] o_req_ctrl_addr  Requesting address to ICache\n" +
                        "  --! @param[in] i_resp_ctrl_valid ICache response is valid\n" +
                        "  --! @param[in] i_resp_ctrl_addr  Response address must be equal to the latest request address\n" +
                        "  --! @param[in] i_resp_ctrl_data  Read value\n" +
                        "  --! @param[out] o_resp_ctrl_ready Response from ICache is accepted\n" +
                        "  --! @param[in] i_req_data_ready  DCache is ready to accept request\n" +
                        "  --! @param[out] o_req_data_valid Request to DCache is valid\n" +
                        "  --! @param[out] o_req_data_write Read/Write transaction\n" +
                        "  --! @param[out] o_req_data_size  Size [Bytes]: 0=1B; 1=2B; 2=4B; 3=8B\n" +
                        "  --! @param[out] o_req_data_addr  Requesting address to DCache\n" +
                        "  --! @param[out] o_req_data_data  Writing value\n" +
                        "  --! @param[in] i_resp_data_valid DCache response is valid\n" +
                        "  --! @param[in] i_resp_data_addr  DCache response address must be equal to the latest request address\n" +
                        "  --! @param[in] i_resp_data_data  Read value\n" +
                        "  --! @param[in] i_resp_data_load_fault Bus response SLVERR or DECERR on read\n" +
                        "  --! @param[in] i_resp_data_store_fault Bus response SLVERR or DECERR on write\n" +
                        "  --! @param[out] o_resp_data_ready Response drom DCache is accepted\n" +
                        "  --! @param[in] i_ext_irq         PLIC interrupt accordingly with spec\n" +
                        "  --! @param[out] o_time           Timer in clock except halt state\n" +
                        "  --! @param[in] i_dport_valid     Debug access from DSU is valid\n" +
                        "  --! @param[in] i_dport_write     Write command flag\n" +
                        "  --! @param[in] i_dport_region    Registers region ID: 0=CSR; 1=IREGS; 2=Control\n" +
                        "  --! @param[in] i_dport_addr      Register idx\n" +
                        "  --! @param[in] i_dport_wdata     Write value\n" +
                        "  --! @param[out] o_dport_ready    Response is ready\n" +
                        "  --! @param[out] o_dport_rdata    Response value\n" +
                        "  --! @param[out] o_flush_address  Address of instruction to remove from ICache\n" +
                        "  --! @param[out] o_flush_valid    Remove address from ICache is valid\n" +
                        "  --! @param[in] i_istate          ICache state machine value\n" +
                        "  --! @param[in] i_dstate          DCache state machine value\n" +
                        "  --! @param[in] i_cstate          cachetop state machine value\n" +
                        "  component Processor is\n" +
                        "  generic (\n" +
                        "    hartid : integer;\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_req_ctrl_ready : in std_logic;\n" +
                        "    o_req_ctrl_valid : out std_logic;\n" +
                        "    o_req_ctrl_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_resp_ctrl_valid : in std_logic;\n" +
                        "    i_resp_ctrl_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_resp_ctrl_data : in std_logic_vector(31 downto 0);\n" +
                        "    i_resp_ctrl_load_fault : in std_logic;\n" +
                        "    o_resp_ctrl_ready : out std_logic;\n" +
                        "    i_req_data_ready : in std_logic;\n" +
                        "    o_req_data_valid : out std_logic;\n" +
                        "    o_req_data_write : out std_logic;\n" +
                        "    o_req_data_size : out std_logic_vector(1 downto 0);\n" +
                        "    o_req_data_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_req_data_data : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    i_resp_data_valid : in std_logic;\n" +
                        "    i_resp_data_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_resp_data_data : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    i_resp_data_load_fault : in std_logic;\n" +
                        "    i_resp_data_store_fault : in std_logic;\n" +
                        "    i_resp_data_store_fault_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_resp_data_ready : out std_logic;\n" +
                        "    i_ext_irq : in std_logic;\n" +
                        "    o_time : out std_logic_vector(63 downto 0);\n" +
                        "    i_dport_valid : in std_logic;\n" +
                        "    i_dport_write : in std_logic;\n" +
                        "    i_dport_region : in std_logic_vector(1 downto 0);\n" +
                        "    i_dport_addr : in std_logic_vector(11 downto 0);\n" +
                        "    i_dport_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_dport_ready : out std_logic;\n" +
                        "    o_dport_rdata : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_halted : out std_logic;\n" +
                        "    o_flush_address : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_flush_valid : out std_logic;\n" +
                        "    i_istate : in std_logic_vector(1 downto 0);\n" +
                        "    i_dstate : in std_logic_vector(1 downto 0);\n" +
                        "    i_cstate : in std_logic_vector(1 downto 0)\n" +
                        "  );\n" +
                        "  end component; \n" +
                        "\n" +
                        "  --! @brief CPU cache top level\n" +
                        "  --! @param[in] i_clk\n" +
                        "  --! @param[in] i_nrst\n" +
                        "  --! @param[in] i_req_ctrl_valid\n" +
                        "  --! @param[in] i_req_ctrl_addr\n" +
                        "  --! @param[out] o_req_ctrl_ready\n" +
                        "  --! @param[out] o_resp_ctrl_valid\n" +
                        "  --! @param[out] o_resp_ctrl_addr\n" +
                        "  --! @param[out] o_resp_ctrl_data\n" +
                        "  --! @param[in] i_resp_ctrl_ready\n" +
                        "  --! @param[out] o_req_data_ready\n" +
                        "  --! @param[in] i_req_data_valid\n" +
                        "  --! @param[in] i_req_data_write\n" +
                        "  --! @param[in] i_req_data_sz\n" +
                        "  --! @param[in] i_req_data_addr\n" +
                        "  --! @param[in] i_req_data_data\n" +
                        "  --! @param[out] o_resp_data_valid\n" +
                        "  --! @param[out] o_resp_data_addr\n" +
                        "  --! @param[out] o_resp_data_data\n" +
                        "  --! @param[out] o_resp_data_load_fault\n" +
                        "  --! @param[out] o_resp_data_store_fault\n" +
                        "  --! @param[in] i_resp_data_ready\n" +
                        "  --! @param[in] i_req_mem_ready      AXI request was accepted\n" +
                        "  --! @param[out] o_req_mem_valid\n" +
                        "  --! @param[out] o_req_mem_write\n" +
                        "  --! @param[out] o_req_mem_addr\n" +
                        "  --! @param[out] o_req_mem_strob\n" +
                        "  --! @param[out] o_req_mem_data\n" +
                        "  --! @param[out] o_req_mem_len        burst length\n" +
                        "  --! @param[out] o_req_mem_burst      burst type: \"00\" FIX; \"01\" INCR; \"10\" WRAP\n" +
                        "  --! @param[in] i_resp_mem_data_valid\n" +
                        "  --! @param[in] i_resp_mem_data\n" +
                        "  --! @param[in] i_resp_mem_load_store\n" +
                        "  --! @param[in] i_resp_mem_store_store\n" +
                        "  --! @param[in] i_flush_address   clear ICache address from debug interface\n" +
                        "  --! @param[in] i_flush_valid     address to clear icache is valid\n" +
                        "  --! @param[out] o_istate        ICache state machine value\n" +
                        "  --! @param[out] o_dstate        DCache state machine value\n" +
                        "  --! @param[out] o_cstate        cachetop state machine value\n" +
                        "  component CacheTop is generic (\n" +
                        "    memtech : integer;\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_req_ctrl_valid : in std_logic;\n" +
                        "    i_req_ctrl_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_req_ctrl_ready : out std_logic;\n" +
                        "    o_resp_ctrl_valid : out std_logic;\n" +
                        "    o_resp_ctrl_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_resp_ctrl_data : out std_logic_vector(31 downto 0);\n" +
                        "    o_resp_ctrl_load_fault : out std_logic;\n" +
                        "    i_resp_ctrl_ready : in std_logic;\n" +
                        "    o_req_data_ready : out std_logic;\n" +
                        "    i_req_data_valid : in std_logic;\n" +
                        "    i_req_data_write : in std_logic;\n" +
                        "    i_req_data_size : in std_logic_vector(1 downto 0);\n" +
                        "    i_req_data_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_req_data_data : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_resp_data_valid : out std_logic;\n" +
                        "    o_resp_data_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_resp_data_data : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_resp_data_load_fault : out std_logic;\n" +
                        "    o_resp_data_store_fault : out std_logic;\n" +
                        "    o_resp_data_store_fault_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_resp_data_ready : in std_logic;\n" +
                        "    i_req_mem_ready : in std_logic;\n" +
                        "    o_req_mem_valid : out std_logic;\n" +
                        "    o_req_mem_write : out std_logic;\n" +
                        "    o_req_mem_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_req_mem_strob : out std_logic_vector(BUS_DATA_BYTES-1 downto 0);\n" +
                        "    o_req_mem_data : out std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    o_req_mem_len : out std_logic_vector(7 downto 0);\n" +
                        "    o_req_mem_burst : out std_logic_vector(1 downto 0);\n" +
                        "    i_resp_mem_data_valid : in std_logic;\n" +
                        "    i_resp_mem_data : in std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    i_resp_mem_load_fault : in std_logic;\n" +
                        "    i_resp_mem_store_fault : in std_logic;\n" +
                        "    i_resp_mem_store_fault_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_flush_address : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_flush_valid : in std_logic;\n" +
                        "    o_istate : out std_logic_vector(1 downto 0);\n" +
                        "    o_dstate : out std_logic_vector(1 downto 0);\n" +
                        "    o_cstate : out std_logic_vector(1 downto 0)\n" +
                        "  );\n" +
                        "  end component; \n" +
                        "\n" +
                        "\n" +
                        "  --! @brief \"River\" CPU Top level.\n" +
                        "  --! @param[in] i_clk                 CPU clock\n" +
                        "  --! @param[in] i_nrst                Reset. Active LOW.\n" +
                        "  --! @param[in] i_req_mem_ready       AXI request was accepted\n" +
                        "  --! @param[out] o_req_mem_valid      AXI memory request is valid\n" +
                        "  --! @param[out] o_req_mem_write      AXI memory request is write type\n" +
                        "  --! @param[out] o_req_mem_addr       AXI memory request address\n" +
                        "  --! @param[out] o_req_mem_strob      Writing strob. 1 bit per Byte\n" +
                        "  --! @param[out] o_req_mem_data       Writing data\n" +
                        "  --! @param[out] o_req_mem_len        burst length\n" +
                        "  --! @param[out] o_req_mem_burst      burst type: \"00\" FIX; \"01\" INCR; \"10\" WRAP\n" +
                        "  --! @param[in] i_resp_mem_data_valid AXI response is valid\n" +
                        "  --! @param[in] i_resp_mem_data       Read data\n" +
                        "  --! @param[in] i_resp_mem_load_fault Bus response with SLVERR or DECERR on read\n" +
                        "  --! @param[in] i_resp_mem_store_fault Bus response with SLVERR or DECERR on write\n" +
                        "  --! @param[in] i_ext_irq             Interrupt line from external interrupts controller (PLIC).\n" +
                        "  --! @param[out] o_time               Timer. Clock counter except halt state.\n" +
                        "  --! @param[in] i_dport_valid         Debug access from DSU is valid\n" +
                        "  --! @param[in] i_dport_write         Write command flag\n" +
                        "  --! @param[in] i_dport_region        Registers region ID: 0=CSR; 1=IREGS; 2=Control\n" +
                        "  --! @param[in] i_dport_addr          Register idx\n" +
                        "  --! @param[in] i_dport_wdata         Write value\n" +
                        "  --! @param[out] o_dport_ready        Response is ready\n" +
                        "  --! @param[out] o_dport_rdata        Response value\n" +
                        "  component RiverTop is\n" +
                        "  generic (\n" +
                        "    memtech : integer := 0;\n" +
                        "    hartid : integer := 0;\n" +
                        "    async_reset : boolean := false\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_req_mem_ready : in std_logic;\n" +
                        "    o_req_mem_valid : out std_logic;\n" +
                        "    o_req_mem_write : out std_logic;\n" +
                        "    o_req_mem_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_req_mem_strob : out std_logic_vector(BUS_DATA_BYTES-1 downto 0);\n" +
                        "    o_req_mem_data : out std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    o_req_mem_len : out std_logic_vector(7 downto 0);\n" +
                        "    o_req_mem_burst : out std_logic_vector(1 downto 0);\n" +
                        "    i_resp_mem_data_valid : in std_logic;\n" +
                        "    i_resp_mem_data : in std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    i_resp_mem_load_fault : in std_logic;\n" +
                        "    i_resp_mem_store_fault : in std_logic;\n" +
                        "    i_resp_mem_store_fault_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_ext_irq : in std_logic;\n" +
                        "    o_time : out std_logic_vector(63 downto 0);\n" +
                        "    i_dport_valid : in std_logic;\n" +
                        "    i_dport_write : in std_logic;\n" +
                        "    i_dport_region : in std_logic_vector(1 downto 0);\n" +
                        "    i_dport_addr : in std_logic_vector(11 downto 0);\n" +
                        "    i_dport_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_dport_ready : out std_logic;\n" +
                        "    o_dport_rdata : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_halted : out std_logic\n" +
                        "  );\n" +
                        "  end component; \n" +
                        "\n" +
                        "end; -- package body";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_river_amba_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2018 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "--! @brief     \"River\" CPU Top level with AXI4 interface.\n" +
                        "------------------------------------------------------------------------------\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "--! AMBA system bus specific library.\n" +
                        "library ambalib;\n" +
                        "--! AXI4 configuration constants.\n" +
                        "use ambalib.types_amba4.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use riverlib.river_cfg.all;\n" +
                        "--! River top level with AMBA interface module declaration\n" +
                        "use riverlib.types_river.all;\n" +
                        "\n" +
                        "entity river_amba is \n" +
                        "  generic (\n" +
                        "    memtech : integer;\n" +
                        "    hartid : integer;\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port ( \n" +
                        "    i_nrst   : in std_logic;\n" +
                        "    i_clk    : in std_logic;\n" +
                        "    i_msti   : in axi4_master_in_type;\n" +
                        "    o_msto   : out axi4_master_out_type;\n" +
                        "    o_mstcfg : out axi4_master_config_type;\n" +
                        "    i_dport  : in dport_in_type;\n" +
                        "    o_dport  : out dport_out_type;\n" +
                        "    i_ext_irq : in std_logic\n" +
                        ");\n" +
                        "end;\n" +
                        " \n" +
                        "architecture arch_river_amba of river_amba is\n" +
                        "\n" +
                        "  constant xconfig : axi4_master_config_type := (\n" +
                        "     descrsize => PNP_CFG_MASTER_DESCR_BYTES,\n" +
                        "     descrtype => PNP_CFG_TYPE_MASTER,\n" +
                        "     vid => VENDOR_GNSSSENSOR,\n" +
                        "     did => RISCV_RIVER_CPU\n" +
                        "  );\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "      reading : std_logic;\n" +
                        "      w_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      w_valid : std_logic;\n" +
                        "      w_last : std_logic;\n" +
                        "      b_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      b_ready : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "      '0', (others => '0'), '0', '0', (others => '0'), '0'\n" +
                        "  );\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "\n" +
                        "  signal w_req_mem_ready : std_logic;\n" +
                        "  signal w_req_mem_valid : std_logic;\n" +
                        "  signal w_req_mem_write : std_logic;\n" +
                        "  signal wb_req_mem_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "  signal wb_req_mem_strob : std_logic_vector(BUS_DATA_BYTES-1 downto 0);\n" +
                        "  signal wb_req_mem_data : std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "  signal wb_req_mem_len : std_logic_vector(7 downto 0);\n" +
                        "  signal wb_req_mem_burst : std_logic_vector(1 downto 0);\n" +
                        "  signal w_resp_mem_data_valid : std_logic;\n" +
                        "  signal w_resp_mem_load_fault : std_logic;\n" +
                        "  signal w_resp_mem_store_fault : std_logic;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  o_mstcfg <= xconfig;\n" +
                        "  w_resp_mem_data_valid <= i_msti.r_valid or (r.w_valid and i_msti.w_ready);\n" +
                        "  -- Slave response resp = SLVERR (2'b10)\n" +
                        "  -- Interconnect response resp = DECERR (2'b11):\n" +
                        "  w_resp_mem_load_fault <= r.reading and i_msti.r_valid and i_msti.r_resp(1);\n" +
                        "  w_resp_mem_store_fault <= r.b_ready and i_msti.b_valid and i_msti.b_resp(1);\n" +
                        "  \n" +
                        "  river0 : RiverTop  generic map (\n" +
                        "      memtech => memtech,\n" +
                        "      hartid => hartid,\n" +
                        "      async_reset => async_reset\n" +
                        "    ) port map (\n" +
                        "      i_clk => i_clk,\n" +
                        "      i_nrst => i_nrst,\n" +
                        "      i_req_mem_ready => w_req_mem_ready,\n" +
                        "      o_req_mem_valid => w_req_mem_valid,\n" +
                        "      o_req_mem_write => w_req_mem_write,\n" +
                        "      o_req_mem_addr => wb_req_mem_addr,\n" +
                        "      o_req_mem_strob => wb_req_mem_strob,\n" +
                        "      o_req_mem_data => wb_req_mem_data,\n" +
                        "      o_req_mem_len => wb_req_mem_len,\n" +
                        "      o_req_mem_burst => wb_req_mem_burst,\n" +
                        "      i_resp_mem_data_valid => w_resp_mem_data_valid,\n" +
                        "      i_resp_mem_data => i_msti.r_data,\n" +
                        "      i_resp_mem_load_fault => w_resp_mem_load_fault,\n" +
                        "      i_resp_mem_store_fault => w_resp_mem_store_fault,\n" +
                        "      i_resp_mem_store_fault_addr => r.b_addr,\n" +
                        "      i_ext_irq => i_ext_irq,\n" +
                        "      o_time => open,\n" +
                        "      i_dport_valid => i_dport.valid,\n" +
                        "      i_dport_write => i_dport.write,\n" +
                        "      i_dport_region => i_dport.region,\n" +
                        "      i_dport_addr => i_dport.addr,\n" +
                        "      i_dport_wdata => i_dport.wdata,\n" +
                        "      o_dport_ready => o_dport.ready,\n" +
                        "      o_dport_rdata => o_dport.rdata,\n" +
                        "      o_halted => o_dport.halted\n" +
                        ");\n" +
                        "\n" +
                        "  comb : process(i_nrst, w_req_mem_valid, w_req_mem_write, wb_req_mem_addr,\n" +
                        "                 wb_req_mem_strob, wb_req_mem_data, wb_req_mem_len,\n" +
                        "                 wb_req_mem_burst, i_msti, r)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable vmsto : axi4_master_out_type;\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    vmsto := axi4_master_out_none;\n" +
                        "    vmsto.ar_valid      := w_req_mem_valid and not w_req_mem_write;\n" +
                        "    vmsto.ar_bits.addr  := wb_req_mem_addr;\n" +
                        "    vmsto.ar_bits.len   := wb_req_mem_len;\n" +
                        "    vmsto.ar_user       := '0';\n" +
                        "    vmsto.ar_id         := conv_std_logic_vector(0, CFG_ROCKET_ID_BITS);\n" +
                        "    vmsto.ar_bits.size  := \"011\"; -- 8 bytes\n" +
                        "    vmsto.ar_bits.burst := wb_req_mem_burst;\n" +
                        "\n" +
                        "    vmsto.aw_valid      := w_req_mem_valid and w_req_mem_write;\n" +
                        "    vmsto.aw_bits.addr  := wb_req_mem_addr;\n" +
                        "    vmsto.aw_bits.len   := wb_req_mem_len;\n" +
                        "    vmsto.aw_user       := '0';\n" +
                        "    vmsto.aw_id         := conv_std_logic_vector(0, CFG_ROCKET_ID_BITS);\n" +
                        "    vmsto.aw_bits.size  := \"011\"; -- 8 bytes\n" +
                        "    vmsto.aw_bits.burst := wb_req_mem_burst;\n" +
                        "\n" +
                        "    vmsto.w_valid := r.w_valid;\n" +
                        "    vmsto.w_last := r.w_last;\n" +
                        "    vmsto.w_strb := wb_req_mem_strob;\n" +
                        "    vmsto.w_data := wb_req_mem_data;\n" +
                        "\n" +
                        "    vmsto.b_ready := r.b_ready;\n" +
                        "    vmsto.r_ready := '1';\n" +
                        "\n" +
                        "    if (w_req_mem_valid and not w_req_mem_write and i_msti.ar_ready) = '1' then\n" +
                        "        v.reading := '1';\n" +
                        "    elsif i_msti.r_valid = '1' and i_msti.r_last = '1' then\n" +
                        "        v.reading := '0';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if (w_req_mem_valid and w_req_mem_write and i_msti.aw_ready) = '1' then\n" +
                        "        v.w_addr := wb_req_mem_addr;\n" +
                        "        v.w_valid := '1';\n" +
                        "        v.w_last := '1';\n" +
                        "    elsif i_msti.w_ready = '1' then\n" +
                        "        v.w_valid := '0';\n" +
                        "        v.w_last := '0';\n" +
                        "    end if;\n" +
                        "    \n" +
                        "    if (r.w_valid and i_msti.w_ready) = '1' then\n" +
                        "        v.b_addr := r.w_addr;\n" +
                        "        v.b_ready := '1';\n" +
                        "    elsif i_msti.b_valid = '1' then\n" +
                        "        v.b_ready := '0';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    rin <= v;\n" +
                        "    o_msto <= vmsto;\n" +
                        "    w_req_mem_ready <= (w_req_mem_write and i_msti.aw_ready)\n" +
                        "                    or (not w_req_mem_write and i_msti.ar_ready);\n" +
                        "  end process;\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(i_clk, i_nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_types_cache_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "--! Standard library\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "library riverlib;\n" +
                        "use riverlib.river_cfg.all;\n" +
                        "\n" +
                        "package types_cache is\n" +
                        "\n" +
                        "  --! ICacheLru config\n" +
                        "  constant CFG_IOFFSET_WIDTH   : integer := 5;    -- [4:0]  log2(ICACHE_LINE_BYTES)\n" +
                        "  constant CFG_IODDEVEN_WIDTH  : integer := 1;    -- [5]    0=even; 1=odd\n" +
                        "  constant CFG_ICACHE_WAYS     : integer := 4;    -- 4 odds, 4 even\n" +
                        "\n" +
                        "  constant CFG_ILINES_PER_WAY : integer := 2**CFG_IINDEX_WIDTH;\n" +
                        "  -- [31:14] tag when 64 KB\n" +
                        "  -- [31:13] tag when 32 KB\n" +
                        "  -- [31:12] tag when 16 KB\n" +
                        "  constant CFG_ITAG_WIDTH : integer := BUS_ADDR_WIDTH\n" +
                        "    - (CFG_IOFFSET_WIDTH + CFG_IODDEVEN_WIDTH + CFG_IINDEX_WIDTH);\n" +
                        "\n" +
                        "  --! Store tag data as:\n" +
                        "  --!     [3:0]            qword is valid flag\n" +
                        "  --!     [4]              load_fault\n" +
                        "  --!     [ITAG_WIDTH+5:5] tag value\n" +
                        "  constant CFG_ITAG_WIDTH_TOTAL : integer := CFG_ITAG_WIDTH + 5;\n" +
                        "\n" +
                        "\n" +
                        "  constant IINDEX_START : integer := CFG_IOFFSET_WIDTH + CFG_IODDEVEN_WIDTH;\n" +
                        "  constant IINDEX_END : integer := IINDEX_START + CFG_IINDEX_WIDTH - 1;\n" +
                        "\n" +
                        "  constant ITAG_START : integer := IINDEX_START + CFG_IINDEX_WIDTH;\n" +
                        "  constant ITAG_END : integer := BUS_ADDR_WIDTH-1;\n" +
                        "\n" +
                        "  component IWayMem is generic (\n" +
                        "    memtech : integer := 0;\n" +
                        "    async_reset : boolean;\n" +
                        "    wayidx : integer\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_radr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_wadr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_wena : in std_logic;\n" +
                        "    i_wstrb : in std_logic_vector(3 downto 0);\n" +
                        "    i_wvalid : in std_logic_vector(3 downto 0);\n" +
                        "    i_wdata : in std_logic_vector(63 downto 0);\n" +
                        "    i_load_fault : in std_logic;\n" +
                        "    o_rtag : out std_logic_vector(CFG_ITAG_WIDTH-1 downto 0);\n" +
                        "    o_rdata : out std_logic_vector(31 downto 0);\n" +
                        "    o_valid : out std_logic;\n" +
                        "    o_load_fault : out std_logic\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "  component ILru is port (\n" +
                        "    i_clk : in std_logic;\n" +
                        "    i_init : in std_logic;\n" +
                        "    i_radr : in std_logic_vector(CFG_IINDEX_WIDTH-1 downto 0);\n" +
                        "    i_wadr : in std_logic_vector(CFG_IINDEX_WIDTH-1 downto 0);\n" +
                        "    i_we : in std_logic;\n" +
                        "    i_lru : in std_logic_vector(1 downto 0);\n" +
                        "    o_lru : out std_logic_vector(1 downto 0)\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_iwaymem_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "library techmap;\n" +
                        "use techmap.types_mem.all;\n" +
                        "library riverlib;\n" +
                        "use riverlib.river_cfg.all;\n" +
                        "use riverlib.types_cache.all;\n" +
                        "\n" +
                        "entity IWayMem is generic (\n" +
                        "    memtech : integer := 0;\n" +
                        "    async_reset : boolean;\n" +
                        "    wayidx : integer\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_radr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_wadr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_wena : in std_logic;\n" +
                        "    i_wstrb : in std_logic_vector(3 downto 0);\n" +
                        "    i_wvalid : in std_logic_vector(3 downto 0);\n" +
                        "    i_wdata : in std_logic_vector(63 downto 0);\n" +
                        "    i_load_fault : in std_logic;\n" +
                        "    o_rtag : out std_logic_vector(CFG_ITAG_WIDTH-1 downto 0);\n" +
                        "    o_rdata : out std_logic_vector(31 downto 0);\n" +
                        "    o_valid : out std_logic;\n" +
                        "    o_load_fault : out std_logic\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_IWayMem of IWayMem is\n" +
                        "\n" +
                        "  constant RAM64_BLOCK_TOTAL : integer := (2**CFG_IOFFSET_WIDTH) / 8;\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "      roffset : std_logic_vector(CFG_IOFFSET_WIDTH-2 downto 0);  -- 2-bytes alignment\n" +
                        "  end record;\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "\n" +
                        "  signal datan : std_logic_vector(64*RAM64_BLOCK_TOTAL-1 downto 0);\n" +
                        "  signal wb_radr : std_logic_vector(CFG_IINDEX_WIDTH-1 downto 0);\n" +
                        "  signal wb_wadr : std_logic_vector(CFG_IINDEX_WIDTH-1 downto 0);\n" +
                        "\n" +
                        "  signal wb_tag_rdata : std_logic_vector(CFG_ITAG_WIDTH_TOTAL-1 downto 0);\n" +
                        "  signal w_tag_wena : std_logic;\n" +
                        "  signal wb_tag_wdata : std_logic_vector(CFG_ITAG_WIDTH_TOTAL-1 downto 0);\n" +
                        "\n" +
                        "  signal wb_data_rdata : std_logic_vector(64*RAM64_BLOCK_TOTAL-1 downto 0);\n" +
                        "  signal w_data_wena : std_logic_vector(RAM64_BLOCK_TOTAL-1 downto 0);\n" +
                        "\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  sp : if CFG_SINGLEPORT_CACHE generate\n" +
                        "    tag0 : ram_tech generic map (\n" +
                        "      memtech => memtech,\n" +
                        "      abits => CFG_IINDEX_WIDTH,\n" +
                        "      dbits => CFG_ITAG_WIDTH_TOTAL\n" +
                        "    ) port map (\n" +
                        "      i_clk => i_clk,\n" +
                        "      i_addr => wb_radr,\n" +
                        "      o_rdata => wb_tag_rdata,\n" +
                        "      i_wena => w_tag_wena,\n" +
                        "      i_wdata => wb_tag_wdata\n" +
                        "    );\n" +
                        "\n" +
                        "    dx : for n in 0 to RAM64_BLOCK_TOTAL-1 generate\n" +
                        "      data0 : ram_tech generic map (\n" +
                        "        memtech => memtech,\n" +
                        "        abits => CFG_IINDEX_WIDTH,\n" +
                        "        dbits => 64\n" +
                        "      ) port map (\n" +
                        "        i_clk => i_clk,\n" +
                        "        i_addr => wb_radr,\n" +
                        "        o_rdata => wb_data_rdata(64*(n+1)-1 downto 64*n),\n" +
                        "        i_wena => w_data_wena(n),\n" +
                        "        i_wdata => i_wdata\n" +
                        "      );\n" +
                        "    end generate;\n" +
                        "  end generate;\n" +
                        "\n" +
                        "  dp : if not CFG_SINGLEPORT_CACHE generate\n" +
                        "    tag0 : dpram_tech generic map (\n" +
                        "      memtech => memtech,\n" +
                        "      abits => CFG_IINDEX_WIDTH,\n" +
                        "      dbits => CFG_ITAG_WIDTH_TOTAL\n" +
                        "    ) port map (\n" +
                        "      i_clk => i_clk,\n" +
                        "      i_raddr => wb_radr,\n" +
                        "      o_rdata => wb_tag_rdata,\n" +
                        "      i_waddr => wb_wadr,\n" +
                        "      i_wena => w_tag_wena,\n" +
                        "      i_wdata => wb_tag_wdata\n" +
                        "    );\n" +
                        "\n" +
                        "    dx : for n in 0 to RAM64_BLOCK_TOTAL-1 generate\n" +
                        "      data0 : dpram_tech generic map (\n" +
                        "        memtech => memtech,\n" +
                        "        abits => CFG_IINDEX_WIDTH,\n" +
                        "        dbits => 64\n" +
                        "      ) port map (\n" +
                        "        i_clk => i_clk,\n" +
                        "        i_raddr => wb_radr,\n" +
                        "        o_rdata => wb_data_rdata(64*(n+1)-1 downto 64*n),\n" +
                        "        i_waddr => wb_wadr,\n" +
                        "        i_wena => w_data_wena(n),\n" +
                        "        i_wdata => i_wdata\n" +
                        "      );\n" +
                        "    end generate;\n" +
                        "  end generate;\n" +
                        "\n" +
                        "  comb : process(i_nrst, i_radr, i_wadr, i_wena, i_wstrb, i_wvalid,\n" +
                        "                 i_wdata, i_load_fault, wb_tag_rdata, wb_data_rdata, r)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable vb_rdata : std_logic_vector(31 downto 0);\n" +
                        "    variable v_valid : std_logic;\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    wb_radr <= i_radr(IINDEX_END downto IINDEX_START);\n" +
                        "    wb_wadr <= i_wadr(IINDEX_END downto IINDEX_START);\n" +
                        "\n" +
                        "    w_tag_wena <= i_wena;\n" +
                        "    wb_tag_wdata <= i_wadr(ITAG_END downto ITAG_START) &\n" +
                        "                   i_load_fault &     -- [4]\n" +
                        "                   i_wvalid;          -- [3:0]\n" +
                        "\n" +
                        "    w_data_wena <= (i_wena & i_wena & i_wena & i_wena) and i_wstrb;\n" +
                        "\n" +
                        "    v_valid := '0';\n" +
                        "    v.roffset := i_radr(CFG_IOFFSET_WIDTH-1 downto 1);\n" +
                        "    case r.roffset is\n" +
                        "    when X\"0\" =>\n" +
                        "        vb_rdata := wb_data_rdata(31 downto 0);\n" +
                        "        v_valid := wb_tag_rdata(0);\n" +
                        "    when X\"1\" =>\n" +
                        "        vb_rdata := wb_data_rdata(47 downto 16);\n" +
                        "        v_valid := wb_tag_rdata(0);\n" +
                        "    when X\"2\" =>\n" +
                        "        vb_rdata := wb_data_rdata(63 downto 32);\n" +
                        "        v_valid := wb_tag_rdata(0);\n" +
                        "    when X\"3\" =>\n" +
                        "        vb_rdata := wb_data_rdata(79 downto 48);\n" +
                        "        v_valid := wb_tag_rdata(0) and wb_tag_rdata(1);\n" +
                        "    when X\"4\" =>\n" +
                        "        vb_rdata := wb_data_rdata(95 downto 64);\n" +
                        "        v_valid := wb_tag_rdata(1);\n" +
                        "    when X\"5\" =>\n" +
                        "        vb_rdata := wb_data_rdata(111 downto 80);\n" +
                        "        v_valid := wb_tag_rdata(1);\n" +
                        "    when X\"6\" =>\n" +
                        "        vb_rdata := wb_data_rdata(127 downto 96);\n" +
                        "        v_valid := wb_tag_rdata(1);\n" +
                        "    when X\"7\" =>\n" +
                        "        vb_rdata := wb_data_rdata(143 downto 112);\n" +
                        "        v_valid := wb_tag_rdata(1) and wb_tag_rdata(2);\n" +
                        "    when X\"8\" =>\n" +
                        "        vb_rdata := wb_data_rdata(159 downto 128);\n" +
                        "        v_valid := wb_tag_rdata(2);\n" +
                        "    when X\"9\" =>\n" +
                        "        vb_rdata := wb_data_rdata(175 downto 144);\n" +
                        "        v_valid := wb_tag_rdata(2);\n" +
                        "    when X\"A\" =>\n" +
                        "        vb_rdata := wb_data_rdata(191 downto 160);\n" +
                        "        v_valid := wb_tag_rdata(2);\n" +
                        "    when X\"B\" =>\n" +
                        "        vb_rdata := wb_data_rdata(207 downto 176);\n" +
                        "        v_valid := wb_tag_rdata(2) and wb_tag_rdata(3);\n" +
                        "    when X\"C\" =>\n" +
                        "        vb_rdata := wb_data_rdata(223 downto 192);\n" +
                        "        v_valid := wb_tag_rdata(3);\n" +
                        "    when X\"D\" =>\n" +
                        "        vb_rdata := wb_data_rdata(239 downto 208);\n" +
                        "        v_valid := wb_tag_rdata(3);\n" +
                        "    when X\"E\" =>\n" +
                        "        vb_rdata := wb_data_rdata(255 downto 224);\n" +
                        "        v_valid := wb_tag_rdata(3);\n" +
                        "    when X\"F\" =>\n" +
                        "        vb_rdata(15 downto 0) := wb_data_rdata(255 downto 240);\n" +
                        "        vb_rdata(31 downto 16) := (others => '0');\n" +
                        "        v_valid := wb_tag_rdata(3);\n" +
                        "    when others =>\n" +
                        "    end case;\n" +
                        "\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v.roffset := (others => '0');\n" +
                        "    end if;\n" +
                        "\n" +
                        "    o_rdata <= vb_rdata;\n" +
                        "    o_rtag <= wb_tag_rdata(CFG_ITAG_WIDTH_TOTAL-1 downto 5);\n" +
                        "    o_valid <= v_valid;\n" +
                        "    o_load_fault <= wb_tag_rdata(4);\n" +
                        "   \n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(i_clk, i_nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r.roffset <= (others => '0');\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_ilru_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "library riverlib;\n" +
                        "use riverlib.river_cfg.all;\n" +
                        "use riverlib.types_cache.all;\n" +
                        "\n" +
                        "entity ILru is port (\n" +
                        "    i_clk : in std_logic;\n" +
                        "    i_init : in std_logic;\n" +
                        "    i_radr : in std_logic_vector(CFG_IINDEX_WIDTH-1 downto 0);\n" +
                        "    i_wadr : in std_logic_vector(CFG_IINDEX_WIDTH-1 downto 0);\n" +
                        "    i_we : in std_logic;\n" +
                        "    i_lru : in std_logic_vector(1 downto 0);\n" +
                        "    o_lru : out std_logic_vector(1 downto 0)\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_ILru of ILru is\n" +
                        "\n" +
                        "  constant LINES_TOTAL : integer := 2**CFG_IINDEX_WIDTH;\n" +
                        "  type array_type is array (0 to LINES_TOTAL-1) of std_logic_vector(7 downto 0);\n" +
                        "\n" +
                        "  signal radr : std_logic_vector(CFG_IINDEX_WIDTH-1 downto 0);\n" +
                        "  signal tbl : array_type;\n" +
                        "  signal wb_tbl_rdata : std_logic_vector(7 downto 0);\n" +
                        "  signal wb_tbl_wdata : std_logic_vector(7 downto 0);\n" +
                        "  signal w_we : std_logic;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  comb : process(i_init, i_radr, i_wadr, i_we, i_lru, wb_tbl_rdata)\n" +
                        "    variable vb_tbl_wdata : std_logic_vector(7 downto 0);\n" +
                        "    variable v_we : std_logic;\n" +
                        "  begin\n" +
                        "\n" +
                        "    v_we := i_we;\n" +
                        "    if i_init = '1' then\n" +
                        "        v_we := '1';\n" +
                        "        vb_tbl_wdata := X\"E4\";  -- 0x3, 0x2, 0x1, 00\n" +
                        "    elsif i_we = '1' then\n" +
                        "        if wb_tbl_rdata(7 downto 6) = i_lru then\n" +
                        "            vb_tbl_wdata := wb_tbl_rdata;\n" +
                        "        elsif wb_tbl_rdata(5 downto 4) = i_lru then\n" +
                        "            vb_tbl_wdata := i_lru & wb_tbl_rdata(7 downto 6)\n" +
                        "                                  & wb_tbl_rdata(3 downto 0);\n" +
                        "        elsif wb_tbl_rdata(3 downto 2) = i_lru then\n" +
                        "            vb_tbl_wdata := i_lru & wb_tbl_rdata(7 downto 4)\n" +
                        "                                  & wb_tbl_rdata(1 downto 0);\n" +
                        "        else\n" +
                        "            vb_tbl_wdata := i_lru & wb_tbl_rdata(7 downto 2);\n" +
                        "        end if;\n" +
                        "    else\n" +
                        "        vb_tbl_wdata := wb_tbl_rdata;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_we <= v_we;\n" +
                        "    wb_tbl_wdata <= vb_tbl_wdata;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  reg : process (i_clk) begin\n" +
                        "    if rising_edge(i_clk) then \n" +
                        "      radr <= i_radr;\n" +
                        "      if w_we = '1' then\n" +
                        "        tbl(conv_integer(i_wadr)) <= wb_tbl_wdata;\n" +
                        "      end if;\n" +
                        "    end if;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  wb_tbl_rdata <= tbl(conv_integer(radr));\n" +
                        "  o_lru <= wb_tbl_rdata(1 downto 0);\n" +
                        " \n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_icache_lru_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "library riverlib;\n" +
                        "use riverlib.river_cfg.all;\n" +
                        "use riverlib.types_cache.all;\n" +
                        "\n" +
                        "entity ICacheLru is generic (\n" +
                        "    memtech : integer;\n" +
                        "    async_reset : boolean;\n" +
                        "    index_width : integer\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    -- Control path:\n" +
                        "    i_req_ctrl_valid : in std_logic;\n" +
                        "    i_req_ctrl_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_req_ctrl_ready : out std_logic;\n" +
                        "    o_resp_ctrl_valid : out std_logic;\n" +
                        "    o_resp_ctrl_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_resp_ctrl_data : out std_logic_vector(31 downto 0);\n" +
                        "    o_resp_ctrl_load_fault : out std_logic;\n" +
                        "    i_resp_ctrl_ready : in std_logic;\n" +
                        "    -- Memory interface:\n" +
                        "    i_req_mem_ready : in std_logic;\n" +
                        "    o_req_mem_valid : out std_logic;\n" +
                        "    o_req_mem_write : out std_logic;\n" +
                        "    o_req_mem_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_req_mem_strob : out std_logic_vector(BUS_DATA_BYTES-1 downto 0);\n" +
                        "    o_req_mem_data : out std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    o_req_mem_len : out std_logic_vector(7 downto 0);\n" +
                        "    o_req_mem_burst : out std_logic_vector(1 downto 0);\n" +
                        "    o_req_mem_last : out std_logic;\n" +
                        "    i_resp_mem_data_valid : in std_logic;\n" +
                        "    i_resp_mem_data : in std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    i_resp_mem_load_fault : in std_logic;\n" +
                        "    -- Debug Signals:\n" +
                        "    i_flush_address : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);  -- clear ICache address from debug interface\n" +
                        "    i_flush_valid : in std_logic;                                      -- address to clear icache is valid\n" +
                        "    o_istate : out std_logic_vector(1 downto 0)\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_ICacheLru of ICacheLru is\n" +
                        "\n" +
                        "  constant FLUSH_ALL_ADDR : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0) := X\"FFFF0000\";\n" +
                        "  constant flush_cnt_zero : std_logic_vector(CFG_IINDEX_WIDTH downto 0) := (others => '0');\n" +
                        "\n" +
                        "  constant MISS : integer := CFG_ICACHE_WAYS;\n" +
                        "\n" +
                        "  constant WAY_EVEN : integer := 0;\n" +
                        "  constant WAY_ODD : integer := 1;\n" +
                        "\n" +
                        "  constant State_Idle : std_logic_vector(2 downto 0) := \"000\";\n" +
                        "  constant State_CheckHit : std_logic_vector(2 downto 0) := \"001\";\n" +
                        "  constant State_WaitGrant : std_logic_vector(2 downto 0) := \"010\";\n" +
                        "  constant State_WaitResp : std_logic_vector(2 downto 0) := \"011\";\n" +
                        "  constant State_CheckResp : std_logic_vector(2 downto 0) := \"100\";\n" +
                        "  constant State_SetupReadAdr : std_logic_vector(2 downto 0) := \"101\";\n" +
                        "  constant State_Flush : std_logic_vector(2 downto 0) := \"110\";\n" +
                        "\n" +
                        "  constant offset_ones : std_logic_vector(CFG_IOFFSET_WIDTH-1 downto 1) := (others => '1');\n" +
                        "\n" +
                        "  type TagMemInType is record\n" +
                        "      radr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      wadr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      wstrb : std_logic_vector(3 downto 0);\n" +
                        "      wvalid : std_logic_vector(3 downto 0);\n" +
                        "      wdata : std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "      load_fault : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  type TagMemInVector is array (0 to 1) of TagMemInType;\n" +
                        " \n" +
                        "\n" +
                        "  type TagMemOutType is record\n" +
                        "      rtag : std_logic_vector(CFG_ITAG_WIDTH-1 downto 0);\n" +
                        "      rdata : std_logic_vector(31 downto 0);\n" +
                        "      valid : std_logic;\n" +
                        "      load_fault : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  type TagMemOutVector is array (0 to CFG_ICACHE_WAYS-1) of TagMemOutType;\n" +
                        "\n" +
                        "\n" +
                        "  type WayMuxType is record\n" +
                        "      hit : integer range 0 to CFG_ICACHE_WAYS;\n" +
                        "      rdata : std_logic_vector(31 downto 0);\n" +
                        "      valid : std_logic;\n" +
                        "      load_fault : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  type WayMuxVector is array (0 to 1) of WayMuxType;\n" +
                        "\n" +
                        "\n" +
                        "  type LruInType is record\n" +
                        "      init : std_logic;\n" +
                        "      radr : std_logic_vector(CFG_IINDEX_WIDTH-1 downto 0);\n" +
                        "      wadr : std_logic_vector(CFG_IINDEX_WIDTH-1 downto 0);\n" +
                        "      we : std_logic;\n" +
                        "      lru : std_logic_vector(1 downto 0);\n" +
                        "  end record;\n" +
                        "\n" +
                        "  type LruInVector is array (0 to 1) of LruInType;\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "      requested : std_logic;\n" +
                        "      req_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      req_addr_overlay : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      use_overlay : std_logic;\n" +
                        "      state : std_logic_vector(2 downto 0);\n" +
                        "      req_mem_valid : std_logic;\n" +
                        "      mem_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      burst_cnt : integer range 0 to 3;\n" +
                        "      burst_wstrb : std_logic_vector(3 downto 0);\n" +
                        "      burst_valid : std_logic_vector(3 downto 0);\n" +
                        "      lru_even_wr : std_logic_vector(1 downto 0);\n" +
                        "      lru_odd_wr : std_logic_vector(1 downto 0);\n" +
                        "      req_flush : std_logic;\n" +
                        "      req_flush_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      req_flush_cnt : std_logic_vector(CFG_IINDEX_WIDTH downto 0);\n" +
                        "      flush_cnt : std_logic_vector(CFG_IINDEX_WIDTH downto 0);\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "    '0', (others => '0'), (others => '0'),  -- requested, req_addr, req_addr_overlay\n" +
                        "    '0', State_Flush,                       -- use_overlay, state\n" +
                        "    '0', FLUSH_ALL_ADDR,                    -- req_mem_valid, mem_addr,\n" +
                        "    0, \"1111\", \"0000\",                      -- burst_cnt, burst_wstrb, burst_valid\n" +
                        "    \"00\", \"00\", '0',                        -- lru_even_wr, lru_odd_wr, req_flush\n" +
                        "    (others => '0'), (others => '0'),       -- req_flush_addr, req_flush_cnt\n" +
                        "    (others => '1')                         -- flush_cnt\n" +
                        "  );\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "  signal swapin : TagMemInVector;\n" +
                        "  signal memeven : TagMemOutVector;\n" +
                        "  signal memodd : TagMemOutVector;\n" +
                        "  signal wb_ena_even : std_logic_vector(CFG_ICACHE_WAYS-1 downto 0);\n" +
                        "  signal wb_ena_odd : std_logic_vector(CFG_ICACHE_WAYS-1 downto 0);\n" +
                        "\n" +
                        "  signal lrui : LruInVector;\n" +
                        "  signal wb_lru_even : std_logic_vector(1 downto 0);\n" +
                        "  signal wb_lru_odd : std_logic_vector(1 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  wayx : for n in 0 to CFG_ICACHE_WAYS-1 generate\n" +
                        "      wayevenx : IWayMem generic map (\n" +
                        "          memtech => memtech,\n" +
                        "          async_reset => async_reset,\n" +
                        "          wayidx => 2*n\n" +
                        "      ) port map (\n" +
                        "          i_clk => i_clk,\n" +
                        "          i_nrst => i_nrst,\n" +
                        "          i_radr => swapin(WAY_EVEN).radr,\n" +
                        "          i_wadr => swapin(WAY_EVEN).wadr,\n" +
                        "          i_wena => wb_ena_even(n),\n" +
                        "          i_wstrb => swapin(WAY_EVEN).wstrb,\n" +
                        "          i_wvalid => swapin(WAY_EVEN).wvalid,\n" +
                        "          i_wdata => swapin(WAY_EVEN).wdata,\n" +
                        "          i_load_fault => swapin(WAY_EVEN).load_fault,\n" +
                        "          o_rtag => memeven(n).rtag,\n" +
                        "          o_rdata => memeven(n).rdata,\n" +
                        "          o_valid => memeven(n).valid,\n" +
                        "          o_load_fault => memeven(n).load_fault\n" +
                        "      );\n" +
                        "\n" +
                        "      wayoddx : IWayMem generic map (\n" +
                        "          async_reset => async_reset,\n" +
                        "          wayidx => 2*n + 1\n" +
                        "      ) port map (\n" +
                        "          i_clk => i_clk,\n" +
                        "          i_nrst => i_nrst,\n" +
                        "          i_radr => swapin(WAY_ODD).radr,\n" +
                        "          i_wadr => swapin(WAY_ODD).wadr,\n" +
                        "          i_wena => wb_ena_odd(n),\n" +
                        "          i_wstrb => swapin(WAY_ODD).wstrb,\n" +
                        "          i_wvalid => swapin(WAY_ODD).wvalid,\n" +
                        "          i_wdata => swapin(WAY_ODD).wdata,\n" +
                        "          i_load_fault => swapin(WAY_ODD).load_fault,\n" +
                        "          o_rtag => memodd(n).rtag,\n" +
                        "          o_rdata => memodd(n).rdata,\n" +
                        "          o_valid => memodd(n).valid,\n" +
                        "          o_load_fault => memodd(n).load_fault\n" +
                        "      );\n" +
                        "  end generate;\n" +
                        "\n" +
                        "  lrueven0 : ILru port map (\n" +
                        "      i_clk => i_clk,\n" +
                        "      i_init => lrui(WAY_EVEN).init,\n" +
                        "      i_radr => lrui(WAY_EVEN).radr,\n" +
                        "      i_wadr => lrui(WAY_EVEN).wadr,\n" +
                        "      i_we => lrui(WAY_EVEN).we,\n" +
                        "      i_lru => lrui(WAY_EVEN).lru,\n" +
                        "      o_lru => wb_lru_even\n" +
                        "  );\n" +
                        "\n" +
                        "  lruodd0 : ILru port map (\n" +
                        "      i_clk => i_clk,\n" +
                        "      i_init => lrui(WAY_ODD).init,\n" +
                        "      i_radr => lrui(WAY_ODD).radr,\n" +
                        "      i_wadr => lrui(WAY_ODD).wadr,\n" +
                        "      i_we => lrui(WAY_ODD).we,\n" +
                        "      i_lru => lrui(WAY_ODD).lru,\n" +
                        "      o_lru => wb_lru_odd\n" +
                        "  );\n" +
                        "\n" +
                        "  comb : process(i_nrst, i_req_ctrl_valid, i_req_ctrl_addr,\n" +
                        "                i_resp_ctrl_ready, i_req_mem_ready, \n" +
                        "                i_resp_mem_data_valid, i_resp_mem_data, i_resp_mem_load_fault, \n" +
                        "                i_flush_address, i_flush_valid,\n" +
                        "                memeven, memodd, wb_lru_even, wb_lru_odd, r)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable waysel : WayMuxVector;\n" +
                        "    variable w_raddr5 : std_logic;\n" +
                        "    variable w_raddr5_r : std_logic;\n" +
                        "    variable w_use_overlay : std_logic;\n" +
                        "    variable wb_req_adr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable wb_radr_overlay : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable wb_rtag : std_logic_vector(CFG_ITAG_WIDTH-1 downto 0);\n" +
                        "    variable wb_rtag_overlay : std_logic_vector(CFG_ITAG_WIDTH-1 downto 0);\n" +
                        "    variable wb_rtag_even : std_logic_vector(CFG_ITAG_WIDTH-1 downto 0);\n" +
                        "    variable wb_rtag_odd : std_logic_vector(CFG_ITAG_WIDTH-1 downto 0);\n" +
                        "    variable wb_hit0 : integer range 0 to CFG_ICACHE_WAYS;\n" +
                        "    variable wb_hit1 : integer range 0 to CFG_ICACHE_WAYS;\n" +
                        "    variable w_hit0_valid : std_logic;\n" +
                        "    variable w_hit1_valid : std_logic;\n" +
                        "    variable wb_mem_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable wb_o_resp_data : std_logic_vector(31 downto 0);\n" +
                        "    variable v_init : std_logic;\n" +
                        "    variable w_ena : std_logic;\n" +
                        "    variable w_last : std_logic;\n" +
                        "    variable w_o_resp_valid : std_logic;\n" +
                        "    variable w_o_resp_load_fault : std_logic;\n" +
                        "    variable w_o_req_ctrl_ready : std_logic;\n" +
                        "    variable wb_wstrb_next : std_logic_vector(3 downto 0);\n" +
                        "    variable v_swapin : TagMemInVector;\n" +
                        "    variable v_lrui : LruInVector;\n" +
                        "    variable vb_ena_even : std_logic_vector(CFG_ICACHE_WAYS-1 downto 0);\n" +
                        "    variable vb_ena_odd : std_logic_vector(CFG_ICACHE_WAYS-1 downto 0);\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    wb_mem_addr := (others => '0');\n" +
                        "\n" +
                        "    if i_req_ctrl_valid = '1' then\n" +
                        "        wb_req_adr := i_req_ctrl_addr;\n" +
                        "    else\n" +
                        "        wb_req_adr := r.req_addr;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_raddr5 := wb_req_adr(CFG_IOFFSET_WIDTH);\n" +
                        "    w_raddr5_r := r.req_addr(CFG_IOFFSET_WIDTH);\n" +
                        "\n" +
                        "    w_use_overlay := '0';\n" +
                        "    if wb_req_adr(CFG_IOFFSET_WIDTH-1 downto 1) = offset_ones then\n" +
                        "        w_use_overlay := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    wb_radr_overlay(BUS_ADDR_WIDTH-1 downto CFG_IOFFSET_WIDTH) := \n" +
                        "        wb_req_adr(BUS_ADDR_WIDTH-1 downto CFG_IOFFSET_WIDTH) + 1;\n" +
                        "    wb_radr_overlay(CFG_IOFFSET_WIDTH-1 downto 0) := (others => '0');\n" +
                        "\n" +
                        "    -- flush request via debug interface\n" +
                        "    if i_flush_valid = '1' then\n" +
                        "        v.req_flush := '1';\n" +
                        "        if i_flush_address(0) = '1' then\n" +
                        "            v.req_flush_cnt := (others => '1');\n" +
                        "            v.req_flush_addr := FLUSH_ALL_ADDR;\n" +
                        "        elsif i_flush_address(CFG_IOFFSET_WIDTH-1 downto 1) = offset_ones then\n" +
                        "            v.req_flush_cnt := conv_std_logic_vector(1, CFG_IINDEX_WIDTH+1);\n" +
                        "            v.req_flush_addr := i_flush_address;\n" +
                        "        else\n" +
                        "            v.req_flush_cnt := (others => '0');\n" +
                        "            v.req_flush_addr := i_flush_address;\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Check read tag and select hit way\n" +
                        "    wb_rtag := r.req_addr(ITAG_END downto ITAG_START);\n" +
                        "    wb_rtag_overlay := r.req_addr_overlay(ITAG_END downto ITAG_START);\n" +
                        "    waysel(WAY_EVEN).hit := MISS;\n" +
                        "    waysel(WAY_EVEN).rdata := (others => '0');\n" +
                        "    waysel(WAY_EVEN).valid := '0';\n" +
                        "    waysel(WAY_EVEN).load_fault := '0';\n" +
                        "    waysel(WAY_ODD).hit := MISS;\n" +
                        "    waysel(WAY_ODD).rdata := (others => '0');\n" +
                        "    waysel(WAY_ODD).valid := '0';\n" +
                        "    waysel(WAY_ODD).load_fault := '0';\n" +
                        "    if r.use_overlay = '0' then\n" +
                        "        wb_rtag_even := wb_rtag;\n" +
                        "        wb_rtag_odd := wb_rtag;\n" +
                        "    elsif w_raddr5_r = '0' then\n" +
                        "        wb_rtag_even := wb_rtag;\n" +
                        "        wb_rtag_odd := wb_rtag_overlay;\n" +
                        "    else\n" +
                        "        wb_rtag_even := wb_rtag_overlay;\n" +
                        "        wb_rtag_odd := wb_rtag;\n" +
                        "    end if;\n" +
                        "    for n in 0 to CFG_ICACHE_WAYS-1 loop\n" +
                        "        if waysel(WAY_EVEN).hit = MISS and memeven(n).rtag = wb_rtag_even then\n" +
                        "            waysel(WAY_EVEN).hit := n;\n" +
                        "            waysel(WAY_EVEN).rdata := memeven(n).rdata;\n" +
                        "            waysel(WAY_EVEN).valid := memeven(n).valid;\n" +
                        "            waysel(WAY_EVEN).load_fault := memeven(n).load_fault;\n" +
                        "        end if;\n" +
                        "\n" +
                        "        if waysel(WAY_ODD).hit = MISS and memodd(n).rtag = wb_rtag_odd then\n" +
                        "            waysel(WAY_ODD).hit := n;\n" +
                        "            waysel(WAY_ODD).rdata := memodd(n).rdata;\n" +
                        "            waysel(WAY_ODD).valid := memodd(n).valid;\n" +
                        "            waysel(WAY_ODD).load_fault := memodd(n).load_fault;\n" +
                        "        end if;\n" +
                        "    end loop;\n" +
                        "\n" +
                        "    -- swap back rdata\n" +
                        "    w_o_resp_load_fault := '0';\n" +
                        "    if w_raddr5_r = '0' then\n" +
                        "        if r.use_overlay = '0' then\n" +
                        "            wb_hit0 := waysel(WAY_EVEN).hit;\n" +
                        "            wb_hit1 := waysel(WAY_EVEN).hit;\n" +
                        "            w_hit0_valid := waysel(WAY_EVEN).valid;\n" +
                        "            w_hit1_valid := waysel(WAY_EVEN).valid;\n" +
                        "            wb_o_resp_data := waysel(WAY_EVEN).rdata;\n" +
                        "            w_o_resp_load_fault := waysel(WAY_EVEN).load_fault;\n" +
                        "        else\n" +
                        "            wb_hit0 := waysel(WAY_EVEN).hit;\n" +
                        "            wb_hit1 := waysel(WAY_ODD).hit;\n" +
                        "            w_hit0_valid := waysel(WAY_EVEN).valid;\n" +
                        "            w_hit1_valid := waysel(WAY_ODD).valid;\n" +
                        "            wb_o_resp_data(15 downto 0) := waysel(WAY_EVEN).rdata(15 downto 0);\n" +
                        "            wb_o_resp_data(31 downto 16) := waysel(WAY_ODD).rdata(15 downto 0);\n" +
                        "            w_o_resp_load_fault :=\n" +
                        "                waysel(WAY_EVEN).load_fault or waysel(WAY_ODD).load_fault;\n" +
                        "        end if;\n" +
                        "    else\n" +
                        "        if r.use_overlay = '0' then\n" +
                        "            wb_hit0 := waysel(WAY_ODD).hit;\n" +
                        "            wb_hit1 := waysel(WAY_ODD).hit;\n" +
                        "            w_hit0_valid := waysel(WAY_ODD).valid;\n" +
                        "            w_hit1_valid := waysel(WAY_ODD).valid;\n" +
                        "            wb_o_resp_data := waysel(WAY_ODD).rdata;\n" +
                        "            w_o_resp_load_fault := waysel(WAY_ODD).load_fault;\n" +
                        "        else\n" +
                        "            wb_hit0 := waysel(WAY_ODD).hit;\n" +
                        "            wb_hit1 := waysel(WAY_EVEN).hit;\n" +
                        "            w_hit0_valid := waysel(WAY_ODD).valid;\n" +
                        "            w_hit1_valid := waysel(WAY_EVEN).valid;\n" +
                        "            wb_o_resp_data(15 downto 0) := waysel(WAY_ODD).rdata(15 downto 0);\n" +
                        "            wb_o_resp_data(31 downto 16) := waysel(WAY_EVEN).rdata(15 downto 0);\n" +
                        "            w_o_resp_load_fault :=\n" +
                        "                waysel(WAY_ODD).load_fault or waysel(WAY_EVEN).load_fault;\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    v_lrui(WAY_EVEN).init := '0';\n" +
                        "    v_lrui(WAY_EVEN).radr := (others => '0');\n" +
                        "    v_lrui(WAY_EVEN).wadr := (others => '0');\n" +
                        "    v_lrui(WAY_EVEN).we := '0';\n" +
                        "    v_lrui(WAY_EVEN).lru := (others => '0');\n" +
                        "    v_lrui(WAY_ODD).init := '0';\n" +
                        "    v_lrui(WAY_ODD).radr := (others => '0');\n" +
                        "    v_lrui(WAY_ODD).wadr := (others => '0');\n" +
                        "    v_lrui(WAY_ODD).we := '0';\n" +
                        "    v_lrui(WAY_ODD).lru := (others => '0');\n" +
                        "    w_o_resp_valid := '0';\n" +
                        "    if r.state = State_Flush then\n" +
                        "        v_lrui(WAY_EVEN).init := not r.mem_addr(CFG_IOFFSET_WIDTH);\n" +
                        "        v_lrui(WAY_EVEN).wadr := r.mem_addr(IINDEX_END downto IINDEX_START);\n" +
                        "        v_lrui(WAY_ODD).init := r.mem_addr(CFG_IOFFSET_WIDTH);\n" +
                        "        v_lrui(WAY_ODD).wadr := r.mem_addr(IINDEX_END downto IINDEX_START);\n" +
                        "    elsif CFG_SINGLEPORT_CACHE and (r.state = State_WaitGrant\n" +
                        "            or r.state = State_WaitResp or r.state = State_CheckResp\n" +
                        "            or r.state = State_SetupReadAdr) then\n" +
                        "            -- Do nothing while memory writing\n" +
                        "    elsif w_hit0_valid = '1' and w_hit1_valid = '1'\n" +
                        "        and wb_hit0 /= MISS and wb_hit1 /= MISS and r.requested = '1' then\n" +
                        "        w_o_resp_valid := '1';\n" +
                        "\n" +
                        "        -- Update LRU table\n" +
                        "        if w_raddr5_r = '0' then\n" +
                        "            v_lrui(WAY_EVEN).we := '1';\n" +
                        "            v_lrui(WAY_EVEN).lru := conv_std_logic_vector(wb_hit0, 2)(1 downto 0);\n" +
                        "            v_lrui(WAY_EVEN).wadr :=\n" +
                        "                r.req_addr(IINDEX_END downto IINDEX_START);\n" +
                        "            if r.use_overlay = '1' then\n" +
                        "                v_lrui(WAY_ODD).we := '1';\n" +
                        "                v_lrui(WAY_ODD).lru := conv_std_logic_vector(wb_hit1, 2)(1 downto 0);\n" +
                        "                v_lrui(WAY_ODD).wadr :=\n" +
                        "                    r.req_addr_overlay(IINDEX_END downto IINDEX_START);\n" +
                        "            end if;\n" +
                        "        else\n" +
                        "            v_lrui(WAY_ODD).we := '1';\n" +
                        "            v_lrui(WAY_ODD).lru := conv_std_logic_vector(wb_hit0, 2)(1 downto 0);\n" +
                        "            v_lrui(WAY_ODD).wadr :=\n" +
                        "                r.req_addr(IINDEX_END downto IINDEX_START);\n" +
                        "            if r.use_overlay = '1' then\n" +
                        "                v_lrui(WAY_EVEN).we := '1';\n" +
                        "                v_lrui(WAY_EVEN).lru := conv_std_logic_vector(wb_hit1, 2)(1 downto 0);\n" +
                        "                v_lrui(WAY_EVEN).wadr :=\n" +
                        "                    r.req_addr_overlay(IINDEX_END downto IINDEX_START);\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_o_req_ctrl_ready := not r.req_flush\n" +
                        "                       and (not r.requested or w_o_resp_valid);\n" +
                        "    if i_req_ctrl_valid = '1' and w_o_req_ctrl_ready = '1' then\n" +
                        "        v.req_addr := i_req_ctrl_addr;\n" +
                        "        v.req_addr_overlay := wb_radr_overlay;\n" +
                        "        v.use_overlay := w_use_overlay;\n" +
                        "        v.requested := '1';\n" +
                        "    elsif w_o_resp_valid = '1' and i_resp_ctrl_ready = '1' then\n" +
                        "        v.requested := '0';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- System Bus access state machine\n" +
                        "    w_last := '0';\n" +
                        "    w_ena := '0';\n" +
                        "    v_init := '0';\n" +
                        "    wb_wstrb_next := r.burst_wstrb(2 downto 0) & r.burst_wstrb(3);\n" +
                        "    case r.state is\n" +
                        "    when State_Idle =>\n" +
                        "        if r.req_flush = '1' then\n" +
                        "            v.state := State_Flush;\n" +
                        "            if r.req_flush_addr(0) = '1' then\n" +
                        "                v.mem_addr := FLUSH_ALL_ADDR;\n" +
                        "                v.flush_cnt := (others => '1');\n" +
                        "            else\n" +
                        "                v.mem_addr := r.req_flush_addr;\n" +
                        "                v.flush_cnt := r.req_flush_cnt;\n" +
                        "            end if;\n" +
                        "            v.burst_wstrb := (others => '1');    -- All qwords in line\n" +
                        "            v.burst_valid := (others => '0');    -- All qwords in line\n" +
                        "        elsif (i_req_ctrl_valid = '1' and w_o_req_ctrl_ready = '1')\n" +
                        "              or r.requested = '1' then\n" +
                        "            --! Check hit even there's no new request only the previous one.\n" +
                        "            --! This must be done in a case of CPU is halted and cache was flushed\n" +
                        "            --!\n" +
                        "            v.state := State_CheckHit;\n" +
                        "        end if;\n" +
                        "    when State_CheckHit =>\n" +
                        "        if w_o_resp_valid = '1' then\n" +
                        "            -- Hit\n" +
                        "            if i_req_ctrl_valid = '1' and w_o_req_ctrl_ready = '1' then\n" +
                        "                v.state := State_CheckHit;\n" +
                        "            else\n" +
                        "                v.state := State_Idle;\n" +
                        "            end if;\n" +
                        "\n" +
                        "        else\n" +
                        "            -- Miss\n" +
                        "            v.req_mem_valid := '1';\n" +
                        "            if w_hit0_valid = '0' or wb_hit0 = MISS then\n" +
                        "                wb_mem_addr := r.req_addr;\n" +
                        "            else\n" +
                        "                wb_mem_addr := r.req_addr_overlay;\n" +
                        "            end if;\n" +
                        "            if i_req_mem_ready = '1' then\n" +
                        "                v.state := State_WaitResp;\n" +
                        "            else\n" +
                        "                v.state := State_WaitGrant;\n" +
                        "            end if;\n" +
                        "\n" +
                        "            v.mem_addr := wb_mem_addr(BUS_ADDR_WIDTH-1 downto 3) & \"000\";\n" +
                        "            v.burst_cnt := 3;\n" +
                        "            case wb_mem_addr(CFG_IOFFSET_WIDTH-1 downto 3) is\n" +
                        "            when \"00\" =>\n" +
                        "                wb_wstrb_next := X\"1\";\n" +
                        "            when \"01\" =>\n" +
                        "                wb_wstrb_next := X\"2\";\n" +
                        "            when \"10\" =>\n" +
                        "                wb_wstrb_next := X\"4\";\n" +
                        "            when \"11\" =>\n" +
                        "                wb_wstrb_next := X\"8\";\n" +
                        "            when others =>\n" +
                        "            end case;\n" +
                        "            v.burst_wstrb := wb_wstrb_next;\n" +
                        "            v.burst_valid := wb_wstrb_next;\n" +
                        "            v.lru_even_wr := wb_lru_even;\n" +
                        "            v.lru_odd_wr := wb_lru_odd;\n" +
                        "        end if;\n" +
                        "    when State_WaitGrant =>\n" +
                        "        if i_req_mem_ready = '1' then\n" +
                        "            v.req_mem_valid := '0';\n" +
                        "            v.state := State_WaitResp;\n" +
                        "        end if;\n" +
                        "    when State_WaitResp =>\n" +
                        "        if r.burst_cnt = 0 then\n" +
                        "            w_last := '1';\n" +
                        "        end if;\n" +
                        "        if i_resp_mem_data_valid = '1' then\n" +
                        "            w_ena := '1';\n" +
                        "            if r.burst_cnt = 0 then\n" +
                        "                v.state := State_CheckResp;\n" +
                        "            else\n" +
                        "                v.burst_cnt := r.burst_cnt - 1;\n" +
                        "            end if;\n" +
                        "            -- Suppose using WRAP burst transaction\n" +
                        "            v.burst_wstrb := wb_wstrb_next;\n" +
                        "            v.burst_valid := r.burst_valid or wb_wstrb_next;\n" +
                        "        end if;\n" +
                        "    when State_CheckResp =>\n" +
                        "        if CFG_SINGLEPORT_CACHE then\n" +
                        "            v.state := State_SetupReadAdr;\n" +
                        "        elsif (w_o_req_ctrl_ready = '1' and i_req_ctrl_valid = '1')\n" +
                        "            or (r.requested = '1' and w_o_resp_valid = '0') then\n" +
                        "            v.state := State_CheckHit;\n" +
                        "        else\n" +
                        "            v.state := State_Idle;\n" +
                        "        end if;\n" +
                        "    when State_SetupReadAdr =>\n" +
                        "        v.state := State_CheckHit;\n" +
                        "    when State_Flush =>\n" +
                        "        v_init := '1';\n" +
                        "        if r.flush_cnt = flush_cnt_zero then\n" +
                        "            v.req_flush := '0';\n" +
                        "            v.state := State_Idle;\n" +
                        "        else\n" +
                        "            v.flush_cnt := r.flush_cnt - 1;\n" +
                        "            v.mem_addr(BUS_ADDR_WIDTH-1 downto CFG_IOFFSET_WIDTH) := \n" +
                        "                   r.mem_addr(BUS_ADDR_WIDTH-1 downto CFG_IOFFSET_WIDTH) + 1;\n" +
                        "        end if;\n" +
                        "    when others =>\n" +
                        "    end case;\n" +
                        "\n" +
                        "    -- Write signals:\n" +
                        "    vb_ena_even := (others => '0');\n" +
                        "    vb_ena_odd := (others => '0');\n" +
                        "    if r.mem_addr(CFG_IOFFSET_WIDTH) = '0' then\n" +
                        "        vb_ena_even := (others => v_init);\n" +
                        "        vb_ena_even(conv_integer(r.lru_even_wr)) := w_ena or v_init;\n" +
                        "    else\n" +
                        "        vb_ena_odd := (others => v_init);\n" +
                        "        vb_ena_odd(conv_integer(r.lru_odd_wr)) := w_ena or v_init;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    v_swapin(WAY_EVEN).wadr := r.mem_addr;\n" +
                        "    v_swapin(WAY_EVEN).wstrb := r.burst_wstrb;\n" +
                        "    v_swapin(WAY_EVEN).wvalid := r.burst_valid;\n" +
                        "    v_swapin(WAY_EVEN).wdata := i_resp_mem_data;\n" +
                        "    v_swapin(WAY_EVEN).load_fault := i_resp_mem_load_fault;\n" +
                        "    v_swapin(WAY_ODD).wadr := r.mem_addr;\n" +
                        "    v_swapin(WAY_ODD).wstrb := r.burst_wstrb;\n" +
                        "    v_swapin(WAY_ODD).wvalid := r.burst_valid;\n" +
                        "    v_swapin(WAY_ODD).wdata := i_resp_mem_data;\n" +
                        "    v_swapin(WAY_ODD).load_fault := i_resp_mem_load_fault;\n" +
                        "\n" +
                        "    if CFG_SINGLEPORT_CACHE and (r.state = State_WaitResp\n" +
                        "        or r.state = State_CheckResp\n" +
                        "        or r.state = State_Flush) then\n" +
                        "        v_swapin(WAY_EVEN).radr := r.mem_addr;\n" +
                        "        v_swapin(WAY_ODD).radr := r.mem_addr;\n" +
                        "    elsif r.state = State_Idle or w_o_resp_valid = '1' then\n" +
                        "        if w_raddr5 = '0' then\n" +
                        "            v_swapin(WAY_EVEN).radr := wb_req_adr;\n" +
                        "            v_swapin(WAY_ODD).radr := wb_radr_overlay;\n" +
                        "            v_lrui(WAY_EVEN).radr := wb_req_adr(IINDEX_END downto IINDEX_START);\n" +
                        "            v_lrui(WAY_ODD).radr := wb_radr_overlay(IINDEX_END downto IINDEX_START);\n" +
                        "        else\n" +
                        "            v_swapin(WAY_EVEN).radr := wb_radr_overlay;\n" +
                        "            v_swapin(WAY_ODD).radr := wb_req_adr;\n" +
                        "            v_lrui(WAY_EVEN).radr := wb_radr_overlay(IINDEX_END downto IINDEX_START);\n" +
                        "            v_lrui(WAY_ODD).radr := wb_req_adr(IINDEX_END downto IINDEX_START);\n" +
                        "        end if;\n" +
                        "    else\n" +
                        "        if w_raddr5_r = '0' then\n" +
                        "            v_swapin(WAY_EVEN).radr := r.req_addr;\n" +
                        "            v_swapin(WAY_ODD).radr := r.req_addr_overlay;\n" +
                        "            v_lrui(WAY_EVEN).radr :=\n" +
                        "                r.req_addr(IINDEX_END downto IINDEX_START);\n" +
                        "            v_lrui(WAY_ODD).radr :=\n" +
                        "                r.req_addr_overlay(IINDEX_END downto IINDEX_START);\n" +
                        "        else\n" +
                        "            v_swapin(WAY_EVEN).radr := r.req_addr_overlay;\n" +
                        "            v_swapin(WAY_ODD).radr := r.req_addr;\n" +
                        "            v_lrui(WAY_EVEN).radr :=\n" +
                        "                r.req_addr_overlay(IINDEX_END downto IINDEX_START);\n" +
                        "            v_lrui(WAY_ODD).radr :=\n" +
                        "                r.req_addr(IINDEX_END downto IINDEX_START);\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    lrui(WAY_EVEN) <= v_lrui(WAY_EVEN);\n" +
                        "    lrui(WAY_ODD) <= v_lrui(WAY_ODD);\n" +
                        "\n" +
                        "    swapin(WAY_EVEN) <= v_swapin(WAY_EVEN);\n" +
                        "    swapin(WAY_ODD) <= v_swapin(WAY_ODD);\n" +
                        "\n" +
                        "    wb_ena_even <= vb_ena_even;\n" +
                        "    wb_ena_odd <= vb_ena_odd;\n" +
                        "\n" +
                        "    o_req_ctrl_ready <= w_o_req_ctrl_ready;\n" +
                        "\n" +
                        "    o_req_mem_valid <= r.req_mem_valid;\n" +
                        "    o_req_mem_addr <= r.mem_addr;\n" +
                        "    o_req_mem_write <= '0';\n" +
                        "    o_req_mem_strob <= (others => '0');\n" +
                        "    o_req_mem_data <= (others => '0');\n" +
                        "    o_req_mem_len <= conv_std_logic_vector(3, 8);\n" +
                        "    o_req_mem_burst <= \"10\";  -- WRAP burst transaction\n" +
                        "    o_req_mem_last <= w_last;\n" +
                        "\n" +
                        "    o_resp_ctrl_valid <= w_o_resp_valid;\n" +
                        "    o_resp_ctrl_data <= wb_o_resp_data;\n" +
                        "    o_resp_ctrl_addr <= r.req_addr;\n" +
                        "    o_resp_ctrl_load_fault <= w_o_resp_load_fault;\n" +
                        "    o_istate <= r.state(1 downto 0);\n" +
                        "    \n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(i_clk, i_nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_icache_vhd_file(String Project_Folder_File) {
        String data =   "-----------------------------------------------------------------------------\n" +
                        "--! @file\n" +
                        "--! @copyright Copyright 2016 GNSS Sensor Ltd. All right reserved.\n" +
                        "--! @author    Sergey Khabarov - sergeykhbr@gmail.com\n" +
                        "--! @brief     Instruction Cache.\n" +
                        "------------------------------------------------------------------------------\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use riverlib.river_cfg.all;\n" +
                        "\n" +
                        "entity ICache is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;                              -- CPU clock\n" +
                        "    i_nrst : in std_logic;                             -- Reset. Active LOW.\n" +
                        "    -- Control path:\n" +
                        "    i_req_ctrl_valid : in std_logic;\n" +
                        "    i_req_ctrl_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_req_ctrl_ready : out std_logic;\n" +
                        "    o_resp_ctrl_valid : out std_logic;\n" +
                        "    o_resp_ctrl_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_resp_ctrl_data : out std_logic_vector(31 downto 0);\n" +
                        "    o_resp_ctrl_load_fault : out std_logic;\n" +
                        "    i_resp_ctrl_ready : in std_logic;\n" +
                        "    -- Memory interface:\n" +
                        "    i_req_mem_ready : in std_logic;\n" +
                        "    o_req_mem_valid : out std_logic;\n" +
                        "    o_req_mem_write : out std_logic;\n" +
                        "    o_req_mem_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_req_mem_strob : out std_logic_vector(BUS_DATA_BYTES-1 downto 0);\n" +
                        "    o_req_mem_data : out std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    o_req_mem_len : out std_logic_vector(7 downto 0);\n" +
                        "    o_req_mem_burst : out std_logic_vector(1 downto 0);\n" +
                        "    o_req_mem_last : out std_logic;\n" +
                        "    i_resp_mem_data_valid : in std_logic;\n" +
                        "    i_resp_mem_data : in std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    i_resp_mem_load_fault : in std_logic;\n" +
                        "    -- Debug Signals:\n" +
                        "    i_flush_address : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);  -- clear ICache address from debug interface\n" +
                        "    i_flush_valid : in std_logic;                                      -- address to clear icache is valid\n" +
                        "    o_istate : out std_logic_vector(1 downto 0)\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_ICache of ICache is\n" +
                        "\n" +
                        "  constant State_Idle : std_logic_vector(1 downto 0) := \"00\";\n" +
                        "  constant State_WaitGrant : std_logic_vector(1 downto 0) := \"01\";\n" +
                        "  constant State_WaitResp : std_logic_vector(1 downto 0) := \"10\";\n" +
                        "  constant State_WaitAccept : std_logic_vector(1 downto 0) := \"11\";\n" +
                        "\n" +
                        "  constant Hit_Line1 : integer := 0;\n" +
                        "  constant Hit_Line2 : integer := 1;\n" +
                        "  constant Hit_Response : integer := 2;\n" +
                        "  constant Hit_Total : integer := 3;\n" +
                        "\n" +
                        "  constant ILINE_TOTAL : integer := 2;\n" +
                        "\n" +
                        "  type line_type is record\n" +
                        "      addr : std_logic_vector(BUS_ADDR_WIDTH-4 downto 0);\n" +
                        "      data : std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "      load_fault : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant LINE_RESET : line_type := (\n" +
                        "    (others => '1'), (others => '0'), '0'\n" +
                        "  );\n" +
                        "\n" +
                        "  type iline_vector is array (0 to ILINE_TOTAL-1) of line_type;\n" +
                        "\n" +
                        "  type line_signal_type is record\n" +
                        "       hit : std_logic_vector(ILINE_TOTAL downto 0);     -- Hit_Total = ILINE_TOTAL + 1\n" +
                        "       hit_hold : std_logic_vector(ILINE_TOTAL-1 downto 0);\n" +
                        "       hit_load_fault : std_logic;\n" +
                        "       hold_load_fault : std_logic;\n" +
                        "       hit_data : std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "       hold_data : std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "  end record;\n" +
                        " \n" +
                        "  type line_signal_vector is array (0 to ILINE_TOTAL-1) of line_signal_type;\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "      iline_addr_req : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      addr_processing : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      state : std_logic_vector(1 downto 0);\n" +
                        "      double_req : std_logic;\n" +
                        "      delay_valid : std_logic;\n" +
                        "      delay_data : std_logic_vector(31 downto 0);\n" +
                        "      delay_load_fault : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "    (others => '0'), (others => '0'), State_Idle,\n" +
                        "    '0', '0', (others => '0'), '0'\n" +
                        "  );\n" +
                        "\n" +
                        "  type adr_type is array (0 to 1) of std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "  signal r_iline, rin_iline : iline_vector;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  comb : process(i_nrst, i_req_ctrl_valid, i_req_ctrl_addr,\n" +
                        "                i_resp_ctrl_ready, i_req_mem_ready, \n" +
                        "                i_resp_mem_data_valid, i_resp_mem_data, i_resp_mem_load_fault, \n" +
                        "                i_flush_address, i_flush_valid, r, r_iline)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable v_iline : iline_vector;\n" +
                        "    variable w_need_mem_req : std_logic;\n" +
                        "    variable wb_hit_word : std_logic_vector(31 downto 0);\n" +
                        "    variable w_hit_load_fault : std_logic;\n" +
                        "    variable wb_l : line_signal_vector;\n" +
                        "    variable w_reuse_lastline : std_logic;\n" +
                        "    variable w_wait_response : std_logic;\n" +
                        "\n" +
                        "    variable w_o_req_ctrl_ready : std_logic;\n" +
                        "    variable w_o_req_mem_valid : std_logic;\n" +
                        "    variable wb_o_req_mem_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable w_req_ctrl_valid : std_logic;\n" +
                        "    variable w_req_fire : std_logic;\n" +
                        "    variable w_o_resp_valid : std_logic;\n" +
                        "    variable wb_o_resp_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable wb_o_resp_data : std_logic_vector(31 downto 0);\n" +
                        "    variable w_o_resp_load_fault : std_logic;\n" +
                        "    variable wb_req_addr : adr_type;\n" +
                        "    variable wb_hold_addr : adr_type;\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "    v_iline := r_iline;\n" +
                        "\n" +
                        "    w_wait_response := '0';\n" +
                        "    if r.state = State_WaitResp and i_resp_mem_data_valid = '0' then\n" +
                        "        w_wait_response := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_req_ctrl_valid := not w_wait_response\n" +
                        "                        and (i_req_ctrl_valid or r.double_req);\n" +
                        "    if r.double_req = '1' then\n" +
                        "        wb_req_addr(0) := r.addr_processing;\n" +
                        "        wb_req_addr(1) := r.addr_processing + 2;\n" +
                        "    else\n" +
                        "        wb_req_addr(0) := i_req_ctrl_addr;\n" +
                        "        wb_req_addr(1) := i_req_ctrl_addr + 2;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    wb_hold_addr(0) := r.addr_processing;\n" +
                        "    wb_hold_addr(1) := r.addr_processing + 2;\n" +
                        "\n" +
                        "    for i in 0 to ILINE_TOTAL-1 loop\n" +
                        "        wb_l(i).hit := (others => '0');\n" +
                        "        wb_l(i).hit_data := (others => '0');\n" +
                        "        wb_l(i).hit_load_fault := '0';\n" +
                        "        if wb_req_addr(i)(BUS_ADDR_WIDTH-1 downto 3) = r_iline(0).addr then\n" +
                        "            wb_l(i).hit(Hit_Line1) := w_req_ctrl_valid;\n" +
                        "            wb_l(i).hit_data := r_iline(0).data;\n" +
                        "            wb_l(i).hit_load_fault := r_iline(0).load_fault;\n" +
                        "        elsif wb_req_addr(i)(BUS_ADDR_WIDTH-1 downto 3) = r_iline(1).addr then\n" +
                        "            wb_l(i).hit(Hit_Line2) := w_req_ctrl_valid;\n" +
                        "            wb_l(i).hit_data := r_iline(1).data;\n" +
                        "            wb_l(i).hit_load_fault := r_iline(1).load_fault;\n" +
                        "        elsif wb_req_addr(i)(BUS_ADDR_WIDTH-1 downto 3) =\n" +
                        "            r.iline_addr_req(BUS_ADDR_WIDTH-1 downto 3) then\n" +
                        "            wb_l(i).hit(Hit_Response) := i_resp_mem_data_valid;\n" +
                        "            wb_l(i).hit_data := i_resp_mem_data;\n" +
                        "            wb_l(i).hit_load_fault := i_resp_mem_load_fault;\n" +
                        "        end if;\n" +
                        "\n" +
                        "        wb_l(i).hit_hold := (others => '0');\n" +
                        "        wb_l(i).hold_data := (others => '0');\n" +
                        "        wb_l(i).hold_load_fault := '0';\n" +
                        "        if wb_hold_addr(i)(BUS_ADDR_WIDTH-1 downto 3) = r_iline(0).addr then\n" +
                        "            wb_l(i).hit_hold(Hit_Line1) := '1';\n" +
                        "            wb_l(i).hold_data := r_iline(0).data;\n" +
                        "            wb_l(i).hold_load_fault := r_iline(0).load_fault;\n" +
                        "        elsif wb_hold_addr(i)(BUS_ADDR_WIDTH-1 downto 3) = r_iline(1).addr then\n" +
                        "            wb_l(i).hit_hold(Hit_Line2) := '1';\n" +
                        "            wb_l(i).hold_data := r_iline(1).data;\n" +
                        "            wb_l(i).hold_load_fault := r_iline(1).load_fault;\n" +
                        "        elsif wb_hold_addr(i)(BUS_ADDR_WIDTH-1 downto 3) =\n" +
                        "            r.iline_addr_req(BUS_ADDR_WIDTH-1 downto 3) then\n" +
                        "            wb_l(i).hold_data := i_resp_mem_data;\n" +
                        "            wb_l(i).hold_load_fault := i_resp_mem_load_fault;\n" +
                        "        end if;\n" +
                        "    end loop;\n" +
                        "\n" +
                        "    wb_hit_word := (others => '0');\n" +
                        "    w_hit_load_fault := '0';\n" +
                        "    w_need_mem_req := '1';\n" +
                        "    if wb_l(0).hit /= \"000\" and wb_l(1).hit /= \"000\" then\n" +
                        "        w_need_mem_req := '0';\n" +
                        "    end if;\n" +
                        "    case r.addr_processing(2 downto 1) is\n" +
                        "    when \"00\" =>\n" +
                        "        wb_hit_word := wb_l(0).hold_data(31 downto 0);\n" +
                        "        w_hit_load_fault := wb_l(0).hold_load_fault;\n" +
                        "    when \"01\" =>\n" +
                        "        wb_hit_word := wb_l(0).hold_data(47 downto 16);\n" +
                        "        w_hit_load_fault := wb_l(0).hold_load_fault;\n" +
                        "    when \"10\" =>\n" +
                        "        wb_hit_word := wb_l(0).hold_data(63 downto 32);\n" +
                        "        w_hit_load_fault := wb_l(0).hold_load_fault;\n" +
                        "    when others =>\n" +
                        "        wb_hit_word := wb_l(1).hold_data(15 downto 0) &\n" +
                        "                       wb_l(0).hold_data(63 downto 48);\n" +
                        "        w_hit_load_fault := wb_l(0).hold_load_fault\n" +
                        "                         or wb_l(1).hold_load_fault;\n" +
                        "    end case;\n" +
                        "\n" +
                        "    if w_req_ctrl_valid = '1' and w_need_mem_req = '0' then\n" +
                        "        v.delay_valid := '1';\n" +
                        "        case i_req_ctrl_addr(2 downto 1) is\n" +
                        "        when \"00\" =>\n" +
                        "            v.delay_data := wb_l(0).hit_data(31 downto 0);\n" +
                        "            v.delay_load_fault := wb_l(0).hit_load_fault;\n" +
                        "        when \"01\" =>\n" +
                        "            v.delay_data := wb_l(0).hit_data(47 downto 16);\n" +
                        "            v.delay_load_fault := wb_l(0).hit_load_fault;\n" +
                        "        when \"10\" =>\n" +
                        "            v.delay_data := wb_l(0).hit_data(63 downto 32);\n" +
                        "            v.delay_load_fault := wb_l(0).hit_load_fault;\n" +
                        "        when others =>\n" +
                        "            v.delay_data := wb_l(1).hit_data(15 downto 0) &\n" +
                        "                            wb_l(0).hit_data(63 downto 48);\n" +
                        "            v.delay_load_fault := wb_l(0).hit_load_fault \n" +
                        "                               or wb_l(1).hit_load_fault;\n" +
                        "        end case;\n" +
                        "    elsif i_resp_ctrl_ready = '1' then\n" +
                        "        v.delay_valid := '0';\n" +
                        "        v.delay_data := (others => '0');\n" +
                        "        v.delay_load_fault := '0';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_o_req_mem_valid := w_need_mem_req and w_req_ctrl_valid;\n" +
                        "    if r.double_req = '1' then\n" +
                        "        if (r.addr_processing(BUS_ADDR_WIDTH-1 downto 3) =\n" +
                        "            r.iline_addr_req(BUS_ADDR_WIDTH-1 downto 3))\n" +
                        "            or (r.addr_processing(BUS_ADDR_WIDTH-1 downto 3) =\n" +
                        "                wb_hold_addr(0)(BUS_ADDR_WIDTH-1 downto 3)) then\n" +
                        "            wb_o_req_mem_addr := wb_hold_addr(1)(BUS_ADDR_WIDTH-1 downto 3) & \"000\";\n" +
                        "        else\n" +
                        "            wb_o_req_mem_addr := wb_hold_addr(0)(BUS_ADDR_WIDTH-1 downto 3) & \"000\";\n" +
                        "        end if;\n" +
                        "    elsif wb_l(0).hit = \"000\" then\n" +
                        "        wb_o_req_mem_addr := wb_req_addr(0)(BUS_ADDR_WIDTH-1 downto 3)  & \"000\";\n" +
                        "    else\n" +
                        "        wb_o_req_mem_addr := wb_req_addr(1)(BUS_ADDR_WIDTH-1 downto 3)  & \"000\";\n" +
                        "    end if;\n" +
                        "    w_o_req_ctrl_ready := not w_need_mem_req or (i_req_mem_ready and not w_wait_response);\n" +
                        "    w_req_fire := w_req_ctrl_valid and w_o_req_ctrl_ready;\n" +
                        "\n" +
                        "    if (w_o_req_mem_valid and i_req_mem_ready and not w_wait_response) = '1'\n" +
                        "       or (r.double_req and not w_wait_response) = '1' then\n" +
                        "        v.iline_addr_req := wb_o_req_mem_addr;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    case r.state is\n" +
                        "    when State_Idle =>\n" +
                        "        if i_req_ctrl_valid = '1' then\n" +
                        "            if w_need_mem_req = '0' then\n" +
                        "                v.state := State_WaitAccept;\n" +
                        "            elsif i_req_mem_ready = '1' then\n" +
                        "                v.state := State_WaitResp;\n" +
                        "            else\n" +
                        "                v.state := State_WaitGrant;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    when State_WaitGrant =>\n" +
                        "        if i_req_mem_ready = '1' then\n" +
                        "            v.state := State_WaitResp;\n" +
                        "        elsif w_need_mem_req = '0' then\n" +
                        "            --! Fetcher can change request address while request wasn't\n" +
                        "            --! accepteed.\n" +
                        "            v.state := State_WaitAccept;\n" +
                        "        end if;\n" +
                        "    when State_WaitResp =>\n" +
                        "        if i_resp_mem_data_valid = '1' then\n" +
                        "            if i_resp_ctrl_ready = '0' then\n" +
                        "                v.state := State_WaitAccept;\n" +
                        "            elsif w_req_ctrl_valid = '0' then\n" +
                        "                v.state := State_Idle;\n" +
                        "            else\n" +
                        "                -- New request\n" +
                        "                if w_need_mem_req = '0' then\n" +
                        "                    v.state := State_WaitAccept;\n" +
                        "                elsif i_req_mem_ready = '1' then\n" +
                        "                    v.state := State_WaitResp;\n" +
                        "                else\n" +
                        "                    v.state := State_WaitGrant;\n" +
                        "                end if;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    when State_WaitAccept =>\n" +
                        "        if i_resp_ctrl_ready = '1' then\n" +
                        "            if w_req_ctrl_valid = '0' then\n" +
                        "                v.state := State_Idle;\n" +
                        "            else\n" +
                        "                if w_need_mem_req = '0' then\n" +
                        "                    v.state := State_WaitAccept;\n" +
                        "                elsif i_req_mem_ready = '1' then\n" +
                        "                    v.state := State_WaitResp;\n" +
                        "                else\n" +
                        "                    v.state := State_WaitGrant;\n" +
                        "                end if;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    when others =>\n" +
                        "    end case;\n" +
                        "\n" +
                        "\n" +
                        "    if w_req_fire = '1' then\n" +
                        "        v.double_req := '0';\n" +
                        "        if i_req_ctrl_addr(2 downto 1) = \"11\"\n" +
                        "            and wb_l(0).hit = \"000\" and wb_l(1).hit = \"000\"\n" +
                        "            and r.double_req = '0' then\n" +
                        "            v.double_req := '1';\n" +
                        "        end if;\n" +
                        "        if r.double_req = '0' then\n" +
                        "            v.addr_processing := i_req_ctrl_addr;\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_reuse_lastline := '0';\n" +
                        "\n" +
                        "    if i_resp_mem_data_valid = '1' then\n" +
                        "        --! Condition to avoid removing the last line:\n" +
                        "        if i_resp_ctrl_ready = '1' then\n" +
                        "            if (wb_l(0).hit(Hit_Line2) or wb_l(1).hit(Hit_Line2)) = '1'\n" +
                        "                and r_iline(1).addr /= wb_o_req_mem_addr(BUS_ADDR_WIDTH-1 downto 3) then\n" +
                        "                w_reuse_lastline := w_need_mem_req;\n" +
                        "            end if;\n" +
                        "        else\n" +
                        "            if (wb_l(0).hit_hold(Hit_Line2) or wb_l(1).hit_hold(Hit_Line2)) = '1'\n" +
                        "                and (wb_l(0).hit_hold(Hit_Line1) or wb_l(1).hit_hold(Hit_Line1)) = '0'\n" +
                        "                and r_iline(1).addr /= r.iline_addr_req(BUS_ADDR_WIDTH-1 downto 3) then\n" +
                        "                w_reuse_lastline := '1';\n" +
                        "            end if;\n" +
                        "		  end if;\n" +
                        "        if w_reuse_lastline = '0' then\n" +
                        "            v_iline(1).addr := r_iline(0).addr;\n" +
                        "            v_iline(1).data := r_iline(0).data;\n" +
                        "            v_iline(1).load_fault := r_iline(0).load_fault;\n" +
                        "        end if;\n" +
                        "        \n" +
                        "        v_iline(0).addr := r.iline_addr_req(BUS_ADDR_WIDTH-1 downto 3);\n" +
                        "        v_iline(0).data := i_resp_mem_data;\n" +
                        "        v_iline(0).load_fault := i_resp_mem_load_fault;\n" +
                        "    end if;\n" +
                        "    if i_flush_valid = '1' then\n" +
                        "        v_iline(0).addr := (others => '1');\n" +
                        "        v_iline(1).addr := (others => '1');\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if r.state = State_WaitAccept then\n" +
                        "        w_o_resp_valid := not r.double_req;\n" +
                        "    else\n" +
                        "        w_o_resp_valid := i_resp_mem_data_valid and not r.double_req;\n" +
                        "    end if;\n" +
                        "    if r.delay_valid = '1' then\n" +
                        "        wb_o_resp_data := r.delay_data;\n" +
                        "        w_o_resp_load_fault := r.delay_load_fault;\n" +
                        "    else\n" +
                        "        wb_o_resp_data := wb_hit_word;\n" +
                        "        w_o_resp_load_fault := w_hit_load_fault;\n" +
                        "    end if;\n" +
                        "    wb_o_resp_addr := r.addr_processing;\n" +
                        "\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "        for i in 0 to ILINE_TOTAL-1 loop\n" +
                        "            v_iline(i) := LINE_RESET;\n" +
                        "        end loop;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    o_req_ctrl_ready <= w_o_req_ctrl_ready;\n" +
                        "    \n" +
                        "    o_req_mem_valid <= w_o_req_mem_valid;\n" +
                        "    o_req_mem_addr <= wb_o_req_mem_addr;\n" +
                        "    o_req_mem_write <= '0';\n" +
                        "    o_req_mem_strob <= (others => '0');\n" +
                        "    o_req_mem_data <= (others => '0');\n" +
                        "    o_req_mem_len <= X\"00\";\n" +
                        "    o_req_mem_burst <= \"00\";\n" +
                        "    o_req_mem_last <= '1';\n" +
                        "\n" +
                        "    o_resp_ctrl_valid <= w_o_resp_valid;\n" +
                        "    o_resp_ctrl_data <= wb_o_resp_data;\n" +
                        "    o_resp_ctrl_addr <= wb_o_resp_addr;\n" +
                        "    o_resp_ctrl_load_fault <= w_o_resp_load_fault;\n" +
                        "    o_istate <= r.state;\n" +
                        "    \n" +
                        "    rin <= v;\n" +
                        "    rin_iline <= v_iline;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(i_clk, i_nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "        for i in 0 to ILINE_TOTAL-1 loop\n" +
                        "            r_iline(i) <= LINE_RESET;\n" +
                        "        end loop;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "        r_iline <= rin_iline;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_dcache_vhd_file(String Project_Folder_File) {
        String data =   "-----------------------------------------------------------------------------\n" +
                        "--! @file\n" +
                        "--! @copyright Copyright 2016 GNSS Sensor Ltd. All right reserved.\n" +
                        "--! @author    Sergey Khabarov - sergeykhbr@gmail.com\n" +
                        "--! @brief     Data Cache.\n" +
                        "------------------------------------------------------------------------------\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use riverlib.river_cfg.all;\n" +
                        "\n" +
                        "\n" +
                        "entity DCache is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;                              -- CPU clock\n" +
                        "    i_nrst : in std_logic;                             -- Reset. Active LOW.\n" +
                        "    -- Data path:\n" +
                        "    i_req_data_valid : in std_logic;\n" +
                        "    i_req_data_write : in std_logic;\n" +
                        "    i_req_data_sz : in std_logic_vector(1 downto 0);\n" +
                        "    i_req_data_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_req_data_data : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_req_data_ready : out std_logic;\n" +
                        "    o_resp_data_valid : out std_logic;\n" +
                        "    o_resp_data_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_resp_data_data : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_resp_data_load_fault : out std_logic;\n" +
                        "    o_resp_data_store_fault : out std_logic;\n" +
                        "    o_resp_data_store_fault_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_resp_data_ready : in std_logic;\n" +
                        "    -- Memory interface:\n" +
                        "    i_req_mem_ready : in std_logic;\n" +
                        "    o_req_mem_valid : out std_logic;\n" +
                        "    o_req_mem_write : out std_logic;\n" +
                        "    o_req_mem_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_req_mem_strob : out std_logic_vector(BUS_DATA_BYTES-1 downto 0);\n" +
                        "    o_req_mem_data : out std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    o_req_mem_len : out std_logic_vector(7 downto 0);\n" +
                        "    o_req_mem_burst : out std_logic_vector(1 downto 0);\n" +
                        "    o_req_mem_last : out std_logic;\n" +
                        "    i_resp_mem_data_valid : in std_logic;\n" +
                        "    i_resp_mem_data : in std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    i_resp_mem_load_fault : in std_logic;\n" +
                        "    i_resp_mem_store_fault : in std_logic;\n" +
                        "    i_resp_mem_store_fault_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    -- Debug Signals:\n" +
                        "    o_dstate : out std_logic_vector(1 downto 0)\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_DCache of DCache is\n" +
                        "\n" +
                        "  constant State_Idle : std_logic_vector(1 downto 0) := \"00\";\n" +
                        "  constant State_WaitGrant : std_logic_vector(1 downto 0) := \"01\";\n" +
                        "  constant State_WaitResp : std_logic_vector(1 downto 0) := \"10\";\n" +
                        "  constant State_WaitAccept : std_logic_vector(1 downto 0) := \"11\";\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "      req_strob : std_logic_vector(BUS_DATA_BYTES-1 downto 0);\n" +
                        "      req_wdata : std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "      dline_data : std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "      dline_addr_req : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      dline_size_req : std_logic_vector(1 downto 0);\n" +
                        "      dline_load_fault : std_logic;\n" +
                        "      state : std_logic_vector(1 downto 0);\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "      (others => '0'), (others => '0'),\n" +
                        "      (others => '0'), (others => '0'), (others => '0'),\n" +
                        "      '0', State_Idle);\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  comb : process(i_nrst, i_req_data_valid, i_req_data_write, i_req_data_sz, \n" +
                        "                i_req_data_addr, i_req_data_data, i_resp_mem_data_valid, \n" +
                        "                i_resp_mem_data, i_resp_mem_load_fault, i_resp_mem_store_fault,\n" +
                        "                i_resp_mem_store_fault_addr, i_req_mem_ready, i_resp_data_ready, r)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable w_wait_response : std_logic;\n" +
                        "    variable w_o_req_data_ready : std_logic;\n" +
                        "    variable w_o_req_mem_valid : std_logic;\n" +
                        "    variable wb_o_req_mem_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable wb_o_req_strob : std_logic_vector(BUS_DATA_BYTES-1 downto 0);\n" +
                        "    variable wb_o_req_wdata : std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    variable w_req_fire : std_logic;\n" +
                        "    variable w_o_resp_valid : std_logic;\n" +
                        "    variable wb_o_resp_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable wb_resp_data_mux : std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    variable wb_o_resp_data : std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    variable w_o_resp_load_fault : std_logic;\n" +
                        "    variable wb_rtmp : std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "    wb_o_req_strob := (others => '0');\n" +
                        "    wb_o_req_wdata := (others => '0');\n" +
                        "    wb_o_resp_data := (others => '0');\n" +
                        "    wb_rtmp := (others => '0');\n" +
                        "\n" +
                        "    w_wait_response := '0';\n" +
                        "    if r.state = State_WaitResp and i_resp_mem_data_valid = '0' then\n" +
                        "        w_wait_response := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    case i_req_data_sz is\n" +
                        "    when \"00\" =>\n" +
                        "        wb_o_req_wdata := i_req_data_data(7 downto 0) &\n" +
                        "            i_req_data_data(7 downto 0) & i_req_data_data(7 downto 0) &\n" +
                        "            i_req_data_data(7 downto 0) & i_req_data_data(7 downto 0) &\n" +
                        "            i_req_data_data(7 downto 0) & i_req_data_data(7 downto 0) &\n" +
                        "            i_req_data_data(7 downto 0);\n" +
                        "        if i_req_data_addr(2 downto 0) = \"000\" then\n" +
                        "            wb_o_req_strob := X\"01\";\n" +
                        "        elsif i_req_data_addr(2 downto 0) = \"001\" then\n" +
                        "            wb_o_req_strob := X\"02\";\n" +
                        "        elsif i_req_data_addr(2 downto 0) = \"010\" then\n" +
                        "            wb_o_req_strob := X\"04\";\n" +
                        "        elsif i_req_data_addr(2 downto 0) = \"011\" then\n" +
                        "            wb_o_req_strob := X\"08\";\n" +
                        "        elsif i_req_data_addr(2 downto 0) = \"100\" then\n" +
                        "            wb_o_req_strob := X\"10\";\n" +
                        "        elsif i_req_data_addr(2 downto 0) = \"101\" then\n" +
                        "            wb_o_req_strob := X\"20\";\n" +
                        "        elsif i_req_data_addr(2 downto 0) = \"110\" then\n" +
                        "            wb_o_req_strob := X\"40\";\n" +
                        "        elsif i_req_data_addr(2 downto 0) = \"111\" then\n" +
                        "            wb_o_req_strob := X\"80\";\n" +
                        "        end if;\n" +
                        "    when \"01\" =>\n" +
                        "        wb_o_req_wdata := i_req_data_data(15 downto 0) &\n" +
                        "            i_req_data_data(15 downto 0) & i_req_data_data(15 downto 0) &\n" +
                        "            i_req_data_data(15 downto 0);\n" +
                        "        if i_req_data_addr(2 downto 1) = \"00\" then\n" +
                        "            wb_o_req_strob := X\"03\";\n" +
                        "        elsif i_req_data_addr(2 downto 1) = \"01\" then\n" +
                        "            wb_o_req_strob := X\"0C\";\n" +
                        "        elsif i_req_data_addr(2 downto 1) = \"10\" then\n" +
                        "            wb_o_req_strob := X\"30\";\n" +
                        "        else\n" +
                        "            wb_o_req_strob := X\"C0\";\n" +
                        "        end if;\n" +
                        "    when \"10\" =>\n" +
                        "        wb_o_req_wdata := i_req_data_data(31 downto 0) &\n" +
                        "                          i_req_data_data(31 downto 0);\n" +
                        "        if i_req_data_addr(2) = '1' then\n" +
                        "            wb_o_req_strob := X\"F0\";\n" +
                        "        else\n" +
                        "            wb_o_req_strob := X\"0F\";\n" +
                        "        end if;\n" +
                        "    when \"11\" =>\n" +
                        "        wb_o_req_wdata := i_req_data_data;\n" +
                        "        wb_o_req_strob := X\"FF\";\n" +
                        "    when others =>\n" +
                        "    end case;\n" +
                        "\n" +
                        "\n" +
                        "    w_o_req_mem_valid := i_req_data_valid and not w_wait_response;\n" +
                        "    wb_o_req_mem_addr := i_req_data_addr(BUS_ADDR_WIDTH-1 downto 3) & \"000\";\n" +
                        "    w_o_req_data_ready := i_req_mem_ready;\n" +
                        "    w_req_fire := w_o_req_mem_valid and w_o_req_data_ready;\n" +
                        "    case r.state is\n" +
                        "    when State_Idle =>\n" +
                        "        if i_req_data_valid = '1' then\n" +
                        "            if i_req_mem_ready = '1' then\n" +
                        "                v.state := State_WaitResp;\n" +
                        "            else\n" +
                        "                v.state := State_WaitGrant;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    when State_WaitGrant =>\n" +
                        "        if i_req_mem_ready = '1' then\n" +
                        "            v.state := State_WaitResp;\n" +
                        "        end if;\n" +
                        "    when State_WaitResp =>\n" +
                        "        if i_resp_mem_data_valid = '1' then\n" +
                        "            if i_resp_data_ready = '0' then\n" +
                        "                v.state := State_WaitAccept;\n" +
                        "            elsif i_req_data_valid = '0' then\n" +
                        "                v.state := State_Idle;\n" +
                        "            else\n" +
                        "                -- New request\n" +
                        "                if i_req_mem_ready = '1' then\n" +
                        "                    v.state := State_WaitResp;\n" +
                        "                else\n" +
                        "                    v.state := State_WaitGrant;\n" +
                        "                end if;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    when State_WaitAccept =>\n" +
                        "        if i_resp_data_ready = '1' then\n" +
                        "            if i_req_data_valid = '0' then\n" +
                        "                v.state := State_Idle;\n" +
                        "            else\n" +
                        "                if i_req_mem_ready = '1' then\n" +
                        "                    v.state := State_WaitResp;\n" +
                        "                else\n" +
                        "                    v.state := State_WaitGrant;\n" +
                        "                end if;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    when others =>\n" +
                        "    end case;\n" +
                        "\n" +
                        "    if w_req_fire = '1' then\n" +
                        "        v.dline_addr_req := i_req_data_addr;\n" +
                        "        v.dline_size_req := i_req_data_sz;\n" +
                        "        v.req_strob := wb_o_req_strob;\n" +
                        "        v.req_wdata := wb_o_req_wdata;\n" +
                        "    end if;\n" +
                        "    if i_resp_mem_data_valid = '1' then\n" +
                        "        v.dline_data := i_resp_mem_data;\n" +
                        "        v.dline_load_fault := i_resp_mem_load_fault;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    wb_o_resp_addr := r.dline_addr_req;\n" +
                        "    if r.state = State_WaitAccept then\n" +
                        "        w_o_resp_valid := '1';\n" +
                        "        wb_resp_data_mux := r.dline_data;\n" +
                        "        w_o_resp_load_fault := r.dline_load_fault;\n" +
                        "    else\n" +
                        "        w_o_resp_valid := i_resp_mem_data_valid;\n" +
                        "        wb_resp_data_mux := i_resp_mem_data;\n" +
                        "        w_o_resp_load_fault := i_resp_mem_load_fault;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    case r.dline_addr_req(2 downto 0) is\n" +
                        "    when \"001\" =>\n" +
                        "        wb_rtmp := X\"00\" & wb_resp_data_mux(63 downto 8);\n" +
                        "    when \"010\" =>\n" +
                        "        wb_rtmp := X\"0000\" & wb_resp_data_mux(63 downto 16);\n" +
                        "    when \"011\" =>\n" +
                        "        wb_rtmp := X\"000000\" & wb_resp_data_mux(63 downto 24);\n" +
                        "    when \"100\" =>\n" +
                        "        wb_rtmp := X\"00000000\" & wb_resp_data_mux(63 downto 32);\n" +
                        "    when \"101\" =>\n" +
                        "        wb_rtmp := X\"0000000000\" & wb_resp_data_mux(63 downto 40);\n" +
                        "    when \"110\" =>\n" +
                        "        wb_rtmp := X\"000000000000\" & wb_resp_data_mux(63 downto 48);\n" +
                        "    when \"111\" =>\n" +
                        "        wb_rtmp := X\"00000000000000\" & wb_resp_data_mux(63 downto 56);\n" +
                        "    when others =>\n" +
                        "        wb_rtmp := wb_resp_data_mux;\n" +
                        "    end case;\n" +
                        "\n" +
                        "    case r.dline_size_req is\n" +
                        "    when \"00\" =>\n" +
                        "        wb_o_resp_data(7 downto 0) := wb_rtmp(7 downto 0);\n" +
                        "    when \"01\" =>\n" +
                        "        wb_o_resp_data(15 downto 0) := wb_rtmp(15 downto 0);\n" +
                        "    when \"10\" =>\n" +
                        "        wb_o_resp_data(31 downto 0) := wb_rtmp(31 downto 0);\n" +
                        "    when others =>\n" +
                        "        wb_o_resp_data := wb_rtmp;\n" +
                        "    end case;\n" +
                        "    \n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    o_req_data_ready <= w_o_req_data_ready;\n" +
                        "\n" +
                        "    o_req_mem_valid <= w_o_req_mem_valid;\n" +
                        "    o_req_mem_addr <= wb_o_req_mem_addr;\n" +
                        "    o_req_mem_write <= i_req_data_write;\n" +
                        "    o_req_mem_strob <= r.req_strob;\n" +
                        "    o_req_mem_data <= r.req_wdata;\n" +
                        "    o_req_mem_len <= X\"00\";\n" +
                        "    o_req_mem_burst <= \"00\";\n" +
                        "    o_req_mem_last <= '1';\n" +
                        "\n" +
                        "    o_resp_data_valid <= w_o_resp_valid;\n" +
                        "    o_resp_data_data <= wb_o_resp_data;\n" +
                        "    o_resp_data_addr <= wb_o_resp_addr;\n" +
                        "    o_resp_data_load_fault <= w_o_resp_load_fault;\n" +
                        "    -- AXI b channel\n" +
                        "    o_resp_data_store_fault <= i_resp_mem_store_fault;\n" +
                        "    o_resp_data_store_fault_addr <= i_resp_mem_store_fault_addr;\n" +
                        "    o_dstate <= r.state;\n" +
                        "    \n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(i_clk, i_nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_cache_top_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use riverlib.river_cfg.all;\n" +
                        "\n" +
                        "\n" +
                        "entity CacheTop is generic (\n" +
                        "    memtech : integer;\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;                              -- CPU clock\n" +
                        "    i_nrst : in std_logic;                             -- Reset. Active LOW.\n" +
                        "    -- Control path:\n" +
                        "    i_req_ctrl_valid : in std_logic;\n" +
                        "    i_req_ctrl_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_req_ctrl_ready : out std_logic;\n" +
                        "    o_resp_ctrl_valid : out std_logic;\n" +
                        "    o_resp_ctrl_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_resp_ctrl_data : out std_logic_vector(31 downto 0);\n" +
                        "    o_resp_ctrl_load_fault : out std_logic;\n" +
                        "    i_resp_ctrl_ready : in std_logic;\n" +
                        "    -- Data path:\n" +
                        "    i_req_data_valid : in std_logic;\n" +
                        "    i_req_data_write : in std_logic;\n" +
                        "    i_req_data_size : in std_logic_vector(1 downto 0);\n" +
                        "    i_req_data_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_req_data_data : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_req_data_ready : out std_logic;\n" +
                        "    o_resp_data_valid : out std_logic;\n" +
                        "    o_resp_data_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_resp_data_data : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_resp_data_load_fault : out std_logic;\n" +
                        "    o_resp_data_store_fault : out std_logic;\n" +
                        "    o_resp_data_store_fault_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_resp_data_ready : in std_logic;\n" +
                        "    -- Memory interface:\n" +
                        "    i_req_mem_ready : in std_logic;                                    -- AXI request was accepted\n" +
                        "    o_req_mem_valid : out std_logic;\n" +
                        "    o_req_mem_write : out std_logic;\n" +
                        "    o_req_mem_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_req_mem_strob : out std_logic_vector(BUS_DATA_BYTES-1 downto 0);\n" +
                        "    o_req_mem_data : out std_logic_vector(BUS_DATA_WIDTH-1 downto 0);  -- burst transaction length\n" +
                        "    o_req_mem_len : out std_logic_vector(7 downto 0);                  -- burst length\n" +
                        "    o_req_mem_burst : out std_logic_vector(1 downto 0);                -- burst type: \"00\" FIX; \"01\" INCR; \"10\" WRAP\n" +
                        "    i_resp_mem_data_valid : in std_logic;\n" +
                        "    i_resp_mem_data : in std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    i_resp_mem_load_fault : in std_logic;                             -- Bus response with SLVERR or DECERR on read\n" +
                        "    i_resp_mem_store_fault : in std_logic;                            -- Bus response with SLVERR or DECERR on write\n" +
                        "    i_resp_mem_store_fault_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    -- Debug signals:\n" +
                        "    i_flush_address : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);  -- clear ICache address from debug interface\n" +
                        "    i_flush_valid : in std_logic;                                      -- address to clear icache is valid\n" +
                        "    o_istate : out std_logic_vector(1 downto 0);                      -- ICache state machine value\n" +
                        "    o_dstate : out std_logic_vector(1 downto 0);                      -- DCache state machine value\n" +
                        "    o_cstate : out std_logic_vector(1 downto 0)                       -- cachetop state machine value\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_CacheTop of CacheTop is\n" +
                        "  constant State_Idle : std_logic_vector(1 downto 0) := \"00\";\n" +
                        "  constant State_IMem : std_logic_vector(1 downto 0) := \"01\";\n" +
                        "  constant State_DMem : std_logic_vector(1 downto 0) := \"10\";\n" +
                        "\n" +
                        "  type CacheOutputType is record\n" +
                        "      req_mem_valid : std_logic;\n" +
                        "      req_mem_write : std_logic;\n" +
                        "      req_mem_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      req_mem_strob : std_logic_vector(BUS_DATA_BYTES-1 downto 0);\n" +
                        "      req_mem_wdata : std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "      req_mem_len : std_logic_vector(7 downto 0);\n" +
                        "      req_mem_burst : std_logic_vector(1 downto 0);\n" +
                        "      req_mem_last : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "      state : std_logic_vector(1 downto 0);\n" +
                        "  end record;\n" +
                        "\n" +
                        "  signal i :  CacheOutputType;\n" +
                        "  signal d :  CacheOutputType;\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "  -- Memory Control interface:\n" +
                        "  signal w_ctrl_resp_mem_data_valid : std_logic;\n" +
                        "  signal wb_ctrl_resp_mem_data : std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "  signal w_ctrl_resp_mem_load_fault : std_logic;\n" +
                        "  signal w_ctrl_req_ready : std_logic;\n" +
                        "  -- Memory Data interface:\n" +
                        "  signal w_data_resp_mem_data_valid : std_logic;\n" +
                        "  signal wb_data_resp_mem_data : std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "  signal w_data_resp_mem_load_fault : std_logic;\n" +
                        "  signal w_data_req_ready : std_logic;\n" +
                        "\n" +
                        "  component ICacheLru is generic (\n" +
                        "    memtech : integer;\n" +
                        "    async_reset : boolean;\n" +
                        "    index_width : integer\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_req_ctrl_valid : in std_logic;\n" +
                        "    i_req_ctrl_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_req_ctrl_ready : out std_logic;\n" +
                        "    o_resp_ctrl_valid : out std_logic;\n" +
                        "    o_resp_ctrl_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_resp_ctrl_data : out std_logic_vector(31 downto 0);\n" +
                        "    o_resp_ctrl_load_fault : out std_logic;\n" +
                        "    i_resp_ctrl_ready : in std_logic;\n" +
                        "    i_req_mem_ready : in std_logic;\n" +
                        "    o_req_mem_valid : out std_logic;\n" +
                        "    o_req_mem_write : out std_logic;\n" +
                        "    o_req_mem_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_req_mem_strob : out std_logic_vector(BUS_DATA_BYTES-1 downto 0);\n" +
                        "    o_req_mem_data : out std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    o_req_mem_len : out std_logic_vector(7 downto 0);\n" +
                        "    o_req_mem_burst : out std_logic_vector(1 downto 0);\n" +
                        "    o_req_mem_last : out std_logic;\n" +
                        "    i_resp_mem_data_valid : in std_logic;\n" +
                        "    i_resp_mem_data : in std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    i_resp_mem_load_fault : in std_logic;\n" +
                        "    i_flush_address : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_flush_valid : in std_logic;\n" +
                        "    o_istate : out std_logic_vector(1 downto 0)\n" +
                        "  );\n" +
                        "  end component; \n" +
                        "\n" +
                        "  component DCache is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_req_data_valid : in std_logic;\n" +
                        "    i_req_data_write : in std_logic;\n" +
                        "    i_req_data_sz : in std_logic_vector(1 downto 0);\n" +
                        "    i_req_data_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_req_data_data : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_req_data_ready : out std_logic;\n" +
                        "    o_resp_data_valid : out std_logic;\n" +
                        "    o_resp_data_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_resp_data_data : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_resp_data_load_fault : out std_logic;\n" +
                        "    o_resp_data_store_fault : out std_logic;\n" +
                        "    o_resp_data_store_fault_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_resp_data_ready : in std_logic;\n" +
                        "    i_req_mem_ready : in std_logic;\n" +
                        "    o_req_mem_valid : out std_logic;\n" +
                        "    o_req_mem_write : out std_logic;\n" +
                        "    o_req_mem_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_req_mem_strob : out std_logic_vector(BUS_DATA_BYTES-1 downto 0);\n" +
                        "    o_req_mem_data : out std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    o_req_mem_len : out std_logic_vector(7 downto 0);\n" +
                        "    o_req_mem_burst : out std_logic_vector(1 downto 0);\n" +
                        "    o_req_mem_last : out std_logic;\n" +
                        "    i_resp_mem_data_valid : in std_logic;\n" +
                        "    i_resp_mem_data : in std_logic_vector(BUS_DATA_WIDTH-1 downto 0);\n" +
                        "    i_resp_mem_load_fault : in std_logic;\n" +
                        "    i_resp_mem_store_fault : in std_logic;\n" +
                        "    i_resp_mem_store_fault_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_dstate : out std_logic_vector(1 downto 0)\n" +
                        "  );\n" +
                        "  end component; \n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "    i0 : ICacheLru generic map (\n" +
                        "        memtech => memtech,\n" +
                        "        async_reset => async_reset,\n" +
                        "        index_width => CFG_IINDEX_WIDTH\n" +
                        "      ) port map (\n" +
                        "        i_clk => i_clk,\n" +
                        "        i_nrst => i_nrst,\n" +
                        "        i_req_ctrl_valid => i_req_ctrl_valid,\n" +
                        "        i_req_ctrl_addr => i_req_ctrl_addr,\n" +
                        "        o_req_ctrl_ready => o_req_ctrl_ready,\n" +
                        "        o_resp_ctrl_valid => o_resp_ctrl_valid,\n" +
                        "        o_resp_ctrl_addr => o_resp_ctrl_addr,\n" +
                        "        o_resp_ctrl_data => o_resp_ctrl_data,\n" +
                        "        o_resp_ctrl_load_fault => o_resp_ctrl_load_fault,\n" +
                        "        i_resp_ctrl_ready => i_resp_ctrl_ready,\n" +
                        "        i_req_mem_ready => w_ctrl_req_ready,\n" +
                        "        o_req_mem_valid => i.req_mem_valid,\n" +
                        "        o_req_mem_write => i.req_mem_write,\n" +
                        "        o_req_mem_addr => i.req_mem_addr,\n" +
                        "        o_req_mem_strob => i.req_mem_strob,\n" +
                        "        o_req_mem_data => i.req_mem_wdata,\n" +
                        "        o_req_mem_len => i.req_mem_len,\n" +
                        "        o_req_mem_burst => i.req_mem_burst,\n" +
                        "        o_req_mem_last => i.req_mem_last,\n" +
                        "        i_resp_mem_data_valid => w_ctrl_resp_mem_data_valid,\n" +
                        "        i_resp_mem_data => wb_ctrl_resp_mem_data,\n" +
                        "        i_resp_mem_load_fault => w_ctrl_resp_mem_load_fault,\n" +
                        "        i_flush_address => i_flush_address,\n" +
                        "        i_flush_valid => i_flush_valid,\n" +
                        "        o_istate => o_istate);\n" +
                        "\n" +
                        "    d0 : DCache generic map (\n" +
                        "        async_reset => async_reset\n" +
                        "      ) port map (\n" +
                        "        i_clk => i_clk,\n" +
                        "        i_nrst => i_nrst,\n" +
                        "        i_req_data_valid => i_req_data_valid,\n" +
                        "        i_req_data_write => i_req_data_write,\n" +
                        "        i_req_data_sz => i_req_data_size,\n" +
                        "        i_req_data_addr => i_req_data_addr,\n" +
                        "        i_req_data_data => i_req_data_data,\n" +
                        "        o_req_data_ready => o_req_data_ready,\n" +
                        "        o_resp_data_valid => o_resp_data_valid,\n" +
                        "        o_resp_data_addr => o_resp_data_addr,\n" +
                        "        o_resp_data_data => o_resp_data_data,\n" +
                        "        o_resp_data_load_fault => o_resp_data_load_fault,\n" +
                        "        o_resp_data_store_fault => o_resp_data_store_fault,\n" +
                        "        o_resp_data_store_fault_addr => o_resp_data_store_fault_addr,\n" +
                        "        i_resp_data_ready => i_resp_data_ready,\n" +
                        "        i_req_mem_ready => w_data_req_ready,\n" +
                        "        o_req_mem_valid => d.req_mem_valid,\n" +
                        "        o_req_mem_write => d.req_mem_write,\n" +
                        "        o_req_mem_addr => d.req_mem_addr,\n" +
                        "        o_req_mem_strob => d.req_mem_strob,\n" +
                        "        o_req_mem_data => d.req_mem_wdata,\n" +
                        "        o_req_mem_len => d.req_mem_len,\n" +
                        "        o_req_mem_burst => d.req_mem_burst,\n" +
                        "        o_req_mem_last => d.req_mem_last,\n" +
                        "        i_resp_mem_data_valid => w_data_resp_mem_data_valid,\n" +
                        "        i_resp_mem_data => wb_data_resp_mem_data,\n" +
                        "        i_resp_mem_load_fault => w_data_resp_mem_load_fault,\n" +
                        "        i_resp_mem_store_fault => i_resp_mem_store_fault,\n" +
                        "        i_resp_mem_store_fault_addr => i_resp_mem_store_fault_addr,\n" +
                        "        o_dstate => o_dstate);\n" +
                        "\n" +
                        "  comb : process(i_nrst, i_req_mem_ready, i_resp_mem_data_valid, i_resp_mem_data,\n" +
                        "                 i_resp_mem_load_fault, i, d, r)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable w_req_mem_valid : std_logic;\n" +
                        "    variable wb_mem_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable wb_mem_len : std_logic_vector(7 downto 0);\n" +
                        "    variable wb_mem_burst : std_logic_vector(1 downto 0);\n" +
                        "    variable w_mem_write : std_logic;\n" +
                        "    variable v_data_req_ready : std_logic;\n" +
                        "    variable v_data_resp_mem_data_valid : std_logic;\n" +
                        "    variable v_ctrl_req_ready : std_logic;\n" +
                        "    variable v_ctrl_resp_mem_data_valid : std_logic;\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    -- default is data path\n" +
                        "    w_req_mem_valid := '0';\n" +
                        "    wb_mem_addr := d.req_mem_addr;\n" +
                        "    w_mem_write := d.req_mem_write;\n" +
                        "    wb_mem_len := d.req_mem_len;\n" +
                        "    wb_mem_burst := d.req_mem_burst;\n" +
                        "    v_data_req_ready := '0';\n" +
                        "    v_data_resp_mem_data_valid := '0';\n" +
                        "    v_ctrl_req_ready := '0';\n" +
                        "    v_ctrl_resp_mem_data_valid := '0';\n" +
                        "   \n" +
                        "    case r.state is\n" +
                        "    when State_Idle =>\n" +
                        "        w_req_mem_valid := i.req_mem_valid or d.req_mem_valid;\n" +
                        "        if d.req_mem_valid = '1' then\n" +
                        "            v_data_req_ready := i_req_mem_ready;\n" +
                        "            if i_req_mem_ready = '1' then\n" +
                        "                v.state := State_DMem;\n" +
                        "            end if;\n" +
                        "        elsif i.req_mem_valid = '1' then\n" +
                        "            v_ctrl_req_ready := i_req_mem_ready;\n" +
                        "            wb_mem_addr := i.req_mem_addr;\n" +
                        "            wb_mem_len := i.req_mem_len;\n" +
                        "            wb_mem_burst := i.req_mem_burst;\n" +
                        "            w_mem_write := i.req_mem_write;\n" +
                        "            if i_req_mem_ready = '1' then\n" +
                        "                v.state := State_IMem;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "\n" +
                        "    when State_DMem =>\n" +
                        "        w_req_mem_valid := d.req_mem_last and (i.req_mem_valid or d.req_mem_valid);\n" +
                        "        if i_resp_mem_data_valid = '1' and d.req_mem_last = '1' then\n" +
                        "            if d.req_mem_valid = '1' then\n" +
                        "                v_data_req_ready := i_req_mem_ready;\n" +
                        "                if i_req_mem_ready = '1' then\n" +
                        "                     v.state := State_DMem;\n" +
                        "                else\n" +
                        "                    v.state := State_Idle;\n" +
                        "                end if;\n" +
                        "            elsif i.req_mem_valid = '1' then\n" +
                        "                v_ctrl_req_ready := i_req_mem_ready;\n" +
                        "                wb_mem_addr := i.req_mem_addr;\n" +
                        "                wb_mem_len := i.req_mem_len;\n" +
                        "                wb_mem_burst := i.req_mem_burst;\n" +
                        "                w_mem_write := i.req_mem_write;\n" +
                        "                if i_req_mem_ready = '1' then\n" +
                        "                    v.state := State_IMem;\n" +
                        "                else\n" +
                        "                    v.state := State_Idle;\n" +
                        "                end if;\n" +
                        "            else\n" +
                        "                v.state := State_Idle;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "        v_data_resp_mem_data_valid := i_resp_mem_data_valid;\n" +
                        "        \n" +
                        "    when State_IMem =>\n" +
                        "        w_req_mem_valid := i.req_mem_last and (i.req_mem_valid or d.req_mem_valid);\n" +
                        "        if i_resp_mem_data_valid = '1' and i.req_mem_last = '1' then\n" +
                        "            if d.req_mem_valid = '1' then\n" +
                        "                v_data_req_ready := i_req_mem_ready;\n" +
                        "                if i_req_mem_ready = '1' then\n" +
                        "                    v.state := State_DMem;\n" +
                        "                else\n" +
                        "                    v.state := State_Idle;\n" +
                        "                end if;\n" +
                        "            elsif i.req_mem_valid = '1' then\n" +
                        "                v_ctrl_req_ready := i_req_mem_ready;\n" +
                        "                wb_mem_addr := i.req_mem_addr;\n" +
                        "                wb_mem_len := i.req_mem_len;\n" +
                        "                wb_mem_burst := i.req_mem_burst;\n" +
                        "                w_mem_write := i.req_mem_write;\n" +
                        "                if i_req_mem_ready = '1' then\n" +
                        "                    v.state := State_IMem;\n" +
                        "                else\n" +
                        "                    v.state := State_Idle;\n" +
                        "                end if;\n" +
                        "            else\n" +
                        "                v.state := State_Idle;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "        v_ctrl_resp_mem_data_valid := i_resp_mem_data_valid;\n" +
                        "        \n" +
                        "    when others =>\n" +
                        "    end case;\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v.state := State_Idle;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_data_req_ready <= v_data_req_ready;\n" +
                        "    w_data_resp_mem_data_valid <= v_data_resp_mem_data_valid;\n" +
                        "    wb_data_resp_mem_data <= i_resp_mem_data;\n" +
                        "    w_data_resp_mem_load_fault <= i_resp_mem_load_fault;\n" +
                        "\n" +
                        "    w_ctrl_req_ready <= v_ctrl_req_ready;\n" +
                        "    w_ctrl_resp_mem_data_valid <= v_ctrl_resp_mem_data_valid;\n" +
                        "    wb_ctrl_resp_mem_data <= i_resp_mem_data;\n" +
                        "    w_ctrl_resp_mem_load_fault <= i_resp_mem_load_fault;\n" +
                        "\n" +
                        "    o_req_mem_valid <= w_req_mem_valid;\n" +
                        "    o_req_mem_addr <= wb_mem_addr;\n" +
                        "    o_req_mem_len <= wb_mem_len;\n" +
                        "    o_req_mem_burst <= wb_mem_burst;\n" +
                        "    o_req_mem_write <= w_mem_write;\n" +
                        "    o_req_mem_strob <= d.req_mem_strob;\n" +
                        "    o_req_mem_data <= d.req_mem_wdata;\n" +
                        "    o_cstate <= r.state;\n" +
                        "    \n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(i_clk, i_nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r.state <= State_Idle;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_stacktrbuf_vhd_file(String Project_Folder_File) {
        String data =   "-----------------------------------------------------------------------------\n" +
                        "--! @file\n" +
                        "--! @copyright Copyright 2017 GNSS Sensor Ltd. All right reserved.\n" +
                        "--! @author    Sergey Khabarov - sergeykhbr@gmail.com\n" +
                        "--! @brief     Stack trace buffer on hardware level.\n" +
                        "------------------------------------------------------------------------------\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "\n" +
                        "entity StackTraceBuffer is \n" +
                        "  generic (\n" +
                        "    abits : integer := 5;\n" +
                        "    dbits : integer := 64\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk   : in std_logic;\n" +
                        "    i_raddr : in std_logic_vector(abits-1 downto 0);\n" +
                        "    o_rdata : out std_logic_vector(dbits-1 downto 0);\n" +
                        "    i_we    : in std_logic;\n" +
                        "    i_waddr : in std_logic_vector(abits-1 downto 0);\n" +
                        "    i_wdata : in std_logic_vector(dbits-1 downto 0)\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_StackTraceBuffer of StackTraceBuffer is\n" +
                        "\n" +
                        "  type ram_type is array ((2**abits)-1 downto 0) of std_logic_vector (dbits-1 downto 0);\n" +
                        "  signal stackbuf    : ram_type;\n" +
                        "  signal raddr       : std_logic_vector(abits-1 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(i_clk) begin \n" +
                        "    if rising_edge(i_clk) then \n" +
                        "      if i_we = '1' then\n" +
                        "        stackbuf(conv_integer(i_waddr)) <= i_wdata; \n" +
                        "      end if;\n" +
                        "      raddr <= i_raddr;\n" +
                        "    end if;\n" +
                        "  end process;\n" +
                        "  \n" +
                        "  o_rdata <= stackbuf(conv_integer(raddr));\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_regibank_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use riverlib.river_cfg.all;\n" +
                        "\n" +
                        "\n" +
                        "entity RegIntBank is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;                                   -- CPU clock\n" +
                        "    i_nrst : in std_logic;                                  -- Reset. Active LOW.\n" +
                        "\n" +
                        "    i_radr1 : in std_logic_vector(5 downto 0);              -- Port 1 read address\n" +
                        "    o_rdata1 : out std_logic_vector(RISCV_ARCH-1 downto 0); -- Port 1 read value\n" +
                        "\n" +
                        "    i_radr2 : in std_logic_vector(5 downto 0);              -- Port 2 read address\n" +
                        "    o_rdata2 : out std_logic_vector(RISCV_ARCH-1 downto 0); -- Port 2 read value\n" +
                        "\n" +
                        "    i_waddr : in std_logic_vector(5 downto 0);              -- Writing value\n" +
                        "    i_wena : in std_logic;                                  -- Writing is enabled\n" +
                        "    i_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0);   -- Writing value\n" +
                        "\n" +
                        "    i_dport_addr : in std_logic_vector(4 downto 0);         -- Debug port address\n" +
                        "    i_dport_ena : in std_logic;                             -- Debug port is enabled\n" +
                        "    i_dport_write : in std_logic;                           -- Debug port write is enabled\n" +
                        "    i_dport_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0); -- Debug port write value\n" +
                        "    o_dport_rdata : out std_logic_vector(RISCV_ARCH-1 downto 0);-- Debug port read value\n" +
                        "\n" +
                        "    o_ra : out std_logic_vector(RISCV_ARCH-1 downto 0);     -- Return address for branch predictor\n" +
                        "    o_sp : out std_logic_vector(RISCV_ARCH-1 downto 0)      -- Stack Pointer for the borders control\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_RegIntBank of RegIntBank is\n" +
                        "\n" +
                        "  type MemoryType is array (0 to Reg_Total-1) \n" +
                        "         of std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "      mem : MemoryType;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  comb : process(i_nrst, i_radr1, i_radr2, i_waddr, i_wena, i_wdata,\n" +
                        "                 i_dport_ena, i_dport_write, i_dport_addr, i_dport_wdata, r)\n" +
                        "    variable v : RegistersType;\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "    --! Debug port has higher priority. Collision must be controlled by SW\n" +
                        "    if (i_dport_ena and i_dport_write) = '1' then\n" +
                        "        if i_dport_addr /= \"00000\" then\n" +
                        "            v.mem(conv_integer(i_dport_addr)) := i_dport_wdata;\n" +
                        "        end if;\n" +
                        "    elsif i_waddr(5) = '0' and i_wena = '1'  then\n" +
                        "        if i_waddr(4 downto 0) /= \"00000\" then\n" +
                        "            v.mem(conv_integer(i_waddr(4 downto 0))) := i_wdata;\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v.mem(Reg_Zero) := (others => '0');\n" +
                        "        for i in 1 to Reg_Total-1 loop\n" +
                        "            v.mem(i) := X\"00000000FEEDFACE\";\n" +
                        "        end loop;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  o_rdata1 <= r.mem(conv_integer(i_radr1(4 downto 0)));\n" +
                        "  o_rdata2 <= r.mem(conv_integer(i_radr2(4 downto 0)));\n" +
                        "  o_dport_rdata <= r.mem(conv_integer(i_dport_addr));\n" +
                        "  o_ra <= r.mem(Reg_ra);\n" +
                        "  o_sp <= r.mem(Reg_sp);\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(i_nrst, i_clk)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r.mem(Reg_Zero) <= (others => '0');\n" +
                        "        for i in 1 to Reg_Total-1 loop\n" +
                        "            r.mem(i) <= X\"00000000FEEDFACE\";\n" +
                        "        end loop;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_regfbank_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use riverlib.river_cfg.all;\n" +
                        "\n" +
                        "\n" +
                        "entity RegFloatBank is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;                                   -- CPU clock\n" +
                        "    i_nrst : in std_logic;                                  -- Reset. Active LOW.\n" +
                        "\n" +
                        "    i_radr1 : in std_logic_vector(5 downto 0);              -- Port 1 read address\n" +
                        "    o_rdata1 : out std_logic_vector(RISCV_ARCH-1 downto 0); -- Port 1 read value\n" +
                        "\n" +
                        "    i_radr2 : in std_logic_vector(5 downto 0);              -- Port 2 read address\n" +
                        "    o_rdata2 : out std_logic_vector(RISCV_ARCH-1 downto 0); -- Port 2 read value\n" +
                        "\n" +
                        "    i_waddr : in std_logic_vector(5 downto 0);              -- Writing value\n" +
                        "    i_wena : in std_logic;                                  -- Writing is enabled\n" +
                        "    i_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0);   -- Writing value\n" +
                        "\n" +
                        "    i_dport_addr : in std_logic_vector(4 downto 0);         -- Debug port address\n" +
                        "    i_dport_ena : in std_logic;                             -- Debug port is enabled\n" +
                        "    i_dport_write : in std_logic;                           -- Debug port write is enabled\n" +
                        "    i_dport_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0); -- Debug port write value\n" +
                        "    o_dport_rdata : out std_logic_vector(RISCV_ARCH-1 downto 0)-- Debug port read value\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_RegFloatBank of RegFloatBank is\n" +
                        "\n" +
                        "  type MemoryType is array (0 to RegFpu_Total-1) \n" +
                        "         of std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "      mem : MemoryType;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  comb : process(i_nrst, i_radr1, i_radr2, i_waddr, i_wena, i_wdata,\n" +
                        "                 i_dport_ena, i_dport_write, i_dport_addr, i_dport_wdata, r)\n" +
                        "    variable v : RegistersType;\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "    --! Debug port has higher priority. Collision must be controlled by SW\n" +
                        "    if (i_dport_ena and i_dport_write) = '1' then\n" +
                        "        if i_dport_addr /= \"00000\" then\n" +
                        "            v.mem(conv_integer(i_dport_addr)) := i_dport_wdata;\n" +
                        "        end if;\n" +
                        "    elsif i_wena = '1' and i_waddr(5) = '1' then\n" +
                        "        v.mem(conv_integer(i_waddr(4 downto 0))) := i_wdata;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        for i in 0 to RegFpu_Total-1 loop\n" +
                        "            v.mem(i) := X\"00000000FEEDFACE\";\n" +
                        "        end loop;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  o_rdata1 <= r.mem(conv_integer(i_radr1(4 downto 0)));\n" +
                        "  o_rdata2 <= r.mem(conv_integer(i_radr2(4 downto 0)));\n" +
                        "  o_dport_rdata <= r.mem(conv_integer(i_dport_addr));\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(i_nrst, i_clk)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        for i in 0 to RegFpu_Total-1 loop\n" +
                        "            r.mem(i) <= X\"00000000FEEDFACE\";\n" +
                        "        end loop;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_proc_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use riverlib.river_cfg.all;\n" +
                        "\n" +
                        "library target;\n" +
                        "use target.config_target.all;\n" +
                        "\n" +
                        "entity Processor is\n" +
                        "  generic (\n" +
                        "    hartid : integer;\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;                                             -- CPU clock\n" +
                        "    i_nrst : in std_logic;                                            -- Reset. Active LOW.\n" +
                        "    -- Control path:\n" +
                        "    i_req_ctrl_ready : in std_logic;                                  -- ICache is ready to accept request\n" +
                        "    o_req_ctrl_valid : out std_logic;                                 -- Request to ICache is valid\n" +
                        "    o_req_ctrl_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);-- Requesting address to ICache\n" +
                        "    i_resp_ctrl_valid : in std_logic;                                 -- ICache response is valid\n" +
                        "    i_resp_ctrl_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);-- Response address must be equal to the latest request address\n" +
                        "    i_resp_ctrl_data : in std_logic_vector(31 downto 0);              -- Read value\n" +
                        "    i_resp_ctrl_load_fault : in std_logic;                            -- bus response with error\n" +
                        "    o_resp_ctrl_ready : out std_logic;\n" +
                        "    -- Data path:\n" +
                        "    i_req_data_ready : in std_logic;                                  -- DCache is ready to accept request\n" +
                        "    o_req_data_valid : out std_logic;                                 -- Request to DCache is valid\n" +
                        "    o_req_data_write : out std_logic;                                 -- Read/Write transaction\n" +
                        "    o_req_data_size : out std_logic_vector(1 downto 0);               -- Size [Bytes]: 0=1B; 1=2B; 2=4B; 3=8B\n" +
                        "    o_req_data_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);-- Requesting address to DCache\n" +
                        "    o_req_data_data : out std_logic_vector(RISCV_ARCH-1 downto 0);    -- Writing value\n" +
                        "    i_resp_data_valid : in std_logic;                                 -- DCache response is valid\n" +
                        "    i_resp_data_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);-- DCache response address must be equal to the latest request address\n" +
                        "    i_resp_data_data : in std_logic_vector(RISCV_ARCH-1 downto 0);    -- Read value\n" +
                        "    i_resp_data_load_fault : in std_logic;                            -- Bus response with SLVERR or DECERR on read\n" +
                        "    i_resp_data_store_fault : in std_logic;                           -- Bus response with SLVERR or DECERR on write\n" +
                        "    i_resp_data_store_fault_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_resp_data_ready : out std_logic;\n" +
                        "    -- External interrupt pin\n" +
                        "    i_ext_irq : in std_logic;                                         -- PLIC interrupt accordingly with spec\n" +
                        "    o_time : out std_logic_vector(63 downto 0);                       -- Timer in clock except halt state\n" +
                        "    -- Debug interface:\n" +
                        "    i_dport_valid : in std_logic;                                     -- Debug access from DSU is valid\n" +
                        "    i_dport_write : in std_logic;                                     -- Write command flag\n" +
                        "    i_dport_region : in std_logic_vector(1 downto 0);                 -- Registers region ID: 0=CSR; 1=IREGS; 2=Control\n" +
                        "    i_dport_addr : in std_logic_vector(11 downto 0);                  -- Register idx\n" +
                        "    i_dport_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0);       -- Write value\n" +
                        "    o_dport_ready : out std_logic;                                    -- Response is ready\n" +
                        "    o_dport_rdata : out std_logic_vector(RISCV_ARCH-1 downto 0);      -- Response value\n" +
                        "    o_halted : out std_logic;\n" +
                        "    -- Debug signals:\n" +
                        "    o_flush_address : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);-- Address of instruction to remove from ICache\n" +
                        "    o_flush_valid : out std_logic;                                    -- Remove address from ICache is valid\n" +
                        "    i_istate : in std_logic_vector(1 downto 0);                       -- ICache state machine value\n" +
                        "    i_dstate : in std_logic_vector(1 downto 0);                       -- DCache state machine value\n" +
                        "    i_cstate : in std_logic_vector(1 downto 0)                        -- CacheTop state machine value\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_Processor of Processor is\n" +
                        "\n" +
                        "    type FetchType is record\n" +
                        "        req_fire : std_logic;\n" +
                        "        instr_load_fault : std_logic;\n" +
                        "        valid : std_logic;\n" +
                        "        pc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "        instr : std_logic_vector(31 downto 0);\n" +
                        "        imem_req_valid : std_logic;\n" +
                        "        imem_req_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "        pipeline_hold : std_logic;\n" +
                        "    end record;\n" +
                        "\n" +
                        "    type InstructionDecodeType is record\n" +
                        "        pc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "        instr : std_logic_vector(31 downto 0);\n" +
                        "        instr_valid : std_logic;\n" +
                        "        memop_store : std_logic;\n" +
                        "        memop_load : std_logic;\n" +
                        "        memop_sign_ext : std_logic;\n" +
                        "        memop_size : std_logic_vector(1 downto 0);\n" +
                        "        rv32 : std_logic;                                    -- 32-bits instruction\n" +
                        "        compressed : std_logic;                              -- C-extension\n" +
                        "        f64 : std_logic;                                     -- D-extension (FPU)\n" +
                        "        unsigned_op : std_logic;                             -- Unsigned operands\n" +
                        "        isa_type : std_logic_vector(ISA_Total-1 downto 0);\n" +
                        "        instr_vec : std_logic_vector(Instr_Total-1 downto 0);\n" +
                        "        exception : std_logic;\n" +
                        "        instr_load_fault : std_logic;\n" +
                        "    end record;\n" +
                        "\n" +
                        "    type ExecuteType is record\n" +
                        "        trap_ready : std_logic;\n" +
                        "        valid : std_logic;\n" +
                        "        instr : std_logic_vector(31 downto 0);\n" +
                        "        pc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "        npc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "        ex_npc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "\n" +
                        "        radr1 : std_logic_vector(5 downto 0);\n" +
                        "        radr2 : std_logic_vector(5 downto 0);\n" +
                        "        res_addr : std_logic_vector(5 downto 0);\n" +
                        "        res_data : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "        mret : std_logic;\n" +
                        "        uret : std_logic;\n" +
                        "        csr_addr : std_logic_vector(11 downto 0);\n" +
                        "        csr_wena : std_logic;\n" +
                        "        csr_wdata : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "        ex_instr_load_fault : std_logic;\n" +
                        "        ex_illegal_instr : std_logic;\n" +
                        "        ex_unalign_load : std_logic;\n" +
                        "        ex_unalign_store : std_logic;\n" +
                        "        ex_breakpoint : std_logic;\n" +
                        "        ex_ecall : std_logic;\n" +
                        "        ex_fpu_invalidop : std_logic;            -- FPU Exception: invalid operation\n" +
                        "        ex_fpu_divbyzero : std_logic;            -- FPU Exception: divide by zero\n" +
                        "        ex_fpu_overflow : std_logic;             -- FPU Exception: overflow\n" +
                        "        ex_fpu_underflow : std_logic;            -- FPU Exception: underflow\n" +
                        "        ex_fpu_inexact : std_logic;              -- FPU Exception: inexact\n" +
                        "        fpu_valid : std_logic;\n" +
                        "\n" +
                        "        memop_sign_ext : std_logic;\n" +
                        "        memop_load : std_logic;\n" +
                        "        memop_store : std_logic;\n" +
                        "        memop_size : std_logic_vector(1 downto 0);\n" +
                        "        memop_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "        pipeline_hold : std_logic;                            -- Hold pipeline from Execution stage\n" +
                        "        call : std_logic;\n" +
                        "        ret : std_logic;\n" +
                        "    end record;\n" +
                        "\n" +
                        "    type MemoryType is record\n" +
                        "        valid : std_logic;\n" +
                        "        instr : std_logic_vector(31 downto 0);\n" +
                        "        pc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "        pipeline_hold : std_logic;\n" +
                        "    end record;\n" +
                        "\n" +
                        "    type WriteBackType is record\n" +
                        "        pc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "        wena : std_logic;\n" +
                        "        waddr : std_logic_vector(5 downto 0);\n" +
                        "        wdata : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    end record;\n" +
                        "\n" +
                        "    type IntRegsType is record\n" +
                        "        rdata1 : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "        rdata2 : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "        dport_rdata : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "        ra : std_logic_vector(RISCV_ARCH-1 downto 0);       -- Return address\n" +
                        "        sp : std_logic_vector(RISCV_ARCH-1 downto 0);       -- Stack pointer\n" +
                        "    end record;\n" +
                        "\n" +
                        "    type FloatRegsType is record\n" +
                        "        rdata1 : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "        rdata2 : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "        dport_rdata : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    end record;\n" +
                        "\n" +
                        "    type CsrType is record\n" +
                        "        rdata : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "        dport_rdata : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "        trap_valid : std_logic;\n" +
                        "        trap_pc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "        break_event : std_logic;\n" +
                        "    end record;\n" +
                        "\n" +
                        "    --! 5-stages CPU pipeline\n" +
                        "    type PipelineType is record\n" +
                        "        f : FetchType;                            -- Fetch instruction stage\n" +
                        "        d : InstructionDecodeType;                -- Decode instruction stage\n" +
                        "        e : ExecuteType;                          -- Execute instruction\n" +
                        "        m : MemoryType;                           -- Memory load/store\n" +
                        "        w : WriteBackType;                        -- Write back registers value\n" +
                        "    end record;\n" +
                        "\n" +
                        "    type DebugType is record\n" +
                        "        core_addr : std_logic_vector(11 downto 0);           -- Address of the sub-region register\n" +
                        "        core_wdata : std_logic_vector(RISCV_ARCH-1 downto 0);-- Write data\n" +
                        "        csr_ena : std_logic;                                 -- Region 0: Access to CSR bank is enabled.\n" +
                        "        csr_write : std_logic;                               -- Region 0: CSR write enable\n" +
                        "        ireg_ena : std_logic;                                -- Region 1: Access to integer register bank is enabled\n" +
                        "        ireg_write : std_logic;                              -- Region 1: Integer registers bank write pulse\n" +
                        "        freg_ena : std_logic;                                -- Region 1: Access to float register bank is enabled\n" +
                        "        freg_write : std_logic;                              -- Region 1: Float registers bank write pulse\n" +
                        "        npc_write : std_logic;                               -- Region 1: npc write enable\n" +
                        "        halt : std_logic;                                    -- Halt signal is equal to hold pipeline\n" +
                        "        clock_cnt : std_logic_vector(63 downto 0);           -- Number of clocks excluding halt state\n" +
                        "        executed_cnt : std_logic_vector(63 downto 0);        -- Number of executed instruction\n" +
                        "        break_mode : std_logic;                              -- Behaviour on EBREAK instruction: 0 = halt; 1 = generate trap\n" +
                        "        br_fetch_valid : std_logic;                          -- Fetch injection address/instr are valid\n" +
                        "        br_address_fetch : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0); -- Fetch injection address to skip ebreak instruciton only once\n" +
                        "        br_instr_fetch : std_logic_vector(31 downto 0);      -- Real instruction value that was replaced by ebreak\n" +
                        "        flush_address : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);-- Address of instruction to remove from ICache\n" +
                        "        flush_valid : std_logic;                                    -- Remove address from ICache is valid\n" +
                        "    end record;\n" +
                        "\n" +
                        "    type BranchPredictorType is record\n" +
                        "       npc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    end record;\n" +
                        "\n" +
                        "    signal ireg : IntRegsType;\n" +
                        "    signal freg : FloatRegsType;\n" +
                        "    signal csr : CsrType;\n" +
                        "    signal w : PipelineType;\n" +
                        "    signal dbg : DebugType;\n" +
                        "    signal bp : BranchPredictorType;\n" +
                        "\n" +
                        "    signal wb_ireg_dport_addr : std_logic_vector(4 downto 0);\n" +
                        "    signal wb_freg_dport_addr : std_logic_vector(4 downto 0);\n" +
                        "    signal wb_exec_dport_npc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    \n" +
                        "    signal w_fetch_pipeline_hold : std_logic;\n" +
                        "    signal w_any_pipeline_hold : std_logic;\n" +
                        "    signal w_exec_pipeline_hold : std_logic;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "    w_fetch_pipeline_hold <= w.e.pipeline_hold or w.m.pipeline_hold or dbg.halt;\n" +
                        "    w_any_pipeline_hold <= w.f.pipeline_hold or w.e.pipeline_hold \n" +
                        "                          or w.m.pipeline_hold  or dbg.halt;\n" +
                        "    w_exec_pipeline_hold <= w.f.pipeline_hold or w.m.pipeline_hold or dbg.halt;\n" +
                        "\n" +
                        "    wb_ireg_dport_addr <= dbg.core_addr(4 downto 0);\n" +
                        "    wb_freg_dport_addr <= dbg.core_addr(4 downto 0);\n" +
                        "    wb_exec_dport_npc <= dbg.core_wdata(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    \n" +
                        "    fetch0 : InstrFetch generic map (\n" +
                        "        async_reset => async_reset\n" +
                        "      ) port map (\n" +
                        "        i_clk => i_clk,\n" +
                        "        i_nrst => i_nrst,\n" +
                        "        i_pipeline_hold => w_fetch_pipeline_hold,\n" +
                        "        i_mem_req_ready => i_req_ctrl_ready,\n" +
                        "        o_mem_addr_valid => w.f.imem_req_valid,\n" +
                        "        o_mem_addr => w.f.imem_req_addr,\n" +
                        "        i_mem_data_valid => i_resp_ctrl_valid,\n" +
                        "        i_mem_data_addr => i_resp_ctrl_addr,\n" +
                        "        i_mem_data => i_resp_ctrl_data,\n" +
                        "        i_mem_load_fault => i_resp_ctrl_load_fault,\n" +
                        "        o_mem_resp_ready => o_resp_ctrl_ready,\n" +
                        "        i_predict_npc => bp.npc,\n" +
                        "        o_mem_req_fire => w.f.req_fire,\n" +
                        "        o_instr_load_fault => w.f.instr_load_fault,\n" +
                        "        o_valid => w.f.valid,\n" +
                        "        o_pc => w.f.pc,\n" +
                        "        o_instr => w.f.instr,\n" +
                        "        o_hold => w.f.pipeline_hold,\n" +
                        "        i_br_fetch_valid => dbg.br_fetch_valid,\n" +
                        "        i_br_address_fetch => dbg.br_address_fetch,\n" +
                        "        i_br_instr_fetch => dbg.br_instr_fetch);\n" +
                        "        \n" +
                        "    dec0 : InstrDecoder generic map (\n" +
                        "        async_reset => async_reset\n" +
                        "      ) port map (\n" +
                        "        i_clk => i_clk,\n" +
                        "        i_nrst => i_nrst,\n" +
                        "        i_any_hold => w_any_pipeline_hold,\n" +
                        "        i_f_valid => w.f.valid,\n" +
                        "        i_f_pc => w.f.pc,\n" +
                        "        i_f_instr => w.f.instr,\n" +
                        "        i_instr_load_fault => w.f.instr_load_fault,\n" +
                        "        o_valid => w.d.instr_valid,\n" +
                        "        o_pc => w.d.pc,\n" +
                        "        o_instr => w.d.instr,\n" +
                        "        o_memop_store => w.d.memop_store,\n" +
                        "        o_memop_load => w.d.memop_load,\n" +
                        "        o_memop_sign_ext => w.d.memop_sign_ext,\n" +
                        "        o_memop_size => w.d.memop_size,\n" +
                        "        o_unsigned_op => w.d.unsigned_op,\n" +
                        "        o_rv32 => w.d.rv32,\n" +
                        "        o_compressed => w.d.compressed,\n" +
                        "        o_f64 => w.d.f64,\n" +
                        "        o_isa_type => w.d.isa_type,\n" +
                        "        o_instr_vec => w.d.instr_vec,\n" +
                        "        o_exception => w.d.exception,\n" +
                        "        o_instr_load_fault => w.d.instr_load_fault);\n" +
                        "\n" +
                        "    exec0 : InstrExecute generic map (\n" +
                        "        async_reset => async_reset\n" +
                        "      ) port map (\n" +
                        "        i_clk => i_clk,\n" +
                        "        i_nrst => i_nrst,\n" +
                        "        i_pipeline_hold => w_exec_pipeline_hold,\n" +
                        "        i_d_valid => w.d.instr_valid,\n" +
                        "        i_d_pc => w.d.pc,\n" +
                        "        i_d_instr => w.d.instr,\n" +
                        "        i_wb_ready => w.m.valid,\n" +
                        "        i_memop_store => w.d.memop_store,\n" +
                        "        i_memop_load => w.d.memop_load,\n" +
                        "        i_memop_sign_ext => w.d.memop_sign_ext,\n" +
                        "        i_memop_size => w.d.memop_size,\n" +
                        "        i_unsigned_op => w.d.unsigned_op,\n" +
                        "        i_rv32 => w.d.rv32,\n" +
                        "        i_compressed => w.d.compressed,\n" +
                        "        i_f64 => w.d.f64,\n" +
                        "        i_isa_type => w.d.isa_type,\n" +
                        "        i_ivec => w.d.instr_vec,\n" +
                        "        i_unsup_exception => w.d.exception,\n" +
                        "        i_instr_load_fault => w.d.instr_load_fault,\n" +
                        "        i_dport_npc_write => dbg.npc_write,\n" +
                        "        i_dport_npc => wb_exec_dport_npc,\n" +
                        "        o_radr1 => w.e.radr1,\n" +
                        "        i_rdata1 => ireg.rdata1,\n" +
                        "        o_radr2 => w.e.radr2,\n" +
                        "        i_rdata2 => ireg.rdata2,\n" +
                        "        i_rfdata1 => freg.rdata1,\n" +
                        "        i_rfdata2 => freg.rdata2,\n" +
                        "        o_res_addr => w.e.res_addr,\n" +
                        "        o_res_data => w.e.res_data,\n" +
                        "        o_pipeline_hold => w.e.pipeline_hold,\n" +
                        "        o_csr_addr => w.e.csr_addr,\n" +
                        "        o_csr_wena => w.e.csr_wena,\n" +
                        "        i_csr_rdata => csr.rdata,\n" +
                        "        o_csr_wdata => w.e.csr_wdata,\n" +
                        "        i_trap_valid => csr.trap_valid,\n" +
                        "        i_trap_pc => csr.trap_pc,\n" +
                        "        o_ex_npc => w.e.ex_npc,\n" +
                        "        o_ex_instr_load_fault => w.e.ex_instr_load_fault,\n" +
                        "        o_ex_illegal_instr => w.e.ex_illegal_instr,\n" +
                        "        o_ex_unalign_store => w.e.ex_unalign_store,\n" +
                        "        o_ex_unalign_load => w.e.ex_unalign_load,\n" +
                        "        o_ex_breakpoint => w.e.ex_breakpoint,\n" +
                        "        o_ex_ecall => w.e.ex_ecall,\n" +
                        "        o_ex_fpu_invalidop => w.e.ex_fpu_invalidop,\n" +
                        "        o_ex_fpu_divbyzero => w.e.ex_fpu_divbyzero,\n" +
                        "        o_ex_fpu_overflow => w.e.ex_fpu_overflow,\n" +
                        "        o_ex_fpu_underflow => w.e.ex_fpu_underflow,\n" +
                        "        o_ex_fpu_inexact => w.e.ex_fpu_inexact,\n" +
                        "        o_fpu_valid => w.e.fpu_valid,\n" +
                        "        o_memop_sign_ext => w.e.memop_sign_ext,\n" +
                        "        o_memop_load => w.e.memop_load,\n" +
                        "        o_memop_store => w.e.memop_store,\n" +
                        "        o_memop_size => w.e.memop_size,\n" +
                        "        o_memop_addr => w.e.memop_addr,\n" +
                        "        o_trap_ready => w.e.trap_ready,\n" +
                        "        o_valid => w.e.valid,\n" +
                        "        o_pc => w.e.pc,\n" +
                        "        o_npc => w.e.npc,\n" +
                        "        o_instr => w.e.instr,\n" +
                        "        o_call => w.e.call,\n" +
                        "        o_ret => w.e.ret,\n" +
                        "        o_mret => w.e.mret,\n" +
                        "        o_uret => w.e.uret);\n" +
                        "\n" +
                        "    mem0 : MemAccess generic map (\n" +
                        "        async_reset => async_reset\n" +
                        "      ) port map (\n" +
                        "        i_clk => i_clk,\n" +
                        "        i_nrst => i_nrst,\n" +
                        "        i_e_valid => w.e.valid,\n" +
                        "        i_e_pc => w.e.pc,\n" +
                        "        i_e_instr => w.e.instr,\n" +
                        "        i_res_addr => w.e.res_addr,\n" +
                        "        i_res_data => w.e.res_data,\n" +
                        "        i_memop_sign_ext => w.e.memop_sign_ext,\n" +
                        "        i_memop_load => w.e.memop_load,\n" +
                        "        i_memop_store => w.e.memop_store,\n" +
                        "        i_memop_size => w.e.memop_size,\n" +
                        "        i_memop_addr => w.e.memop_addr,\n" +
                        "        o_waddr => w.w.waddr,\n" +
                        "        o_wena => w.w.wena,\n" +
                        "        o_wdata => w.w.wdata,\n" +
                        "        i_mem_req_ready => i_req_data_ready,\n" +
                        "        o_mem_valid => o_req_data_valid,\n" +
                        "        o_mem_write => o_req_data_write,\n" +
                        "        o_mem_sz => o_req_data_size,\n" +
                        "        o_mem_addr => o_req_data_addr,\n" +
                        "        o_mem_data => o_req_data_data,\n" +
                        "        i_mem_data_valid => i_resp_data_valid,\n" +
                        "        i_mem_data_addr => i_resp_data_addr,\n" +
                        "        i_mem_data => i_resp_data_data,\n" +
                        "        o_mem_resp_ready => o_resp_data_ready,\n" +
                        "        o_hold => w.m.pipeline_hold,\n" +
                        "        o_valid => w.m.valid,\n" +
                        "        o_pc => w.m.pc,\n" +
                        "        o_instr => w.m.instr);\n" +
                        "\n" +
                        "    predic0 : BranchPredictor generic map (\n" +
                        "        async_reset => async_reset\n" +
                        "      ) port map (\n" +
                        "        i_clk => i_clk,\n" +
                        "        i_nrst => i_nrst,\n" +
                        "        i_req_mem_fire => w.f.req_fire,\n" +
                        "        i_resp_mem_valid => i_resp_ctrl_valid,\n" +
                        "        i_resp_mem_addr => i_resp_ctrl_addr,\n" +
                        "        i_resp_mem_data => i_resp_ctrl_data,\n" +
                        "        i_e_npc => w.e.npc,\n" +
                        "        i_ra => ireg.ra,\n" +
                        "        o_npc_predict => bp.npc);\n" +
                        "\n" +
                        "\n" +
                        "    iregs0 : RegIntBank generic map (\n" +
                        "        async_reset => async_reset\n" +
                        "      ) port map ( \n" +
                        "        i_clk => i_clk,\n" +
                        "        i_nrst => i_nrst,\n" +
                        "        i_radr1 => w.e.radr1,\n" +
                        "        o_rdata1 => ireg.rdata1,\n" +
                        "        i_radr2 => w.e.radr2,\n" +
                        "        o_rdata2 => ireg.rdata2,\n" +
                        "        i_waddr => w.w.waddr,\n" +
                        "        i_wena => w.w.wena,\n" +
                        "        i_wdata => w.w.wdata,\n" +
                        "        i_dport_addr => wb_ireg_dport_addr,\n" +
                        "        i_dport_ena => dbg.ireg_ena,\n" +
                        "        i_dport_write => dbg.ireg_write,\n" +
                        "        i_dport_wdata => dbg.core_wdata,\n" +
                        "        o_dport_rdata => ireg.dport_rdata,\n" +
                        "        o_ra => ireg.ra,   -- Return address\n" +
                        "        o_sp => ireg.sp);\n" +
                        "\n" +
                        "    fpuena : if CFG_FPU_ENABLE generate\n" +
                        "      fregs0 : RegFloatBank generic map (\n" +
                        "        async_reset => async_reset\n" +
                        "      ) port map (\n" +
                        "        i_clk => i_clk,\n" +
                        "        i_nrst => i_nrst,\n" +
                        "        i_radr1 => w.e.radr1,\n" +
                        "        o_rdata1 => freg.rdata1,\n" +
                        "        i_radr2 => w.e.radr2,\n" +
                        "        o_rdata2 => freg.rdata2,\n" +
                        "        i_waddr => w.w.waddr,\n" +
                        "        i_wena => w.w.wena,\n" +
                        "        i_wdata => w.w.wdata,\n" +
                        "        i_dport_addr => wb_freg_dport_addr,\n" +
                        "        i_dport_ena => dbg.freg_ena,\n" +
                        "        i_dport_write => dbg.freg_write,\n" +
                        "        i_dport_wdata => dbg.core_wdata,\n" +
                        "        o_dport_rdata => freg.dport_rdata);\n" +
                        "    end generate;\n" +
                        "\n" +
                        "    fpudis : if not CFG_FPU_ENABLE generate\n" +
                        "        freg.rdata1 <= (others => '0');\n" +
                        "        freg.rdata2 <= (others => '0');\n" +
                        "        freg.dport_rdata <= (others => '0');\n" +
                        "    end generate;\n" +
                        "\n" +
                        "    csr0 : CsrRegs generic map (\n" +
                        "        hartid => hartid,\n" +
                        "        async_reset => async_reset\n" +
                        "      ) port map (\n" +
                        "        i_clk => i_clk,\n" +
                        "        i_nrst => i_nrst,\n" +
                        "        i_mret => w.e.mret,\n" +
                        "        i_uret => w.e.uret,\n" +
                        "        i_sp => ireg.sp,\n" +
                        "        i_addr => w.e.csr_addr,\n" +
                        "        i_wena => w.e.csr_wena,\n" +
                        "        i_wdata => w.e.csr_wdata,\n" +
                        "        o_rdata => csr.rdata,\n" +
                        "        i_trap_ready => w.e.trap_ready,\n" +
                        "        i_ex_pc => w.e.npc,\n" +
                        "        i_ex_npc => w.e.ex_npc,\n" +
                        "        i_ex_data_addr => i_resp_data_addr,\n" +
                        "        i_ex_data_load_fault => i_resp_data_load_fault,\n" +
                        "        i_ex_data_store_fault => i_resp_data_store_fault,\n" +
                        "        i_ex_data_store_fault_addr => i_resp_data_store_fault_addr,\n" +
                        "        i_ex_instr_load_fault => w.e.ex_instr_load_fault,\n" +
                        "        i_ex_illegal_instr => w.e.ex_illegal_instr,\n" +
                        "        i_ex_unalign_store => w.e.ex_unalign_store,\n" +
                        "        i_ex_unalign_load => w.e.ex_unalign_load,\n" +
                        "        i_ex_breakpoint => w.e.ex_breakpoint,\n" +
                        "        i_ex_ecall => w.e.ex_ecall,\n" +
                        "        i_ex_fpu_invalidop => w.e.ex_fpu_invalidop,\n" +
                        "        i_ex_fpu_divbyzero => w.e.ex_fpu_divbyzero,\n" +
                        "        i_ex_fpu_overflow => w.e.ex_fpu_overflow,\n" +
                        "        i_ex_fpu_underflow => w.e.ex_fpu_underflow,\n" +
                        "        i_ex_fpu_inexact => w.e.ex_fpu_inexact,\n" +
                        "        i_fpu_valid => w.e.fpu_valid,\n" +
                        "        i_irq_external => i_ext_irq,\n" +
                        "        o_trap_valid => csr.trap_valid,\n" +
                        "        o_trap_pc => csr.trap_pc,\n" +
                        "        i_break_mode => dbg.break_mode,\n" +
                        "        o_break_event => csr.break_event,\n" +
                        "        i_dport_ena => dbg.csr_ena,\n" +
                        "        i_dport_write => dbg.csr_write,\n" +
                        "        i_dport_addr => dbg.core_addr,\n" +
                        "        i_dport_wdata => dbg.core_wdata,\n" +
                        "        o_dport_rdata => csr.dport_rdata);\n" +
                        "\n" +
                        "\n" +
                        "    dbg0 : DbgPort generic map (\n" +
                        "        async_reset => async_reset\n" +
                        "    ) port map (\n" +
                        "        i_clk => i_clk,\n" +
                        "        i_nrst => i_nrst,\n" +
                        "        i_dport_valid => i_dport_valid,\n" +
                        "        i_dport_write => i_dport_write,\n" +
                        "        i_dport_region => i_dport_region,\n" +
                        "        i_dport_addr => i_dport_addr,\n" +
                        "        i_dport_wdata => i_dport_wdata,\n" +
                        "        o_dport_ready => o_dport_ready,\n" +
                        "        o_dport_rdata => o_dport_rdata,\n" +
                        "        o_core_addr => dbg.core_addr,\n" +
                        "        o_core_wdata => dbg.core_wdata,\n" +
                        "        o_csr_ena => dbg.csr_ena,\n" +
                        "        o_csr_write => dbg.csr_write,\n" +
                        "        i_csr_rdata => csr.dport_rdata,\n" +
                        "        o_ireg_ena => dbg.ireg_ena,\n" +
                        "        o_ireg_write => dbg.ireg_write,\n" +
                        "        o_freg_ena => dbg.freg_ena,\n" +
                        "        o_freg_write => dbg.freg_write,\n" +
                        "        o_npc_write => dbg.npc_write,\n" +
                        "        i_ireg_rdata => ireg.dport_rdata,\n" +
                        "        i_freg_rdata => freg.dport_rdata,\n" +
                        "        i_pc => w.e.pc,\n" +
                        "        i_npc => w.e.npc,\n" +
                        "        i_e_valid => w.e.valid,\n" +
                        "        i_e_call => w.e.call,\n" +
                        "        i_e_ret => w.e.ret,\n" +
                        "        i_m_valid => w.m.valid,\n" +
                        "        o_clock_cnt => dbg.clock_cnt,\n" +
                        "        o_executed_cnt => dbg.executed_cnt,\n" +
                        "        o_halt => dbg.halt,\n" +
                        "        i_ebreak => csr.break_event,\n" +
                        "        o_break_mode => dbg.break_mode,\n" +
                        "        o_br_fetch_valid => dbg.br_fetch_valid,\n" +
                        "        o_br_address_fetch => dbg.br_address_fetch,\n" +
                        "        o_br_instr_fetch => dbg.br_instr_fetch,\n" +
                        "        o_flush_address => dbg.flush_address,\n" +
                        "        o_flush_valid => dbg.flush_valid,\n" +
                        "        i_istate => i_istate,\n" +
                        "        i_dstate => i_dstate,\n" +
                        "        i_cstate => i_cstate);\n" +
                        "\n" +
                        "    o_flush_valid <= dbg.flush_valid or csr.break_event;\n" +
                        "    o_flush_address <= w.e.npc when csr.break_event = '1' else dbg.flush_address;\n" +
                        "    o_req_ctrl_valid <= w.f.imem_req_valid;\n" +
                        "    o_req_ctrl_addr <= w.f.imem_req_addr;\n" +
                        "    o_time <= dbg.clock_cnt;\n" +
                        "    o_halted <= dbg.halt;\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_memaccess_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use riverlib.river_cfg.all;\n" +
                        "\n" +
                        "entity MemAccess is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk  : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_e_valid : in std_logic;                                         -- Execution stage outputs are valid\n" +
                        "    i_e_pc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);          -- Execution stage instruction pointer\n" +
                        "    i_e_instr : in std_logic_vector(31 downto 0);                     -- Execution stage instruction value\n" +
                        "\n" +
                        "    i_res_addr : in std_logic_vector(5 downto 0);                     -- Register address to be written (0=no writing)\n" +
                        "    i_res_data : in std_logic_vector(RISCV_ARCH-1 downto 0);          -- Register value to be written\n" +
                        "    i_memop_sign_ext : in std_logic;                                  -- Load data with sign extending (if less than 8 Bytes)\n" +
                        "    i_memop_load : in std_logic;                                      -- Load data from memory and write to i_res_addr\n" +
                        "    i_memop_store : in std_logic;                                     -- Store i_res_data value into memory\n" +
                        "    i_memop_size : in std_logic_vector(1 downto 0);                   -- Encoded memory transaction size in bytes: 0=1B; 1=2B; 2=4B; 3=8B\n" +
                        "    i_memop_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);    -- Memory access address\n" +
                        "    o_wena : out std_logic;                                           -- Write enable signal\n" +
                        "    o_waddr : out std_logic_vector(5 downto 0);                       -- Output register address (0 = x0 = no write)\n" +
                        "    o_wdata : out std_logic_vector(RISCV_ARCH-1 downto 0);            -- Register value\n" +
                        "\n" +
                        "    -- Memory interface:\n" +
                        "    i_mem_req_ready : in std_logic;\n" +
                        "    o_mem_valid : out std_logic;                                      -- Memory request is valid\n" +
                        "    o_mem_write : out std_logic;                                      -- Memory write request\n" +
                        "    o_mem_sz : out std_logic_vector(1 downto 0);                      -- Encoded data size in bytes: 0=1B; 1=2B; 2=4B; 3=8B\n" +
                        "    o_mem_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);     -- Data path requested address\n" +
                        "    o_mem_data : out std_logic_vector(BUS_DATA_WIDTH-1 downto 0);     -- Data path requested data (write transaction)\n" +
                        "    i_mem_data_valid : in std_logic;                                  -- Data path memory response is valid\n" +
                        "    i_mem_data_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0); -- Data path memory response address\n" +
                        "    i_mem_data : in std_logic_vector(BUS_DATA_WIDTH-1 downto 0);      -- Data path memory response value\n" +
                        "    o_mem_resp_ready : out std_logic;\n" +
                        "\n" +
                        "    o_hold : out std_logic;                                           -- Memory operation is more than 1 clock\n" +
                        "    o_valid : out std_logic;                                          -- Output is valid\n" +
                        "    o_pc : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);           -- Valid instruction pointer\n" +
                        "    o_instr : out std_logic_vector(31 downto 0)                       -- Valid instruction value\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_MemAccess of MemAccess is\n" +
                        "\n" +
                        "  constant State_Idle : std_logic_vector(1 downto 0) := \"00\";\n" +
                        "  constant State_WaitReqAccept : std_logic_vector(1 downto 0) := \"01\";\n" +
                        "  constant State_WaitResponse : std_logic_vector(1 downto 0) := \"10\";\n" +
                        "  constant State_RegForward : std_logic_vector(1 downto 0) := \"11\";\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "      state : std_logic_vector(1 downto 0);\n" +
                        "      memop_r : std_logic;\n" +
                        "      memop_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      pc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      instr : std_logic_vector(31 downto 0);\n" +
                        "\n" +
                        "      res_addr : std_logic_vector(5 downto 0);\n" +
                        "      res_data : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "      memop_sign_ext : std_logic;\n" +
                        "      memop_size : std_logic_vector(1 downto 0);\n" +
                        "      wena : std_logic;\n" +
                        "  end record;\n" +
                        " \n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "    State_Idle,                              -- state\n" +
                        "    '0', (others => '0'),                    -- memop_r, memop_addr\n" +
                        "    (others => '0'), (others => '0'),        -- pc, instr\n" +
                        "    (others => '0'),                         -- res_addr\n" +
                        "    (others => '0'), '0',                    -- res_data, memop_sign_ext\n" +
                        "    (others => '0'), '0'                     -- memop_size, wena\n" +
                        "  );\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "\n" +
                        "  -- TODO: move into separate module\n" +
                        "  -- queue signals before move into separate module\n" +
                        "  constant QUEUE_WIDTH : integer := RISCV_ARCH + 6 + 32 + BUS_ADDR_WIDTH\n" +
                        "                                    + 2 + 1 + 1 + 1 + BUS_ADDR_WIDTH;\n" +
                        "  constant QUEUE_DEPTH : integer := 1;\n" +
                        "\n" +
                        "  type queue_data_type is array (0 to QUEUE_DEPTH-1) of std_logic_vector(QUEUE_WIDTH-1 downto 0);\n" +
                        "\n" +
                        "  type QueueRegisterType is record\n" +
                        "    wcnt : integer range 0 to QUEUE_DEPTH;\n" +
                        "    mem : queue_data_type;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  signal queue_we : std_logic;\n" +
                        "  signal queue_re : std_logic;\n" +
                        "  signal queue_data_i : std_logic_vector(QUEUE_WIDTH-1 downto 0);\n" +
                        "  signal queue_data_o : std_logic_vector(QUEUE_WIDTH-1 downto 0);\n" +
                        "  signal qr, qrin : QueueRegisterType;\n" +
                        "  signal queue_nempty : std_logic;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  queue_data_i <= \n" +
                        "    i_res_data &\n" +
                        "    i_res_addr &\n" +
                        "    i_e_instr &\n" +
                        "    i_e_pc &\n" +
                        "    i_memop_size & \n" +
                        "    i_memop_sign_ext &\n" +
                        "    i_memop_store &\n" +
                        "    (i_memop_load or i_memop_store) &\n" +
                        "    i_memop_addr;\n" +
                        "\n" +
                        "  queue_we <= i_e_valid;\n" +
                        "\n" +
                        "  qproc : process (i_nrst, queue_we, queue_re, queue_data_i, qr)\n" +
                        "    variable nempty : std_logic;\n" +
                        "    variable vb_data_o : std_logic_vector(QUEUE_WIDTH-1 downto 0);\n" +
                        "    variable qv : QueueRegisterType;\n" +
                        "    variable full : std_logic;\n" +
                        "  begin\n" +
                        "    qv := qr;\n" +
                        "\n" +
                        "    full := '0';\n" +
                        "    if qr.wcnt = QUEUE_DEPTH then\n" +
                        "        full := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    vb_data_o := qr.mem(0);\n" +
                        "    if queue_re = '1' and queue_we = '1' then\n" +
                        "        if qr.wcnt = 0 then\n" +
                        "            vb_data_o := queue_data_i;\n" +
                        "        else\n" +
                        "            qv.mem(0) := queue_data_i;\n" +
                        "        end if;\n" +
                        "    elsif queue_re = '0' and queue_we = '1' then\n" +
                        "        if full = '0' then\n" +
                        "            qv.wcnt := qr.wcnt + 1;\n" +
                        "            qv.mem(0) := queue_data_i;\n" +
                        "        end if;\n" +
                        "    elsif queue_re = '1' and queue_we = '0' then\n" +
                        "        if qr.wcnt /= 0 then\n" +
                        "            qv.wcnt := qr.wcnt - 1;\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    nempty := '0';\n" +
                        "    if queue_we = '1' or qr.wcnt /= 0 then\n" +
                        "        nempty := '1';\n" +
                        "    end if;\n" +
                        " \n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        qv.wcnt := 0;\n" +
                        "        for k in 0 to QUEUE_DEPTH-1 loop\n" +
                        "            qv.mem(k) := (others => '0');\n" +
                        "        end loop;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    qrin <= qv;\n" +
                        "    queue_nempty <= nempty;\n" +
                        "    queue_data_o <= vb_data_o;\n" +
                        "  end process;\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "  comb : process(i_nrst, i_mem_req_ready, i_e_valid, i_res_addr,\n" +
                        "                i_mem_data_valid, i_mem_data_addr, i_mem_data,\n" +
                        "                queue_data_o, queue_nempty, r)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable w_mem_access : std_logic;\n" +
                        "    variable w_mem_valid : std_logic;\n" +
                        "    variable w_mem_write : std_logic;\n" +
                        "    variable w_mem_sign_ext : std_logic;\n" +
                        "    variable wb_mem_sz : std_logic_vector(1 downto 0);\n" +
                        "    variable wb_mem_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable wb_mem_data : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable w_hold : std_logic;\n" +
                        "    variable w_valid : std_logic;\n" +
                        "    variable w_queue_re : std_logic;\n" +
                        "    variable wb_mem_data_signext : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable wb_res_data : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable wb_res_addr : std_logic_vector(5 downto 0);\n" +
                        "    variable wb_e_pc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable wb_e_instr : std_logic_vector(31 downto 0);\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    w_mem_valid := '0';\n" +
                        "    w_hold := '0';\n" +
                        "    w_valid := '0';\n" +
                        "    w_queue_re := '0';\n" +
                        "\n" +
                        "    wb_mem_data := queue_data_o(2*BUS_ADDR_WIDTH+RISCV_ARCH+43-1 downto 2*BUS_ADDR_WIDTH+43);\n" +
                        "    wb_res_addr := queue_data_o(2*BUS_ADDR_WIDTH+43-1 downto 2*BUS_ADDR_WIDTH+37);\n" +
                        "    wb_e_instr := queue_data_o(2*BUS_ADDR_WIDTH+37-1 downto 2*BUS_ADDR_WIDTH+5);\n" +
                        "    wb_e_pc := queue_data_o(2*BUS_ADDR_WIDTH+5-1 downto BUS_ADDR_WIDTH+5);\n" +
                        "    wb_mem_sz := queue_data_o(BUS_ADDR_WIDTH+4 downto BUS_ADDR_WIDTH+3);\n" +
                        "    w_mem_sign_ext := queue_data_o(BUS_ADDR_WIDTH+2);\n" +
                        "    w_mem_write := queue_data_o(BUS_ADDR_WIDTH+1);\n" +
                        "    w_mem_access := queue_data_o(BUS_ADDR_WIDTH);\n" +
                        "    wb_mem_addr := queue_data_o(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "\n" +
                        "    case r.state is\n" +
                        "    when State_Idle =>\n" +
                        "        w_queue_re := '1';\n" +
                        "        if queue_nempty = '1' then\n" +
                        "            if w_mem_access = '1' then\n" +
                        "                w_mem_valid := '1';\n" +
                        "                if i_mem_req_ready = '1' then\n" +
                        "                    v.state := State_WaitResponse;\n" +
                        "                else\n" +
                        "                    w_hold := '1';\n" +
                        "                    v.state := State_WaitReqAccept;\n" +
                        "                end if;\n" +
                        "            else\n" +
                        "                v.state := State_RegForward;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    when State_WaitReqAccept =>\n" +
                        "        w_mem_valid := '1';\n" +
                        "        w_mem_write := not r.memop_r;\n" +
                        "        wb_mem_sz := r.memop_size;\n" +
                        "        wb_mem_addr := r.memop_addr;\n" +
                        "        wb_mem_data := r.res_data;\n" +
                        "        w_hold := '1';\n" +
                        "        if i_mem_req_ready = '1' then\n" +
                        "            v.state := State_WaitResponse;\n" +
                        "        end if;\n" +
                        "    when State_WaitResponse =>\n" +
                        "        w_valid := '1';\n" +
                        "        w_queue_re := '1';\n" +
                        "        if i_mem_data_valid = '0' then\n" +
                        "            w_queue_re := '0';\n" +
                        "            w_valid := '0';\n" +
                        "            w_hold := '1';\n" +
                        "        elsif queue_nempty = '1' then\n" +
                        "            if w_mem_access = '1' then\n" +
                        "                w_mem_valid := '1';\n" +
                        "                if i_mem_req_ready = '1' then\n" +
                        "                    v.state := State_WaitResponse;\n" +
                        "                else\n" +
                        "                    w_hold := '1';\n" +
                        "                    v.state := State_WaitReqAccept;\n" +
                        "                end if;\n" +
                        "            else\n" +
                        "                v.state := State_RegForward;\n" +
                        "            end if;\n" +
                        "        else\n" +
                        "            v.state := State_Idle;\n" +
                        "        end if;\n" +
                        "    when State_RegForward =>\n" +
                        "        w_valid := '1';\n" +
                        "        w_queue_re := '1';\n" +
                        "        if queue_nempty = '1' then\n" +
                        "            if w_mem_access = '1' then\n" +
                        "                w_mem_valid := '1';\n" +
                        "                if i_mem_req_ready = '1' then\n" +
                        "                    v.state := State_WaitResponse;\n" +
                        "                else\n" +
                        "                    w_hold := '1';\n" +
                        "                    v.state := State_WaitReqAccept;\n" +
                        "                end if;\n" +
                        "            else\n" +
                        "                v.state := State_RegForward;\n" +
                        "            end if;\n" +
                        "        else\n" +
                        "            v.state := State_Idle;\n" +
                        "        end if;\n" +
                        "    when others =>\n" +
                        "    end case;\n" +
                        "\n" +
                        "    if w_queue_re = '1' then\n" +
                        "        v.pc := wb_e_pc;\n" +
                        "        v.instr := wb_e_instr;\n" +
                        "        v.res_addr := wb_res_addr;\n" +
                        "        v.res_data := wb_mem_data;\n" +
                        "        if wb_res_addr = \"000000\" then\n" +
                        "            v.wena := '0';\n" +
                        "        else\n" +
                        "            v.wena := '1';\n" +
                        "        end if;\n" +
                        "        v.memop_addr := wb_mem_addr;\n" +
                        "        v.memop_r := w_mem_access and not w_mem_write;\n" +
                        "        v.memop_sign_ext := w_mem_sign_ext;\n" +
                        "        v.memop_size := wb_mem_sz;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    case r.memop_size is\n" +
                        "    when MEMOP_1B =>\n" +
                        "        wb_mem_data_signext := i_mem_data;\n" +
                        "        if i_mem_data(7) = '1' then\n" +
                        "            wb_mem_data_signext(63 downto 8) := (others => '1');\n" +
                        "        end if;\n" +
                        "    when MEMOP_2B =>\n" +
                        "        wb_mem_data_signext := i_mem_data;\n" +
                        "        if i_mem_data(15) = '1' then\n" +
                        "            wb_mem_data_signext(63 downto 16) := (others => '1');\n" +
                        "        end if;\n" +
                        "    when MEMOP_4B =>\n" +
                        "        wb_mem_data_signext := i_mem_data;\n" +
                        "        if i_mem_data(31) = '1' then\n" +
                        "            wb_mem_data_signext(63 downto 32) := (others => '1');\n" +
                        "        end if;\n" +
                        "    when others =>\n" +
                        "        wb_mem_data_signext := i_mem_data;\n" +
                        "    end case;\n" +
                        "\n" +
                        "    if r.memop_r = '1' then\n" +
                        "        if r.memop_sign_ext = '1' then\n" +
                        "            wb_res_data := wb_mem_data_signext;\n" +
                        "        else\n" +
                        "            wb_res_data := i_mem_data;\n" +
                        "        end if;\n" +
                        "    else\n" +
                        "        wb_res_data := r.res_data;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    queue_re <= w_queue_re;\n" +
                        "\n" +
                        "    o_mem_resp_ready <= '1';\n" +
                        "\n" +
                        "    o_mem_valid <= w_mem_valid;\n" +
                        "    o_mem_write <= w_mem_write;\n" +
                        "    o_mem_sz <= wb_mem_sz;\n" +
                        "    o_mem_addr <= wb_mem_addr;\n" +
                        "    o_mem_data <= wb_mem_data;\n" +
                        "\n" +
                        "    o_wena <= r.wena and w_valid;\n" +
                        "    o_waddr <= r.res_addr;\n" +
                        "    o_wdata <= wb_res_data;\n" +
                        "    o_hold <= w_hold;\n" +
                        "    o_valid <= w_valid;\n" +
                        "    o_pc <= r.pc;\n" +
                        "    o_instr <= r.instr;\n" +
                        "    \n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(i_clk, i_nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "        qr.wcnt <= 0;\n" +
                        "        for k in 0 to QUEUE_DEPTH-1 loop\n" +
                        "            qr.mem(k) <= (others => '0');\n" +
                        "        end loop;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "        qr <= qrin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_fetch_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use riverlib.river_cfg.all;\n" +
                        "\n" +
                        "\n" +
                        "entity InstrFetch is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk  : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_pipeline_hold : in std_logic;\n" +
                        "    i_mem_req_ready : in std_logic;\n" +
                        "    o_mem_addr_valid : out std_logic;\n" +
                        "    o_mem_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_mem_data_valid : in std_logic;\n" +
                        "    i_mem_data_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_mem_data : in std_logic_vector(31 downto 0);\n" +
                        "    i_mem_load_fault : in std_logic;\n" +
                        "    o_mem_resp_ready : out std_logic;\n" +
                        "\n" +
                        "    i_predict_npc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "\n" +
                        "    o_mem_req_fire : out std_logic;                    -- used by branch predictor to form new npc value\n" +
                        "    o_instr_load_fault : out std_logic;                -- fault instruction's address\n" +
                        "    o_valid : out std_logic;\n" +
                        "    o_pc : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_instr : out std_logic_vector(31 downto 0);\n" +
                        "    o_hold : out std_logic;                                -- Hold due no response from icache yet\n" +
                        "    i_br_fetch_valid : in std_logic;                       -- Fetch injection address/instr are valid\n" +
                        "    i_br_address_fetch : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0); -- Fetch injection address to skip ebreak instruciton only once\n" +
                        "    i_br_instr_fetch : in std_logic_vector(31 downto 0)   -- Real instruction value that was replaced by ebreak\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_InstrFetch of InstrFetch is\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "      wait_resp : std_logic;\n" +
                        "      pipeline_init : std_logic_vector(4 downto 0);\n" +
                        "      br_address : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      br_instr : std_logic_vector(31 downto 0);\n" +
                        "\n" +
                        "      resp_address : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      resp_data : std_logic_vector(31 downto 0);\n" +
                        "      resp_valid : std_logic;\n" +
                        "      instr_load_fault : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "    '0', (others => '0'),\n" +
                        "    (others => '1'),  -- br_address\n" +
                        "    (others =>'0'),   -- br_instr\n" +
                        "    (others =>'0'), (others =>'0'), '0',\n" +
                        "    '0'               -- instr_load_fault\n" +
                        "  );\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  comb : process(i_nrst, i_pipeline_hold, i_mem_req_ready, i_mem_data_valid,\n" +
                        "                i_mem_data_addr, i_mem_data, i_mem_load_fault, i_predict_npc, \n" +
                        "                i_br_fetch_valid, i_br_address_fetch, i_br_instr_fetch, r)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable w_o_req_valid : std_logic;\n" +
                        "    variable w_o_req_fire : std_logic;\n" +
                        "    variable w_o_hold : std_logic;\n" +
                        "    variable wb_o_pc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable wb_o_instr : std_logic_vector(31 downto 0);\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    w_o_req_valid := not i_pipeline_hold\n" +
                        "        and not (r.wait_resp and not i_mem_data_valid);\n" +
                        "    w_o_req_fire := i_mem_req_ready and w_o_req_valid;\n" +
                        "\n" +
                        "    w_o_hold := not (r.wait_resp and i_mem_data_valid);\n" +
                        "\n" +
                        "    if w_o_req_fire = '1' then\n" +
                        "        v.wait_resp := '1';\n" +
                        "    elsif i_mem_data_valid = '1' and i_pipeline_hold = '0' then\n" +
                        "        v.wait_resp := '0';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if i_mem_data_valid = '1' and r.wait_resp = '1' and i_pipeline_hold = '0' then\n" +
                        "        v.resp_valid := '1';\n" +
                        "        v.resp_address := i_mem_data_addr;\n" +
                        "        v.resp_data := i_mem_data;\n" +
                        "        v.instr_load_fault := i_mem_load_fault;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    wb_o_pc := r.resp_address;\n" +
                        "    wb_o_instr := r.resp_data;\n" +
                        "\n" +
                        "\n" +
                        "    if i_br_fetch_valid = '1' then\n" +
                        "        v.br_address := i_br_address_fetch;\n" +
                        "        v.br_instr := i_br_instr_fetch;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Breakpoint skip logic that allows to continue execution\n" +
                        "    -- without actual breakpoint remove only once \n" +
                        "    if wb_o_pc = r.br_address then\n" +
                        "        wb_o_instr := r.br_instr;\n" +
                        "        if i_mem_data_valid = '1' and r.wait_resp = '1' and i_pipeline_hold = '0' then\n" +
                        "            v.br_address := (others => '1');\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    \n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    o_mem_addr_valid <= w_o_req_valid;\n" +
                        "    o_mem_addr <= i_predict_npc;\n" +
                        "    o_mem_req_fire <= w_o_req_fire;\n" +
                        "    o_instr_load_fault <= r.instr_load_fault;\n" +
                        "    o_valid <= r.resp_valid and not (i_pipeline_hold or w_o_hold);\n" +
                        "    o_pc <= wb_o_pc;\n" +
                        "    o_instr <= wb_o_instr;\n" +
                        "    o_mem_resp_ready <= r.wait_resp and not i_pipeline_hold;\n" +
                        "    o_hold <= w_o_hold;\n" +
                        "    \n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(i_clk, i_nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_execute_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use IEEE.std_logic_arith.all;  -- UNSIGNED function\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use riverlib.river_cfg.all;\n" +
                        "\n" +
                        "library target;\n" +
                        "use target.config_target.all;\n" +
                        "\n" +
                        "entity InstrExecute is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk  : in std_logic;\n" +
                        "    i_nrst : in std_logic;                                      -- Reset active LOW\n" +
                        "    i_pipeline_hold : in std_logic;                             -- Hold execution by any reason\n" +
                        "    i_d_valid : in std_logic;                                   -- Decoded instruction is valid\n" +
                        "    i_d_pc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);    -- Instruction pointer on decoded instruction\n" +
                        "    i_d_instr : in std_logic_vector(31 downto 0);               -- Decoded instruction value\n" +
                        "    i_wb_ready : in std_logic;                                  -- End of write back operation\n" +
                        "    i_memop_store : in std_logic;                               -- Store to memory operation\n" +
                        "    i_memop_load : in std_logic;                                -- Load from memoru operation\n" +
                        "    i_memop_sign_ext : in std_logic;                            -- Load memory value with sign extending\n" +
                        "    i_memop_size : in std_logic_vector(1 downto 0);             -- Memory transaction size\n" +
                        "    i_unsigned_op : in std_logic;                               -- Unsigned operands\n" +
                        "    i_rv32 : in std_logic;                                      -- 32-bits instruction\n" +
                        "    i_compressed : in std_logic;                                -- C-extension (2-bytes length)\n" +
                        "    i_f64 : in std_logic;                                       -- D-extension (FPU)\n" +
                        "    i_isa_type : in std_logic_vector(ISA_Total-1 downto 0);     -- Type of the instruction's structure (ISA spec.)\n" +
                        "    i_ivec : in std_logic_vector(Instr_Total-1 downto 0);       -- One pulse per supported instruction.\n" +
                        "    i_unsup_exception : in std_logic;                           -- Unsupported instruction exception\n" +
                        "    i_instr_load_fault : in std_logic;                          -- Instruction fetched from fault address\n" +
                        "    i_dport_npc_write : in std_logic;                           -- Write npc value from debug port\n" +
                        "    i_dport_npc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);-- Debug port npc value to write\n" +
                        "\n" +
                        "    o_radr1 : out std_logic_vector(5 downto 0);                 -- Integer/float register index 1\n" +
                        "    i_rdata1 : in std_logic_vector(RISCV_ARCH-1 downto 0);      -- Integer register value 1\n" +
                        "    o_radr2 : out std_logic_vector(5 downto 0);                 -- Integer/float register index 2\n" +
                        "    i_rdata2 : in std_logic_vector(RISCV_ARCH-1 downto 0);      -- Integer register value 2\n" +
                        "    i_rfdata1 : in std_logic_vector(RISCV_ARCH-1 downto 0);     -- Float register value 1\n" +
                        "    i_rfdata2 : in std_logic_vector(RISCV_ARCH-1 downto 0);     -- Float register value 2\n" +
                        "    o_res_addr : out std_logic_vector(5 downto 0);              -- Address to store result of the instruction (0=do not store)\n" +
                        "    o_res_data : out std_logic_vector(RISCV_ARCH-1 downto 0);   -- Value to store\n" +
                        "    o_pipeline_hold : out std_logic;                            -- Hold pipeline while 'writeback' not done or multi-clock instruction.\n" +
                        "    o_csr_addr : out std_logic_vector(11 downto 0);             -- CSR address. 0 if not a CSR instruction with xret signals mode switching\n" +
                        "    o_csr_wena : out std_logic;                                 -- Write new CSR value\n" +
                        "    i_csr_rdata : in std_logic_vector(RISCV_ARCH-1 downto 0);   -- CSR current value\n" +
                        "    o_csr_wdata : out std_logic_vector(RISCV_ARCH-1 downto 0);  -- CSR new value\n" +
                        "    i_trap_valid : in std_logic;\n" +
                        "    i_trap_pc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    -- exceptions:\n" +
                        "    o_ex_npc : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    o_ex_instr_load_fault : out std_logic;                      -- Instruction fetched from fault address\n" +
                        "    o_ex_illegal_instr : out std_logic;\n" +
                        "    o_ex_unalign_store : out std_logic;\n" +
                        "    o_ex_unalign_load : out std_logic;\n" +
                        "    o_ex_breakpoint : out std_logic;\n" +
                        "    o_ex_ecall : out std_logic;\n" +
                        "    o_ex_fpu_invalidop : out std_logic;            -- FPU Exception: invalid operation\n" +
                        "    o_ex_fpu_divbyzero : out std_logic;            -- FPU Exception: divide by zero\n" +
                        "    o_ex_fpu_overflow : out std_logic;             -- FPU Exception: overflow\n" +
                        "    o_ex_fpu_underflow : out std_logic;            -- FPU Exception: underflow\n" +
                        "    o_ex_fpu_inexact : out std_logic;              -- FPU Exception: inexact\n" +
                        "    o_fpu_valid : out std_logic;                   -- FPU output is valid\n" +
                        "\n" +
                        "    o_memop_sign_ext : out std_logic;                           -- Load data with sign extending\n" +
                        "    o_memop_load : out std_logic;                               -- Load data instruction\n" +
                        "    o_memop_store : out std_logic;                              -- Store data instruction\n" +
                        "    o_memop_size : out std_logic_vector(1 downto 0);            -- 0=1bytes; 1=2bytes; 2=4bytes; 3=8bytes\n" +
                        "    o_memop_addr : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);-- Memory access address\n" +
                        "\n" +
                        "    o_trap_ready : out std_logic;                               -- Trap branch request was accepted\n" +
                        "    o_valid : out std_logic;                                    -- Output is valid\n" +
                        "    o_pc : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);     -- Valid instruction pointer\n" +
                        "    o_npc : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);    -- Next instruction pointer. Next decoded pc must match to this value or will be ignored.\n" +
                        "    o_instr : out std_logic_vector(31 downto 0);                -- Valid instruction value\n" +
                        "    o_call : out std_logic;                                     -- CALL pseudo instruction detected\n" +
                        "    o_ret : out std_logic;                                      -- RET pseudoinstruction detected\n" +
                        "    o_mret : out std_logic;                                     -- MRET instruction\n" +
                        "    o_uret : out std_logic                                      -- URET instruction\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_InstrExecute of InstrExecute is\n" +
                        "\n" +
                        "  constant Multi_MUL : integer := 0;\n" +
                        "  constant Multi_DIV : integer := 1;\n" +
                        "  constant Multi_FPU : integer := 2;\n" +
                        "  constant Multi_Total : integer := 3;\n" +
                        "\n" +
                        "  constant State_WaitInstr : std_logic_vector(2 downto 0) := \"000\";\n" +
                        "  constant State_SingleCycle : std_logic_vector(2 downto 0) := \"001\";\n" +
                        "  constant State_MultiCycle : std_logic_vector(2 downto 0) := \"010\";\n" +
                        "  constant State_Hold : std_logic_vector(2 downto 0) := \"011\";\n" +
                        "  constant State_Hazard : std_logic_vector(2 downto 0) := \"100\";\n" +
                        "\n" +
                        "  constant zero64 : std_logic_vector(63 downto 0) := (others => '0');\n" +
                        "\n" +
                        "  type multi_arith_type is array (0 to Multi_Total-1) \n" +
                        "      of std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "        state : std_logic_vector(2 downto 0);\n" +
                        "        d_valid : std_logic;                                   -- Valid decoded instruction latch\n" +
                        "        pc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "        npc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "        instr : std_logic_vector(31 downto 0);\n" +
                        "        res_addr : std_logic_vector(5 downto 0);\n" +
                        "        res_val : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "        memop_load : std_logic;\n" +
                        "        memop_store : std_logic;\n" +
                        "        memop_sign_ext : std_logic;\n" +
                        "        memop_size : std_logic_vector(1 downto 0);\n" +
                        "        memop_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "\n" +
                        "        multi_res_addr : std_logic_vector(5 downto 0);         -- latched output reg. address while multi-cycle instruction\n" +
                        "        multi_pc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);-- latched pc-value while multi-cycle instruction\n" +
                        "        multi_npc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);-- latched npc-value while multi-cycle instruction\n" +
                        "        multi_instr : std_logic_vector(31 downto 0);           -- Multi-cycle instruction is under processing\n" +
                        "        multi_ena : std_logic_vector(Multi_Total-1 downto 0);  -- Enable pulse for Operation that takes more than 1 clock\n" +
                        "        multi_rv32 : std_logic;                                -- Long operation with 32-bits operands\n" +
                        "        multi_f64 : std_logic;                                 -- Long float operation\n" +
                        "        multi_unsigned : std_logic;                            -- Long operation with unsiged operands\n" +
                        "        multi_residual_high : std_logic;                       -- Flag for Divider module: 0=divsion output; 1=residual output\n" +
                        "                                                               -- Flag for multiplier: 0=usual; 1=get high bits\n" +
                        "        multiclock_ena : std_logic;\n" +
                        "        multi_ivec_fpu : std_logic_vector(Instr_FPU_Total-1 downto 0);\n" +
                        "        multi_a1 : std_logic_vector(RISCV_ARCH-1 downto 0);    -- Multi-cycle operand 1\n" +
                        "        multi_a2 : std_logic_vector(RISCV_ARCH-1 downto 0);    -- Multi-cycle operand 2\n" +
                        "\n" +
                        "        hazard_addr0 : std_logic_vector(5 downto 0);           -- Updated register address on previous step\n" +
                        "        hazard_depth : std_logic_vector(1 downto 0);           -- Number of modificated registers that wasn't done yet\n" +
                        "        hold_valid : std_logic;\n" +
                        "        hold_multi_ena : std_logic;\n" +
                        "\n" +
                        "        call : std_logic;\n" +
                        "        ret : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "    State_WaitInstr,                                   -- state\n" +
                        "    '0', (others => '0'), CFG_NMI_RESET_VECTOR,        -- d_valid, pc, npc\n" +
                        "    (others => '0'), (others => '0'), (others => '0'), -- instr, res_addr, res_val\n" +
                        "    '0', '0', '0', \"00\", (others => '0'),              -- memop_load, memop_store, memop_sign_ext, memop_size, memop_addr\n" +
                        "    (others => '0'), (others => '0'), (others => '0'), -- multi_res_addr, multi_pc, multi_npc\n" +
                        "    (others => '0'), (others => '0'), '0',             -- multi_instr, multi_ena, multi_rv32\n" +
                        "    '0', '0',  '0',                                    -- multi_f64, multi_unsigned, multi_residual_high\n" +
                        "    '0', (others => '0'),                              -- multiclock_ena, multi_ivec_fpu\n" +
                        "    (others => '0'), (others => '0'),                  -- multi_a1, multi_a2\n" +
                        "    (others => '0'), (others => '0'),                  -- hazard_add0, hazard_depth\n" +
                        "    '0', '0',                                          -- hold_valid, hold_multi_ena\n" +
                        "    '0', '0'                                           -- call, ret\n" +
                        "  );\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "\n" +
                        "  signal wb_arith_res : multi_arith_type;\n" +
                        "  signal w_arith_valid : std_logic_vector(Multi_Total-1 downto 0);\n" +
                        "  signal w_arith_busy : std_logic_vector(Multi_Total-1 downto 0);\n" +
                        "\n" +
                        "  signal wb_shifter_a1 : std_logic_vector(RISCV_ARCH-1 downto 0);  -- Shifters operand 1\n" +
                        "  signal wb_shifter_a2 : std_logic_vector(5 downto 0);             -- Shifters operand 2\n" +
                        "  signal wb_sll : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "  signal wb_sllw : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "  signal wb_srl : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "  signal wb_srlw : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "  signal wb_sra : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "  signal wb_sraw : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "  \n" +
                        " component IntMulCycloneV is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk  : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_ena : in std_logic;\n" +
                        "    i_unsigned : in std_logic;\n" +
                        "    i_high : in std_logic;\n" +
                        "    i_rv32 : in std_logic;\n" +
                        "    i_a1 : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    i_a2 : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_res : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_valid : out std_logic;\n" +
                        "    o_busy : out std_logic\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "  component IntDiv is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk  : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_ena : in std_logic;\n" +
                        "    i_unsigned : in std_logic;\n" +
                        "    i_rv32 : in std_logic;\n" +
                        "    i_residual : in std_logic;\n" +
                        "    i_a1 : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    i_a2 : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_res : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_valid : out std_logic;\n" +
                        "    o_busy : out std_logic\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "  \n" +
                        "  component Shifter is port (\n" +
                        "    i_a1 : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    i_a2 : in std_logic_vector(5 downto 0);\n" +
                        "    o_sll : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_sllw : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_srl : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_sra : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_srlw : out std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    o_sraw : out std_logic_vector(RISCV_ARCH-1 downto 0)\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "  component FpuTop is \n" +
                        "  generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_nrst         : in std_logic;\n" +
                        "    i_clk          : in std_logic;\n" +
                        "    i_ena          : in std_logic;\n" +
                        "    i_ivec         : in std_logic_vector(Instr_FPU_Total-1 downto 0);\n" +
                        "    i_a            : in std_logic_vector(63 downto 0);\n" +
                        "    i_b            : in std_logic_vector(63 downto 0);\n" +
                        "    o_res          : out std_logic_vector(63 downto 0);\n" +
                        "    o_ex_invalidop : out std_logic;   -- Exception: invalid operation\n" +
                        "    o_ex_divbyzero : out std_logic;   -- Exception: divide by zero\n" +
                        "    o_ex_overflow  : out std_logic;   -- Exception: overflow\n" +
                        "    o_ex_underflow : out std_logic;   -- Exception: underflow\n" +
                        "    o_ex_inexact   : out std_logic;   -- Exception: inexact\n" +
                        "    o_valid        : out std_logic;\n" +
                        "    o_busy         : out std_logic\n" +
                        "  );\n" +
                        "  end component; \n" +
                        "\n" +
                        "begin\n" +
                        "   \n" +
                        "   mul_ena : if CFG_MUL_ENABLE generate\n" +
                        "      mul0 : IntMulCycloneV generic map (\n" +
                        "			async_reset => async_reset\n" +
                        "		) port map (\n" +
                        "			i_clk  => i_clk,\n" +
                        "			i_nrst => i_nrst,\n" +
                        "			i_ena => r.multi_ena(Multi_MUL),\n" +
                        "			i_unsigned => r.multi_unsigned,\n" +
                        "			i_high => r.multi_residual_high,\n" +
                        "			i_rv32 => r.multi_rv32,\n" +
                        "			i_a1 => r.multi_a1,\n" +
                        "			i_a2 => r.multi_a2,\n" +
                        "			o_res => wb_arith_res(Multi_MUL),\n" +
                        "			o_valid => w_arith_valid(Multi_MUL),\n" +
                        "			o_busy => w_arith_busy(Multi_MUL)\n" +
                        "		);\n" +
                        "   end generate;\n" +
                        "\n" +
                        "   mul_dis : if not CFG_MUL_ENABLE generate\n" +
                        "      wb_arith_res(Multi_MUL)		<= (others => '0');\n" +
                        "		w_arith_valid(Multi_MUL)	<= '0';\n" +
                        "		w_arith_busy(Multi_MUL)		<= '0';\n" +
                        "   end generate;\n" +
                        "\n" +
                        "   div0 : IntDiv generic map (\n" +
                        "      async_reset => async_reset\n" +
                        "   ) port map (\n" +
                        "      i_clk  => i_clk,\n" +
                        "      i_nrst => i_nrst,\n" +
                        "      i_ena => r.multi_ena(Multi_DIV),\n" +
                        "      i_unsigned => r.multi_unsigned,\n" +
                        "      i_residual => r.multi_residual_high,\n" +
                        "      i_rv32 => r.multi_rv32,\n" +
                        "      i_a1 => r.multi_a1,\n" +
                        "      i_a2 => r.multi_a2,\n" +
                        "      o_res => wb_arith_res(Multi_DIV),\n" +
                        "      o_valid => w_arith_valid(Multi_DIV),\n" +
                        "      o_busy => w_arith_busy(Multi_DIV));\n" +
                        "      \n" +
                        "  sh0 : Shifter port map (\n" +
                        "      i_a1 => wb_shifter_a1,\n" +
                        "      i_a2 => wb_shifter_a2,\n" +
                        "      o_sll => wb_sll,\n" +
                        "      o_sllw => wb_sllw,\n" +
                        "      o_srl => wb_srl,\n" +
                        "      o_sra => wb_sra,\n" +
                        "      o_srlw => wb_srlw,\n" +
                        "      o_sraw => wb_sraw);\n" +
                        "\n" +
                        "  fpuena : if CFG_FPU_ENABLE generate\n" +
                        "     fpu0 : FpuTop generic map (\n" +
                        "        async_reset => async_reset\n" +
                        "     ) port map (\n" +
                        "        i_clk => i_clk,\n" +
                        "        i_nrst => i_nrst,\n" +
                        "        i_ena => r.multi_ena(Multi_FPU),\n" +
                        "        i_ivec => r.multi_ivec_fpu,\n" +
                        "        i_a => r.multi_a1,\n" +
                        "        i_b => r.multi_a2,\n" +
                        "        o_res => wb_arith_res(Multi_FPU),\n" +
                        "        o_ex_invalidop => o_ex_fpu_invalidop,\n" +
                        "        o_ex_divbyzero => o_ex_fpu_divbyzero,\n" +
                        "        o_ex_overflow => o_ex_fpu_overflow,\n" +
                        "        o_ex_underflow => o_ex_fpu_underflow,\n" +
                        "        o_ex_inexact => o_ex_fpu_inexact,\n" +
                        "        o_valid => w_arith_valid(Multi_FPU),\n" +
                        "        o_busy => w_arith_busy(Multi_FPU)\n" +
                        "     );\n" +
                        "  end generate;\n" +
                        "\n" +
                        "  fpudis : if not CFG_FPU_ENABLE generate\n" +
                        "        wb_arith_res(Multi_FPU) <= (others => '0');\n" +
                        "        w_arith_valid(Multi_FPU) <= '0';\n" +
                        "        w_arith_busy(Multi_FPU) <= '0';\n" +
                        "        o_fpu_valid <= '0';\n" +
                        "        o_ex_fpu_invalidop <= '0';\n" +
                        "        o_ex_fpu_divbyzero <= '0';\n" +
                        "        o_ex_fpu_overflow <= '0';\n" +
                        "        o_ex_fpu_underflow <= '0';\n" +
                        "        o_ex_fpu_inexact <= '0';\n" +
                        "  end generate;\n" +
                        "\n" +
                        "  comb : process(i_nrst, i_pipeline_hold, i_d_valid, i_d_pc, i_d_instr,\n" +
                        "                 i_wb_ready, i_memop_load, i_memop_store, i_memop_sign_ext,\n" +
                        "                 i_memop_size, i_unsigned_op, i_rv32, i_compressed, i_f64, i_isa_type, i_ivec,\n" +
                        "                 i_rdata1, i_rdata2, i_rfdata1, i_rfdata2, i_csr_rdata, \n" +
                        "                 i_trap_valid, i_trap_pc, i_dport_npc_write,\n" +
                        "                 i_dport_npc, i_unsup_exception, i_instr_load_fault,\n" +
                        "                 wb_arith_res, w_arith_valid, w_arith_busy,\n" +
                        "                 wb_sll, wb_sllw, wb_srl, wb_srlw, wb_sra, wb_sraw, r)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable w_exception_store : std_logic;\n" +
                        "    variable w_exception_load : std_logic;\n" +
                        "    variable wb_radr1 : std_logic_vector(5 downto 0);      -- [5] 0=Integer bank; 1=FPU bank\n" +
                        "    variable wb_rdata1 : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable wb_radr2 : std_logic_vector(5 downto 0);\n" +
                        "    variable wb_rdata2 : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable w_mret : std_logic;\n" +
                        "    variable w_uret : std_logic;\n" +
                        "    variable w_csr_wena : std_logic;\n" +
                        "    variable wb_res_addr : std_logic_vector(5 downto 0);\n" +
                        "    variable wb_csr_addr  : std_logic_vector(11 downto 0);\n" +
                        "    variable wb_csr_wdata : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable wb_res : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable wb_npc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable wb_ex_npc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable wb_off : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable wb_mask_i31 : std_logic_vector(RISCV_ARCH-1 downto 0);    -- Bits depending instr[31] bits\n" +
                        "    variable wb_sum64 : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable wb_sum32 : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable wb_sub64 : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable wb_sub32 : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable wb_and64 : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable wb_or64 : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable wb_xor64 : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable w_memop_load : std_logic;\n" +
                        "    variable w_memop_store : std_logic;\n" +
                        "    variable w_memop_sign_ext : std_logic;\n" +
                        "    variable wb_memop_size : std_logic_vector(1 downto 0);\n" +
                        "    variable wb_memop_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "\n" +
                        "    variable w_valid : std_logic;\n" +
                        "    variable w_pc_valid : std_logic;\n" +
                        "    variable w_next_ready : std_logic;\n" +
                        "    variable w_hold : std_logic;\n" +
                        "    variable w_multi_valid : std_logic;\n" +
                        "    variable w_multi_ena : std_logic;\n" +
                        "    variable w_fpu_ena : std_logic;\n" +
                        "    variable w_res_wena : std_logic;\n" +
                        "    variable w_pc_branch : std_logic;\n" +
                        "    variable w_hazard_lvl1 : std_logic;\n" +
                        "    variable w_hazard_lvl2 : std_logic;\n" +
                        "    variable w_less : std_logic;\n" +
                        "    variable w_gr_equal : std_logic;\n" +
                        "    variable wv : std_logic_vector(Instr_Total-1 downto 0);\n" +
                        "    variable opcode_len : integer;\n" +
                        "\n" +
                        "  begin\n" +
                        "\n" +
                        "    wb_radr1 := (others => '0');\n" +
                        "    wb_radr2 := (others => '0');\n" +
                        "    w_mret := '0';\n" +
                        "    w_uret := '0';\n" +
                        "    w_csr_wena := '0';\n" +
                        "    wb_res_addr := (others => '0');\n" +
                        "    wb_csr_addr := (others => '0');\n" +
                        "    wb_csr_wdata := (others => '0');\n" +
                        "    wb_res := (others => '0');\n" +
                        "    wb_off := (others => '0');\n" +
                        "    wb_rdata1 := (others => '0');\n" +
                        "    wb_rdata2 := (others => '0');\n" +
                        "    w_memop_load := '0';\n" +
                        "    w_memop_store := '0';\n" +
                        "    w_memop_sign_ext := '0';\n" +
                        "    wb_memop_size := (others => '0');\n" +
                        "    wb_memop_addr := (others => '0');\n" +
                        "    wv := i_ivec;\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    wb_mask_i31 := (others => i_d_instr(31));\n" +
                        "\n" +
                        "    w_pc_valid := '0';\n" +
                        "    if i_d_pc = r.npc then\n" +
                        "        w_pc_valid := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if i_isa_type(ISA_R_type) = '1' then\n" +
                        "        wb_radr1 := ('0' & i_d_instr(19 downto 15));\n" +
                        "        wb_rdata1 := i_rdata1;\n" +
                        "        wb_radr2 := ('0' & i_d_instr(24 downto 20));\n" +
                        "        wb_rdata2 := i_rdata2;\n" +
                        "        if CFG_FPU_ENABLE and i_f64 = '1' then\n" +
                        "            if (wv(Instr_FMOV_D_X) or wv(Instr_FMOV_W_X) or\n" +
                        "                wv(Instr_FCVT_D_L) or wv(Instr_FCVT_D_LU) or\n" +
                        "                wv(Instr_FCVT_D_W) or wv(Instr_FCVT_D_WU)) = '0' then\n" +
                        "                wb_radr1 := ('1' & i_d_instr(19 downto 15));\n" +
                        "                wb_rdata1 := i_rfdata1;\n" +
                        "            end if;\n" +
                        "            if (wv(Instr_FMOV_X_D) or wv(Instr_FMOV_X_W)) = '0' then\n" +
                        "                wb_radr2 := ('1' & i_d_instr(24 downto 20));\n" +
                        "                wb_rdata2 := i_rfdata2;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    elsif i_isa_type(ISA_I_type) = '1' then\n" +
                        "        wb_radr1 := ('0' & i_d_instr(19 downto 15));\n" +
                        "        wb_rdata1 := i_rdata1;\n" +
                        "        wb_radr2 := (others => '0');\n" +
                        "        wb_rdata2 := wb_mask_i31(63 downto 12) & i_d_instr(31 downto 20);\n" +
                        "    elsif i_isa_type(ISA_SB_type) = '1' then\n" +
                        "        wb_radr1 := ('0' & i_d_instr(19 downto 15));\n" +
                        "        wb_rdata1 := i_rdata1;\n" +
                        "        wb_radr2 := ('0' & i_d_instr(24 downto 20));\n" +
                        "        wb_rdata2 := i_rdata2;\n" +
                        "        wb_off(RISCV_ARCH-1 downto 12) := wb_mask_i31(RISCV_ARCH-1 downto 12);\n" +
                        "        wb_off(12) := i_d_instr(31);\n" +
                        "        wb_off(11) := i_d_instr(7);\n" +
                        "        wb_off(10 downto 5) := i_d_instr(30 downto 25);\n" +
                        "        wb_off(4 downto 1) := i_d_instr(11 downto 8);\n" +
                        "        wb_off(0) := '0';\n" +
                        "    elsif i_isa_type(ISA_UJ_type) = '1' then\n" +
                        "        wb_radr1 := (others => '0');\n" +
                        "        wb_rdata1 := X\"00000000\" & i_d_pc;\n" +
                        "        wb_radr2 := (others => '0');\n" +
                        "        wb_off(RISCV_ARCH-1 downto 20) := wb_mask_i31(RISCV_ARCH-1 downto 20);\n" +
                        "        wb_off(19 downto 12) := i_d_instr(19 downto 12);\n" +
                        "        wb_off(11) := i_d_instr(20);\n" +
                        "        wb_off(10 downto 1) := i_d_instr(30 downto 21);\n" +
                        "        wb_off(0) := '0';\n" +
                        "    elsif i_isa_type(ISA_U_type) = '1'then\n" +
                        "        wb_radr1 := (others => '0');\n" +
                        "        wb_rdata1 := X\"00000000\" & i_d_pc;\n" +
                        "        wb_radr2 := (others => '0');\n" +
                        "        wb_rdata2(31 downto 0) := i_d_instr(31 downto 12) & X\"000\";\n" +
                        "        wb_rdata2(RISCV_ARCH-1 downto 32) := wb_mask_i31(RISCV_ARCH-1 downto 32);\n" +
                        "    elsif i_isa_type(ISA_S_type) = '1' then\n" +
                        "        wb_radr1 := ('0' & i_d_instr(19 downto 15));\n" +
                        "        wb_rdata1 := i_rdata1;\n" +
                        "        wb_radr2 := ('0' & i_d_instr(24 downto 20));\n" +
                        "        wb_rdata2 := i_rdata2;\n" +
                        "        wb_off(RISCV_ARCH-1 downto 12) := wb_mask_i31(RISCV_ARCH-1 downto 12);\n" +
                        "        wb_off(11 downto 5) := i_d_instr(31 downto 25);\n" +
                        "        wb_off(4 downto 0) := i_d_instr(11 downto 7);\n" +
                        "        if CFG_FPU_ENABLE and wv(Instr_FSD) = '1' then\n" +
                        "            wb_radr2 := ('1' & i_d_instr(24 downto 20));\n" +
                        "            wb_rdata2 := i_rfdata2;\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    --! Default number of cycles per instruction = 0 (1 clock per instr)\n" +
                        "    --! If instruction is multicycle then modify this value.\n" +
                        "    --!\n" +
                        "    w_fpu_ena := '0';\n" +
                        "    if CFG_FPU_ENABLE then\n" +
                        "        if i_f64 = '1' and (wv(Instr_FSD) or wv(Instr_FLD)) = '0' then\n" +
                        "            w_fpu_ena := '1';\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_multi_ena := wv(Instr_MUL) or wv(Instr_MULW) or wv(Instr_DIV)\n" +
                        "                    or wv(Instr_DIVU) or wv(Instr_DIVW) or wv(Instr_DIVUW)\n" +
                        "                    or wv(Instr_REM) or wv(Instr_REMU) or wv(Instr_REMW)\n" +
                        "                    or wv(Instr_REMUW) or w_fpu_ena;\n" +
                        "\n" +
                        "    w_multi_valid := w_arith_valid(Multi_MUL) or w_arith_valid(Multi_DIV)\n" +
                        "                   or w_arith_valid(Multi_FPU);\n" +
                        "\n" +
                        "    -- Don't modify registers on conditional jumps:\n" +
                        "    w_res_wena := not (wv(Instr_BEQ) or wv(Instr_BGE) or wv(Instr_BGEU)\n" +
                        "               or wv(Instr_BLT) or wv(Instr_BLTU) or wv(Instr_BNE)\n" +
                        "               or wv(Instr_SD) or wv(Instr_SW) or wv(Instr_SH) or wv(Instr_SB)\n" +
                        "               or wv(Instr_FSD)\n" +
                        "               or wv(Instr_MRET) or wv(Instr_URET)\n" +
                        "               or wv(Instr_ECALL) or wv(Instr_EBREAK));\n" +
                        "\n" +
                        "    if w_multi_valid = '1' then\n" +
                        "        wb_res_addr := r.multi_res_addr;\n" +
                        "        v.multiclock_ena := '0';\n" +
                        "    elsif w_res_wena = '1' then\n" +
                        "        wb_res_addr := ('0' & i_d_instr(11 downto 7));\n" +
                        "        if CFG_FPU_ENABLE then\n" +
                        "            if i_f64 = '1' and wv(Instr_FLD) = '1' then\n" +
                        "                wb_res_addr(5) := '1';\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    else\n" +
                        "        wb_res_addr := (others => '0');\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    w_next_ready := '0';\n" +
                        "    w_hold := '0';\n" +
                        "\n" +
                        "    if i_d_valid = '1' and w_pc_valid = '1' then\n" +
                        "        w_next_ready := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    --! Valid values on the inputs radr1,radr2 will be 2 cycles after\n" +
                        "    --! signal o_valid = 1\n" +
                        "    --!\n" +
                        "    w_hazard_lvl1 := '0';\n" +
                        "    if r.res_addr /= \"000000\" and\n" +
                        "        (wb_radr1 = r.res_addr or wb_radr2 = r.res_addr) then\n" +
                        "        w_hazard_lvl1 := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_hazard_lvl2 := '0';\n" +
                        "    if r.hazard_addr0 /= \"000000\" and\n" +
                        "        (wb_radr1 = r.hazard_addr0 or wb_radr2 = r.hazard_addr0) then\n" +
                        "        w_hazard_lvl2 := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_valid := '0';\n" +
                        "    case r.state is\n" +
                        "    when State_WaitInstr =>\n" +
                        "        if r.hazard_depth /= \"00\" and w_hazard_lvl2 = '1' then\n" +
                        "            -- Hazard after missed predicted instruction 1 cycle\n" +
                        "            w_hold := '1';\n" +
                        "            w_next_ready := '0';\n" +
                        "        elsif i_pipeline_hold = '1' then\n" +
                        "            v.state := State_Hold;\n" +
                        "            v.hold_valid := w_next_ready;\n" +
                        "            v.hold_multi_ena := w_multi_ena;\n" +
                        "        elsif w_next_ready = '1' then\n" +
                        "            if w_multi_ena = '1' then\n" +
                        "                w_hold := '1';\n" +
                        "                v.state := State_MultiCycle;\n" +
                        "            else\n" +
                        "                v.state := State_SingleCycle;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    when State_SingleCycle =>\n" +
                        "        w_valid := '1';\n" +
                        "        if w_hazard_lvl1 = '1' then\n" +
                        "            -- 2-cycles wait state\n" +
                        "            w_hold := '1';\n" +
                        "            w_next_ready := '0';\n" +
                        "            v.state := State_Hazard;\n" +
                        "        elsif w_hazard_lvl2 = '1' then\n" +
                        "            -- 1-cycle wait state\n" +
                        "            w_hold := '1';\n" +
                        "            w_next_ready := '0';\n" +
                        "            if i_wb_ready = '1' then\n" +
                        "                v.state := State_WaitInstr;\n" +
                        "            else\n" +
                        "                -- Queue in memaccess module allows to accept 2 LOAD instructions\n" +
                        "                v.state := State_Hazard;\n" +
                        "            end if;\n" +
                        "        elsif i_pipeline_hold = '1' then\n" +
                        "            v.state := State_Hold;\n" +
                        "            v.hold_valid := w_next_ready;\n" +
                        "            v.hold_multi_ena := w_multi_ena;\n" +
                        "        elsif w_next_ready = '1' then\n" +
                        "            if w_multi_ena = '1' then\n" +
                        "                w_hold := '1';\n" +
                        "                v.state := State_MultiCycle;\n" +
                        "            else\n" +
                        "                v.state := State_SingleCycle;\n" +
                        "            end if;\n" +
                        "        else\n" +
                        "            v.state := State_WaitInstr;\n" +
                        "        end if;\n" +
                        "    when State_MultiCycle =>\n" +
                        "        w_hold := '1';\n" +
                        "        w_next_ready := '0';\n" +
                        "        if w_multi_valid = '1' then\n" +
                        "            v.state := State_SingleCycle;\n" +
                        "        end if;\n" +
                        "    when State_Hold =>\n" +
                        "        --! No need to raise w_hold because it is already hold, but we have\n" +
                        "        --! to use previously latched values of instruction type because outputs\n" +
                        "        --! pc and npc switched for next instruction\n" +
                        "        w_next_ready := '0';\n" +
                        "        if i_pipeline_hold = '0' then\n" +
                        "            if r.hold_valid = '1' then\n" +
                        "                if r.hold_multi_ena = '1' and w_multi_valid = '0' then\n" +
                        "                    v.state := State_MultiCycle;\n" +
                        "                else\n" +
                        "                    v.state := State_SingleCycle;\n" +
                        "                end if;\n" +
                        "            else\n" +
                        "                v.state := State_WaitInstr;\n" +
                        "            end if;\n" +
                        "        elsif r.hold_multi_ena = '1' then\n" +
                        "            --! Track the end of multi-instruction while in Hold state\n" +
                        "            if w_multi_valid = '1' then\n" +
                        "                v.hold_multi_ena := '0';\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    when State_Hazard =>\n" +
                        "        w_next_ready := '0';\n" +
                        "        w_hold := '1';\n" +
                        "        if i_wb_ready = '1' then\n" +
                        "            v.state := State_WaitInstr;\n" +
                        "        end if;\n" +
                        "    when others =>\n" +
                        "    end case;\n" +
                        "\n" +
                        "    if w_valid = '1' then\n" +
                        "        v.hazard_addr0 := r.res_addr;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if w_valid = '1' and i_wb_ready = '0' then\n" +
                        "        v.hazard_depth := r.hazard_depth + 1;\n" +
                        "    elsif w_valid = '0' and i_wb_ready = '1' then\n" +
                        "        v.hazard_depth := r.hazard_depth - 1;\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    -- parallel ALU:\n" +
                        "    wb_sum64 := wb_rdata1 + wb_rdata2;\n" +
                        "    wb_sum32(31 downto 0) := wb_rdata1(31 downto 0) + wb_rdata2(31 downto 0);\n" +
                        "    wb_sum32(63 downto 32) := (others => wb_sum32(31));\n" +
                        "    wb_sub64 := wb_rdata1 - wb_rdata2;\n" +
                        "    wb_sub32(31 downto 0) := wb_rdata1(31 downto 0) - wb_rdata2(31 downto 0);\n" +
                        "    wb_sub32(63 downto 32) := (others => wb_sub32(31));\n" +
                        "    wb_and64 := wb_rdata1 and wb_rdata2;\n" +
                        "    wb_or64 := wb_rdata1 or wb_rdata2;\n" +
                        "    wb_xor64 := wb_rdata1 xor wb_rdata2;\n" +
                        "    \n" +
                        "    wb_shifter_a1 <= wb_rdata1;\n" +
                        "    wb_shifter_a2 <= wb_rdata2(5 downto 0);\n" +
                        "\n" +
                        "    w_less := '0';\n" +
                        "    w_gr_equal := '0';\n" +
                        "    if UNSIGNED(wb_rdata1) < UNSIGNED(wb_rdata2) then\n" +
                        "        w_less := '1';\n" +
                        "    end if;\n" +
                        "    if UNSIGNED(wb_rdata1) >= UNSIGNED(wb_rdata2) then\n" +
                        "        w_gr_equal := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Relative Branch on some condition:\n" +
                        "    w_pc_branch := '0';\n" +
                        "    if ((wv(Instr_BEQ) = '1' and (wb_sub64 = zero64))\n" +
                        "        or (wv(Instr_BGE) = '1' and (wb_sub64(63) = '0'))\n" +
                        "        or (wv(Instr_BGEU) = '1' and (w_gr_equal = '1'))\n" +
                        "        or (wv(Instr_BLT) = '1' and (wb_sub64(63) = '1'))\n" +
                        "        or (wv(Instr_BLTU) = '1' and (w_less = '1'))\n" +
                        "        or (wv(Instr_BNE) = '1' and (wb_sub64 /= zero64))) then\n" +
                        "        w_pc_branch := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    opcode_len := 4;\n" +
                        "    if i_compressed = '1' then\n" +
                        "        opcode_len := 2;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if w_pc_branch = '1' then\n" +
                        "        wb_npc := i_d_pc + wb_off(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    elsif wv(Instr_JAL) = '1' then\n" +
                        "        wb_res(63 downto 32) := (others => '0');\n" +
                        "        wb_res(31 downto 0) := i_d_pc + opcode_len;\n" +
                        "        wb_npc := wb_rdata1(BUS_ADDR_WIDTH-1 downto 0) + wb_off(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    elsif wv(Instr_JALR) = '1' then\n" +
                        "        wb_res(63 downto 32) := (others => '0');\n" +
                        "        wb_res(31 downto 0) := i_d_pc + opcode_len;\n" +
                        "        wb_npc := wb_rdata1(BUS_ADDR_WIDTH-1 downto 0) + wb_rdata2(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "        wb_npc(0) := '0';\n" +
                        "    elsif wv(Instr_MRET) = '1' then\n" +
                        "        wb_res(63 downto 32) := (others => '0');\n" +
                        "        wb_res(31 downto 0) := i_d_pc + opcode_len;\n" +
                        "        w_mret := '1';\n" +
                        "        w_csr_wena := '0';\n" +
                        "        wb_csr_addr := CSR_mepc;\n" +
                        "        wb_npc := i_csr_rdata(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    elsif wv(Instr_URET) = '1' then\n" +
                        "        wb_res(63 downto 32) := (others => '0');\n" +
                        "        wb_res(31 downto 0) := i_d_pc + opcode_len;\n" +
                        "        w_uret := '1';\n" +
                        "        w_csr_wena := '0';\n" +
                        "        wb_csr_addr := CSR_uepc;\n" +
                        "        wb_npc := i_csr_rdata(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    else\n" +
                        "        -- Instr_HRET, Instr_SRET, Instr_FENCE, Instr_FENCE_I:\n" +
                        "        wb_npc := i_d_pc + opcode_len;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if i_memop_load = '1' then\n" +
                        "        wb_memop_addr := wb_rdata1(BUS_ADDR_WIDTH-1 downto 0)\n" +
                        "                      + wb_rdata2(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    elsif i_memop_store = '1' then\n" +
                        "        wb_memop_addr := wb_rdata1(BUS_ADDR_WIDTH-1 downto 0)\n" +
                        "                       + wb_off(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_exception_store := '0';\n" +
                        "    w_exception_load := '0';\n" +
                        "\n" +
                        "    if ((wv(Instr_LD) = '1' and wb_memop_addr(2 downto 0) /= \"000\")\n" +
                        "        or ((wv(Instr_LW) or wv(Instr_LWU)) = '1' and wb_memop_addr(1 downto 0) /= \"00\")\n" +
                        "        or ((wv(Instr_LH) or wv(Instr_LHU)) = '1' and wb_memop_addr(0) /= '0'))  then\n" +
                        "        w_exception_load := '1';\n" +
                        "    end if;\n" +
                        "    if ((wv(Instr_SD) = '1' and wb_memop_addr(2 downto 0) /= \"000\")\n" +
                        "        or (wv(Instr_SW) = '1' and wb_memop_addr(1 downto 0) /= \"00\")\n" +
                        "        or (wv(Instr_SH) = '1' and wb_memop_addr(0) /= '0')) then\n" +
                        "        w_exception_store := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    v.multi_ena := (others => '0');\n" +
                        "    v.multi_rv32 := i_rv32;\n" +
                        "    v.multi_f64 := i_f64;\n" +
                        "    v.multi_unsigned := i_unsigned_op;\n" +
                        "    v.multi_residual_high := '0';\n" +
                        "    if w_fpu_ena = '1' then\n" +
                        "        v.multi_a1 := wb_rdata1;\n" +
                        "        v.multi_a2 := wb_rdata2;\n" +
                        "    else\n" +
                        "        v.multi_a1 := i_rdata1;\n" +
                        "        v.multi_a2 := i_rdata2;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if (w_multi_ena and w_next_ready) = '1' then\n" +
                        "        v.multiclock_ena := '1';\n" +
                        "        v.multi_res_addr := wb_res_addr;\n" +
                        "        if CFG_FPU_ENABLE then\n" +
                        "            v.multi_ivec_fpu := wv(Instr_FSGNJ_D downto Instr_FADD_D);\n" +
                        "            if w_fpu_ena = '1' and (wv(Instr_FMOV_X_D) or wv(Instr_FEQ_D)\n" +
                        "                or wv(Instr_FMOV_X_W)\n" +
                        "                or wv(Instr_FLT_D) or wv(Instr_FLE_D)\n" +
                        "                or wv(Instr_FCVT_LU_D) or wv(Instr_FCVT_L_D)\n" +
                        "                or wv(Instr_FCVT_WU_D) or wv(Instr_FCVT_W_D)) = '0' then\n" +
                        "                v.multi_res_addr := '1' & wb_res_addr(4 downto 0);\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "        v.multi_pc := i_d_pc;\n" +
                        "        v.multi_instr := i_d_instr;\n" +
                        "        if i_trap_valid = '1' then\n" +
                        "            v.multi_npc := i_trap_pc;\n" +
                        "        else\n" +
                        "            v.multi_npc := wb_npc;\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    -- ALU block selector:\n" +
                        "    if w_arith_valid(Multi_MUL) = '1' then\n" +
                        "        wb_res := wb_arith_res(Multi_MUL);\n" +
                        "    elsif w_arith_valid(Multi_DIV) = '1' then\n" +
                        "        wb_res := wb_arith_res(Multi_DIV);\n" +
                        "    elsif w_arith_valid(Multi_FPU) = '1' then\n" +
                        "        wb_res := wb_arith_res(Multi_FPU);\n" +
                        "    elsif i_memop_load = '1' then\n" +
                        "        w_memop_load := '1';\n" +
                        "        w_memop_sign_ext := i_memop_sign_ext;\n" +
                        "        wb_memop_size := i_memop_size;\n" +
                        "    elsif i_memop_store = '1' then\n" +
                        "        w_memop_store := '1';\n" +
                        "        wb_memop_size := i_memop_size;\n" +
                        "        wb_res := wb_rdata2;\n" +
                        "    elsif (wv(Instr_ADD) or wv(Instr_ADDI) or wv(Instr_AUIPC)) = '1' then\n" +
                        "        wb_res := wb_sum64;\n" +
                        "    elsif (wv(Instr_ADDW) or wv(Instr_ADDIW)) = '1' then\n" +
                        "        wb_res := wb_sum32;\n" +
                        "    elsif wv(Instr_SUB) = '1' then\n" +
                        "        wb_res := wb_sub64;\n" +
                        "    elsif wv(Instr_SUBW) = '1' then\n" +
                        "        wb_res := wb_sub32;\n" +
                        "    elsif (wv(Instr_SLL) or wv(Instr_SLLI)) = '1' then\n" +
                        "        wb_res := wb_sll;\n" +
                        "    elsif (wv(Instr_SLLW) or wv(Instr_SLLIW)) = '1' then\n" +
                        "        wb_res := wb_sllw;\n" +
                        "    elsif (wv(Instr_SRL) or wv(Instr_SRLI)) = '1' then\n" +
                        "        wb_res := wb_srl;\n" +
                        "    elsif (wv(Instr_SRLW) or wv(Instr_SRLIW)) = '1' then\n" +
                        "        wb_res := wb_srlw;\n" +
                        "    elsif (wv(Instr_SRA) or wv(Instr_SRAI)) = '1' then\n" +
                        "        wb_res := wb_sra;\n" +
                        "    elsif (wv(Instr_SRAW) or wv(Instr_SRAW) or wv(Instr_SRAIW)) = '1' then\n" +
                        "        wb_res := wb_sraw;\n" +
                        "    elsif (wv(Instr_AND) or wv(Instr_ANDI)) = '1' then\n" +
                        "        wb_res := wb_and64;\n" +
                        "    elsif (wv(Instr_OR) or wv(Instr_ORI)) = '1' then\n" +
                        "        wb_res := wb_or64;\n" +
                        "    elsif (wv(Instr_XOR) or wv(Instr_XORI)) = '1' then\n" +
                        "        wb_res := wb_xor64;\n" +
                        "    elsif (wv(Instr_SLT) or wv(Instr_SLTI)) = '1' then\n" +
                        "        wb_res(RISCV_ARCH-1 downto 1) := (others => '0');\n" +
                        "        wb_res(0) := wb_sub64(63);\n" +
                        "    elsif (wv(Instr_SLTU) or wv(Instr_SLTIU)) = '1' then\n" +
                        "        wb_res(63 downto 1) := (others => '0');\n" +
                        "        wb_res(0) := w_less;\n" +
                        "    elsif wv(Instr_LUI) = '1' then\n" +
                        "        wb_res := wb_rdata2;\n" +
                        "    elsif (wv(Instr_MUL) or wv(Instr_MULW)) = '1' then\n" +
                        "        v.multi_ena(Multi_MUL) := w_next_ready;\n" +
                        "    elsif (wv(Instr_DIV) or wv(Instr_DIVU)\n" +
                        "            or wv(Instr_DIVW) or wv(Instr_DIVUW)) = '1' then\n" +
                        "        v.multi_ena(Multi_DIV) := w_next_ready;\n" +
                        "    elsif (wv(Instr_REM) or wv(Instr_REMU)\n" +
                        "            or wv(Instr_REMW) or wv(Instr_REMUW)) = '1' then\n" +
                        "        v.multi_ena(Multi_DIV) := w_next_ready;\n" +
                        "        v.multi_residual_high := '1';\n" +
                        "    elsif w_fpu_ena = '1' then\n" +
                        "        v.multi_ena(Multi_FPU) := w_next_ready;\n" +
                        "    elsif wv(Instr_CSRRC) = '1' then\n" +
                        "        wb_res := i_csr_rdata;\n" +
                        "        w_csr_wena := '1';\n" +
                        "        wb_csr_addr := wb_rdata2(11 downto 0);\n" +
                        "        wb_csr_wdata := i_csr_rdata and (not i_rdata1);\n" +
                        "    elsif wv(Instr_CSRRCI) = '1' then\n" +
                        "        wb_res := i_csr_rdata;\n" +
                        "        w_csr_wena := '1';\n" +
                        "        wb_csr_addr := wb_rdata2(11 downto 0);\n" +
                        "        wb_csr_wdata(RISCV_ARCH-1 downto 5) := i_csr_rdata(RISCV_ARCH-1 downto 5);\n" +
                        "        wb_csr_wdata(4 downto 0) := i_csr_rdata(4 downto 0) and not wb_radr1(4 downto 0);  -- zero-extending 5 to 64-bits\n" +
                        "    elsif wv(Instr_CSRRS) = '1' then\n" +
                        "        wb_res := i_csr_rdata;\n" +
                        "        w_csr_wena := '1';\n" +
                        "        wb_csr_addr := wb_rdata2(11 downto 0);\n" +
                        "        wb_csr_wdata := i_csr_rdata or i_rdata1;\n" +
                        "    elsif wv(Instr_CSRRSI) = '1' then\n" +
                        "        wb_res := i_csr_rdata;\n" +
                        "        w_csr_wena := '1';\n" +
                        "        wb_csr_addr := wb_rdata2(11 downto 0);\n" +
                        "        wb_csr_wdata(RISCV_ARCH-1 downto 5) := i_csr_rdata(RISCV_ARCH-1 downto 5);\n" +
                        "        wb_csr_wdata(4 downto 0) := i_csr_rdata(4 downto 0) or wb_radr1(4 downto 0);  -- zero-extending 5 to 64-bits\n" +
                        "    elsif wv(Instr_CSRRW) = '1' then\n" +
                        "        wb_res := i_csr_rdata;\n" +
                        "        w_csr_wena := '1';\n" +
                        "        wb_csr_addr := wb_rdata2(11 downto 0);\n" +
                        "        wb_csr_wdata := i_rdata1;\n" +
                        "    elsif wv(Instr_CSRRWI) = '1' then\n" +
                        "        wb_res := i_csr_rdata;\n" +
                        "        w_csr_wena := '1';\n" +
                        "        wb_csr_addr := wb_rdata2(11 downto 0);\n" +
                        "        wb_csr_wdata(RISCV_ARCH-1 downto 5) := (others => '0');\n" +
                        "        wb_csr_wdata(4 downto 0) := wb_radr1(4 downto 0);  -- zero-extending 5 to 64-bits\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    o_trap_ready <= w_next_ready;\n" +
                        "\n" +
                        "    o_ex_instr_load_fault <= i_instr_load_fault and w_next_ready;\n" +
                        "    o_ex_illegal_instr <= i_unsup_exception and w_next_ready;\n" +
                        "    o_ex_unalign_store <= w_exception_store and w_next_ready;\n" +
                        "    o_ex_unalign_load <= w_exception_load and w_next_ready;\n" +
                        "    o_ex_breakpoint <= wv(Instr_EBREAK) and w_next_ready;\n" +
                        "    o_ex_ecall <= wv(Instr_ECALL) and w_next_ready;\n" +
                        "\n" +
                        "    v.call := '0';\n" +
                        "    v.ret := '0';\n" +
                        "    wb_ex_npc := (others => '0');\n" +
                        "    if i_dport_npc_write = '1' then\n" +
                        "        v.npc := i_dport_npc;\n" +
                        "    elsif w_multi_valid = '1' then\n" +
                        "        -- multi-cycle instruction ending by single-cycle state\n" +
                        "        -- so no need to check jump opcodes\n" +
                        "        v.pc := r.multi_pc;\n" +
                        "        v.instr := r.multi_instr;\n" +
                        "        v.npc := r.multi_npc;\n" +
                        "        v.memop_load := '0';\n" +
                        "        v.memop_sign_ext := '0';\n" +
                        "        v.memop_store := '0';\n" +
                        "        v.memop_size := (others => '0');\n" +
                        "        v.memop_addr := (others => '0');\n" +
                        "\n" +
                        "        v.res_addr := wb_res_addr;\n" +
                        "        v.res_val := wb_res;\n" +
                        "    elsif w_next_ready = '1' then\n" +
                        "        v.pc := i_d_pc;\n" +
                        "        v.instr := i_d_instr;\n" +
                        "        if i_trap_valid = '1' then\n" +
                        "            v.npc := i_trap_pc;\n" +
                        "            wb_ex_npc := wb_npc;\n" +
                        "        else\n" +
                        "            v.npc := wb_npc;\n" +
                        "        end if;\n" +
                        "        v.memop_load := w_memop_load;\n" +
                        "        v.memop_sign_ext := w_memop_sign_ext;\n" +
                        "        v.memop_store := w_memop_store;\n" +
                        "        v.memop_size := wb_memop_size;\n" +
                        "        v.memop_addr := wb_memop_addr;\n" +
                        "\n" +
                        "        v.res_addr := wb_res_addr;\n" +
                        "        v.res_val := wb_res;\n" +
                        "\n" +
                        "        if wv(Instr_JAL) = '1' and conv_integer(wb_res_addr) = Reg_ra then\n" +
                        "            v.call := '1';\n" +
                        "        end if;\n" +
                        "        if wv(Instr_JALR) = '1' then\n" +
                        "            if conv_integer(wb_res_addr) = Reg_ra then\n" +
                        "                v.call := '1';\n" +
                        "            elsif wb_rdata2 = zero64 and conv_integer(wb_radr1) = Reg_ra then\n" +
                        "                v.ret := '1';\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    o_radr1 <= wb_radr1;\n" +
                        "    o_radr2 <= wb_radr2;\n" +
                        "    o_res_addr <= r.res_addr;\n" +
                        "    o_res_data <= r.res_val;\n" +
                        "    o_pipeline_hold <= w_hold;\n" +
                        "\n" +
                        "    o_csr_wena <= w_csr_wena and w_next_ready;\n" +
                        "    o_csr_addr <= wb_csr_addr;\n" +
                        "    o_csr_wdata <= wb_csr_wdata;\n" +
                        "    o_ex_npc <= wb_ex_npc;\n" +
                        "\n" +
                        "    o_memop_sign_ext <= r.memop_sign_ext;\n" +
                        "    o_memop_load <= r.memop_load;\n" +
                        "    o_memop_store <= r.memop_store;\n" +
                        "    o_memop_size <= r.memop_size;\n" +
                        "    o_memop_addr <= r.memop_addr;\n" +
                        "\n" +
                        "    o_valid <= w_valid;\n" +
                        "    o_pc <= r.pc;\n" +
                        "    o_npc <= r.npc;\n" +
                        "    o_instr <= r.instr;\n" +
                        "    o_call <= r.call;\n" +
                        "    o_ret <= r.ret;\n" +
                        "    o_mret <= w_mret;\n" +
                        "    o_uret <= w_uret;\n" +
                        "    o_fpu_valid <= w_arith_valid(Multi_FPU);\n" +
                        "    \n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(i_clk, i_nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_decoder_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use riverlib.river_cfg.all;\n" +
                        "\n" +
                        "library target;\n" +
                        "use target.config_target.all;\n" +
                        "\n" +
                        "entity InstrDecoder is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk  : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_any_hold : in std_logic;                               -- Hold pipeline by any reason\n" +
                        "    i_f_valid : in std_logic;                                -- Fetch input valid\n" +
                        "    i_f_pc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0); -- Fetched pc\n" +
                        "    i_f_instr : in std_logic_vector(31 downto 0);            -- Fetched instruction value\n" +
                        "    i_instr_load_fault : in std_logic;                       -- Instruction fetched from fault address\n" +
                        "\n" +
                        "    o_valid : out std_logic;                                 -- Current output values are valid\n" +
                        "    o_pc : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);  -- Current instruction pointer value\n" +
                        "    o_instr : out std_logic_vector(31 downto 0);             -- Current instruction value\n" +
                        "    o_memop_store : out std_logic;                           -- Store to memory operation\n" +
                        "    o_memop_load : out std_logic;                            -- Load from memoru operation\n" +
                        "    o_memop_sign_ext : out std_logic;                        -- Load memory value with sign extending\n" +
                        "    o_memop_size : out std_logic_vector(1 downto 0);         -- Memory transaction size\n" +
                        "    o_rv32 : out std_logic;                                  -- 32-bits instruction\n" +
                        "    o_compressed : out std_logic;                            -- 16-bits opcode (C-extension)\n" +
                        "    o_f64 : out std_logic;                                   -- 64-bits FPU (D-extension)\n" +
                        "    o_unsigned_op : out std_logic;                           -- Unsigned operands\n" +
                        "    o_isa_type : out std_logic_vector(ISA_Total-1 downto 0); -- Instruction format accordingly with ISA\n" +
                        "    o_instr_vec : out std_logic_vector(Instr_Total-1 downto 0); -- One bit per decoded instruction bus\n" +
                        "    o_exception : out std_logic;                             -- Unimplemented instruction\n" +
                        "    o_instr_load_fault : out std_logic                       -- Instruction fetched from fault address\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_InstrDecoder of InstrDecoder is\n" +
                        "\n" +
                        "  -- LB, LH, LW, LD, LBU, LHU, LWU\n" +
                        "  constant OPCODE_LB     : std_logic_vector(4 downto 0) := \"00000\";\n" +
                        "  -- FLD\n" +
                        "  constant OPCODE_FPU_LD : std_logic_vector(4 downto 0) := \"00001\";\n" +
                        "  -- FENCE, FENCE_I\n" +
                        "  constant OPCODE_FENCE  : std_logic_vector(4 downto 0) := \"00011\";\n" +
                        "  --  ADDI, ANDI, ORI, SLLI, SLTI, SLTIU, SRAI, SRLI, XORI\n" +
                        "  constant OPCODE_ADDI   : std_logic_vector(4 downto 0) := \"00100\";\n" +
                        "  -- AUIPC\n" +
                        "  constant OPCODE_AUIPC  : std_logic_vector(4 downto 0) := \"00101\";\n" +
                        "  -- ADDIW, SLLIW, SRAIW, SRLIW\n" +
                        "  constant OPCODE_ADDIW  : std_logic_vector(4 downto 0) := \"00110\";\n" +
                        "  -- SB, SH, SW, SD\n" +
                        "  constant OPCODE_SB     : std_logic_vector(4 downto 0) := \"01000\";\n" +
                        "  -- FSD\n" +
                        "  constant OPCODE_FPU_SD : std_logic_vector(4 downto 0) := \"01001\";\n" +
                        "  -- ADD, AND, OR, SLT, SLTU, SLL, SRA, SRL, SUB, XOR, DIV, DIVU, MUL, REM, REMU\n" +
                        "  constant OPCODE_ADD    : std_logic_vector(4 downto 0) := \"01100\";\n" +
                        "  -- LUI\n" +
                        "  constant OPCODE_LUI    : std_logic_vector(4 downto 0) := \"01101\";\n" +
                        "  -- ADDW, SLLW, SRAW, SRLW, SUBW, DIVW, DIVUW, MULW, REMW, REMUW\n" +
                        "  constant OPCODE_ADDW   : std_logic_vector(4 downto 0) := \"01110\";\n" +
                        "  -- FPU operations\n" +
                        "  constant OPCODE_FPU_OP : std_logic_vector(4 downto 0) := \"10100\";\n" +
                        "  -- BEQ, BNE, BLT, BGE, BLTU, BGEU\n" +
                        "  constant OPCODE_BEQ    : std_logic_vector(4 downto 0) := \"11000\";\n" +
                        "  -- JALR\n" +
                        "  constant OPCODE_JALR   : std_logic_vector(4 downto 0) := \"11001\";\n" +
                        "  -- JAL\n" +
                        "  constant OPCODE_JAL    : std_logic_vector(4 downto 0) := \"11011\";\n" +
                        "  -- CSRRC, CSRRCI, CSRRS, CSRRSI, CSRRW, CSRRWI, URET, SRET, HRET, MRET\n" +
                        "  constant OPCODE_CSRR   : std_logic_vector(4 downto 0) := \"11100\"; \n" +
                        "  -- Compressed instruction set\n" +
                        "  constant OPCODE_C_ADDI4SPN : std_logic_vector(4 downto 0) := \"00000\";\n" +
                        "  constant OPCODE_C_NOP_ADDI : std_logic_vector(4 downto 0) := \"00001\";\n" +
                        "  constant OPCODE_C_SLLI     : std_logic_vector(4 downto 0) := \"00010\";\n" +
                        "  constant OPCODE_C_JAL_ADDIW : std_logic_vector(4 downto 0) := \"00101\";\n" +
                        "  constant OPCODE_C_LW       : std_logic_vector(4 downto 0) := \"01000\";\n" +
                        "  constant OPCODE_C_LI       : std_logic_vector(4 downto 0) := \"01001\";\n" +
                        "  constant OPCODE_C_LWSP     : std_logic_vector(4 downto 0) := \"01010\";\n" +
                        "  constant OPCODE_C_LD       : std_logic_vector(4 downto 0) := \"01100\";\n" +
                        "  constant OPCODE_C_ADDI16SP_LUI : std_logic_vector(4 downto 0) := \"01101\";\n" +
                        "  constant OPCODE_C_LDSP     : std_logic_vector(4 downto 0) := \"01110\";\n" +
                        "  constant OPCODE_C_MATH     : std_logic_vector(4 downto 0) := \"10001\";\n" +
                        "  constant OPCODE_C_JR_MV_EBREAK_JALR_ADD : std_logic_vector(4 downto 0) := \"10010\";\n" +
                        "  constant OPCODE_C_J        : std_logic_vector(4 downto 0) := \"10101\";\n" +
                        "  constant OPCODE_C_SW       : std_logic_vector(4 downto 0) := \"11000\";\n" +
                        "  constant OPCODE_C_BEQZ     : std_logic_vector(4 downto 0) := \"11001\";\n" +
                        "  constant OPCODE_C_SWSP     : std_logic_vector(4 downto 0) := \"11010\";\n" +
                        "  constant OPCODE_C_SD       : std_logic_vector(4 downto 0) := \"11100\";\n" +
                        "  constant OPCODE_C_BNEZ     : std_logic_vector(4 downto 0) := \"11101\";\n" +
                        "  constant OPCODE_C_SDSP     : std_logic_vector(4 downto 0) := \"11110\";\n" +
                        "\n" +
                        "\n" +
                        "  constant INSTR_NONE : std_logic_vector(Instr_Total-1 downto 0) := (others => '0');\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "      valid : std_logic;\n" +
                        "      pc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      isa_type : std_logic_vector(ISA_Total-1 downto 0);\n" +
                        "      instr_vec : std_logic_vector(Instr_Total-1 downto 0);\n" +
                        "      instr : std_logic_vector(31 downto 0);\n" +
                        "      memop_store : std_logic;\n" +
                        "      memop_load : std_logic;\n" +
                        "      memop_sign_ext : std_logic;\n" +
                        "      memop_size : std_logic_vector(1 downto 0);\n" +
                        "      unsigned_op : std_logic;\n" +
                        "      rv32 : std_logic;\n" +
                        "      f64 : std_logic;\n" +
                        "      compressed : std_logic;\n" +
                        "      instr_load_fault : std_logic;\n" +
                        "      instr_unimplemented : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "    '0', (others => '0'), (others => '0'),   -- valid, pc, isa_type\n" +
                        "    (others => '0'), (others => '0'), '0',   -- instr_vec, instr, memop_store\n" +
                        "    '0', '0', \"00\",                          -- memop_load, memop_sign_ext, memop_size\n" +
                        "    '0', '0', '0',                           -- unsigned_op, rv32, f64\n" +
                        "    '0', '0', '0'                            -- compressed, instr_load_fault, instr_unimpl\n" +
                        "  );\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "\n" +
                        "  comb : process(i_nrst, i_any_hold, i_f_valid, i_f_pc, i_f_instr, i_instr_load_fault, r)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable w_o_valid : std_logic;\n" +
                        "    variable w_error : std_logic;\n" +
                        "    variable w_compressed : std_logic;\n" +
                        "    variable wb_instr : std_logic_vector(31 downto 0);\n" +
                        "    variable wb_instr_out : std_logic_vector(31 downto 0);\n" +
                        "    variable wb_opcode1 : std_logic_vector(4 downto 0);\n" +
                        "    variable wb_opcode2 : std_logic_vector(2 downto 0);\n" +
                        "    variable wb_dec : std_logic_vector(Instr_Total-1 downto 0);\n" +
                        "    variable wb_isa_type : std_logic_vector(ISA_Total-1 downto 0);\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "    w_error := '0';\n" +
                        "    w_compressed := '0';\n" +
                        "    wb_instr := i_f_instr;\n" +
                        "    wb_opcode1 := wb_instr(6 downto 2);\n" +
                        "    wb_opcode2 := wb_instr(14 downto 12);\n" +
                        "    wb_dec := (others => '0');\n" +
                        "    wb_isa_type := (others => '0');\n" +
                        "\n" +
                        "    if wb_instr(1 downto 0) /= \"11\" then\n" +
                        "        w_compressed := '1';\n" +
                        "        wb_opcode1 := wb_instr(15 downto 13) & wb_instr(1 downto 0);\n" +
                        "        wb_instr_out := X\"00000003\";\n" +
                        "        case wb_opcode1 is\n" +
                        "        when OPCODE_C_ADDI4SPN =>\n" +
                        "            wb_isa_type(ISA_I_type) := '1';\n" +
                        "            wb_dec(Instr_ADDI) := '1';\n" +
                        "            wb_instr_out(11 downto 7) := \"01\" & wb_instr(4 downto 2);   -- rd\n" +
                        "            wb_instr_out(19 downto 15) := \"00010\";                     -- rs1 = sp\n" +
                        "            wb_instr_out(29 downto 22) :=\n" +
                        "                wb_instr(10 downto 7) & wb_instr(12 downto 11) & wb_instr(5) & wb_instr(6);\n" +
                        "        when OPCODE_C_NOP_ADDI =>\n" +
                        "            wb_isa_type(ISA_I_type) := '1';\n" +
                        "            wb_dec(Instr_ADDI) := '1';\n" +
                        "            wb_instr_out(11 downto 7) := wb_instr(11 downto 7);   -- rd\n" +
                        "            wb_instr_out(19 downto 15) := wb_instr(11 downto 7);  -- rs1\n" +
                        "            wb_instr_out(24 downto 20) := wb_instr(6 downto 2);   -- imm\n" +
                        "            if wb_instr(12) = '1' then\n" +
                        "                wb_instr_out(31 downto 25) := (others => '1');\n" +
                        "            end if;\n" +
                        "        when OPCODE_C_SLLI =>\n" +
                        "            wb_isa_type(ISA_I_type) := '1';\n" +
                        "            wb_dec(Instr_SLLI) := '1';\n" +
                        "            wb_instr_out(11 downto 7) := wb_instr(11 downto 7);      -- rd\n" +
                        "            wb_instr_out(19 downto 15) := wb_instr(11 downto 7);     -- rs1\n" +
                        "            wb_instr_out(25 downto 20) := wb_instr(12) & wb_instr(6 downto 2);  -- shamt\n" +
                        "        when OPCODE_C_JAL_ADDIW =>\n" +
                        "            -- JAL is the RV32C only instruction\n" +
                        "            wb_isa_type(ISA_I_type) := '1';\n" +
                        "            wb_dec(Instr_ADDIW) := '1';\n" +
                        "            wb_instr_out(11 downto 7) := wb_instr(11 downto 7);      -- rd\n" +
                        "            wb_instr_out(19 downto 15) := wb_instr(11 downto 7);     -- rs1\n" +
                        "            wb_instr_out(24 downto 20) := wb_instr(6 downto 2);      -- imm\n" +
                        "            if wb_instr(12) = '1' then\n" +
                        "                wb_instr_out(31 downto 25) := (others => '1');\n" +
                        "            end if;\n" +
                        "        when OPCODE_C_LW =>\n" +
                        "            wb_isa_type(ISA_I_type) := '1';\n" +
                        "            wb_dec(Instr_LW) := '1';\n" +
                        "            wb_instr_out(11 downto 7) := \"01\" & wb_instr(4 downto 2);   -- rd\n" +
                        "            wb_instr_out(19 downto 15) := \"01\" & wb_instr(9 downto 7);  -- rs1\n" +
                        "            wb_instr_out(26 downto 22) :=\n" +
                        "                wb_instr(5) & wb_instr(12 downto 10) & wb_instr(6);\n" +
                        "        when OPCODE_C_LI =>  -- ADDI rd = r0 + imm\n" +
                        "            wb_isa_type(ISA_I_type) := '1';\n" +
                        "            wb_dec(Instr_ADDI) := '1';\n" +
                        "            wb_instr_out(11 downto 7) := wb_instr(11 downto 7);      -- rd\n" +
                        "            wb_instr_out(24 downto 20) := wb_instr(6 downto 2);      -- imm\n" +
                        "            if wb_instr(12) = '1' then\n" +
                        "                wb_instr_out(31 downto 25) := (others => '1');\n" +
                        "            end if;\n" +
                        "        when OPCODE_C_LWSP =>\n" +
                        "            wb_isa_type(ISA_I_type) := '1';\n" +
                        "            wb_dec(Instr_LW) := '1';\n" +
                        "            wb_instr_out(11 downto 7) := wb_instr(11 downto 7);    -- rd\n" +
                        "            wb_instr_out(19 downto 15) := \"00010\";                 -- rs1 = sp\n" +
                        "            wb_instr_out(27 downto 22) :=\n" +
                        "                wb_instr(3 downto 2) & wb_instr(12) & wb_instr(6 downto 4);\n" +
                        "        when OPCODE_C_LD =>\n" +
                        "            wb_isa_type(ISA_I_type) := '1';\n" +
                        "            wb_dec(Instr_LD) := '1';\n" +
                        "            wb_instr_out(11 downto 7) := \"01\" & wb_instr(4 downto 2);   -- rd\n" +
                        "            wb_instr_out(19 downto 15) := \"01\" & wb_instr(9 downto 7);  -- rs1\n" +
                        "            wb_instr_out(27 downto 23) :=\n" +
                        "                wb_instr(6) & wb_instr(5) & wb_instr(12 downto 10);\n" +
                        "        when OPCODE_C_ADDI16SP_LUI =>\n" +
                        "            if wb_instr(11 downto 7) = \"00010\" then\n" +
                        "                wb_isa_type(ISA_I_type) := '1';\n" +
                        "                wb_dec(Instr_ADDI) := '1';\n" +
                        "                wb_instr_out(11 downto 7) := \"00010\";     -- rd = sp\n" +
                        "                wb_instr_out(19 downto 15) := \"00010\";    -- rs1 = sp\n" +
                        "                wb_instr_out(28 downto 24) :=\n" +
                        "                    wb_instr(4 downto 3) & wb_instr(5) & wb_instr(2) & wb_instr(6);\n" +
                        "                if wb_instr(12) = '1' then\n" +
                        "                    wb_instr_out(31 downto 29) := (others => '1');\n" +
                        "                end if;\n" +
                        "            else\n" +
                        "                wb_isa_type(ISA_U_type) := '1';\n" +
                        "                wb_dec(Instr_LUI) := '1';\n" +
                        "                wb_instr_out(11 downto 7) := wb_instr(11 downto 7);  -- rd\n" +
                        "                wb_instr_out(16 downto 12) := wb_instr(6 downto 2);\n" +
                        "                if wb_instr(12) = '1' then\n" +
                        "                    wb_instr_out(31 downto 17) := (others => '1');\n" +
                        "                end if;\n" +
                        "            end if;\n" +
                        "        when OPCODE_C_LDSP =>\n" +
                        "            wb_isa_type(ISA_I_type) := '1';\n" +
                        "            wb_dec(Instr_LD) := '1';\n" +
                        "            wb_instr_out(11 downto 7) := wb_instr(11 downto 7);  -- rd\n" +
                        "            wb_instr_out(19 downto 15) := \"00010\";               -- rs1 = sp\n" +
                        "            wb_instr_out(28 downto 23) :=\n" +
                        "                wb_instr(4 downto 2) & wb_instr(12) & wb_instr(6 downto 5);\n" +
                        "        when OPCODE_C_MATH =>\n" +
                        "            if wb_instr(11 downto 10) = \"00\" then\n" +
                        "                wb_isa_type(ISA_I_type) := '1';\n" +
                        "                wb_dec(Instr_SRLI) := '1';\n" +
                        "                wb_instr_out(11 downto 7) := \"01\" & wb_instr(9 downto 7);   -- rd\n" +
                        "                wb_instr_out(19 downto 15) := \"01\" & wb_instr(9 downto 7);  -- rs1\n" +
                        "                wb_instr_out(25 downto 20) := wb_instr(12) & wb_instr(6 downto 2);  -- shamt\n" +
                        "            elsif wb_instr(11 downto 10) = \"01\" then\n" +
                        "                wb_isa_type(ISA_I_type) := '1';\n" +
                        "                wb_dec(Instr_SRAI) := '1';\n" +
                        "                wb_instr_out(11 downto 7) := \"01\" & wb_instr(9 downto 7);   -- rd\n" +
                        "                wb_instr_out(19 downto 15) := \"01\" & wb_instr(9 downto 7);  -- rs1\n" +
                        "                wb_instr_out(25 downto 20) := wb_instr(12) & wb_instr(6 downto 2);  -- shamt\n" +
                        "            elsif wb_instr(11 downto 10) = \"10\" then\n" +
                        "                wb_isa_type(ISA_I_type) := '1';\n" +
                        "                wb_dec(Instr_ANDI) := '1';\n" +
                        "                wb_instr_out(11 downto 7) := \"01\" & wb_instr(9 downto 7);   -- rd\n" +
                        "                wb_instr_out(19 downto 15) := \"01\" & wb_instr(9 downto 7);  -- rs1\n" +
                        "                wb_instr_out(24 downto 20) := wb_instr(6 downto 2);        -- imm\n" +
                        "                if wb_instr(12) = '1' then\n" +
                        "                    wb_instr_out(31 downto 25) := (others => '1');\n" +
                        "                end if;\n" +
                        "            elsif wb_instr(12) = '0' then\n" +
                        "                wb_isa_type(ISA_R_type) := '1';\n" +
                        "                wb_instr_out(11 downto 7) := \"01\" & wb_instr(9 downto 7);   -- rd\n" +
                        "                wb_instr_out(19 downto 15) := \"01\" & wb_instr(9 downto 7);  -- rs1\n" +
                        "                wb_instr_out(24 downto 20) := \"01\" & wb_instr(4 downto 2);  -- rs2\n" +
                        "                case wb_instr(6 downto 5) is\n" +
                        "                when \"00\" =>\n" +
                        "                    wb_dec(Instr_SUB) := '1';\n" +
                        "                when \"01\" =>\n" +
                        "                    wb_dec(Instr_XOR) := '1';\n" +
                        "                when \"10\" =>\n" +
                        "                    wb_dec(Instr_OR) := '1';\n" +
                        "                when others =>\n" +
                        "                    wb_dec(Instr_AND) := '1';\n" +
                        "                end case;\n" +
                        "            else\n" +
                        "                wb_isa_type(ISA_R_type) := '1';\n" +
                        "                wb_instr_out(11 downto 7) := \"01\" & wb_instr(9 downto 7);   -- rd\n" +
                        "                wb_instr_out(19 downto 15) := \"01\" & wb_instr(9 downto 7);  -- rs1\n" +
                        "                wb_instr_out(24 downto 20) := \"01\" & wb_instr(4 downto 2);  -- rs2\n" +
                        "                case wb_instr(6 downto 5) is\n" +
                        "                when \"00\" =>\n" +
                        "                    wb_dec(Instr_SUBW) := '1';\n" +
                        "                when \"01\" =>\n" +
                        "                    wb_dec(Instr_ADDW) := '1';\n" +
                        "                when others =>\n" +
                        "                    w_error := '1';\n" +
                        "                end case;\n" +
                        "            end if;\n" +
                        "        when OPCODE_C_JR_MV_EBREAK_JALR_ADD =>\n" +
                        "            wb_isa_type(ISA_I_type) := '1';\n" +
                        "            if wb_instr(12) = '0' then\n" +
                        "                if wb_instr(6 downto 2) = \"00000\" then\n" +
                        "                    wb_dec(Instr_JALR) := '1';\n" +
                        "                    wb_instr_out(19 downto 15) := wb_instr(11 downto 7);  -- rs1\n" +
                        "                else\n" +
                        "                    wb_dec(Instr_ADDI) := '1';\n" +
                        "                    wb_instr_out(11 downto 7) := wb_instr(11 downto 7);   -- rd\n" +
                        "                    wb_instr_out(19 downto 15) := wb_instr(6 downto 2);   -- rs1\n" +
                        "                end if;\n" +
                        "            else\n" +
                        "                if wb_instr(11 downto 7) = \"00000\" and wb_instr(6 downto 2) = \"00000\" then\n" +
                        "                    wb_dec(Instr_EBREAK) := '1';\n" +
                        "                elsif wb_instr(6 downto 2) = \"00000\" then\n" +
                        "                    wb_dec(Instr_JALR) := '1';\n" +
                        "                    wb_instr_out(11 downto 7) := \"00001\";                 -- rd = ra\n" +
                        "                    wb_instr_out(19 downto 15) := wb_instr(11 downto 7);  -- rs1\n" +
                        "                else\n" +
                        "                    wb_dec(Instr_ADD) := '1';\n" +
                        "                    wb_isa_type(ISA_R_type) := '1';\n" +
                        "                    wb_instr_out(11 downto 7) := wb_instr(11 downto 7);   -- rd\n" +
                        "                    wb_instr_out(19 downto 15) := wb_instr(11 downto 7);  -- rs1\n" +
                        "                    wb_instr_out(24 downto 20) := wb_instr(6 downto 2);   -- rs2\n" +
                        "                end if;\n" +
                        "            end if;\n" +
                        "        when OPCODE_C_J =>   -- JAL with rd = 0\n" +
                        "            wb_isa_type(ISA_UJ_type) := '1';\n" +
                        "            wb_dec(Instr_JAL) := '1';\n" +
                        "            wb_instr_out(20) := wb_instr(12);            -- imm11\n" +
                        "            wb_instr_out(23 downto 21) := wb_instr(5 downto 3);      -- imm10_1(3:1)\n" +
                        "            wb_instr_out(24) := wb_instr(11);            -- imm10_1(4)\n" +
                        "            wb_instr_out(25) := wb_instr(2);             -- imm10_1(5)\n" +
                        "            wb_instr_out(26) := wb_instr(7);             -- imm10_1(6)\n" +
                        "            wb_instr_out(27) := wb_instr(6);             -- imm10_1(7)\n" +
                        "            wb_instr_out(29 downto 28) := wb_instr(10 downto 9);     -- imm10_1(9:8)\n" +
                        "            wb_instr_out(30) := wb_instr(8);             -- imm10_1(10)\n" +
                        "            if wb_instr(12) = '1' then\n" +
                        "                wb_instr_out(19 downto 12) := (others => '1'); -- imm19_12\n" +
                        "                wb_instr_out(31) := '1';                 -- imm20\n" +
                        "            end if;\n" +
                        "        when OPCODE_C_SW =>\n" +
                        "            wb_isa_type(ISA_S_type) := '1';\n" +
                        "            wb_dec(Instr_SW) := '1';\n" +
                        "            wb_instr_out(24 downto 20) := \"01\" & wb_instr(4 downto 2);    -- rs2\n" +
                        "            wb_instr_out(19 downto 15) := \"01\" & wb_instr(9 downto 7);    -- rs1\n" +
                        "            wb_instr_out(11 downto 9) := wb_instr(11 downto 10) & wb_instr(6);\n" +
                        "            wb_instr_out(26 downto 25) := wb_instr(5) & wb_instr(12);\n" +
                        "        when OPCODE_C_BEQZ =>\n" +
                        "            wb_isa_type(ISA_SB_type) := '1';\n" +
                        "            wb_dec(Instr_BEQ) := '1';\n" +
                        "            wb_instr_out(19 downto 15) := \"01\" & wb_instr(9 downto 7);    -- rs1\n" +
                        "            wb_instr_out(11 downto 8) := wb_instr(11 downto 10) & wb_instr(4 downto 3);\n" +
                        "            wb_instr_out(27 downto 25) := wb_instr(6 downto 5) & wb_instr(2);\n" +
                        "            if wb_instr(12) = '1' then\n" +
                        "                wb_instr_out(30 downto 28) := (others => '1');\n" +
                        "                wb_instr_out(7) := '1';\n" +
                        "                wb_instr_out(31) := '1';\n" +
                        "            end if;\n" +
                        "        when OPCODE_C_SWSP =>\n" +
                        "            wb_isa_type(ISA_S_type) := '1';\n" +
                        "            wb_dec(Instr_SW) := '1';\n" +
                        "            wb_instr_out(24 downto 20) := wb_instr(6 downto 2);  -- rs2\n" +
                        "            wb_instr_out(19 downto 15) := \"00010\";             -- rs1 = sp\n" +
                        "            wb_instr_out(11 downto 9) := wb_instr(11 downto 9);\n" +
                        "            wb_instr_out(27 downto 25) := wb_instr(8 downto 7) & wb_instr(12);\n" +
                        "        when OPCODE_C_SD =>\n" +
                        "            wb_isa_type(ISA_S_type) := '1';\n" +
                        "            wb_dec(Instr_SD) := '1';\n" +
                        "            wb_instr_out(24 downto 20) := \"01\" & wb_instr(4 downto 2);  -- rs2\n" +
                        "            wb_instr_out(19 downto 15) := \"01\" & wb_instr(9 downto 7);  -- rs1\n" +
                        "            wb_instr_out(11 downto 10) := wb_instr(11 downto 10);\n" +
                        "            wb_instr_out(27 downto 25) := wb_instr(6 downto 5) & wb_instr(12);\n" +
                        "        when OPCODE_C_BNEZ =>\n" +
                        "            wb_isa_type(ISA_SB_type) := '1';\n" +
                        "            wb_dec(Instr_BNE) := '1';\n" +
                        "            wb_instr_out(19 downto 15) := \"01\" & wb_instr(9 downto 7);    -- rs1\n" +
                        "            wb_instr_out(11 downto 8) := wb_instr(11 downto 10) & wb_instr(4 downto 3);\n" +
                        "            wb_instr_out(27 downto 25) := wb_instr(6 downto 5) & wb_instr(2);\n" +
                        "            if wb_instr(12) = '1' then\n" +
                        "                wb_instr_out(30 downto 28) := (others => '1');\n" +
                        "                wb_instr_out(7) := '1';\n" +
                        "                wb_instr_out(31) := '1';\n" +
                        "            end if;\n" +
                        "        when OPCODE_C_SDSP =>\n" +
                        "            wb_isa_type(ISA_S_type) := '1';\n" +
                        "            wb_dec(Instr_SD) := '1';\n" +
                        "            wb_instr_out(24 downto 20) := wb_instr(6 downto 2);  -- rs2\n" +
                        "            wb_instr_out(19 downto 15) := \"00010\";               -- rs1 = sp\n" +
                        "            wb_instr_out(11 downto 10) := wb_instr(11 downto 10);\n" +
                        "            wb_instr_out(28 downto 25) := wb_instr(9 downto 7) & wb_instr(12);\n" +
                        "        when others =>\n" +
                        "            w_error := '1';\n" +
                        "        end case;\n" +
                        "    else -- compressed/!not compressed\n" +
                        "        case wb_opcode1 is\n" +
                        "        when OPCODE_ADD =>\n" +
                        "            wb_isa_type(ISA_R_type) := '1';\n" +
                        "            case wb_opcode2 is\n" +
                        "            when \"000\" =>\n" +
                        "                if wb_instr(31 downto 25) = \"0000000\" then\n" +
                        "                    wb_dec(Instr_ADD) := '1';\n" +
                        "                elsif wb_instr(31 downto 25) = \"0000001\" then\n" +
                        "                    wb_dec(Instr_MUL) := '1';\n" +
                        "                elsif wb_instr(31 downto 25) = \"0100000\" then\n" +
                        "                    wb_dec(Instr_SUB) := '1';\n" +
                        "                else\n" +
                        "                    w_error := '1';\n" +
                        "                end if;\n" +
                        "            when \"001\" =>\n" +
                        "                wb_dec(Instr_SLL) := '1';\n" +
                        "            when \"010\" =>\n" +
                        "                wb_dec(Instr_SLT) := '1';\n" +
                        "            when \"011\" =>\n" +
                        "                wb_dec(Instr_SLTU) := '1';\n" +
                        "            when \"100\" =>\n" +
                        "                if wb_instr(31 downto 25) = \"0000000\" then\n" +
                        "                    wb_dec(Instr_XOR) := '1';\n" +
                        "                elsif wb_instr(31 downto 25) = \"0000001\" then\n" +
                        "                    wb_dec(Instr_DIV) := '1';\n" +
                        "                else \n" +
                        "                    w_error := '1';\n" +
                        "                end if;\n" +
                        "            when \"101\" =>\n" +
                        "                if wb_instr(31 downto 25) = \"0000000\" then\n" +
                        "                    wb_dec(Instr_SRL) := '1';\n" +
                        "                elsif wb_instr(31 downto 25) = \"0000001\" then\n" +
                        "                    wb_dec(Instr_DIVU) := '1';\n" +
                        "                elsif wb_instr(31 downto 25) = \"0100000\" then\n" +
                        "                    wb_dec(Instr_SRA) := '1';\n" +
                        "                else\n" +
                        "                    w_error := '1';\n" +
                        "                end if;\n" +
                        "            when \"110\" =>\n" +
                        "                if wb_instr(31 downto 25) = \"0000000\" then\n" +
                        "                    wb_dec(Instr_OR) := '1';\n" +
                        "                elsif wb_instr(31 downto 25) = \"0000001\" then\n" +
                        "                    wb_dec(Instr_REM) := '1';\n" +
                        "                else\n" +
                        "                    w_error := '1';\n" +
                        "                end if;\n" +
                        "            when \"111\" =>\n" +
                        "                if wb_instr(31 downto 25) = \"0000000\" then\n" +
                        "                    wb_dec(Instr_AND) := '1';\n" +
                        "                elsif wb_instr(31 downto 25) = \"0000001\" then\n" +
                        "                    wb_dec(Instr_REMU) := '1';\n" +
                        "                else\n" +
                        "                    w_error := '1';\n" +
                        "                end if;\n" +
                        "            when others =>\n" +
                        "                w_error := '1';\n" +
                        "            end case;\n" +
                        "        when OPCODE_ADDI =>\n" +
                        "            wb_isa_type(ISA_I_type) := '1';\n" +
                        "            case wb_opcode2 is\n" +
                        "            when \"000\" =>\n" +
                        "                wb_dec(Instr_ADDI) := '1';\n" +
                        "            when \"001\" =>\n" +
                        "                wb_dec(Instr_SLLI) := '1';\n" +
                        "            when \"010\" =>\n" +
                        "                wb_dec(Instr_SLTI) := '1';\n" +
                        "            when \"011\" =>\n" +
                        "                wb_dec(Instr_SLTIU) := '1';\n" +
                        "            when \"100\" =>\n" +
                        "                wb_dec(Instr_XORI) := '1';\n" +
                        "            when \"101\" =>\n" +
                        "                if wb_instr(31 downto 26) = \"000000\" then\n" +
                        "                    wb_dec(Instr_SRLI) := '1';\n" +
                        "                elsif wb_instr(31 downto 26) = \"010000\" then\n" +
                        "                    wb_dec(Instr_SRAI) := '1';\n" +
                        "                else\n" +
                        "                    w_error := '1';\n" +
                        "                end if;\n" +
                        "            when \"110\" =>\n" +
                        "                wb_dec(Instr_ORI) := '1';\n" +
                        "            when \"111\" =>\n" +
                        "                wb_dec(Instr_ANDI) := '1';\n" +
                        "            when others =>\n" +
                        "                w_error := '1';\n" +
                        "            end case;\n" +
                        "        when OPCODE_ADDIW =>\n" +
                        "            wb_isa_type(ISA_I_type) := '1';\n" +
                        "            case wb_opcode2 is\n" +
                        "            when \"000\" =>\n" +
                        "                wb_dec(Instr_ADDIW) := '1';\n" +
                        "            when \"001\" =>\n" +
                        "                wb_dec(Instr_SLLIW) := '1';\n" +
                        "            when \"101\" =>\n" +
                        "                if wb_instr(31 downto 25) = \"0000000\" then\n" +
                        "                    wb_dec(Instr_SRLIW) := '1';\n" +
                        "                elsif wb_instr(31 downto 25) = \"0100000\" then\n" +
                        "                    wb_dec(Instr_SRAIW) := '1';\n" +
                        "                else\n" +
                        "                    w_error := '1';\n" +
                        "                end if;\n" +
                        "            when others =>\n" +
                        "                w_error := '1';\n" +
                        "            end case;\n" +
                        "        when OPCODE_ADDW =>\n" +
                        "            wb_isa_type(ISA_R_type) := '1';\n" +
                        "            case wb_opcode2 is\n" +
                        "            when \"000\" =>\n" +
                        "                if wb_instr(31 downto 25) = \"0000000\" then\n" +
                        "                    wb_dec(Instr_ADDW) := '1';\n" +
                        "                elsif wb_instr(31 downto 25) = \"0000001\" then\n" +
                        "                    wb_dec(Instr_MULW) := '1';\n" +
                        "                elsif wb_instr(31 downto 25) = \"0100000\" then\n" +
                        "                    wb_dec(Instr_SUBW) := '1';\n" +
                        "                else\n" +
                        "                    w_error := '1';\n" +
                        "                end if;\n" +
                        "            when \"001\" =>\n" +
                        "                wb_dec(Instr_SLLW) := '1';\n" +
                        "            when \"100\" =>\n" +
                        "                if wb_instr(31 downto 25) = \"0000001\" then\n" +
                        "                    wb_dec(Instr_DIVW) := '1';\n" +
                        "                else\n" +
                        "                    w_error := '1';\n" +
                        "                end if;\n" +
                        "            when \"101\" =>\n" +
                        "                if wb_instr(31 downto 25) = \"0000000\" then\n" +
                        "                    wb_dec(Instr_SRLW) := '1';\n" +
                        "                elsif wb_instr(31 downto 25) = \"0000001\" then\n" +
                        "                    wb_dec(Instr_DIVUW) := '1';\n" +
                        "                elsif wb_instr(31 downto 25) = \"0100000\" then\n" +
                        "                    wb_dec(Instr_SRAW) := '1';\n" +
                        "                else\n" +
                        "                    w_error := '1';\n" +
                        "                end if;\n" +
                        "            when \"110\" =>\n" +
                        "                if wb_instr(31 downto 25) = \"0000001\" then\n" +
                        "                    wb_dec(Instr_REMW) := '1';\n" +
                        "                else\n" +
                        "                    w_error := '1';\n" +
                        "                end if;\n" +
                        "            when \"111\" =>\n" +
                        "                if wb_instr(31 downto 25) = \"0000001\" then\n" +
                        "                    wb_dec(Instr_REMUW) := '1';\n" +
                        "                else\n" +
                        "                    w_error := '1';\n" +
                        "                end if;\n" +
                        "            when others =>\n" +
                        "                w_error := '1';\n" +
                        "            end case;\n" +
                        "        when OPCODE_AUIPC =>\n" +
                        "            wb_isa_type(ISA_U_type) := '1';\n" +
                        "            wb_dec(Instr_AUIPC) := '1';\n" +
                        "        when OPCODE_BEQ =>\n" +
                        "            wb_isa_type(ISA_SB_type) := '1';\n" +
                        "            case wb_opcode2 is\n" +
                        "            when \"000\" =>\n" +
                        "                wb_dec(Instr_BEQ) := '1';\n" +
                        "            when \"001\" =>\n" +
                        "                wb_dec(Instr_BNE) := '1';\n" +
                        "            when \"100\" =>\n" +
                        "                wb_dec(Instr_BLT) := '1';\n" +
                        "            when \"101\" =>\n" +
                        "                wb_dec(Instr_BGE) := '1';\n" +
                        "            when \"110\" =>\n" +
                        "                wb_dec(Instr_BLTU) := '1';\n" +
                        "            when \"111\" =>\n" +
                        "                wb_dec(Instr_BGEU) := '1';\n" +
                        "            when others =>\n" +
                        "                w_error := '1';\n" +
                        "            end case;\n" +
                        "        when OPCODE_JAL =>\n" +
                        "            wb_isa_type(ISA_UJ_type) := '1';\n" +
                        "            wb_dec(Instr_JAL) := '1';\n" +
                        "        when OPCODE_JALR =>\n" +
                        "            wb_isa_type(ISA_I_type) := '1';\n" +
                        "            case wb_opcode2 is\n" +
                        "            when \"000\" =>\n" +
                        "                wb_dec(Instr_JALR) := '1';\n" +
                        "            when others =>\n" +
                        "                w_error := '1';\n" +
                        "            end case;\n" +
                        "        when OPCODE_LB =>\n" +
                        "            wb_isa_type(ISA_I_type) := '1';\n" +
                        "            case wb_opcode2 is\n" +
                        "            when \"000\" =>\n" +
                        "                wb_dec(Instr_LB) := '1';\n" +
                        "            when \"001\" =>\n" +
                        "                wb_dec(Instr_LH) := '1';\n" +
                        "            when \"010\" =>\n" +
                        "                wb_dec(Instr_LW) := '1';\n" +
                        "            when \"011\" =>\n" +
                        "                wb_dec(Instr_LD) := '1';\n" +
                        "            when \"100\" =>\n" +
                        "                wb_dec(Instr_LBU) := '1';\n" +
                        "            when \"101\" =>\n" +
                        "                wb_dec(Instr_LHU) := '1';\n" +
                        "            when \"110\" =>\n" +
                        "                wb_dec(Instr_LWU) := '1';\n" +
                        "            when others =>\n" +
                        "                w_error := '1';\n" +
                        "            end case;\n" +
                        "        when OPCODE_LUI =>\n" +
                        "            wb_isa_type(ISA_U_type) := '1';\n" +
                        "            wb_dec(Instr_LUI) := '1';\n" +
                        "        when OPCODE_SB =>\n" +
                        "            wb_isa_type(ISA_S_type) := '1';\n" +
                        "            case wb_opcode2 is\n" +
                        "            when \"000\" =>\n" +
                        "                wb_dec(Instr_SB) := '1';\n" +
                        "            when \"001\" =>\n" +
                        "                wb_dec(Instr_SH) := '1';\n" +
                        "            when \"010\" =>\n" +
                        "                wb_dec(Instr_SW) := '1';\n" +
                        "            when \"011\" =>\n" +
                        "                wb_dec(Instr_SD) := '1';\n" +
                        "            when others =>\n" +
                        "                w_error := '1';\n" +
                        "            end case;\n" +
                        "        when OPCODE_CSRR =>\n" +
                        "            wb_isa_type(ISA_I_type) := '1';\n" +
                        "            case wb_opcode2 is\n" +
                        "            when \"000\" =>\n" +
                        "                if wb_instr = X\"00000073\" then\n" +
                        "                    wb_dec(Instr_ECALL) := '1';\n" +
                        "                elsif wb_instr = X\"00100073\" then\n" +
                        "                    wb_dec(Instr_EBREAK) := '1';\n" +
                        "                elsif wb_instr = X\"00200073\" then\n" +
                        "                    wb_dec(Instr_URET) := '1';\n" +
                        "                elsif wb_instr = X\"10200073\" then\n" +
                        "                    wb_dec(Instr_SRET) := '1';\n" +
                        "                elsif wb_instr = X\"20200073\" then\n" +
                        "                    wb_dec(Instr_HRET) := '1';\n" +
                        "                elsif wb_instr = X\"30200073\" then\n" +
                        "                    wb_dec(Instr_MRET) := '1';\n" +
                        "                else\n" +
                        "                    w_error := '1';\n" +
                        "                end if;\n" +
                        "            when \"001\" =>\n" +
                        "                wb_dec(Instr_CSRRW) := '1';\n" +
                        "            when \"010\" =>\n" +
                        "                wb_dec(Instr_CSRRS) := '1';\n" +
                        "            when \"011\" =>\n" +
                        "                wb_dec(Instr_CSRRC) := '1';\n" +
                        "            when \"101\" =>\n" +
                        "                wb_dec(Instr_CSRRWI) := '1';\n" +
                        "            when \"110\" =>\n" +
                        "                wb_dec(Instr_CSRRSI) := '1';\n" +
                        "            when \"111\" =>\n" +
                        "                wb_dec(Instr_CSRRCI) := '1';\n" +
                        "            when others =>\n" +
                        "                w_error := '1';\n" +
                        "            end case;\n" +
                        "        when OPCODE_FENCE =>\n" +
                        "            case wb_opcode2 is\n" +
                        "            when \"000\" =>\n" +
                        "                wb_dec(Instr_FENCE) := '1';\n" +
                        "            when \"001\" =>\n" +
                        "                wb_dec(Instr_FENCE_I) := '1';\n" +
                        "            when others =>\n" +
                        "                w_error := '1';\n" +
                        "            end case;\n" +
                        "\n" +
                        "        when others =>\n" +
                        "            if CFG_FPU_ENABLE then\n" +
                        "                case wb_opcode1 is\n" +
                        "                when OPCODE_FPU_LD =>\n" +
                        "                    wb_isa_type(ISA_I_type) := '1';\n" +
                        "                    if wb_opcode2 = \"011\" then\n" +
                        "                        wb_dec(Instr_FLD) := '1';\n" +
                        "                    else\n" +
                        "                        w_error := '1';\n" +
                        "                    end if;\n" +
                        "                when OPCODE_FPU_SD =>\n" +
                        "                    wb_isa_type(ISA_S_type) := '1';\n" +
                        "                    if wb_opcode2 = \"011\" then\n" +
                        "                        wb_dec(Instr_FSD) := '1';\n" +
                        "                    else\n" +
                        "                        w_error := '1';\n" +
                        "                    end if;\n" +
                        "                when OPCODE_FPU_OP =>\n" +
                        "                    wb_isa_type(ISA_R_type) := '1';\n" +
                        "                    case wb_instr(31 downto 25) is\n" +
                        "                    when \"0000001\" =>\n" +
                        "                        wb_dec(Instr_FADD_D) := '1';\n" +
                        "                    when \"0000101\" =>\n" +
                        "                        wb_dec(Instr_FSUB_D) := '1';\n" +
                        "                    when \"0001001\" =>\n" +
                        "                        wb_dec(Instr_FMUL_D) := '1';\n" +
                        "                    when \"0001101\" =>\n" +
                        "                        wb_dec(Instr_FDIV_D) := '1';\n" +
                        "                    when \"0010001\" =>\n" +
                        "                        if wb_opcode2 = \"000\" then\n" +
                        "                            wb_dec(Instr_FSGNJ_D) := '1';\n" +
                        "                        else\n" +
                        "                            w_error := '1';\n" +
                        "                        end if;\n" +
                        "                    when \"0010101\" =>\n" +
                        "                        if wb_opcode2 = \"000\" then\n" +
                        "                            wb_dec(Instr_FMIN_D) := '1';\n" +
                        "                        elsif wb_opcode2 = \"001\" then\n" +
                        "                            wb_dec(Instr_FMAX_D) := '1';\n" +
                        "                        else\n" +
                        "                            w_error := '1';\n" +
                        "                        end if;\n" +
                        "                    when \"0100000\" =>\n" +
                        "                        if wb_instr(24 downto 20) = \"00001\" then\n" +
                        "                            wb_dec(Instr_FCVT_S_D) := '1';\n" +
                        "                        else\n" +
                        "                            w_error := '1';\n" +
                        "                        end if;\n" +
                        "                    when \"0100001\" =>\n" +
                        "                        if wb_instr(24 downto 20) = \"00000\" then\n" +
                        "                            wb_dec(Instr_FCVT_D_S) := '1';\n" +
                        "                        else\n" +
                        "                            w_error := '1';\n" +
                        "                        end if;\n" +
                        "                    when \"1010001\" =>\n" +
                        "                        if wb_opcode2 = \"000\" then\n" +
                        "                            wb_dec(Instr_FLE_D) := '1';\n" +
                        "                        elsif wb_opcode2 = \"001\" then\n" +
                        "                            wb_dec(Instr_FLT_D) := '1';\n" +
                        "                        elsif wb_opcode2 = \"010\" then\n" +
                        "                            wb_dec(Instr_FEQ_D) := '1';\n" +
                        "                        else\n" +
                        "                            w_error := '1';\n" +
                        "                        end if;\n" +
                        "                    when \"1100001\" =>\n" +
                        "                        if wb_instr(24 downto 20) = \"00000\" then\n" +
                        "                            wb_dec(Instr_FCVT_W_D) := '1';\n" +
                        "                        elsif wb_instr(24 downto 20) = \"00001\" then\n" +
                        "                            wb_dec(Instr_FCVT_WU_D) := '1';\n" +
                        "                        elsif wb_instr(24 downto 20) = \"00010\" then\n" +
                        "                            wb_dec(Instr_FCVT_L_D) := '1';\n" +
                        "                        elsif wb_instr(24 downto 20) = \"00011\" then\n" +
                        "                            wb_dec(Instr_FCVT_LU_D) := '1';\n" +
                        "                        else\n" +
                        "                            w_error := '1';\n" +
                        "                        end if;\n" +
                        "                    when \"1101001\" =>\n" +
                        "                        if wb_instr(24 downto 20) = \"00000\" then\n" +
                        "                            wb_dec(Instr_FCVT_D_W) := '1';\n" +
                        "                        elsif wb_instr(24 downto 20) = \"00001\" then\n" +
                        "                            wb_dec(Instr_FCVT_D_WU) := '1';\n" +
                        "                        elsif wb_instr(24 downto 20) = \"00010\" then\n" +
                        "                            wb_dec(Instr_FCVT_D_L) := '1';\n" +
                        "                        elsif wb_instr(24 downto 20) = \"00011\" then\n" +
                        "                            wb_dec(Instr_FCVT_D_LU) := '1';\n" +
                        "                        else\n" +
                        "                            w_error := '1';\n" +
                        "                        end if;\n" +
                        "                    when \"1110001\" =>\n" +
                        "                        if wb_instr(24 downto 20) = \"00000\" and wb_opcode2 = \"000\" then\n" +
                        "                            wb_dec(Instr_FMOV_X_D) := '1';\n" +
                        "                        else\n" +
                        "                            w_error := '1';\n" +
                        "                        end if;\n" +
                        "						  when \"1110000\" =>\n" +
                        "                        if wb_instr(24 downto 20) = \"00000\" and wb_opcode2 = \"000\" then\n" +
                        "                            wb_dec(Instr_FMOV_X_W) := '1';\n" +
                        "                        else\n" +
                        "                            w_error := '1';\n" +
                        "                        end if;\n" +
                        "                    when \"1111001\" =>\n" +
                        "                        if wb_instr(24 downto 20) = \"00000\" and wb_opcode2 = \"000\" then\n" +
                        "                            wb_dec(Instr_FMOV_D_X) := '1';\n" +
                        "                        else\n" +
                        "                            w_error := '1';\n" +
                        "                        end if;\n" +
                        "                    when \"1111000\" =>\n" +
                        "                        if wb_instr(24 downto 20) = \"00000\" and wb_opcode2 = \"000\" then\n" +
                        "                            wb_dec(Instr_FMOV_W_X) := '1';\n" +
                        "                        else\n" +
                        "                            w_error := '1';\n" +
                        "                        end if;\n" +
                        "                    when others =>\n" +
                        "                        w_error := '1';\n" +
                        "                    end case;\n" +
                        "                when others =>\n" +
                        "                    w_error := '1';\n" +
                        "                end case;\n" +
                        "            else\n" +
                        "                w_error := '1';\n" +
                        "            end if;\n" +
                        "        end case;\n" +
                        "        wb_instr_out := wb_instr;\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    if i_f_valid = '1' then\n" +
                        "        v.valid := '1';\n" +
                        "        v.pc := i_f_pc;\n" +
                        "        v.instr := wb_instr_out;\n" +
                        "        v.compressed := w_compressed;\n" +
                        "        v.instr_load_fault := i_instr_load_fault;\n" +
                        "\n" +
                        "        v.isa_type := wb_isa_type;\n" +
                        "        v.instr_vec := wb_dec;\n" +
                        "        v.memop_store := wb_dec(Instr_SD) or wb_dec(Instr_SW) \n" +
                        "                      or wb_dec(Instr_SH) or wb_dec(Instr_SB)\n" +
                        "                      or wb_dec(Instr_FSD);\n" +
                        "        v.memop_load := wb_dec(Instr_LD) or wb_dec(Instr_LW)\n" +
                        "                or wb_dec(Instr_LH) or wb_dec(Instr_LB)\n" +
                        "                or wb_dec(Instr_LWU) or wb_dec(Instr_LHU) \n" +
                        "                or wb_dec(Instr_LBU) or wb_dec(Instr_FLD);\n" +
                        "        v.memop_sign_ext := wb_dec(Instr_LD) or wb_dec(Instr_LW)\n" +
                        "                or wb_dec(Instr_LH) or wb_dec(Instr_LB);\n" +
                        "        if (wb_dec(Instr_LD) or wb_dec(Instr_SD) or\n" +
                        "            wb_dec(Instr_FLD) or wb_dec(Instr_FSD)) = '1' then\n" +
                        "            v.memop_size := MEMOP_8B;\n" +
                        "        elsif (wb_dec(Instr_LW) or wb_dec(Instr_LWU) or wb_dec(Instr_SW)) = '1' then\n" +
                        "            v.memop_size := MEMOP_4B;\n" +
                        "        elsif (wb_dec(Instr_LH) or wb_dec(Instr_LHU) or wb_dec(Instr_SH)) = '1' then\n" +
                        "            v.memop_size := MEMOP_2B;\n" +
                        "        else\n" +
                        "            v.memop_size := MEMOP_1B;\n" +
                        "        end if;\n" +
                        "        v.unsigned_op := wb_dec(Instr_DIVU) or wb_dec(Instr_REMU) or\n" +
                        "                         wb_dec(Instr_DIVUW) or wb_dec(Instr_REMUW) or\n" +
                        "                         wb_dec(Instr_FCVT_WU_D) or\n" +
                        "                         wb_dec(Instr_FCVT_LU_D);\n" +
                        "\n" +
                        "        v.rv32 := wb_dec(Instr_ADDW) or wb_dec(Instr_ADDIW) \n" +
                        "            or wb_dec(Instr_SLLW) or wb_dec(Instr_SLLIW) or wb_dec(Instr_SRAW)\n" +
                        "            or wb_dec(Instr_SRAIW)\n" +
                        "            or wb_dec(Instr_SRLW) or wb_dec(Instr_SRLIW) or wb_dec(Instr_SUBW) \n" +
                        "            or wb_dec(Instr_DIVW) or wb_dec(Instr_DIVUW) or wb_dec(Instr_MULW)\n" +
                        "            or wb_dec(Instr_REMW) or wb_dec(Instr_REMUW);\n" +
                        "\n" +
                        "        v.f64 := wb_dec(Instr_FADD_D) or wb_dec(Instr_FSUB_D)\n" +
                        "            or wb_dec(Instr_FMUL_D) or wb_dec(Instr_FDIV_D)\n" +
                        "            or wb_dec(Instr_FMIN_D) or wb_dec(Instr_FMAX_D)\n" +
                        "            or wb_dec(Instr_FLE_D) or wb_dec(Instr_FLT_D)\n" +
                        "            or wb_dec(Instr_FEQ_D) or wb_dec(Instr_FCVT_W_D)\n" +
                        "            or wb_dec(Instr_FCVT_WU_D) or wb_dec(Instr_FCVT_L_D)\n" +
                        "            or wb_dec(Instr_FCVT_LU_D) or wb_dec(Instr_FMOV_X_D)\n" +
                        "            or wb_dec(Instr_FCVT_D_W) or wb_dec(Instr_FCVT_D_WU)\n" +
                        "            or wb_dec(Instr_FCVT_D_L) or wb_dec(Instr_FCVT_D_LU)\n" +
                        "            or wb_dec(Instr_FMOV_D_X) or wb_dec(Instr_FLD)\n" +
                        "            or wb_dec(Instr_FSD) or wb_dec(Instr_FSGNJ_D)\n" +
                        "            or wb_dec(Instr_FCVT_S_D) or wb_dec(Instr_FCVT_D_S)\n" +
                        "            or wb_dec(Instr_FMOV_W_X) or wb_dec(Instr_FMOV_X_W);\n" +
                        "        \n" +
                        "        v.instr_unimplemented := w_error;\n" +
                        "    elsif i_any_hold = '0' then\n" +
                        "        v.valid := '0';\n" +
                        "    end if;\n" +
                        "    w_o_valid := r.valid;\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    o_valid <= w_o_valid;\n" +
                        "    o_pc <= r.pc;\n" +
                        "    o_instr <= r.instr;\n" +
                        "    o_memop_load <= r.memop_load;\n" +
                        "    o_memop_store <= r.memop_store;\n" +
                        "    o_memop_sign_ext <= r.memop_sign_ext;\n" +
                        "    o_memop_size <= r.memop_size;\n" +
                        "    o_unsigned_op <= r.unsigned_op;\n" +
                        "    o_rv32 <= r.rv32;\n" +
                        "    o_f64 <= r.f64;\n" +
                        "    o_compressed <= r.compressed;\n" +
                        "    o_isa_type <= r.isa_type;\n" +
                        "    o_instr_vec <= r.instr_vec;\n" +
                        "    o_exception <= r.instr_unimplemented;\n" +
                        "    o_instr_load_fault <= r.instr_load_fault;\n" +
                        "    \n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(i_clk, i_nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_dbg_port_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use riverlib.river_cfg.all;\n" +
                        "\n" +
                        "\n" +
                        "entity DbgPort is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;                                     -- CPU clock\n" +
                        "    i_nrst : in std_logic;                                    -- Reset. Active LOW.\n" +
                        "    -- \"RIVER\" Debug interface\n" +
                        "    i_dport_valid : in std_logic;                             -- Debug access from DSU is valid\n" +
                        "    i_dport_write : in std_logic;                             -- Write command flag\n" +
                        "    i_dport_region : in std_logic_vector(1 downto 0);         -- Registers region ID: 0=CSR; 1=IREGS; 2=Control\n" +
                        "    i_dport_addr : in std_logic_vector(11 downto 0);          -- Register idx\n" +
                        "    i_dport_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0);-- Write value\n" +
                        "    o_dport_ready : out std_logic;                            -- Response is ready\n" +
                        "    o_dport_rdata : out std_logic_vector(RISCV_ARCH-1 downto 0);-- Response value\n" +
                        "    -- CPU debugging signals:\n" +
                        "    o_core_addr : out std_logic_vector(11 downto 0);          -- Address of the sub-region register\n" +
                        "    o_core_wdata : out std_logic_vector(RISCV_ARCH-1 downto 0);-- Write data\n" +
                        "    o_csr_ena : out std_logic;                                -- Region 0: Access to CSR bank is enabled.\n" +
                        "    o_csr_write : out std_logic;                              -- Region 0: CSR write enable\n" +
                        "    i_csr_rdata : in std_logic_vector(RISCV_ARCH-1 downto 0); -- Region 0: CSR read value\n" +
                        "    o_ireg_ena : out std_logic;                               -- Region 1: Access to integer register bank is enabled\n" +
                        "    o_ireg_write : out std_logic;                             -- Region 1: Integer registers bank write pulse\n" +
                        "    o_freg_ena : out std_logic;                               -- Region 1: Access to float register bank is enabled\n" +
                        "    o_freg_write : out std_logic;                             -- Region 1: Float registers bank write pulse\n" +
                        "    o_npc_write : out std_logic;                              -- Region 1: npc write enable\n" +
                        "    i_ireg_rdata : in std_logic_vector(RISCV_ARCH-1 downto 0);-- Region 1: Integer register read value\n" +
                        "    i_freg_rdata : in std_logic_vector(RISCV_ARCH-1 downto 0);-- Region 1: Float register read value\n" +
                        "    i_pc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);    -- Region 1: Instruction pointer\n" +
                        "    i_npc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);   -- Region 1: Next Instruction pointer\n" +
                        "    i_e_valid : in std_logic;                                 -- Stepping control signal\n" +
                        "    i_e_call : in std_logic;                                  -- pseudo-instruction CALL\n" +
                        "    i_e_ret : in std_logic;                                   -- pseudo-instruction RET\n" +
                        "    i_m_valid : in std_logic;                                 -- To compute number of valid executed instruction\n" +
                        "    o_clock_cnt : out std_logic_vector(63 downto 0);          -- Number of clocks excluding halt state\n" +
                        "    o_executed_cnt : out std_logic_vector(63 downto 0);       -- Number of executed instructions\n" +
                        "    o_halt : out std_logic;                                   -- Halt signal is equal to hold pipeline\n" +
                        "    i_ebreak : in std_logic;                                  -- ebreak instruction decoded\n" +
                        "    o_break_mode : out std_logic;                             -- Behaviour on EBREAK instruction: 0 = halt; 1 = generate trap\n" +
                        "    o_br_fetch_valid : out std_logic;                         -- Fetch injection address/instr are valid\n" +
                        "    o_br_address_fetch : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0); -- Fetch injection address to skip ebreak instruciton only once\n" +
                        "    o_br_instr_fetch : out std_logic_vector(31 downto 0);     -- Real instruction value that was replaced by ebreak\n" +
                        "    o_flush_address : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);  -- Address of instruction to remove from ICache\n" +
                        "    o_flush_valid : out std_logic;                            -- Remove address from ICache is valid\n" +
                        "    -- Debug signals:\n" +
                        "    i_istate : in std_logic_vector(1 downto 0);               -- ICache state machine value\n" +
                        "    i_dstate : in std_logic_vector(1 downto 0);               -- DCache state machine value\n" +
                        "    i_cstate : in std_logic_vector(1 downto 0)                -- CacheTop state machine value\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_DbgPort of DbgPort is\n" +
                        "\n" +
                        "  constant zero64 : std_logic_vector(63 downto 0) := (others => '0');\n" +
                        "  constant one64 : std_logic_vector(63 downto 0) := X\"0000000000000001\";\n" +
                        "  constant STACKTR_ADRSZ : integer := log2(CFG_STACK_TRACE_BUF_SIZE);\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "      ready : std_logic;\n" +
                        "      halt : std_logic;\n" +
                        "      breakpoint : std_logic;\n" +
                        "      stepping_mode : std_logic;\n" +
                        "      stepping_mode_cnt : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "      trap_on_break : std_logic;\n" +
                        "      br_address_fetch : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      br_instr_fetch : std_logic_vector(31 downto 0);\n" +
                        "      br_fetch_valid : std_logic;\n" +
                        "      flush_address : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      flush_valid : std_logic;\n" +
                        "\n" +
                        "      rdata : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "      stepping_mode_steps : std_logic_vector(RISCV_ARCH-1 downto 0); -- Number of steps before halt in stepping mode\n" +
                        "      clock_cnt : std_logic_vector(63 downto 0);               -- Timer in clocks.\n" +
                        "      executed_cnt : std_logic_vector(63 downto 0);            -- Number of valid executed instructions\n" +
                        "      stack_trace_cnt : integer range 0 to CFG_STACK_TRACE_BUF_SIZE-1; -- Stack trace buffer counter\n" +
                        "      rd_trbuf_ena : std_logic;\n" +
                        "      rd_trbuf_addr0 : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "    '0', '0', '0',                          -- ready, halt, breakpoint\n" +
                        "    '0', (others => '0'), '0',              -- stepping_mode. stepping_mode_cnt, trap_on_break\n" +
                        "    (others => '0'), (others => '0'), '0',  -- br_address_fetch, br_instr_fetch, br_fetch_valid\n" +
                        "    (others => '0'), '0',                   -- flush_address, flush_valid\n" +
                        "    (others => '0'), (others => '0'),       -- rdata, stepping_mode_steps\n" +
                        "    (others => '0'), (others => '0'),       -- clock_cnt, executed_cnt\n" +
                        "    0, '0', '0'                             -- stack_trace_cnt, rd_trbuf_ena, rd_trbuf_addr0\n" +
                        "  );\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "  signal wb_stack_raddr : std_logic_vector(STACKTR_ADRSZ-1 downto 0);\n" +
                        "  signal wb_stack_rdata : std_logic_vector(2*BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "  signal w_stack_we : std_logic;\n" +
                        "  signal wb_stack_waddr : std_logic_vector(STACKTR_ADRSZ-1 downto 0);\n" +
                        "  signal wb_stack_wdata : std_logic_vector(2*BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "\n" +
                        "  component StackTraceBuffer is\n" +
                        "  generic (\n" +
                        "    abits : integer := 5;\n" +
                        "    dbits : integer := 64\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk   : in std_logic;\n" +
                        "    i_raddr : in std_logic_vector(abits-1 downto 0);\n" +
                        "    o_rdata : out std_logic_vector(dbits-1 downto 0);\n" +
                        "    i_we    : in std_logic;\n" +
                        "    i_waddr : in std_logic_vector(abits-1 downto 0);\n" +
                        "    i_wdata : in std_logic_vector(dbits-1 downto 0)\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "\n" +
                        "  stacktr_ena : if CFG_STACK_TRACE_BUF_SIZE /= 0 generate \n" +
                        "    stacktr0 : StackTraceBuffer generic map (\n" +
                        "      abits => STACKTR_ADRSZ,\n" +
                        "      dbits => 2*BUS_ADDR_WIDTH\n" +
                        "    ) port map (\n" +
                        "      i_clk   => i_clk,\n" +
                        "      i_raddr => wb_stack_raddr,\n" +
                        "      o_rdata => wb_stack_rdata,\n" +
                        "      i_we    => w_stack_we,\n" +
                        "      i_waddr => wb_stack_waddr,\n" +
                        "      i_wdata => wb_stack_wdata\n" +
                        "    );\n" +
                        "  end generate;\n" +
                        "\n" +
                        "  comb : process(i_nrst, i_dport_valid, i_dport_write, i_dport_region, \n" +
                        "                 i_dport_addr, i_dport_wdata, i_ireg_rdata, i_freg_rdata,\n" +
                        "                 i_csr_rdata, i_pc, i_npc, i_e_valid, i_m_valid, i_ebreak, r,\n" +
                        "                 wb_stack_rdata, i_e_call, i_e_ret, i_istate, i_dstate,\n" +
                        "                 i_cstate)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable wb_o_core_addr : std_logic_vector(11 downto 0);\n" +
                        "    variable wb_o_core_wdata : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable wb_rdata : std_logic_vector(63 downto 0);\n" +
                        "    variable wb_o_rdata : std_logic_vector(63 downto 0);\n" +
                        "    variable wb_idx : integer range 0 to 4095;\n" +
                        "    variable w_o_csr_ena : std_logic;\n" +
                        "    variable w_o_csr_write : std_logic;\n" +
                        "    variable w_o_ireg_ena : std_logic;\n" +
                        "    variable w_o_ireg_write : std_logic;\n" +
                        "    variable w_o_freg_ena : std_logic;\n" +
                        "    variable w_o_freg_write : std_logic;\n" +
                        "    variable w_o_npc_write : std_logic;\n" +
                        "    variable w_cur_halt : std_logic;\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    wb_o_core_addr := (others => '0');\n" +
                        "    wb_o_core_wdata := (others => '0');\n" +
                        "    wb_rdata := (others => '0');\n" +
                        "    wb_o_rdata := (others => '0');\n" +
                        "    wb_idx := conv_integer(i_dport_addr);\n" +
                        "    w_o_csr_ena := '0';\n" +
                        "    w_o_csr_write := '0';\n" +
                        "    w_o_ireg_ena := '0';\n" +
                        "    w_o_ireg_write := '0';\n" +
                        "    w_o_freg_ena := '0';\n" +
                        "    w_o_freg_write := '0';\n" +
                        "    w_o_npc_write := '0';\n" +
                        "    v.br_fetch_valid := '0';\n" +
                        "    v.flush_valid := '0';\n" +
                        "    v.rd_trbuf_ena := '0';\n" +
                        "    wb_stack_raddr <= (others => '0');\n" +
                        "    w_stack_we <= '0';\n" +
                        "    wb_stack_waddr <= (others => '0');\n" +
                        "    wb_stack_wdata <= (others => '0');\n" +
                        "\n" +
                        "    v.ready := i_dport_valid;\n" +
                        "\n" +
                        "    w_cur_halt := '0';\n" +
                        "    if i_e_valid = '1' then\n" +
                        "        if r.stepping_mode_cnt /= zero64(RISCV_ARCH-1 downto 0) then\n" +
                        "            v.stepping_mode_cnt := r.stepping_mode_cnt - 1;\n" +
                        "            if r.stepping_mode_cnt = one64 then\n" +
                        "                v.halt := '1';\n" +
                        "                w_cur_halt := '1';\n" +
                        "                v.stepping_mode := '0';\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if r.halt = '0' then\n" +
                        "        v.clock_cnt := r.clock_cnt + 1;\n" +
                        "    end if;\n" +
                        "    if i_e_valid = '1' then\n" +
                        "        v.executed_cnt := r.executed_cnt + 1;\n" +
                        "    end if;\n" +
                        "    if i_ebreak = '1' then\n" +
                        "        v.breakpoint := '1';\n" +
                        "        if r.trap_on_break = '0' then\n" +
                        "            v.halt := '1';\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if CFG_STACK_TRACE_BUF_SIZE /= 0 then\n" +
                        "        if i_e_call = '1' and r.stack_trace_cnt /= (CFG_STACK_TRACE_BUF_SIZE - 1) then\n" +
                        "            w_stack_we <= '1';\n" +
                        "            wb_stack_waddr <= conv_std_logic_vector(r.stack_trace_cnt, STACKTR_ADRSZ);\n" +
                        "            wb_stack_wdata <= i_npc & i_pc;\n" +
                        "            v.stack_trace_cnt := r.stack_trace_cnt + 1;\n" +
                        "        elsif i_e_ret = '1' and r.stack_trace_cnt /= 0 then\n" +
                        "            v.stack_trace_cnt := r.stack_trace_cnt - 1;\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if i_dport_valid = '1' then\n" +
                        "        case i_dport_region is\n" +
                        "        when \"00\" =>\n" +
                        "            w_o_csr_ena := '1';\n" +
                        "            wb_o_core_addr := i_dport_addr;\n" +
                        "            wb_rdata := i_csr_rdata;\n" +
                        "            if i_dport_write = '1' then\n" +
                        "                w_o_csr_write := '1';\n" +
                        "                wb_o_core_wdata := i_dport_wdata;\n" +
                        "            end if;\n" +
                        "        when \"01\" =>\n" +
                        "            if wb_idx < 32 then\n" +
                        "                w_o_ireg_ena := '1';\n" +
                        "                wb_o_core_addr := i_dport_addr;\n" +
                        "                wb_rdata := i_ireg_rdata;\n" +
                        "                if i_dport_write = '1' then\n" +
                        "                    w_o_ireg_write := '1';\n" +
                        "                    wb_o_core_wdata := i_dport_wdata;\n" +
                        "                end if;\n" +
                        "            elsif wb_idx = 32 then\n" +
                        "                --! Read only register\n" +
                        "                wb_rdata(BUS_ADDR_WIDTH-1 downto 0) := i_pc;\n" +
                        "            elsif wb_idx = 33 then\n" +
                        "                wb_rdata(BUS_ADDR_WIDTH-1 downto 0) := i_npc;\n" +
                        "                if i_dport_write = '1' then\n" +
                        "                    w_o_npc_write := '1';\n" +
                        "                    wb_o_core_wdata := i_dport_wdata;\n" +
                        "                end if;\n" +
                        "            elsif wb_idx = 34 then\n" +
                        "                wb_rdata(STACKTR_ADRSZ-1 downto 0) := \n" +
                        "							conv_std_logic_vector(r.stack_trace_cnt, STACKTR_ADRSZ);\n" +
                        "                if i_dport_write = '1' then\n" +
                        "                    v.stack_trace_cnt := conv_integer(i_dport_wdata);\n" +
                        "                end if;\n" +
                        "            elsif (wb_idx >= 64) and (wb_idx < 96) then\n" +
                        "                w_o_freg_ena := '1';\n" +
                        "                wb_o_core_addr := i_dport_addr;\n" +
                        "                wb_rdata := i_freg_rdata;\n" +
                        "                if i_dport_write = '1' then\n" +
                        "                    w_o_freg_write := '1';\n" +
                        "                    wb_o_core_wdata := i_dport_wdata;\n" +
                        "                end if;\n" +
                        "            elsif (wb_idx >= 128) and (wb_idx < (128 + 2 * CFG_STACK_TRACE_BUF_SIZE)) then\n" +
                        "                    v.rd_trbuf_ena := '1';\n" +
                        "                    v.rd_trbuf_addr0 := conv_std_logic_vector(wb_idx, 1)(0);\n" +
                        "                    wb_stack_raddr <= conv_std_logic_vector((wb_idx - 128) / 2, STACKTR_ADRSZ);\n" +
                        "            end if;\n" +
                        "        when \"10\" =>\n" +
                        "            case wb_idx is\n" +
                        "            when 0 =>\n" +
                        "                wb_rdata(0) := r.halt;\n" +
                        "                wb_rdata(2) := r.breakpoint;\n" +
                        "                wb_rdata(33 downto 32) := i_istate;\n" +
                        "                wb_rdata(37 downto 36) := i_dstate;\n" +
                        "                wb_rdata(41 downto 40) := i_cstate;\n" +
                        "                if i_dport_write = '1' then\n" +
                        "                    v.halt := i_dport_wdata(0);\n" +
                        "                    v.stepping_mode := i_dport_wdata(1);\n" +
                        "                    if i_dport_wdata(1) = '1' then\n" +
                        "                        v.stepping_mode_cnt := r.stepping_mode_steps;\n" +
                        "                    end if;\n" +
                        "                end if;\n" +
                        "            when 1 =>\n" +
                        "                wb_rdata := r.stepping_mode_steps;\n" +
                        "                if i_dport_write = '1' then\n" +
                        "                    v.stepping_mode_steps := i_dport_wdata;\n" +
                        "                end if;\n" +
                        "            when 2 =>\n" +
                        "                wb_rdata := r.clock_cnt;\n" +
                        "            when 3 =>\n" +
                        "                wb_rdata := r.executed_cnt;\n" +
                        "            when 4 =>\n" +
                        "                --! Trap on instruction:\n" +
                        "                --!      0 = Halt pipeline on ECALL instruction\n" +
                        "                --!      1 = Generate trap on ECALL instruction\n" +
                        "                wb_rdata(0) := r.trap_on_break;\n" +
                        "                if i_dport_write = '1' then\n" +
                        "                    v.trap_on_break := i_dport_wdata(0);\n" +
                        "                end if;\n" +
                        "            when 5 =>\n" +
                        "                -- todo: add hardware breakpoint\n" +
                        "            when 6 =>\n" +
                        "                -- todo: remove hardware breakpoint\n" +
                        "            when 7 =>\n" +
                        "                wb_rdata(BUS_ADDR_WIDTH-1 downto 0) := r.br_address_fetch;\n" +
                        "                if i_dport_write = '1' then\n" +
                        "                    v.br_address_fetch := i_dport_wdata(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "                end if;\n" +
                        "            when 8 =>\n" +
                        "                wb_rdata(31 downto 0) := r.br_instr_fetch;\n" +
                        "                if i_dport_write = '1' then\n" +
                        "                    v.br_fetch_valid := '1';\n" +
                        "                    v.breakpoint := '0';\n" +
                        "                    v.br_instr_fetch := i_dport_wdata(31 downto 0);\n" +
                        "                end if;\n" +
                        "            when 9 =>\n" +
                        "                wb_rdata(BUS_ADDR_WIDTH-1 downto 0) := r.flush_address;\n" +
                        "                if i_dport_write = '1' then\n" +
                        "                    v.flush_valid := '1';\n" +
                        "                    v.flush_address := i_dport_wdata(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "                end if;\n" +
                        "            when others =>\n" +
                        "            end case;\n" +
                        "        when others =>\n" +
                        "        end case;\n" +
                        "    end if;\n" +
                        "    v.rdata := wb_rdata;\n" +
                        "    if r.rd_trbuf_ena = '1' then\n" +
                        "        if r.rd_trbuf_addr0 = '0' then\n" +
                        "            wb_o_rdata(BUS_ADDR_WIDTH-1 downto 0) :=\n" +
                        "					wb_stack_rdata(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "        else\n" +
                        "            wb_o_rdata(BUS_ADDR_WIDTH-1 downto 0) :=\n" +
                        "					wb_stack_rdata(2*BUS_ADDR_WIDTH-1 downto BUS_ADDR_WIDTH);\n" +
                        "        end if;\n" +
                        "    else\n" +
                        "        wb_o_rdata := r.rdata;\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    rin <= v;\n" +
                        "\n" +
                        "    o_core_addr <= wb_o_core_addr;\n" +
                        "    o_core_wdata <= wb_o_core_wdata;\n" +
                        "    o_csr_ena <= w_o_csr_ena;\n" +
                        "    o_csr_write <= w_o_csr_write;\n" +
                        "    o_ireg_ena <= w_o_ireg_ena;\n" +
                        "    o_ireg_write <= w_o_ireg_write;\n" +
                        "    o_freg_ena <= w_o_freg_ena;\n" +
                        "    o_freg_write <= w_o_freg_write;\n" +
                        "    o_npc_write <= w_o_npc_write;\n" +
                        "    o_clock_cnt <= r.clock_cnt;\n" +
                        "    o_executed_cnt <= r.executed_cnt;\n" +
                        "    o_halt <= r.halt or w_cur_halt;\n" +
                        "    o_break_mode <= r.trap_on_break;\n" +
                        "    o_br_fetch_valid <= r.br_fetch_valid;\n" +
                        "    o_br_address_fetch <= r.br_address_fetch;\n" +
                        "    o_br_instr_fetch <= r.br_instr_fetch;\n" +
                        "    o_flush_address <= r.flush_address;\n" +
                        "    o_flush_valid <= r.flush_valid;\n" +
                        "\n" +
                        "    o_dport_ready <= r.ready;\n" +
                        "    o_dport_rdata <= wb_o_rdata;\n" +
                        "  end process;\n" +
                        "\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(i_clk, i_nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_csr_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.std_logic_misc.all;  -- or_reduce()\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use riverlib.river_cfg.all;\n" +
                        "\n" +
                        "library target;\n" +
                        "use target.config_target.all;\n" +
                        "\n" +
                        "entity CsrRegs is \n" +
                        "  generic (\n" +
                        "    hartid : integer;\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;                                   -- CPU clock\n" +
                        "    i_nrst : in std_logic;                                  -- Reset. Active LOW.\n" +
                        "    i_mret : in std_logic;                                  -- mret instruction signals mode switching\n" +
                        "    i_uret : in std_logic;                                  -- uret instruction signals mode switching\n" +
                        "    i_sp : in std_logic_vector(RISCV_ARCH-1 downto 0);      -- Stack Pointer for the borders control\n" +
                        "    i_addr : in std_logic_vector(11 downto 0);              -- CSR address, if xret=1 switch mode accordingly\n" +
                        "    i_wena : in std_logic;                                  -- Write enable\n" +
                        "    i_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0);   -- CSR writing value\n" +
                        "    o_rdata : out std_logic_vector(RISCV_ARCH-1 downto 0);  -- CSR read value\n" +
                        "    i_trap_ready : in std_logic;                            -- Trap branch request was accepted\n" +
                        "    i_ex_pc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_ex_npc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_ex_data_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);-- Data path: address must be equal to the latest request address\n" +
                        "    i_ex_data_load_fault : in std_logic;                    -- Data path: Bus response with SLVERR or DECERR on read\n" +
                        "    i_ex_data_store_fault : in std_logic;                   -- Data path: Bus response with SLVERR or DECERR on write\n" +
                        "    i_ex_data_store_fault_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    i_ex_instr_load_fault : in std_logic;\n" +
                        "    i_ex_illegal_instr : in std_logic;\n" +
                        "    i_ex_unalign_store : in std_logic;\n" +
                        "    i_ex_unalign_load : in std_logic;\n" +
                        "    i_ex_breakpoint : in std_logic;\n" +
                        "    i_ex_ecall : in std_logic;\n" +
                        "    i_ex_fpu_invalidop : in std_logic;         -- FPU Exception: invalid operation\n" +
                        "    i_ex_fpu_divbyzero : in std_logic;         -- FPU Exception: divide by zero\n" +
                        "    i_ex_fpu_overflow : in std_logic;          -- FPU Exception: overflow\n" +
                        "    i_ex_fpu_underflow : in std_logic;         -- FPU Exception: underflow\n" +
                        "    i_ex_fpu_inexact : in std_logic;           -- FPU Exception: inexact\n" +
                        "    i_fpu_valid : in std_logic;                -- FPU output is valid\n" +
                        "    i_irq_external : in std_logic;\n" +
                        "    o_trap_valid : out std_logic;                              -- Trap pulse\n" +
                        "    o_trap_pc : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);-- trap on pc\n" +
                        "\n" +
                        "    i_break_mode : in std_logic;                            -- Behaviour on EBREAK instruction: 0 = halt; 1 = generate trap\n" +
                        "    o_break_event : out std_logic;                          -- 1 clock EBREAK detected\n" +
                        "\n" +
                        "    i_dport_ena : in std_logic;                              -- Debug port request is enabled\n" +
                        "    i_dport_write : in std_logic;                            -- Debug port Write enable\n" +
                        "    i_dport_addr : in std_logic_vector(11 downto 0);         -- Debug port CSR address\n" +
                        "    i_dport_wdata : in std_logic_vector(RISCV_ARCH-1 downto 0);-- Debug port CSR writing value\n" +
                        "    o_dport_rdata : out std_logic_vector(RISCV_ARCH-1 downto 0)-- Debug port CSR read value\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_CsrRegs of CsrRegs is\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "      mtvec : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "      mscratch : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "      mstackovr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      mstackund : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      mbadaddr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      mode : std_logic_vector(1 downto 0);\n" +
                        "      uie : std_logic;                       -- User level interrupts ena for current priv. mode\n" +
                        "      mie : std_logic;                       -- Machine level interrupts ena for current priv. mode\n" +
                        "      mpie : std_logic;                      -- Previous MIE value\n" +
                        "      mstackovr_ena : std_logic;             -- Stack Overflow control enabled\n" +
                        "      mstackund_ena : std_logic;             -- Stack Underflow control enabled\n" +
                        "      mpp : std_logic_vector(1 downto 0);    -- Previous mode\n" +
                        "      mepc : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "      ext_irq : std_logic;\n" +
                        "\n" +
                        "      ex_fpu_invalidop : std_logic;          -- FPU Exception: invalid operation\n" +
                        "      ex_fpu_divbyzero : std_logic;          -- FPU Exception: divide by zero\n" +
                        "      ex_fpu_overflow : std_logic;           -- FPU Exception: overflow\n" +
                        "      ex_fpu_underflow : std_logic;          -- FPU Exception: underflow\n" +
                        "      ex_fpu_inexact : std_logic;            -- FPU Exception: inexact\n" +
                        "      trap_irq : std_logic;\n" +
                        "      trap_code : std_logic_vector(4 downto 0);\n" +
                        "      trap_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      break_event : std_logic;\n" +
                        "      hold_data_store_fault : std_logic;\n" +
                        "      hold_data_load_fault : std_logic;\n" +
                        "      hold_mbadaddr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "        (others => '0'), -- mtvec\n" +
                        "        (others => '0'), -- mscratch\n" +
                        "        (others => '0'), -- mstackovr\n" +
                        "        (others => '0'), -- mstackund\n" +
                        "        (others => '0'), -- mbadaddr\n" +
                        "        PRV_M,           -- mode\n" +
                        "        '0', '0', '0',\n" +
                        "        '0',             -- mstackovr_ena\n" +
                        "        '0',             -- mstackund_ena\n" +
                        "        (others => '0'), (others => '0'), '0',\n" +
                        "        '0', '0', '0', '0', '0', \n" +
                        "        '0', (others => '0'), (others => '0'), '0',\n" +
                        "        '0', '0', (others => '0'));\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "  \n" +
                        "  procedure procedure_RegAccess(\n" +
                        "     iaddr  : in std_logic_vector(11 downto 0);\n" +
                        "     iwena  : in std_logic;\n" +
                        "     iwdata : in std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "     ir : in RegistersType;\n" +
                        "     ov : out RegistersType;\n" +
                        "     ordata : out std_logic_vector(RISCV_ARCH-1 downto 0)) is\n" +
                        "  begin\n" +
                        "    ov := ir;\n" +
                        "    ordata := (others => '0');\n" +
                        "    case iaddr is\n" +
                        "    when CSR_fflags =>\n" +
                        "        ordata(0) := ir.ex_fpu_inexact;\n" +
                        "        ordata(1) := ir.ex_fpu_underflow;\n" +
                        "        ordata(2) := ir.ex_fpu_overflow;\n" +
                        "        ordata(3) := ir.ex_fpu_divbyzero;\n" +
                        "        ordata(4) := ir.ex_fpu_invalidop;\n" +
                        "        if CFG_FPU_ENABLE then\n" +
                        "            if iwena = '1' then\n" +
                        "                ov.ex_fpu_inexact := iwdata(0);\n" +
                        "                ov.ex_fpu_underflow := iwdata(1);\n" +
                        "                ov.ex_fpu_overflow := iwdata(2);\n" +
                        "                ov.ex_fpu_divbyzero := iwdata(3);\n" +
                        "                ov.ex_fpu_invalidop := iwdata(4);\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    when CSR_frm =>\n" +
                        "        if CFG_FPU_ENABLE then\n" +
                        "            ordata(2 downto 0) := \"100\";  -- Round mode: round to Nearest (RMM)\n" +
                        "        end if;\n" +
                        "    when CSR_fcsr =>\n" +
                        "        ordata(0) := ir.ex_fpu_inexact;\n" +
                        "        ordata(1) := ir.ex_fpu_underflow;\n" +
                        "        ordata(2) := ir.ex_fpu_overflow;\n" +
                        "        ordata(3) := ir.ex_fpu_divbyzero;\n" +
                        "        ordata(4) := ir.ex_fpu_invalidop;\n" +
                        "        if CFG_FPU_ENABLE then\n" +
                        "            ordata(7 downto 5) := \"100\";  -- Round mode: round to Nearest (RMM)\n" +
                        "            if iwena = '1' then\n" +
                        "                ov.ex_fpu_inexact := iwdata(0);\n" +
                        "                ov.ex_fpu_underflow := iwdata(1);\n" +
                        "                ov.ex_fpu_overflow := iwdata(2);\n" +
                        "                ov.ex_fpu_divbyzero := iwdata(3);\n" +
                        "                ov.ex_fpu_invalidop := iwdata(4);\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    when CSR_misa =>\n" +
                        "        --! Base[XLEN-1:XLEN-2]\n" +
                        "        --!     1 = 32\n" +
                        "        --!     2 = 64\n" +
                        "        --!     3 = 128\n" +
                        "        --!\n" +
                        "        ordata(RISCV_ARCH-1 downto RISCV_ARCH-2) := \"10\";\n" +
                        "        --! BitCharacterDescription\n" +
                        "        --! 0  A Atomic extension\n" +
                        "        --! 1  B Tentatively reserved for Bit operations extension\n" +
                        "        --! 2  C Compressed extension\n" +
                        "        --! 3  D Double-precision Foating-point extension\n" +
                        "        --! 4  E RV32E base ISA (embedded)\n" +
                        "        --! 5  F Single-precision Foating-point extension\n" +
                        "        --! 6  G Additional standard extensions present\n" +
                        "        --! 7  H Hypervisor mode implemented\n" +
                        "        --! 8  I RV32I/64I/128I base ISA\n" +
                        "        --! 9  J Reserved\n" +
                        "        --! 10 K Reserved\n" +
                        "        --! 11 L Tentatively reserved for Decimal Floating-Point extension\n" +
                        "        --! 12 M Integer Multiply/Divide extension\n" +
                        "        --! 13 N User-level interrupts supported\n" +
                        "        --! 14 O Reserved\n" +
                        "        --! 15 P Tentatively reserved for Packed-SIMD extension\n" +
                        "        --! 16 Q Quad-precision Foating-point extension\n" +
                        "        --! 17 R Reserved\n" +
                        "        --! 18 S Supervisor mode implemented\n" +
                        "        --! 19 T Tentatively reserved for Transactional Memory extension\n" +
                        "        --! 20 U User mode implemented\n" +
                        "        --! 21 V Tentatively reserved for Vector extension\n" +
                        "        --! 22 W Reserved\n" +
                        "        --! 23 X Non-standard extensions present\n" +
                        "        --! 24 Y Reserved\n" +
                        "        --! 25 Z Reserve\n" +
                        "        --!\n" +
                        "        ordata(8) := '1';\n" +
                        "        ordata(12) := '1';\n" +
                        "        ordata(20) := '1';\n" +
                        "        ordata(2) := '1';\n" +
                        "        if CFG_FPU_ENABLE then\n" +
                        "            ordata(3) := '1';\n" +
                        "        end if;\n" +
                        "    when CSR_mvendorid =>\n" +
                        "        ordata(31 downto 0) := CFG_VENDOR_ID;\n" +
                        "    when CSR_marchid =>\n" +
                        "    when CSR_mimplementationid =>\n" +
                        "        ordata(31 downto 0) := CFG_IMPLEMENTATION_ID;\n" +
                        "    when CSR_mhartid =>\n" +
                        "        ordata(31 downto 0) := conv_std_logic_vector(hartid, 32);\n" +
                        "    when CSR_uepc =>    -- User mode program counter\n" +
                        "    when CSR_mstatus => -- Machine mode status register\n" +
                        "        ordata(0) := ir.uie;\n" +
                        "        ordata(3) := ir.mie;\n" +
                        "        ordata(7) := ir.mpie;\n" +
                        "        ordata(12 downto 11) := ir.mpp;\n" +
                        "        if CFG_FPU_ENABLE then\n" +
                        "            ordata(14 downto 13) := \"01\";  -- FS field: Initial state\n" +
                        "        end if;\n" +
                        "        ordata(33 downto 32) := \"10\";  -- UXL: User mode supported 64-bits\n" +
                        "        if iwena = '1' then\n" +
                        "            ov.uie := iwdata(0);\n" +
                        "            ov.mie := iwdata(3);\n" +
                        "            ov.mpie := iwdata(7);\n" +
                        "            ov.mpp := iwdata(12 downto 11);\n" +
                        "        end if;\n" +
                        "    when CSR_medeleg => -- Machine exception delegation\n" +
                        "    when CSR_mideleg => -- Machine interrupt delegation\n" +
                        "    when CSR_mie =>     -- Machine interrupt enable bit\n" +
                        "    when CSR_mtvec =>\n" +
                        "        ordata := ir.mtvec;\n" +
                        "        if iwena = '1' then\n" +
                        "            ov.mtvec := iwdata;\n" +
                        "        end if;\n" +
                        "    when CSR_mtimecmp => -- Machine wall-clock timer compare value\n" +
                        "    when CSR_mscratch => -- Machine scratch register\n" +
                        "        ordata := ir.mscratch;\n" +
                        "        if iwena = '1' then\n" +
                        "            ov.mscratch := iwdata;\n" +
                        "        end if;\n" +
                        "    when CSR_mepc => -- Machine program counter\n" +
                        "        ordata := ir.mepc;\n" +
                        "        if iwena = '1' then\n" +
                        "            ov.mepc := iwdata;\n" +
                        "        end if;\n" +
                        "    when CSR_mcause => -- Machine trap cause\n" +
                        "        ordata(63) := ir.trap_irq;\n" +
                        "        ordata(4 downto 0) := ir.trap_code;\n" +
                        "    when CSR_mbadaddr =>   -- Machine bad address\n" +
                        "        ordata(BUS_ADDR_WIDTH-1 downto 0) := ir.mbadaddr;\n" +
                        "    when CSR_mip =>        -- Machine interrupt pending\n" +
                        "    when CSR_mstackovr =>  -- Machine stack overflow\n" +
                        "        ordata(BUS_ADDR_WIDTH-1 downto 0) := ir.mstackovr;\n" +
                        "        if iwena = '1' then\n" +
                        "            ov.mstackovr := iwdata(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "            ov.mstackovr_ena := or_reduce(iwdata(BUS_ADDR_WIDTH-1 downto 0));\n" +
                        "        end if;\n" +
                        "    when CSR_mstackund =>  -- Machine stack underflow\n" +
                        "        ordata(BUS_ADDR_WIDTH-1 downto 0) := ir.mstackund;\n" +
                        "        if iwena = '1' then\n" +
                        "            ov.mstackund := iwdata(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "            ov.mstackund_ena := or_reduce(iwdata(BUS_ADDR_WIDTH-1 downto 0));\n" +
                        "        end if;\n" +
                        "    when others =>\n" +
                        "    end case;\n" +
                        "  end;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  comb : process(i_nrst, i_mret, i_uret, i_sp, i_addr, i_wena, i_wdata, i_trap_ready,\n" +
                        "                 i_ex_pc, i_ex_npc, i_ex_data_addr, i_ex_data_load_fault, i_ex_data_store_fault,\n" +
                        "                 i_ex_data_store_fault_addr,\n" +
                        "                 i_ex_instr_load_fault, i_ex_illegal_instr, i_ex_unalign_load, i_ex_unalign_store,\n" +
                        "                 i_ex_breakpoint, i_ex_ecall, \n" +
                        "                 i_ex_fpu_invalidop, i_ex_fpu_divbyzero, i_ex_fpu_overflow,\n" +
                        "                 i_ex_fpu_underflow, i_ex_fpu_inexact, i_fpu_valid, i_irq_external,\n" +
                        "                 i_break_mode, i_dport_ena, i_dport_write, i_dport_addr, i_dport_wdata,\n" +
                        "                 r)\n" +
                        "    variable tv1, tv2, v : RegistersType;\n" +
                        "    variable wb_rdata : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable wb_dport_rdata : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable w_ie : std_logic;\n" +
                        "    variable w_ext_irq : std_logic;\n" +
                        "    variable w_dport_wena : std_logic;\n" +
                        "    variable w_trap_valid : std_logic;\n" +
                        "    variable wb_trap_pc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable w_trap_irq : std_logic;\n" +
                        "    variable w_exception_xret : std_logic;\n" +
                        "    variable wb_trap_code : std_logic_vector(4 downto 0);\n" +
                        "    variable wb_mbadaddr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable w_mstackovr : std_logic;\n" +
                        "    variable w_mstackund : std_logic;\n" +
                        "  begin\n" +
                        "\n" +
                        "    tv1 := r;\n" +
                        "\n" +
                        "    w_dport_wena := i_dport_ena and i_dport_write;\n" +
                        "\n" +
                        "    procedure_RegAccess(i_addr, i_wena, i_wdata,\n" +
                        "                        tv1, tv2, wb_rdata);\n" +
                        "\n" +
                        "    procedure_RegAccess(i_dport_addr, w_dport_wena,\n" +
                        "                        i_dport_wdata, tv2, v, wb_dport_rdata);\n" +
                        "\n" +
                        "    w_ie := '0';\n" +
                        "    if (r.mode /= PRV_M) or r.mie = '1' then\n" +
                        "        w_ie := '1';\n" +
                        "    end if;\n" +
                        "    w_ext_irq := i_irq_external and w_ie;\n" +
                        "    if i_trap_ready = '1' then\n" +
                        "        v.ext_irq := w_ext_irq;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_exception_xret := '0';\n" +
                        "    if (i_mret = '1' and r.mode /= PRV_M) or\n" +
                        "        (i_uret = '1' and r.mode /= PRV_U) then\n" +
                        "        w_exception_xret := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_mstackovr := '0';\n" +
                        "    if i_sp(BUS_ADDR_WIDTH-1 downto 0) < r.mstackovr then\n" +
                        "        w_mstackovr := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_mstackund := '0';\n" +
                        "    if i_sp(BUS_ADDR_WIDTH-1 downto 0) > r.mstackund then\n" +
                        "        w_mstackund := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if i_fpu_valid = '1' then\n" +
                        "        v.ex_fpu_invalidop := i_ex_fpu_invalidop;\n" +
                        "        v.ex_fpu_divbyzero := i_ex_fpu_divbyzero;\n" +
                        "        v.ex_fpu_overflow := i_ex_fpu_overflow;\n" +
                        "        v.ex_fpu_underflow := i_ex_fpu_underflow;\n" +
                        "        v.ex_fpu_inexact := i_ex_fpu_inexact;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_trap_valid := '0';\n" +
                        "    w_trap_irq := '0';\n" +
                        "    wb_trap_code := (others => '0');\n" +
                        "    v.break_event := '0';\n" +
                        "    wb_trap_pc := r.mtvec(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    wb_mbadaddr := i_ex_pc;\n" +
                        "\n" +
                        "    if i_ex_instr_load_fault = '1' then\n" +
                        "        w_trap_valid := '1';\n" +
                        "        wb_trap_pc := CFG_NMI_INSTR_FAULT_ADDR;\n" +
                        "        wb_trap_code := EXCEPTION_InstrFault;\n" +
                        "        -- illegal address instruction can generate any other exceptions\n" +
                        "        v.hold_data_load_fault := '0';\n" +
                        "        v.hold_data_store_fault := '0';\n" +
                        "    elsif i_ex_illegal_instr = '1' or w_exception_xret = '1' then\n" +
                        "        w_trap_valid := '1';\n" +
                        "        wb_trap_pc := CFG_NMI_INSTR_ILLEGAL_ADDR;\n" +
                        "        wb_trap_code := EXCEPTION_InstrIllegal;\n" +
                        "        -- illegal instruction can generate any other exceptions\n" +
                        "        v.hold_data_load_fault := '0';\n" +
                        "        v.hold_data_store_fault := '0';\n" +
                        "    elsif i_ex_breakpoint = '1' then\n" +
                        "        v.break_event := '1';\n" +
                        "        w_trap_valid := '1';\n" +
                        "        wb_trap_code := EXCEPTION_Breakpoint;\n" +
                        "        if i_break_mode = '0' then\n" +
                        "            wb_trap_pc := i_ex_pc;\n" +
                        "        else\n" +
                        "            wb_trap_pc := CFG_NMI_BREAKPOINT_ADDR;\n" +
                        "        end if;\n" +
                        "    elsif i_ex_unalign_load = '1' then\n" +
                        "        w_trap_valid := '1';\n" +
                        "        wb_trap_pc := CFG_NMI_LOAD_UNALIGNED_ADDR;\n" +
                        "        wb_trap_code := EXCEPTION_LoadMisalign;\n" +
                        "    elsif i_ex_data_load_fault = '1' or r.hold_data_load_fault = '1' then\n" +
                        "        w_trap_valid := '1';\n" +
                        "        v.hold_data_load_fault := '0';\n" +
                        "        if i_trap_ready = '0' then\n" +
                        "            v.hold_data_load_fault := '1';\n" +
                        "        end if;\n" +
                        "        wb_trap_pc := CFG_NMI_LOAD_FAULT_ADDR;\n" +
                        "        if i_ex_data_load_fault = '1'  then\n" +
                        "            wb_mbadaddr := i_ex_data_addr;     -- miss-access read data address\n" +
                        "            v.hold_mbadaddr := i_ex_data_addr;\n" +
                        "        else\n" +
                        "            wb_mbadaddr := r.hold_mbadaddr;\n" +
                        "        end if;\n" +
                        "        wb_trap_code := EXCEPTION_LoadFault;\n" +
                        "    elsif i_ex_unalign_store = '1' then\n" +
                        "        w_trap_valid := '1';\n" +
                        "        wb_trap_pc := CFG_NMI_STORE_UNALIGNED_ADDR;\n" +
                        "        wb_trap_code := EXCEPTION_StoreMisalign;\n" +
                        "    elsif i_ex_data_store_fault = '1' or r.hold_data_store_fault = '1' then\n" +
                        "        w_trap_valid := '1';\n" +
                        "        v.hold_data_store_fault := '0';\n" +
                        "        if i_trap_ready = '0' then\n" +
                        "            v.hold_data_store_fault := '1';\n" +
                        "        end if;\n" +
                        "        wb_trap_pc := CFG_NMI_STORE_FAULT_ADDR;\n" +
                        "        if i_ex_data_store_fault = '1' then\n" +
                        "            wb_mbadaddr := i_ex_data_store_fault_addr;     -- miss-access write data address\n" +
                        "            v.hold_mbadaddr := i_ex_data_store_fault_addr;\n" +
                        "        else\n" +
                        "            wb_mbadaddr := r.hold_mbadaddr;\n" +
                        "        end if;\n" +
                        "        wb_trap_code := EXCEPTION_StoreFault;\n" +
                        "    elsif i_ex_ecall = '1' then\n" +
                        "        w_trap_valid := '1';\n" +
                        "        if r.mode = PRV_M then\n" +
                        "            wb_trap_pc := CFG_NMI_CALL_FROM_MMODE_ADDR;\n" +
                        "            wb_trap_code := EXCEPTION_CallFromMmode;\n" +
                        "        else\n" +
                        "            wb_trap_pc := CFG_NMI_CALL_FROM_UMODE_ADDR;\n" +
                        "            wb_trap_code := EXCEPTION_CallFromUmode;\n" +
                        "        end if;\n" +
                        "    elsif r.mstackovr_ena = '1' and w_mstackovr = '1' then\n" +
                        "        w_trap_valid := '1';\n" +
                        "        wb_trap_pc := CFG_NMI_STACK_OVERFLOW_ADDR;\n" +
                        "        wb_trap_code := EXCEPTION_StackOverflow;\n" +
                        "        if i_trap_ready = '1' then\n" +
                        "            v.mstackovr := (others => '0');\n" +
                        "            v.mstackovr_ena := '0';\n" +
                        "        end if;\n" +
                        "    elsif r.mstackund_ena = '1' and w_mstackund = '1' then\n" +
                        "        w_trap_valid := '1';\n" +
                        "        wb_trap_pc := CFG_NMI_STACK_UNDERFLOW_ADDR;\n" +
                        "        wb_trap_code := EXCEPTION_StackUnderflow;\n" +
                        "        if i_trap_ready = '1' then\n" +
                        "            v.mstackund := (others => '0');\n" +
                        "            v.mstackund_ena := '0';\n" +
                        "        end if;\n" +
                        "    elsif w_ext_irq = '1' and r.ext_irq = '0' then\n" +
                        "        w_trap_valid := '1';\n" +
                        "        wb_trap_pc := r.mtvec(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "        wb_trap_code := INTERRUPT_MExternal;\n" +
                        "        w_trap_irq := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if i_addr = CSR_mepc and (not w_exception_xret and (i_mret or i_uret)) = '1' then\n" +
                        "        -- Switch to previous mode\n" +
                        "        v.mie := r.mpie;\n" +
                        "        v.mpie := '1';\n" +
                        "        v.mode := r.mpp;\n" +
                        "        v.mpp := PRV_U;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Behaviour on EBREAK instruction defined by 'i_break_mode':\n" +
                        "    --     0 = halt;\n" +
                        "    --     1 = generate trap\n" +
                        "    if (w_trap_valid and i_trap_ready and (i_break_mode or not i_ex_breakpoint)) = '1' then\n" +
                        "        v.mie := '0';\n" +
                        "        v.mpp := r.mode;\n" +
                        "        v.mepc(RISCV_ARCH-1 downto BUS_ADDR_WIDTH) := (others => '0');\n" +
                        "        v.mepc(BUS_ADDR_WIDTH-1 downto 0) := i_ex_npc;\n" +
                        "        v.mbadaddr := wb_mbadaddr;\n" +
                        "        v.trap_code := wb_trap_code;\n" +
                        "        v.trap_irq := w_trap_irq;\n" +
                        "        v.mode := PRV_M;\n" +
                        "        case r.mode is\n" +
                        "        when PRV_U =>\n" +
                        "            v.mpie := r.uie;\n" +
                        "        when PRV_M =>\n" +
                        "            v.mpie := r.mie;\n" +
                        "        when others =>\n" +
                        "        end case;\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    o_trap_valid <= w_trap_valid;\n" +
                        "    o_trap_pc <= wb_trap_pc;\n" +
                        "    o_rdata <= wb_rdata;\n" +
                        "    o_dport_rdata <= wb_dport_rdata;\n" +
                        "    o_break_event <= r.break_event;\n" +
                        "    \n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(i_clk, i_nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_bp_predic_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use riverlib.river_cfg.all;\n" +
                        "\n" +
                        "\n" +
                        "entity BranchPredictor is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk : in std_logic;                              -- CPU clock\n" +
                        "    i_nrst : in std_logic;                             -- Reset. Active LOW.\n" +
                        "    i_req_mem_fire : in std_logic;                     -- Memory request was accepted\n" +
                        "    i_resp_mem_valid : in std_logic;                   -- Memory response from ICache is valid\n" +
                        "    i_resp_mem_addr : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);-- Memory response address\n" +
                        "    i_resp_mem_data : in std_logic_vector(31 downto 0);-- Memory response value\n" +
                        "    i_e_npc : in std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);  -- Valid instruction value awaited by 'Executor'\n" +
                        "    i_ra : in std_logic_vector(RISCV_ARCH-1 downto 0); -- Return address register value\n" +
                        "    o_npc_predict : out std_logic_vector(BUS_ADDR_WIDTH-1 downto 0)  -- Predicted next instruction address\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_BranchPredictor of BranchPredictor is\n" +
                        "\n" +
                        "  type HistoryType is record\n" +
                        "      resp_pc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "      resp_npc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "  end record;\n" +
                        "  constant history_none : HistoryType := (\n" +
                        "    (others => '1'), (others => '1')\n" +
                        "  );\n" +
                        "\n" +
                        "  type HistoryVector is array (0 to 2) of HistoryType;\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "      h : HistoryVector;\n" +
                        "      wait_resp : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "      (others => history_none), '0'\n" +
                        "  );\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  comb : process(i_nrst, i_req_mem_fire, i_resp_mem_valid, i_resp_mem_addr,\n" +
                        "                 i_resp_mem_data, i_e_npc, i_ra, r)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable vb_tmp : std_logic_vector(31 downto 0);\n" +
                        "    variable vb_npc_predicted : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable vb_pc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable vb_npc : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable v_jal : std_logic;\n" +
                        "    variable vb_jal_off : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable vb_jal_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable v_branch : std_logic;\n" +
                        "    variable vb_branch_off : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable vb_branch_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable v_c_j : std_logic;\n" +
                        "    variable vb_c_j_off : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable vb_c_j_addr : std_logic_vector(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    variable v_c_ret : std_logic;\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    vb_pc := r.h(0).resp_pc;\n" +
                        "    vb_tmp := i_resp_mem_data;\n" +
                        " \n" +
                        "    -- Unconditional jump \"J\"\n" +
                        "    vb_jal_off(BUS_ADDR_WIDTH-1 downto 20) := (others => vb_tmp(31));\n" +
                        "    vb_jal_off(19 downto 12) := vb_tmp(19 downto 12);\n" +
                        "    vb_jal_off(11) := vb_tmp(20);\n" +
                        "    vb_jal_off(10 downto 1) := vb_tmp(30 downto 21);\n" +
                        "    vb_jal_off(0) := '0';\n" +
                        "    vb_jal_addr := vb_pc + vb_jal_off;\n" +
                        "\n" +
                        "    v_jal := '0';\n" +
                        "    if vb_tmp(6 downto 0) = \"1101111\" then\n" +
                        "        if (vb_jal_addr /= r.h(1).resp_pc) and (vb_jal_addr /= r.h(2).resp_pc) then\n" +
                        "            v_jal := '1';\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Conditional branches \"BEQ\", \"BNE\", \"BLT\", \"BGE\", BLTU\", \"BGEU\"\n" +
                        "    -- Only negative offset leads to predicted jumps\n" +
                        "    if vb_tmp(31) = '1' then\n" +
                        "        vb_branch_off(BUS_ADDR_WIDTH-1 downto 12) := (others => '1');\n" +
                        "    else\n" +
                        "        vb_branch_off(BUS_ADDR_WIDTH-1 downto 12) := (others => '0');\n" +
                        "    end if;\n" +
                        "    vb_branch_off(11) := vb_tmp(7);\n" +
                        "    vb_branch_off(10 downto 5) := vb_tmp(30 downto 25);\n" +
                        "    vb_branch_off(4 downto 1) := vb_tmp(11 downto 8);\n" +
                        "    vb_branch_off(0) := '0';\n" +
                        "    vb_branch_addr := vb_pc + vb_branch_off;\n" +
                        "\n" +
                        "    v_branch := '0';\n" +
                        "    if (vb_tmp(6 downto 0) = \"1100011\") and (vb_tmp(31) = '1') then\n" +
                        "        if (vb_branch_addr /= r.h(1).resp_pc)\n" +
                        "            and (vb_branch_addr /= r.h(2).resp_pc) then\n" +
                        "            v_branch := '1';\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Check Compressed \"C_J\" unconditional jump\n" +
                        "    if vb_tmp(12) = '1' then\n" +
                        "        vb_c_j_off(BUS_ADDR_WIDTH-1 downto 11) := (others => '1');\n" +
                        "    else\n" +
                        "        vb_c_j_off(BUS_ADDR_WIDTH-1 downto 11) := (others => '0');\n" +
                        "    end if;\n" +
                        "    vb_c_j_off(10) := vb_tmp(8);\n" +
                        "    vb_c_j_off(9 downto 8) := vb_tmp(10 downto 9);\n" +
                        "    vb_c_j_off(7) := vb_tmp(6);\n" +
                        "    vb_c_j_off(6) := vb_tmp(7);\n" +
                        "    vb_c_j_off(5) := vb_tmp(2);\n" +
                        "    vb_c_j_off(4) := vb_tmp(11);\n" +
                        "    vb_c_j_off(3 downto 1) := vb_tmp(5 downto 3);\n" +
                        "    vb_c_j_off(0) := '0';\n" +
                        "    vb_c_j_addr := vb_pc + vb_c_j_off;\n" +
                        "\n" +
                        "    v_c_j := '0';\n" +
                        "    if (vb_tmp(15 downto 13) = \"101\") and (vb_tmp(1 downto 0) = \"01\") then\n" +
                        "        if (vb_c_j_addr /= r.h(1).resp_pc) and (vb_c_j_addr /= r.h(2).resp_pc) then\n" +
                        "            v_c_j := '1';\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Compressed RET pseudo-instruction\n" +
                        "    v_c_ret := '0';\n" +
                        "    if vb_tmp(15 downto 0) = X\"8082\" then\n" +
                        "        v_c_ret := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if v_jal = '1' then\n" +
                        "        vb_npc_predicted := vb_jal_addr;\n" +
                        "    elsif v_branch = '1' then\n" +
                        "        vb_npc_predicted := vb_branch_addr;\n" +
                        "    elsif v_c_j = '1' then\n" +
                        "        vb_npc_predicted := vb_c_j_addr;\n" +
                        "    elsif v_c_ret = '1' then\n" +
                        "        vb_npc_predicted := i_ra(BUS_ADDR_WIDTH-1 downto 0);\n" +
                        "    elsif vb_tmp(1 downto 0) = \"11\" then\n" +
                        "        vb_npc_predicted := r.h(0).resp_pc + 4;\n" +
                        "    else\n" +
                        "        vb_npc_predicted := r.h(0).resp_pc + 2;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if i_e_npc = r.h(2).resp_pc then\n" +
                        "        if r.h(2).resp_npc = r.h(1).resp_pc then\n" +
                        "            if r.h(1).resp_npc = r.h(0).resp_pc then\n" +
                        "                vb_npc := vb_npc_predicted;\n" +
                        "            else\n" +
                        "                vb_npc := r.h(1).resp_npc;\n" +
                        "            end if;\n" +
                        "        elsif r.h(2).resp_npc = r.h(0).resp_pc then\n" +
                        "            vb_npc := vb_npc_predicted;\n" +
                        "        else\n" +
                        "            vb_npc := r.h(2).resp_npc;\n" +
                        "        end if;\n" +
                        "    elsif i_e_npc = r.h(1).resp_pc then\n" +
                        "        if r.h(1).resp_npc = r.h(0).resp_pc then\n" +
                        "            vb_npc := vb_npc_predicted;\n" +
                        "        else\n" +
                        "            vb_npc := r.h(1).resp_npc;\n" +
                        "        end if;\n" +
                        "    elsif i_e_npc = r.h(0).resp_pc then\n" +
                        "        vb_npc := vb_npc_predicted;\n" +
                        "    else\n" +
                        "        vb_npc := i_e_npc;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if i_req_mem_fire = '1' and r.wait_resp = '0' then\n" +
                        "        v.wait_resp := '1';\n" +
                        "        v.h(0).resp_pc := vb_npc;\n" +
                        "        v.h(0).resp_npc := (others => '1');\n" +
                        "        v.h(1) := r.h(0);\n" +
                        "        v.h(2) := r.h(1);\n" +
                        "    elsif i_req_mem_fire = '1' and i_resp_mem_valid = '1' then\n" +
                        "        v.wait_resp := '1';\n" +
                        "        v.h(0).resp_pc := vb_npc;\n" +
                        "        v.h(0).resp_npc := (others => '1');\n" +
                        "        v.h(1) := r.h(0);\n" +
                        "        v.h(1).resp_npc := vb_npc;\n" +
                        "        v.h(2) := r.h(1);\n" +
                        "    elsif i_resp_mem_valid = '1' and r.wait_resp = '1' then\n" +
                        "        v.wait_resp := '0';\n" +
                        "        v.h(0).resp_npc := vb_npc;\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    o_npc_predict <= vb_npc;\n" +
                        "    \n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(i_clk, i_nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_l2d_d_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "\n" +
                        "entity Long2Double is \n" +
                        "  generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_nrst       : in std_logic;\n" +
                        "    i_clk        : in std_logic;\n" +
                        "    i_ena        : in std_logic;\n" +
                        "    i_signed     : in std_logic;\n" +
                        "    i_w32        : in std_logic;\n" +
                        "    i_a          : in std_logic_vector(63 downto 0);\n" +
                        "    o_res        : out std_logic_vector(63 downto 0);\n" +
                        "    o_valid      : out std_logic;\n" +
                        "    o_busy       : out std_logic\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_Long2Double of Long2Double is\n" +
                        " \n" +
                        "  constant zero64 : std_logic_vector(63 downto 0) := (others => '0');\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "    busy : std_logic;\n" +
                        "    ena : std_logic_vector(2 downto 0);\n" +
                        "    signA : std_logic;\n" +
                        "    absA : std_logic_vector(63 downto 0);\n" +
                        "    result : std_logic_vector(63 downto 0);\n" +
                        "    op_signed : std_logic;\n" +
                        "    mantAlign : std_logic_vector(63 downto 0);\n" +
                        "    lshift : integer range 0 to 63;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "    '0', (others => '0'),                      -- busy, ena\n" +
                        "    '0', (others => '0'), (others => '0'),     -- signA, absA, result\n" +
                        "    '0', (others => '0'), 0                    -- op_signed, mantAlign, lshift\n" +
                        "  );\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  comb : process(i_nrst, i_ena, i_signed, i_w32, i_a, r)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable mantAlign : std_logic_vector(63 downto 0);\n" +
                        "    variable lshift : integer range 0 to 63;\n" +
                        "    variable expAlign : std_logic_vector(10 downto 0);\n" +
                        "    variable mantEven : std_logic;\n" +
                        "    variable mant05 : std_logic;\n" +
                        "    variable mantOnes : std_logic;\n" +
                        "    variable rndBit : std_logic;\n" +
                        "    variable v_signA : std_logic;\n" +
                        "    variable vb_A : std_logic_vector(63 downto 0);\n" +
                        "    variable res : std_logic_vector(63 downto 0);\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    v.ena := r.ena(1 downto 0) & (i_ena and not r.busy);\n" +
                        "    if i_w32 = '0' then\n" +
                        "        v_signA := i_a(63);\n" +
                        "        vb_A := i_a;\n" +
                        "    elsif i_signed = '1' and i_a(31) = '1' then\n" +
                        "        v_signA := '1';\n" +
                        "        vb_A(63 downto 32) := (others => '1');\n" +
                        "        vb_A(31 downto 0) := i_a(31 downto 0);\n" +
                        "    else\n" +
                        "        v_signA := '0';\n" +
                        "        vb_A(31 downto 0) := i_a(31 downto 0);\n" +
                        "        vb_A(63 downto 32) := (others => '0');\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if i_ena = '1' then\n" +
                        "        v.busy := '1';\n" +
                        "        if i_signed = '1' and v_signA = '1' then\n" +
                        "            v.signA := '1';\n" +
                        "            v.absA := not vb_A + 1;\n" +
                        "        else\n" +
                        "            v.signA := '0';\n" +
                        "            v.absA := vb_A;\n" +
                        "        end if;\n" +
                        "        v.op_signed := i_signed;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- multiplexer, probably if/elsif in rtl:\n" +
                        "    mantAlign := (others => '0');\n" +
                        "    lshift := 63;\n" +
                        "    if r.absA(63) = '1' then\n" +
                        "        mantAlign := r.absA;\n" +
                        "    else\n" +
                        "        for i in 1 to 63 loop\n" +
                        "            if lshift = 63 and r.absA(63 - i) = '1' then\n" +
                        "                mantAlign := r.absA(63-i downto 0) & zero64(i-1 downto 0);\n" +
                        "                lshift := i;\n" +
                        "            end if;\n" +
                        "        end loop;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if r.ena(0) = '1' then\n" +
                        "        v.mantAlign := mantAlign;\n" +
                        "        v.lshift := lshift;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if r.absA = zero64 then\n" +
                        "        expAlign := (others => '0');\n" +
                        "    else\n" +
                        "        expAlign := conv_std_logic_vector(1086 - r.lshift, 11);\n" +
                        "    end if;\n" +
                        "\n" +
                        "    mantEven := r.mantAlign(11);\n" +
                        "    mant05 := '0';\n" +
                        "    if r.mantAlign(10 downto 0) = \"11111111111\" then\n" +
                        "        mant05 := '1';\n" +
                        "    end if;\n" +
                        "    rndBit := r.mantAlign(10) and not(mant05 and mantEven);\n" +
                        "    mantOnes := '0';\n" +
                        "    if r.mantAlign(63) = '1' and r.mantAlign(62 downto 11) = X\"fffffffffffff\" then\n" +
                        "        mantOnes := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Result multiplexers:\n" +
                        "    res(63) := r.signA and r.op_signed;\n" +
                        "    res(62 downto 52) := expAlign + (\"0000000000\" & (mantOnes and rndBit));\n" +
                        "    res(51 downto 0) := r.mantAlign(62 downto 11) + rndBit;\n" +
                        "\n" +
                        "    if r.ena(1) = '1' then\n" +
                        "        v.result := res;\n" +
                        "        v.busy := '0';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  o_res <= r.result;\n" +
                        "  o_valid <= r.ena(2);\n" +
                        "  o_busy <= r.busy;\n" +
                        "  \n" +
                        "  -- registers:\n" +
                        "  regs : process(i_nrst, i_clk)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
                                new GeneralFunctions().write_file(Project_Folder_File, data);
                            }

    private void generate_idiv53_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "\n" +
                        "entity idiv53 is \n" +
                        "  generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_nrst       : in std_logic;\n" +
                        "    i_clk        : in std_logic;\n" +
                        "    i_ena        : in std_logic;\n" +
                        "    i_divident   : in std_logic_vector(52 downto 0);\n" +
                        "    i_divisor    : in std_logic_vector(52 downto 0);\n" +
                        "    o_result     : out std_logic_vector(104 downto 0);\n" +
                        "    o_lshift     : out std_logic_vector(6 downto 0);\n" +
                        "    o_rdy        : out std_logic;\n" +
                        "    o_overflow   : out std_logic;\n" +
                        "    o_zero_resid : out std_logic\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_idiv53 of idiv53 is\n" +
                        "\n" +
                        "  constant zero53 : std_logic_vector(52 downto 0) := (others => '0');\n" +
                        "\n" +
                        "  component divstage53 is \n" +
                        "  port (\n" +
                        "    i_mux_ena    : in std_logic;  -- find first non-zero bit\n" +
                        "    i_muxind     : in std_logic_vector(55 downto 0);  -- bits indexes 8x7 bits bus\n" +
                        "    i_divident   : in std_logic_vector(60 downto 0);  -- integer value\n" +
                        "    i_divisor    : in std_logic_vector(52 downto 0);  -- integer value\n" +
                        "    o_dif        : out std_logic_vector(52 downto 0); -- residual value\n" +
                        "    o_bits       : out std_logic_vector(7 downto 0);  -- resulting bits\n" +
                        "    o_muxind     : out std_logic_vector(6 downto 0);  -- first found non-zero bit\n" +
                        "    o_muxind_rdy : out std_logic                      -- seeking was successfull\n" +
                        "  );\n" +
                        "  end component; \n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "    delay : std_logic_vector(14 downto 0);\n" +
                        "    lshift : std_logic_vector(6 downto 0);\n" +
                        "    lshift_rdy : std_logic;\n" +
                        "    divisor : std_logic_vector(52 downto 0);\n" +
                        "    divident : std_logic_vector(60 downto 0);\n" +
                        "    bits : std_logic_vector(104 downto 0);\n" +
                        "    overflow : std_logic;\n" +
                        "    zero_resid : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "    (others => '0'), (others => '0'), '0',\n" +
                        "    (others => '0'), (others => '0'), (others => '0'),\n" +
                        "    '0', '0');\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "  signal w_mux_ena_i : std_logic;\n" +
                        "  signal wb_muxind_i : std_logic_vector(55 downto 0);\n" +
                        "  signal wb_divident_i : std_logic_vector(60 downto 0);\n" +
                        "  signal wb_divisor_i : std_logic_vector(52 downto 0);\n" +
                        "  signal wb_dif_o : std_logic_vector(52 downto 0);\n" +
                        "  signal wb_bits_o : std_logic_vector(7 downto 0);\n" +
                        "  signal wb_muxind_o : std_logic_vector(6 downto 0);\n" +
                        "  signal w_muxind_rdy_o : std_logic;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  divstage0 : divstage53 port map (\n" +
                        "    i_mux_ena => w_mux_ena_i,\n" +
                        "    i_muxind => wb_muxind_i,\n" +
                        "    i_divident => wb_divident_i,\n" +
                        "    i_divisor => wb_divisor_i,\n" +
                        "    o_dif => wb_dif_o,\n" +
                        "    o_bits => wb_bits_o,\n" +
                        "    o_muxind => wb_muxind_o,\n" +
                        "    o_muxind_rdy => w_muxind_rdy_o\n" +
                        "  );\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  comb : process(i_nrst, i_ena, i_divident, i_divisor, r,\n" +
                        "                 wb_dif_o, wb_bits_o, wb_muxind_o, w_muxind_rdy_o)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable vb_muxind : std_logic_vector(55 downto 0);\n" +
                        "    variable vb_bits : std_logic_vector(104 downto 0);\n" +
                        "    variable v_mux_ena_i : std_logic;\n" +
                        "  begin\n" +
                        "    v := r;\n" +
                        "    vb_bits := r.bits;\n" +
                        "\n" +
                        "    v_mux_ena_i := '0';\n" +
                        "    v.delay := r.delay(13 downto 0) & i_ena;\n" +
                        "    vb_muxind := (others => '0');\n" +
                        "    if i_ena = '1' then\n" +
                        "        v.divident := X\"00\" & i_divident;\n" +
                        "        v.divisor := i_divisor;\n" +
                        "        v.lshift_rdy := '0';\n" +
                        "        v.overflow := '0';\n" +
                        "        v.zero_resid := '0';\n" +
                        "    elsif r.delay(0) = '1' then\n" +
                        "        v_mux_ena_i := not r.lshift_rdy;\n" +
                        "        v.divident := wb_dif_o & X\"00\";\n" +
                        "        vb_bits(104) := not wb_dif_o(52);\n" +
                        "    elsif r.delay(1) = '1' then\n" +
                        "        v_mux_ena_i := not r.lshift_rdy;\n" +
                        "        v.divident := wb_dif_o & X\"00\";\n" +
                        "        vb_muxind(55 downto 49) := conv_std_logic_vector(1, 7);\n" +
                        "        vb_muxind(48 downto 42) := conv_std_logic_vector(2, 7);\n" +
                        "        vb_muxind(41 downto 35) := conv_std_logic_vector(3, 7);\n" +
                        "        vb_muxind(34 downto 28) := conv_std_logic_vector(4, 7);\n" +
                        "        vb_muxind(27 downto 21) := conv_std_logic_vector(5, 7);\n" +
                        "        vb_muxind(20 downto 14) := conv_std_logic_vector(6, 7);\n" +
                        "        vb_muxind(13 downto 7)  := conv_std_logic_vector(7, 7);\n" +
                        "        vb_muxind(6 downto 0)   := conv_std_logic_vector(8, 7);\n" +
                        "        vb_bits(103 downto 96) := wb_bits_o;\n" +
                        "    elsif r.delay(2) = '1' then\n" +
                        "        v_mux_ena_i := not r.lshift_rdy;\n" +
                        "        v.divident := wb_dif_o & X\"00\";\n" +
                        "        vb_muxind(55 downto 49) := conv_std_logic_vector(9, 7);\n" +
                        "        vb_muxind(48 downto 42) := conv_std_logic_vector(10, 7);\n" +
                        "        vb_muxind(41 downto 35) := conv_std_logic_vector(11, 7);\n" +
                        "        vb_muxind(34 downto 28) := conv_std_logic_vector(12, 7);\n" +
                        "        vb_muxind(27 downto 21) := conv_std_logic_vector(13, 7);\n" +
                        "        vb_muxind(20 downto 14) := conv_std_logic_vector(14, 7);\n" +
                        "        vb_muxind(13 downto 7)  := conv_std_logic_vector(15, 7);\n" +
                        "        vb_muxind(6 downto 0)   := conv_std_logic_vector(16, 7);\n" +
                        "        vb_bits(95 downto 88) := wb_bits_o;\n" +
                        "    elsif r.delay(3) = '1' then\n" +
                        "        v_mux_ena_i := not r.lshift_rdy;\n" +
                        "        v.divident := wb_dif_o & X\"00\";\n" +
                        "        vb_muxind(55 downto 49) := conv_std_logic_vector(17, 7);\n" +
                        "        vb_muxind(48 downto 42) := conv_std_logic_vector(18, 7);\n" +
                        "        vb_muxind(41 downto 35) := conv_std_logic_vector(19, 7);\n" +
                        "        vb_muxind(34 downto 28) := conv_std_logic_vector(20, 7);\n" +
                        "        vb_muxind(27 downto 21) := conv_std_logic_vector(21, 7);\n" +
                        "        vb_muxind(20 downto 14) := conv_std_logic_vector(22, 7);\n" +
                        "        vb_muxind(13 downto 7)  := conv_std_logic_vector(23, 7);\n" +
                        "        vb_muxind(6 downto 0)   := conv_std_logic_vector(24, 7);\n" +
                        "        vb_bits(87 downto 80) := wb_bits_o;\n" +
                        "    elsif r.delay(4) = '1' then\n" +
                        "        v_mux_ena_i := not r.lshift_rdy;\n" +
                        "        v.divident := wb_dif_o & X\"00\";\n" +
                        "        vb_muxind(55 downto 49) := conv_std_logic_vector(25, 7);\n" +
                        "        vb_muxind(48 downto 42) := conv_std_logic_vector(26, 7);\n" +
                        "        vb_muxind(41 downto 35) := conv_std_logic_vector(27, 7);\n" +
                        "        vb_muxind(34 downto 28) := conv_std_logic_vector(28, 7);\n" +
                        "        vb_muxind(27 downto 21) := conv_std_logic_vector(29, 7);\n" +
                        "        vb_muxind(20 downto 14) := conv_std_logic_vector(30, 7);\n" +
                        "        vb_muxind(13 downto 7)  := conv_std_logic_vector(31, 7);\n" +
                        "        vb_muxind(6 downto 0)   := conv_std_logic_vector(32, 7);\n" +
                        "        vb_bits(79 downto 72) := wb_bits_o;\n" +
                        "    elsif r.delay(5) = '1' then\n" +
                        "        v_mux_ena_i := not r.lshift_rdy;\n" +
                        "        v.divident := wb_dif_o & X\"00\";\n" +
                        "        vb_muxind(55 downto 49) := conv_std_logic_vector(33, 7);\n" +
                        "        vb_muxind(48 downto 42) := conv_std_logic_vector(34, 7);\n" +
                        "        vb_muxind(41 downto 35) := conv_std_logic_vector(35, 7);\n" +
                        "        vb_muxind(34 downto 28) := conv_std_logic_vector(36, 7);\n" +
                        "        vb_muxind(27 downto 21) := conv_std_logic_vector(37, 7);\n" +
                        "        vb_muxind(20 downto 14) := conv_std_logic_vector(38, 7);\n" +
                        "        vb_muxind(13 downto 7)  := conv_std_logic_vector(39, 7);\n" +
                        "        vb_muxind(6 downto 0)   := conv_std_logic_vector(40, 7);\n" +
                        "        vb_bits(71 downto 64) := wb_bits_o;\n" +
                        "    elsif r.delay(6) = '1' then\n" +
                        "        v_mux_ena_i := not r.lshift_rdy;\n" +
                        "        v.divident := wb_dif_o & X\"00\";\n" +
                        "        vb_muxind(55 downto 49) := conv_std_logic_vector(41, 7);\n" +
                        "        vb_muxind(48 downto 42) := conv_std_logic_vector(42, 7);\n" +
                        "        vb_muxind(41 downto 35) := conv_std_logic_vector(43, 7);\n" +
                        "        vb_muxind(34 downto 28) := conv_std_logic_vector(44, 7);\n" +
                        "        vb_muxind(27 downto 21) := conv_std_logic_vector(45, 7);\n" +
                        "        vb_muxind(20 downto 14) := conv_std_logic_vector(46, 7);\n" +
                        "        vb_muxind(13 downto 7)  := conv_std_logic_vector(47, 7);\n" +
                        "        vb_muxind(6 downto 0)   := conv_std_logic_vector(48, 7);\n" +
                        "        vb_bits(63 downto 56) := wb_bits_o;\n" +
                        "    elsif r.delay(7) = '1' then\n" +
                        "        v_mux_ena_i := not r.lshift_rdy;\n" +
                        "        v.divident := wb_dif_o & X\"00\";\n" +
                        "        vb_muxind(55 downto 49) := conv_std_logic_vector(49, 7);\n" +
                        "        vb_muxind(48 downto 42) := conv_std_logic_vector(50, 7);\n" +
                        "        vb_muxind(41 downto 35) := conv_std_logic_vector(51, 7);\n" +
                        "        vb_muxind(34 downto 28) := conv_std_logic_vector(52, 7);\n" +
                        "        vb_muxind(27 downto 21) := conv_std_logic_vector(53, 7);\n" +
                        "        vb_muxind(20 downto 14) := conv_std_logic_vector(54, 7);\n" +
                        "        vb_muxind(13 downto 7)  := conv_std_logic_vector(55, 7);\n" +
                        "        vb_muxind(6 downto 0)   := conv_std_logic_vector(56, 7);\n" +
                        "        vb_bits(55 downto 48) := wb_bits_o;\n" +
                        "    elsif r.delay(8) = '1' then\n" +
                        "        v_mux_ena_i := not r.lshift_rdy;\n" +
                        "        v.divident := wb_dif_o & X\"00\";\n" +
                        "        vb_muxind(55 downto 49) := conv_std_logic_vector(57, 7);\n" +
                        "        vb_muxind(48 downto 42) := conv_std_logic_vector(58, 7);\n" +
                        "        vb_muxind(41 downto 35) := conv_std_logic_vector(59, 7);\n" +
                        "        vb_muxind(34 downto 28) := conv_std_logic_vector(60, 7);\n" +
                        "        vb_muxind(27 downto 21) := conv_std_logic_vector(61, 7);\n" +
                        "        vb_muxind(20 downto 14) := conv_std_logic_vector(62, 7);\n" +
                        "        vb_muxind(13 downto 7)  := conv_std_logic_vector(63, 7);\n" +
                        "        vb_muxind(6 downto 0)   := conv_std_logic_vector(64, 7);\n" +
                        "        vb_bits(47 downto 40) := wb_bits_o;\n" +
                        "    elsif r.delay(9) = '1' then\n" +
                        "        v_mux_ena_i := not r.lshift_rdy;\n" +
                        "        v.divident := wb_dif_o & X\"00\";\n" +
                        "        vb_muxind(55 downto 49) := conv_std_logic_vector(65, 7);\n" +
                        "        vb_muxind(48 downto 42) := conv_std_logic_vector(66, 7);\n" +
                        "        vb_muxind(41 downto 35) := conv_std_logic_vector(67, 7);\n" +
                        "        vb_muxind(34 downto 28) := conv_std_logic_vector(68, 7);\n" +
                        "        vb_muxind(27 downto 21) := conv_std_logic_vector(69, 7);\n" +
                        "        vb_muxind(20 downto 14) := conv_std_logic_vector(70, 7);\n" +
                        "        vb_muxind(13 downto 7)  := conv_std_logic_vector(71, 7);\n" +
                        "        vb_muxind(6 downto 0)   := conv_std_logic_vector(72, 7);\n" +
                        "        vb_bits(39 downto 32) := wb_bits_o;\n" +
                        "    elsif r.delay(10) = '1' then\n" +
                        "        v_mux_ena_i := not r.lshift_rdy;\n" +
                        "        v.divident := wb_dif_o & X\"00\";\n" +
                        "        vb_muxind(55 downto 49) := conv_std_logic_vector(73, 7);\n" +
                        "        vb_muxind(48 downto 42) := conv_std_logic_vector(74, 7);\n" +
                        "        vb_muxind(41 downto 35) := conv_std_logic_vector(75, 7);\n" +
                        "        vb_muxind(34 downto 28) := conv_std_logic_vector(76, 7);\n" +
                        "        vb_muxind(27 downto 21) := conv_std_logic_vector(77, 7);\n" +
                        "        vb_muxind(20 downto 14) := conv_std_logic_vector(78, 7);\n" +
                        "        vb_muxind(13 downto 7)  := conv_std_logic_vector(79, 7);\n" +
                        "        vb_muxind(6 downto 0)   := conv_std_logic_vector(80, 7);\n" +
                        "        vb_bits(31 downto 24) := wb_bits_o;\n" +
                        "    elsif r.delay(11) = '1' then\n" +
                        "        v_mux_ena_i := not r.lshift_rdy;\n" +
                        "        v.divident := wb_dif_o & X\"00\";\n" +
                        "        vb_muxind(55 downto 49) := conv_std_logic_vector(81, 7);\n" +
                        "        vb_muxind(48 downto 42) := conv_std_logic_vector(82, 7);\n" +
                        "        vb_muxind(41 downto 35) := conv_std_logic_vector(83, 7);\n" +
                        "        vb_muxind(34 downto 28) := conv_std_logic_vector(84, 7);\n" +
                        "        vb_muxind(27 downto 21) := conv_std_logic_vector(85, 7);\n" +
                        "        vb_muxind(20 downto 14) := conv_std_logic_vector(86, 7);\n" +
                        "        vb_muxind(13 downto 7)  := conv_std_logic_vector(87, 7);\n" +
                        "        vb_muxind(6 downto 0)   := conv_std_logic_vector(88, 7);\n" +
                        "        vb_bits(23 downto 16) := wb_bits_o;\n" +
                        "    elsif r.delay(12) = '1' then\n" +
                        "        v_mux_ena_i := not r.lshift_rdy;\n" +
                        "        v.divident := wb_dif_o & X\"00\";\n" +
                        "        vb_muxind(55 downto 49) := conv_std_logic_vector(89, 7);\n" +
                        "        vb_muxind(48 downto 42) := conv_std_logic_vector(90, 7);\n" +
                        "        vb_muxind(41 downto 35) := conv_std_logic_vector(91, 7);\n" +
                        "        vb_muxind(34 downto 28) := conv_std_logic_vector(92, 7);\n" +
                        "        vb_muxind(27 downto 21) := conv_std_logic_vector(93, 7);\n" +
                        "        vb_muxind(20 downto 14) := conv_std_logic_vector(94, 7);\n" +
                        "        vb_muxind(13 downto 7)  := conv_std_logic_vector(95, 7);\n" +
                        "        vb_muxind(6 downto 0)   := conv_std_logic_vector(96, 7);\n" +
                        "        vb_bits(15 downto 8) := wb_bits_o;\n" +
                        "    elsif r.delay(13) = '1' then\n" +
                        "        v_mux_ena_i := not r.lshift_rdy;\n" +
                        "        v.divident := wb_dif_o & X\"00\";\n" +
                        "        vb_muxind(55 downto 49) := conv_std_logic_vector(97, 7);\n" +
                        "        vb_muxind(48 downto 42) := conv_std_logic_vector(98, 7);\n" +
                        "        vb_muxind(41 downto 35) := conv_std_logic_vector(99, 7);\n" +
                        "        vb_muxind(34 downto 28) := conv_std_logic_vector(100, 7);\n" +
                        "        vb_muxind(27 downto 21) := conv_std_logic_vector(101, 7);\n" +
                        "        vb_muxind(20 downto 14) := conv_std_logic_vector(102, 7);\n" +
                        "        vb_muxind(13 downto 7)  := conv_std_logic_vector(103, 7);\n" +
                        "        vb_muxind(6 downto 0)   := conv_std_logic_vector(104, 7);\n" +
                        "        vb_bits(7 downto 0) := wb_bits_o;\n" +
                        "\n" +
                        "        if wb_dif_o = zero53 then\n" +
                        "            v.zero_resid := '1';\n" +
                        "        end if;\n" +
                        "        if r.lshift = \"1111111\" then\n" +
                        "            v.overflow := '1';\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if r.lshift_rdy = '0' then\n" +
                        "        if w_muxind_rdy_o = '1' then\n" +
                        "            v.lshift_rdy := '1';\n" +
                        "            v.lshift := wb_muxind_o;\n" +
                        "        elsif r.delay(13) = '1' then\n" +
                        "            v.lshift_rdy := '1';\n" +
                        "            v.lshift := conv_std_logic_vector(104, 7);\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_mux_ena_i <= v_mux_ena_i;\n" +
                        "    wb_divident_i <= r.divident;\n" +
                        "    wb_divisor_i <= r.divisor;\n" +
                        "    wb_muxind_i <= vb_muxind;\n" +
                        "    v.bits := vb_bits;\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  o_result <= r.bits;\n" +
                        "  o_lshift <= r.lshift;\n" +
                        "  o_overflow <= r.overflow;\n" +
                        "  o_zero_resid <= r.zero_resid;\n" +
                        "  o_rdy <= r.delay(14);\n" +
                        "  \n" +
                        "  -- registers:\n" +
                        "  regs : process(i_nrst, i_clk)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
                                new GeneralFunctions().write_file(Project_Folder_File, data);
                            }

    private void generate_fpu_top_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "library riverlib;\n" +
                        "use riverlib.river_cfg.all;\n" +
                        "\n" +
                        "entity FpuTop is \n" +
                        "  generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_nrst         : in std_logic;\n" +
                        "    i_clk          : in std_logic;\n" +
                        "    i_ena          : in std_logic;\n" +
                        "    i_ivec         : in std_logic_vector(Instr_FPU_Total-1 downto 0);\n" +
                        "    i_a            : in std_logic_vector(63 downto 0);\n" +
                        "    i_b            : in std_logic_vector(63 downto 0);\n" +
                        "    o_res          : out std_logic_vector(63 downto 0);\n" +
                        "    o_ex_invalidop : out std_logic;   -- Exception: invalid operation\n" +
                        "    o_ex_divbyzero : out std_logic;   -- Exception: divide by zero\n" +
                        "    o_ex_overflow  : out std_logic;   -- Exception: overflow\n" +
                        "    o_ex_underflow : out std_logic;   -- Exception: underflow\n" +
                        "    o_ex_inexact   : out std_logic;   -- Exception: inexact\n" +
                        "    o_valid        : out std_logic;\n" +
                        "    o_busy         : out std_logic\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_FpuTop of FpuTop is\n" +
                        "\n" +
                        "  component DoubleAdd is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_nrst       : in std_logic;\n" +
                        "    i_clk        : in std_logic;\n" +
                        "    i_ena        : in std_logic;\n" +
                        "    i_add        : in std_logic;\n" +
                        "    i_sub        : in std_logic;\n" +
                        "    i_eq         : in std_logic;\n" +
                        "    i_lt         : in std_logic;\n" +
                        "    i_le         : in std_logic;\n" +
                        "    i_max        : in std_logic;\n" +
                        "    i_min        : in std_logic;\n" +
                        "    i_a          : in std_logic_vector(63 downto 0);\n" +
                        "    i_b          : in std_logic_vector(63 downto 0);\n" +
                        "    o_res        : out std_logic_vector(63 downto 0);\n" +
                        "    o_illegal_op : out std_logic;\n" +
                        "    o_overflow   : out std_logic;\n" +
                        "    o_valid      : out std_logic;\n" +
                        "    o_busy       : out std_logic\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "  component DoubleDiv is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_nrst       : in std_logic;\n" +
                        "    i_clk        : in std_logic;\n" +
                        "    i_ena        : in std_logic;\n" +
                        "    i_a          : in std_logic_vector(63 downto 0);\n" +
                        "    i_b          : in std_logic_vector(63 downto 0);\n" +
                        "    o_res        : out std_logic_vector(63 downto 0);\n" +
                        "    o_illegal_op : out std_logic;\n" +
                        "    o_divbyzero  : out std_logic;\n" +
                        "    o_overflow   : out std_logic;\n" +
                        "    o_underflow  : out std_logic;\n" +
                        "    o_valid      : out std_logic;\n" +
                        "    o_busy       : out std_logic\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "  component DoubleMul is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_nrst       : in std_logic;\n" +
                        "    i_clk        : in std_logic;\n" +
                        "    i_ena        : in std_logic;\n" +
                        "    i_a          : in std_logic_vector(63 downto 0);\n" +
                        "    i_b          : in std_logic_vector(63 downto 0);\n" +
                        "    o_res        : out std_logic_vector(63 downto 0);\n" +
                        "    o_illegal_op : out std_logic;\n" +
                        "    o_overflow   : out std_logic;\n" +
                        "    o_valid      : out std_logic;\n" +
                        "    o_busy       : out std_logic\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "  component Double2Single is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_nrst       : in std_logic;\n" +
                        "    i_clk        : in std_logic;\n" +
                        "    i_ena        : in std_logic;\n" +
                        "    i_signed     : in std_logic;\n" +
                        "    i_w32        : in std_logic;\n" +
                        "    i_a          : in std_logic_vector(63 downto 0);\n" +
                        "    o_res        : out std_logic_vector(63 downto 0);\n" +
                        "    o_overflow   : out std_logic;\n" +
                        "    o_underflow  : out std_logic;\n" +
                        "    o_valid      : out std_logic;\n" +
                        "    o_busy       : out std_logic\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "  \n" +
                        "  component Single2Double is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_nrst       : in std_logic;\n" +
                        "    i_clk        : in std_logic;\n" +
                        "    i_ena        : in std_logic;\n" +
                        "    i_signed     : in std_logic;\n" +
                        "    i_w32        : in std_logic;\n" +
                        "    i_a          : in std_logic_vector(63 downto 0);\n" +
                        "    o_res        : out std_logic_vector(63 downto 0);\n" +
                        "    o_overflow   : out std_logic;\n" +
                        "    o_underflow  : out std_logic;\n" +
                        "    o_valid      : out std_logic;\n" +
                        "    o_busy       : out std_logic\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "  \n" +
                        "  component Double2Long is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_nrst       : in std_logic;\n" +
                        "    i_clk        : in std_logic;\n" +
                        "    i_ena        : in std_logic;\n" +
                        "    i_signed     : in std_logic;\n" +
                        "    i_w32        : in std_logic;\n" +
                        "    i_a          : in std_logic_vector(63 downto 0);\n" +
                        "    o_res        : out std_logic_vector(63 downto 0);\n" +
                        "    o_overflow   : out std_logic;\n" +
                        "    o_underflow  : out std_logic;\n" +
                        "    o_valid      : out std_logic;\n" +
                        "    o_busy       : out std_logic\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "  component Long2Double is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_nrst       : in std_logic;\n" +
                        "    i_clk        : in std_logic;\n" +
                        "    i_ena        : in std_logic;\n" +
                        "    i_signed     : in std_logic;\n" +
                        "    i_w32        : in std_logic;\n" +
                        "    i_a          : in std_logic_vector(63 downto 0);\n" +
                        "    o_res        : out std_logic_vector(63 downto 0);\n" +
                        "    o_valid      : out std_logic;\n" +
                        "    o_busy       : out std_logic\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "    ivec : std_logic_vector(Instr_FPU_Total-1 downto 0);\n" +
                        "    busy : std_logic;\n" +
                        "    ready : std_logic;\n" +
                        "    a : std_logic_vector(63 downto 0);\n" +
                        "    b : std_logic_vector(63 downto 0);\n" +
                        "    result : std_logic_vector(63 downto 0);\n" +
                        "    ex_invalidop : std_logic;   -- Exception: invalid operation\n" +
                        "    ex_divbyzero : std_logic;   -- Exception: divide by zero\n" +
                        "    ex_overflow : std_logic;    -- Exception: overflow\n" +
                        "    ex_underflow : std_logic;   -- Exception: underflow\n" +
                        "    ex_inexact : std_logic;     -- Exception: inexact\n" +
                        "    ena_fadd : std_logic;\n" +
                        "    ena_fdiv : std_logic;\n" +
                        "    ena_fmul : std_logic;\n" +
                        "    ena_d2s : std_logic;\n" +
                        "    ena_s2d : std_logic;\n" +
                        "    ena_d2l : std_logic;\n" +
                        "    ena_l2d : std_logic;\n" +
                        "    ena_w32 : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "    (others => '0'),                                -- ivec\n" +
                        "    '0', '0', (others => '0'), (others => '0'),     -- busy, ready, a, b\n" +
                        "    (others => '0'),                                -- result\n" +
                        "    '0', '0', '0',                                  -- ex_invalidop, ex_divbyzero, ex_overflow\n" +
                        "    '0', '0', '0',                                  -- ex_underflow, ex_inexact, ena_fadd\n" +
                        "    '0', '0', '0', '0', '0', '0',                   -- ena_fdiv, ena_fmul, ena_d2s, ena_s2d, ena_d2l, ena_l2d\n" +
                        "    '0'                                             -- ena_w32\n" +
                        "  );\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "\n" +
                        "  signal w_fadd_d : std_logic;\n" +
                        "  signal w_fsub_d : std_logic;\n" +
                        "  signal w_feq_d : std_logic;\n" +
                        "  signal w_flt_d : std_logic;\n" +
                        "  signal w_fle_d : std_logic;\n" +
                        "  signal w_fmax_d : std_logic;\n" +
                        "  signal w_fmin_d : std_logic;\n" +
                        "  signal w_fcvt_signed : std_logic;\n" +
                        "  signal wb_res_fadd : std_logic_vector(63 downto 0);\n" +
                        "  signal w_valid_fadd : std_logic;\n" +
                        "  signal w_illegalop_fadd : std_logic;\n" +
                        "  signal w_overflow_fadd : std_logic;\n" +
                        "  signal w_busy_fadd : std_logic;\n" +
                        "\n" +
                        "  signal wb_res_fdiv : std_logic_vector(63 downto 0);\n" +
                        "  signal w_valid_fdiv : std_logic;\n" +
                        "  signal w_illegalop_fdiv : std_logic;\n" +
                        "  signal w_divbyzero_fdiv : std_logic;\n" +
                        "  signal w_overflow_fdiv : std_logic;\n" +
                        "  signal w_underflow_fdiv : std_logic;\n" +
                        "  signal w_busy_fdiv : std_logic;\n" +
                        "\n" +
                        "  signal wb_res_fmul : std_logic_vector(63 downto 0);\n" +
                        "  signal w_valid_fmul : std_logic;\n" +
                        "  signal w_illegalop_fmul : std_logic;\n" +
                        "  signal w_overflow_fmul : std_logic;\n" +
                        "  signal w_busy_fmul : std_logic;\n" +
                        "\n" +
                        "  signal wb_res_d2l : std_logic_vector(63 downto 0);\n" +
                        "  signal w_valid_d2l : std_logic;\n" +
                        "  signal w_overflow_d2l : std_logic;\n" +
                        "  signal w_underflow_d2l : std_logic;\n" +
                        "  signal w_busy_d2l : std_logic;\n" +
                        "  \n" +
                        "  signal wb_res_d2s : std_logic_vector(63 downto 0);\n" +
                        "  signal w_valid_d2s : std_logic;\n" +
                        "  signal w_overflow_d2s : std_logic;\n" +
                        "  signal w_underflow_d2s : std_logic;\n" +
                        "  signal w_busy_d2s : std_logic;\n" +
                        "  \n" +
                        "  signal wb_res_s2d : std_logic_vector(63 downto 0);\n" +
                        "  signal w_valid_s2d : std_logic;\n" +
                        "  signal w_overflow_s2d : std_logic;\n" +
                        "  signal w_underflow_s2d : std_logic;\n" +
                        "  signal w_busy_s2d : std_logic;\n" +
                        "\n" +
                        "  signal wb_res_l2d : std_logic_vector(63 downto 0);\n" +
                        "  signal w_valid_l2d : std_logic;\n" +
                        "  signal w_busy_l2d : std_logic;\n" +
                        "\n" +
                        "begin\n" +
                        "    fadd_d0 : DoubleAdd generic map (\n" +
                        "      async_reset => async_reset\n" +
                        "    ) port map (\n" +
                        "      i_clk => i_clk,\n" +
                        "      i_nrst => i_nrst,\n" +
                        "      i_ena => r.ena_fadd,\n" +
                        "      i_add => w_fadd_d,\n" +
                        "      i_sub => w_fsub_d,\n" +
                        "      i_eq => w_feq_d,\n" +
                        "      i_lt => w_flt_d,\n" +
                        "      i_le => w_fle_d,\n" +
                        "      i_max => w_fmax_d,\n" +
                        "      i_min => w_fmin_d,\n" +
                        "      i_a => r.a,\n" +
                        "      i_b => r.b,\n" +
                        "      o_res => wb_res_fadd,\n" +
                        "      o_illegal_op => w_illegalop_fadd,\n" +
                        "      o_overflow => w_overflow_fadd,\n" +
                        "      o_valid => w_valid_fadd,\n" +
                        "      o_busy => w_busy_fadd\n" +
                        "    );\n" +
                        "\n" +
                        "    fdiv_d0 : DoubleDiv generic map (\n" +
                        "      async_reset => async_reset\n" +
                        "    ) port map (\n" +
                        "      i_clk => i_clk,\n" +
                        "      i_nrst => i_nrst,\n" +
                        "      i_ena => r.ena_fdiv,\n" +
                        "      i_a => r.a,\n" +
                        "      i_b => r.b,\n" +
                        "      o_res => wb_res_fdiv,\n" +
                        "      o_illegal_op => w_illegalop_fdiv,\n" +
                        "      o_divbyzero => w_divbyzero_fdiv,\n" +
                        "      o_overflow => w_overflow_fdiv,\n" +
                        "      o_underflow => w_underflow_fdiv,\n" +
                        "      o_valid => w_valid_fdiv,\n" +
                        "      o_busy => w_busy_fdiv\n" +
                        "    );\n" +
                        "\n" +
                        "    fmul_d0 : DoubleMul generic map (\n" +
                        "      async_reset => async_reset\n" +
                        "    ) port map (\n" +
                        "      i_clk => i_clk,\n" +
                        "      i_nrst => i_nrst,\n" +
                        "      i_ena => r.ena_fmul,\n" +
                        "      i_a => r.a,\n" +
                        "      i_b => r.b,\n" +
                        "      o_res => wb_res_fmul,\n" +
                        "      o_illegal_op => w_illegalop_fmul,\n" +
                        "      o_overflow => w_overflow_fmul,\n" +
                        "      o_valid => w_valid_fmul,\n" +
                        "      o_busy => w_busy_fmul\n" +
                        "    );\n" +
                        "\n" +
                        "    d2l_d0 : Double2Long generic map (\n" +
                        "      async_reset => async_reset\n" +
                        "    ) port map (\n" +
                        "      i_clk => i_clk,\n" +
                        "      i_nrst => i_nrst,\n" +
                        "      i_ena => r.ena_d2l,\n" +
                        "      i_signed => w_fcvt_signed,\n" +
                        "      i_w32 => r.ena_w32,\n" +
                        "      i_a => r.a,\n" +
                        "      o_res => wb_res_d2l,\n" +
                        "      o_overflow => w_overflow_d2l,\n" +
                        "      o_underflow => w_underflow_d2l,\n" +
                        "      o_valid => w_valid_d2l,\n" +
                        "      o_busy => w_busy_d2l\n" +
                        "    );\n" +
                        "	 \n" +
                        "	 d2s_d0 : Double2Single generic map (\n" +
                        "      async_reset => async_reset\n" +
                        "    ) port map (\n" +
                        "      i_clk => i_clk,\n" +
                        "      i_nrst => i_nrst,\n" +
                        "      i_ena => r.ena_d2s,\n" +
                        "      i_signed => w_fcvt_signed,\n" +
                        "      i_w32 => r.ena_w32,\n" +
                        "      i_a => r.a,\n" +
                        "      o_res => wb_res_d2s,\n" +
                        "      o_overflow => w_overflow_d2s,\n" +
                        "      o_underflow => w_underflow_d2s,\n" +
                        "      o_valid => w_valid_d2s,\n" +
                        "      o_busy => w_busy_d2s\n" +
                        "    );\n" +
                        "	 \n" +
                        "	 s2d_d0 : Single2Double generic map (\n" +
                        "      async_reset => async_reset\n" +
                        "    ) port map (\n" +
                        "      i_clk => i_clk,\n" +
                        "      i_nrst => i_nrst,\n" +
                        "      i_ena => r.ena_s2d,\n" +
                        "      i_signed => w_fcvt_signed,\n" +
                        "      i_w32 => r.ena_w32,\n" +
                        "      i_a => r.a,\n" +
                        "      o_res => wb_res_s2d,\n" +
                        "      o_overflow => w_overflow_s2d,\n" +
                        "      o_underflow => w_underflow_s2d,\n" +
                        "      o_valid => w_valid_s2d,\n" +
                        "      o_busy => w_busy_s2d\n" +
                        "    );\n" +
                        "\n" +
                        "    l2d_d0 : Long2Double generic map (\n" +
                        "      async_reset => async_reset\n" +
                        "    ) port map (\n" +
                        "      i_clk => i_clk,\n" +
                        "      i_nrst => i_nrst,\n" +
                        "      i_ena => r.ena_l2d,\n" +
                        "      i_signed => w_fcvt_signed,\n" +
                        "      i_w32 => r.ena_w32,\n" +
                        "      i_a => r.a,\n" +
                        "      o_res => wb_res_l2d,\n" +
                        "      o_valid => w_valid_l2d,\n" +
                        "      o_busy => w_busy_l2d\n" +
                        "    );\n" +
                        "\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  comb : process(i_nrst, i_ena, i_ivec, i_a, i_b, r,\n" +
                        "                wb_res_fadd, w_valid_fadd, w_illegalop_fadd, w_overflow_fadd, w_busy_fadd,\n" +
                        "                wb_res_fdiv, w_valid_fdiv, w_illegalop_fdiv, w_divbyzero_fdiv, w_overflow_fdiv,\n" +
                        "                w_underflow_fdiv, w_busy_fdiv,\n" +
                        "                wb_res_fmul, w_valid_fmul, w_illegalop_fmul, w_overflow_fmul, w_busy_fmul,\n" +
                        "                wb_res_d2l, w_valid_d2l, w_overflow_d2l, w_underflow_d2l, w_busy_d2l,\n" +
                        "                wb_res_l2d, w_valid_l2d, w_busy_l2d, wb_res_d2s, w_valid_d2s, w_busy_d2s,\n" +
                        "					 wb_res_s2d, w_valid_s2d, w_busy_s2d)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable iv : std_logic_vector(Instr_FPU_Total-1 downto 0);\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "    iv := i_ivec;\n" +
                        "\n" +
                        "    v.ena_fadd := '0';\n" +
                        "    v.ena_fdiv := '0';\n" +
                        "    v.ena_fmul := '0';\n" +
                        "    v.ena_d2s := '0';\n" +
                        "    v.ena_s2d := '0';\n" +
                        "    v.ena_d2l := '0';\n" +
                        "    v.ena_l2d := '0';\n" +
                        "    v.ready := '0';\n" +
                        "    if i_ena = '1' and r.busy = '0' then\n" +
                        "        v.busy := '1';\n" +
                        "        v.a := i_a;\n" +
                        "        v.b := i_b;\n" +
                        "        v.ivec := i_ivec;\n" +
                        "        v.ex_invalidop := '0';\n" +
                        "        v.ex_divbyzero := '0';\n" +
                        "        v.ex_overflow := '0';\n" +
                        "        v.ex_underflow := '0';\n" +
                        "        v.ex_inexact := '0';\n" +
                        "\n" +
                        "        v.ena_fadd := iv(Instr_FADD_D - Instr_FADD_D)\n" +
                        "                    or iv(Instr_FSUB_D - Instr_FADD_D)\n" +
                        "                    or iv(Instr_FLE_D - Instr_FADD_D)\n" +
                        "                    or iv(Instr_FLT_D - Instr_FADD_D)\n" +
                        "                    or iv(Instr_FEQ_D - Instr_FADD_D)\n" +
                        "                    or iv(Instr_FMAX_D - Instr_FADD_D)\n" +
                        "                    or iv(Instr_FMIN_D - Instr_FADD_D);\n" +
                        "        v.ena_fdiv := iv(Instr_FDIV_D - Instr_FADD_D);\n" +
                        "        v.ena_fmul := iv(Instr_FMUL_D - Instr_FADD_D);\n" +
                        "        v.ena_d2s := iv(Instr_FCVT_S_D - Instr_FADD_D);\n" +
                        "        v.ena_s2d := iv(Instr_FCVT_D_S - Instr_FADD_D);\n" +
                        "        v.ena_d2l := iv(Instr_FCVT_LU_D - Instr_FADD_D)\n" +
                        "                    or iv(Instr_FCVT_L_D - Instr_FADD_D)\n" +
                        "                    or iv(Instr_FCVT_WU_D - Instr_FADD_D)\n" +
                        "                    or iv(Instr_FCVT_W_D - Instr_FADD_D);\n" +
                        "        v.ena_l2d := iv(Instr_FCVT_D_LU - Instr_FADD_D)\n" +
                        "                    or iv(Instr_FCVT_D_L - Instr_FADD_D)\n" +
                        "                    or iv(Instr_FCVT_D_WU - Instr_FADD_D)\n" +
                        "                    or iv(Instr_FCVT_D_W - Instr_FADD_D);\n" +
                        "\n" +
                        "        v.ena_w32 := iv(Instr_FCVT_WU_D - Instr_FADD_D)\n" +
                        "                    or iv(Instr_FCVT_W_D - Instr_FADD_D)\n" +
                        "                    or iv(Instr_FCVT_D_WU - Instr_FADD_D)\n" +
                        "                    or iv(Instr_FCVT_D_W - Instr_FADD_D);\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if r.busy = '1' and (r.ivec(Instr_FMOV_X_D - Instr_FADD_D)\n" +
                        "                        or r.ivec(Instr_FMOV_X_W - Instr_FADD_D)\n" +
                        "                        or r.ivec(Instr_FMOV_W_X - Instr_FADD_D)\n" +
                        "                        or r.ivec(Instr_FMOV_D_X - Instr_FADD_D)) = '1' then\n" +
                        "        v.busy := '0';\n" +
                        "        v.ready := '1';\n" +
                        "        v.result := r.a;\n" +
                        "    elsif r.busy = '1' and (r.ivec(Instr_FSGNJ_D - Instr_FADD_D)) = '1' then\n" +
                        "	     v.busy := '0';\n" +
                        "        v.ready := '1';\n" +
                        "        v.result := r.b(63) & r.a(62 downto 0);\n" +
                        "    elsif w_valid_fadd = '1' then\n" +
                        "        v.busy := '0';\n" +
                        "        v.ready := '1';\n" +
                        "        v.result := wb_res_fadd;\n" +
                        "        v.ex_invalidop := w_illegalop_fadd;\n" +
                        "        v.ex_overflow := w_overflow_fadd;\n" +
                        "    elsif w_valid_fdiv = '1' then\n" +
                        "        v.busy := '0';\n" +
                        "        v.ready := '1';\n" +
                        "        v.result := wb_res_fdiv;\n" +
                        "        v.ex_invalidop := w_illegalop_fdiv;\n" +
                        "        v.ex_divbyzero := w_divbyzero_fdiv;\n" +
                        "        v.ex_overflow := w_overflow_fdiv;\n" +
                        "        v.ex_underflow := w_underflow_fdiv;\n" +
                        "    elsif w_valid_fmul = '1' then\n" +
                        "        v.busy := '0';\n" +
                        "        v.ready := '1';\n" +
                        "        v.result := wb_res_fmul;\n" +
                        "        v.ex_invalidop := w_illegalop_fmul;\n" +
                        "        v.ex_overflow := w_overflow_fmul;\n" +
                        "    elsif w_valid_d2l = '1' then\n" +
                        "        v.busy := '0';\n" +
                        "        v.ready := '1';\n" +
                        "        v.result := wb_res_d2l;\n" +
                        "        v.ex_overflow := w_overflow_d2l;\n" +
                        "        v.ex_underflow := w_underflow_d2l;\n" +
                        "    elsif w_valid_d2s = '1' then\n" +
                        "        v.busy := '0';\n" +
                        "        v.ready := '1';\n" +
                        "        v.result := wb_res_d2s;\n" +
                        "        v.ex_overflow := w_overflow_d2s;\n" +
                        "        v.ex_underflow := w_underflow_d2s;\n" +
                        "    elsif w_valid_s2d = '1' then\n" +
                        "        v.busy := '0';\n" +
                        "        v.ready := '1';\n" +
                        "        v.result := wb_res_s2d;\n" +
                        "        v.ex_overflow := w_overflow_s2d;\n" +
                        "        v.ex_underflow := w_underflow_s2d;\n" +
                        "    elsif w_valid_l2d = '1' then\n" +
                        "        v.busy := '0';\n" +
                        "        v.ready := '1';\n" +
                        "        v.result := wb_res_l2d;\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "    w_fadd_d <= r.ivec(Instr_FADD_D - Instr_FADD_D);\n" +
                        "    w_fsub_d <= r.ivec(Instr_FSUB_D - Instr_FADD_D);\n" +
                        "    w_feq_d <= r.ivec(Instr_FEQ_D - Instr_FADD_D);\n" +
                        "    w_flt_d <= r.ivec(Instr_FLT_D - Instr_FADD_D);\n" +
                        "    w_fle_d <= r.ivec(Instr_FLE_D - Instr_FADD_D);\n" +
                        "    w_fmax_d <= r.ivec(Instr_FMAX_D - Instr_FADD_D);\n" +
                        "    w_fmin_d <= r.ivec(Instr_FMIN_D - Instr_FADD_D);\n" +
                        "    w_fcvt_signed <= r.ivec(Instr_FCVT_L_D - Instr_FADD_D) or\n" +
                        "                     r.ivec(Instr_FCVT_D_L - Instr_FADD_D) or\n" +
                        "                     r.ivec(Instr_FCVT_W_D - Instr_FADD_D) or\n" +
                        "                     r.ivec(Instr_FCVT_D_W - Instr_FADD_D);\n" +
                        "\n" +
                        "    o_res <= r.result;\n" +
                        "    o_ex_invalidop <= r.ex_invalidop;\n" +
                        "    o_ex_divbyzero <= r.ex_divbyzero;\n" +
                        "    o_ex_overflow <= r.ex_overflow;\n" +
                        "    o_ex_underflow <= r.ex_underflow;\n" +
                        "    o_ex_inexact <= r.ex_inexact;\n" +
                        "    o_valid <= r.ready;\n" +
                        "    o_busy <= r.busy;\n" +
                        "  \n" +
                        "  -- registers:\n" +
                        "  regs : process(i_nrst, i_clk)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_fmul_d_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.std_logic_arith.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "\n" +
                        "entity DoubleMul is \n" +
                        "  generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_nrst       : in std_logic;\n" +
                        "    i_clk        : in std_logic;\n" +
                        "    i_ena        : in std_logic;\n" +
                        "    i_a          : in std_logic_vector(63 downto 0);\n" +
                        "    i_b          : in std_logic_vector(63 downto 0);\n" +
                        "    o_res        : out std_logic_vector(63 downto 0);\n" +
                        "    o_illegal_op : out std_logic;\n" +
                        "    o_overflow   : out std_logic;\n" +
                        "    o_valid      : out std_logic;\n" +
                        "    o_busy       : out std_logic\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_DoubleMul of DoubleMul is\n" +
                        "\n" +
                        "  component FP_MUL_64 is\n" +
                        "    port (\n" +
                        "      clk    : in  std_logic                     := 'X';             -- clk\n" +
                        "      areset : in  std_logic                     := 'X';             -- reset\n" +
                        "      a      : in  std_logic_vector(63 downto 0) := (others => 'X'); -- a\n" +
                        "      b      : in  std_logic_vector(63 downto 0) := (others => 'X'); -- b\n" +
                        "      q      : out std_logic_vector(63 downto 0)                     -- q\n" +
                        "    );\n" +
                        "  end component;\n" +
                        "  \n" +
                        "  signal s_o_res        : std_logic_vector(63 downto 0);\n" +
                        "  signal counter_st     : std_logic_vector(2 downto 0);\n" +
                        "  signal reset          : std_logic;\n" +
                        "  signal s_o_illegal_op : std_logic;\n" +
                        "  signal s_o_busy       : std_logic;\n" +
                        "  \n" +
                        "  begin\n" +
                        "  \n" +
                        "  reset  <= not(i_nrst);\n" +
                        "  o_busy <= s_o_busy;\n" +
                        "  o_res <= s_o_res;\n" +
                        "  \n" +
                        "  o_overflow   <= '1' when s_o_res(63 downto 52) = X\"7FF\" else -- Not sure of this\n" +
                        "                  '0';\n" +
                        "  s_o_illegal_op <= '1' when (i_a(62 downto 52) = \"11111111111\") or (i_b(62 downto 52) = \"11111111111\") else\n" +
                        "                    '0';\n" +
                        "\n" +
                        "  FP_MUL_COMP_64 : component FP_MUL_64\n" +
                        "  port map (\n" +
                        "    clk    => i_clk,\n" +
                        "    areset => reset,\n" +
                        "    a      => i_a,\n" +
                        "    b      => i_b,\n" +
                        "    q      => s_o_res\n" +
                        "  );\n" +
                        "  \n" +
                        "  process(i_nrst, i_clk)\n" +
                        "  begin\n" +
                        "    if i_nrst = '0' then\n" +
                        "      counter_st     <= (others => '0');\n" +
                        "		s_o_busy       <= '0';\n" +
                        "		o_illegal_op   <= '0';\n" +
                        "		o_valid        <= '0';\n" +
                        "		\n" +
                        "	 elsif rising_edge(i_clk) then\n" +
                        "	   if i_ena = '1' then\n" +
                        "		  s_o_busy <= '1';\n" +
                        "		  counter_st <= \"000\";\n" +
                        "		end if;\n" +
                        "		\n" +
                        "		if s_o_busy = '1' then\n" +
                        "		  counter_st <= counter_st + \"001\";\n" +
                        "		end if;\n" +
                        "		\n" +
                        "		if counter_st = \"011\" then\n" +
                        "		  o_valid  <= '1';\n" +
                        "		  s_o_busy <= '0';\n" +
                        "		  o_illegal_op <= s_o_illegal_op;\n" +
                        "		elsif counter_st = \"100\" then\n" +
                        "		  o_valid  <= '0';\n" +
                        "		  counter_st <= \"000\";\n" +
                        "		end if;\n" +
                        "	 end if;\n" +
                        "  \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
                                new GeneralFunctions().write_file(Project_Folder_File, data);
                            }

    private void generate_fdiv_d_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "\n" +
                        "entity DoubleDiv is \n" +
                        "  generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_nrst       : in std_logic;\n" +
                        "    i_clk        : in std_logic;\n" +
                        "    i_ena        : in std_logic;\n" +
                        "    i_a          : in std_logic_vector(63 downto 0);\n" +
                        "    i_b          : in std_logic_vector(63 downto 0);\n" +
                        "    o_res        : out std_logic_vector(63 downto 0);\n" +
                        "    o_illegal_op : out std_logic;\n" +
                        "    o_divbyzero  : out std_logic;\n" +
                        "    o_overflow   : out std_logic;\n" +
                        "    o_underflow  : out std_logic;\n" +
                        "    o_valid      : out std_logic;\n" +
                        "    o_busy       : out std_logic\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_DoubleDiv of DoubleDiv is\n" +
                        "\n" +
                        "  component idiv53 is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_nrst       : in std_logic;\n" +
                        "    i_clk        : in std_logic;\n" +
                        "    i_ena        : in std_logic;\n" +
                        "    i_divident   : in std_logic_vector(52 downto 0);\n" +
                        "    i_divisor    : in std_logic_vector(52 downto 0);\n" +
                        "    o_result     : out std_logic_vector(104 downto 0);\n" +
                        "    o_lshift     : out std_logic_vector(6 downto 0);\n" +
                        "    o_rdy        : out std_logic;\n" +
                        "    o_overflow   : out std_logic;\n" +
                        "    o_zero_resid : out std_logic\n" +
                        "  );\n" +
                        "  end component;\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "    busy : std_logic;\n" +
                        "    ena : std_logic_vector(4 downto 0);\n" +
                        "    a : std_logic_vector(63 downto 0);\n" +
                        "    b : std_logic_vector(63 downto 0);\n" +
                        "    result : std_logic_vector(63 downto 0);\n" +
                        "    zeroA : std_logic;\n" +
                        "    zeroB : std_logic;\n" +
                        "    divisor : std_logic_vector(52 downto 0);\n" +
                        "    preShift : std_logic_vector(5 downto 0);\n" +
                        "    expAB : std_logic_vector(12 downto 0);\n" +
                        "    expAlign : std_logic_vector(11 downto 0);\n" +
                        "    mantAlign : std_logic_vector(104 downto 0);\n" +
                        "    postShift : std_logic_vector(11 downto 0);\n" +
                        "    mantPostScale : std_logic_vector(104 downto 0);\n" +
                        "    nanRes : std_logic;\n" +
                        "    overflow : std_logic;\n" +
                        "    underflow : std_logic;\n" +
                        "    illegal_op : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "    '0', (others => '0'),                               -- busy, ena\n" +
                        "    (others => '0'), (others => '0'), (others => '0'),  -- a, b, result\n" +
                        "    '0', '0', (others => '0'), (others => '0'),         -- zeroA, zeroB, divisor, preShift\n" +
                        "    (others => '0'), (others => '0'), (others => '0'),  -- expAB, expAlign, mantAlign\n" +
                        "    (others => '0'), (others => '0'),                   -- postShift, mantPostScale\n" +
                        "    '0', '0', '0', '0'                                  -- nanRes, overflow, underflow, illegal_op\n" +
                        "  );\n" +
                        "\n" +
                        "  constant zero105 : std_logic_vector(104 downto 0) := (others => '0');\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "\n" +
                        "  signal w_idiv_ena : std_logic;\n" +
                        "  signal wb_divident : std_logic_vector(52 downto 0);\n" +
                        "  signal wb_divisor : std_logic_vector(52 downto 0);\n" +
                        "  signal wb_idiv_result : std_logic_vector(104 downto 0);\n" +
                        "  signal wb_idiv_lshift : std_logic_vector(6 downto 0);\n" +
                        "  signal w_idiv_rdy : std_logic;\n" +
                        "  signal w_idiv_overflow : std_logic;\n" +
                        "  signal w_idiv_zeroresid : std_logic;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  u_idiv53 : idiv53 generic map (\n" +
                        "    async_reset => async_reset\n" +
                        "  ) port map (\n" +
                        "    i_nrst => i_nrst,\n" +
                        "    i_clk => i_clk,\n" +
                        "    i_ena => w_idiv_ena,\n" +
                        "    i_divident => wb_divident,\n" +
                        "    i_divisor => wb_divisor,\n" +
                        "    o_result => wb_idiv_result,\n" +
                        "    o_lshift => wb_idiv_lshift,\n" +
                        "    o_rdy => w_idiv_rdy,\n" +
                        "    o_overflow => w_idiv_overflow,\n" +
                        "    o_zero_resid => w_idiv_zeroresid\n" +
                        "  );\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  comb : process(i_nrst, i_ena, i_a, i_b, r,\n" +
                        "                 wb_idiv_result, wb_idiv_lshift, w_idiv_rdy, w_idiv_overflow,\n" +
                        "                 w_idiv_zeroresid)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable signA : std_logic;\n" +
                        "    variable signB : std_logic;\n" +
                        "    variable mantA : std_logic_vector(52 downto 0);\n" +
                        "    variable mantB : std_logic_vector(52 downto 0);\n" +
                        "    variable zeroA : std_logic;\n" +
                        "    variable zeroB : std_logic;\n" +
                        "    variable divisor : std_logic_vector(52 downto 0);\n" +
                        "    variable preShift : integer range 0 to 52;\n" +
                        "    variable expAB_t : std_logic_vector(11 downto 0);\n" +
                        "    variable expAB : std_logic_vector(12 downto 0);\n" +
                        "    variable mantAlign : std_logic_vector(104 downto 0);\n" +
                        "    variable expShift : std_logic_vector(11 downto 0);\n" +
                        "    variable expAlign : std_logic_vector(12 downto 0);\n" +
                        "    variable postShift : std_logic_vector(11 downto 0);\n" +
                        "    variable mantPostScale : std_logic_vector(104 downto 0);\n" +
                        "    variable mantShort : std_logic_vector(52 downto 0);\n" +
                        "    variable tmpMant05 : std_logic_vector(51 downto 0);\n" +
                        "    variable mantOnes : std_logic;\n" +
                        "    variable mantEven : std_logic;\n" +
                        "    variable mant05 : std_logic;\n" +
                        "    variable rndBit : std_logic;\n" +
                        "    variable nanA : std_logic;\n" +
                        "    variable nanB : std_logic;\n" +
                        "    variable mantZeroA : std_logic;\n" +
                        "    variable mantZeroB : std_logic;\n" +
                        "    variable res : std_logic_vector(63 downto 0);\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    v.ena(0) := i_ena and not r.busy;\n" +
                        "    v.ena(1) := r.ena(0);\n" +
                        "    v.ena(4 downto 2) := r.ena(3 downto 2) & w_idiv_rdy;\n" +
                        "\n" +
                        "    if i_ena = '1' then\n" +
                        "        v.busy := '1';\n" +
                        "        v.overflow := '0';\n" +
                        "        v.underflow := '0';\n" +
                        "        v.illegal_op := '0';\n" +
                        "        v.a := i_a;\n" +
                        "        v.b := i_b;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    signA := r.a(63);\n" +
                        "    signB := r.b(63);\n" +
                        "\n" +
                        "    zeroA := '0';\n" +
                        "    if r.a(62 downto 0) = zero105(62 downto 0) then\n" +
                        "        zeroA := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    zeroB := '0';\n" +
                        "    if r.b(62 downto 0) = zero105(62 downto 0) then\n" +
                        "        zeroB := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    mantA(51 downto 0) := r.a(51 downto 0);\n" +
                        "    mantA(52) := '0';\n" +
                        "    if r.a(62 downto 52) /= zero105(10 downto 0) then\n" +
                        "        mantA(52) := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    mantB(51 downto 0) := r.b(51 downto 0);\n" +
                        "    mantB(52) := '0';\n" +
                        "    if r.b(62 downto 52) /= zero105(10 downto 0) then\n" +
                        "        mantB(52) := '1';\n" +
                        "        divisor := mantB;\n" +
                        "        preShift := 0;\n" +
                        "    else\n" +
                        "        divisor := mantB;\n" +
                        "        preShift := 0;\n" +
                        "        for i in 1 to 52 loop\n" +
                        "            if preShift = 0 and mantB(52 - i) = '1' then\n" +
                        "                divisor := mantB(52-i downto 0) & zero105(i-1 downto 0);\n" +
                        "                preShift := i;\n" +
                        "            end if;\n" +
                        "        end loop;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- expA - expB + 1023\n" +
                        "    expAB_t := ('0' & r.a(62 downto 52)) + 1023;\n" +
                        "    expAB := ('0' & expAB_t) - (\"00\" & r.b(62 downto 52));\n" +
                        "\n" +
                        "    if r.ena(0) = '1' then\n" +
                        "        v.divisor := divisor;\n" +
                        "        v.preShift := conv_std_logic_vector(preShift, 6);\n" +
                        "        v.expAB := expAB;\n" +
                        "        v.zeroA := zeroA;\n" +
                        "        v.zeroB := zeroB;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_idiv_ena <= r.ena(1);\n" +
                        "    wb_divident <= mantA;\n" +
                        "    wb_divisor <= r.divisor;\n" +
                        "\n" +
                        "    -- idiv53 module:\n" +
                        "    mantAlign := (others => '0');\n" +
                        "    if wb_idiv_lshift = zero105(6 downto 0) then\n" +
                        "        mantAlign := wb_idiv_result;\n" +
                        "    else\n" +
                        "        for i in 1 to 104 loop\n" +
                        "            if i = conv_integer(wb_idiv_lshift) then\n" +
                        "                mantAlign := wb_idiv_result(104-i downto 0) & zero105(i-1 downto 0);\n" +
                        "            end if;\n" +
                        "        end loop;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    expShift := (\"000000\" & r.preShift) - (\"00000\" & wb_idiv_lshift);\n" +
                        "    if r.b(62 downto 52) = \"00000000000\" and r.a(62 downto 52) /= \"00000000000\" then\n" +
                        "        expShift := expShift - 1;\n" +
                        "    elsif r.b(62 downto 52) /= \"00000000000\" and r.a(62 downto 52) = \"00000000000\" then\n" +
                        "        expShift := expShift + 1;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    expAlign := r.expAB + (expShift(11) & expShift);\n" +
                        "    if expAlign(12) = '1' then\n" +
                        "        postShift := not expAlign(11 downto 0) + 2;\n" +
                        "    else\n" +
                        "        postShift := (others => '0');\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if w_idiv_rdy = '1' then\n" +
                        "        v.expAlign := expAlign(11 downto 0);\n" +
                        "        v.mantAlign := mantAlign;\n" +
                        "        v.postShift := postShift;\n" +
                        "\n" +
                        "        -- Exceptions:\n" +
                        "        v.nanRes := '0';\n" +
                        "        if expAlign = \"0011111111111\" then\n" +
                        "            v.nanRes := '1';\n" +
                        "        end if;\n" +
                        "        v.overflow := not expAlign(12) and expAlign(11);\n" +
                        "        v.underflow := expAlign(12) and expAlign(11);\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Prepare to mantissa post-scale\n" +
                        "    mantPostScale := (others => '0');\n" +
                        "    if r.postShift = X\"000\" then\n" +
                        "        mantPostScale := r.mantAlign;\n" +
                        "    elsif r.postShift < conv_std_logic_vector(105, 12) then\n" +
                        "        for i in 1 to 104 loop\n" +
                        "            if conv_std_logic_vector(i, 7) = r.postShift(6 downto 0) then\n" +
                        "                mantPostScale := zero105(i-1 downto 0) & r.mantAlign(104 downto i);\n" +
                        "            end if;\n" +
                        "        end loop;\n" +
                        "    end if;\n" +
                        "    if r.ena(2) = '1' then\n" +
                        "        v.mantPostScale := mantPostScale;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Rounding bit\n" +
                        "    mantShort := r.mantPostScale(104 downto 52);\n" +
                        "    tmpMant05 := r.mantPostScale(51 downto 0);\n" +
                        "    mantOnes := '0';\n" +
                        "    if mantShort(52) = '1' and mantShort(51 downto 0) = X\"fffffffffffff\" then\n" +
                        "        mantOnes := '1';\n" +
                        "    end if;\n" +
                        "    mantEven := r.mantPostScale(52);\n" +
                        "    mant05 := '0';\n" +
                        "    if tmpMant05 = X\"8000000000000\" then\n" +
                        "        mant05 := '1';\n" +
                        "    end if;\n" +
                        "    rndBit := r.mantPostScale(51) and not(mant05 and not mantEven);\n" +
                        "\n" +
                        "    -- Check Borders\n" +
                        "    nanA := '0';\n" +
                        "    if r.a(62 downto 52) = \"11111111111\" then\n" +
                        "        nanA := '1';\n" +
                        "    end if;\n" +
                        "    nanB := '0';\n" +
                        "    if r.b(62 downto 52) = \"11111111111\" then\n" +
                        "        nanB := '1';\n" +
                        "    end if;\n" +
                        "    mantZeroA := '0';\n" +
                        "    if r.a(51 downto 0) = zero105(51 downto 0) then\n" +
                        "        mantZeroA := '1';\n" +
                        "    end if;\n" +
                        "    mantZeroB := '0';\n" +
                        "    if r.b(51 downto 0) = zero105(51 downto 0) then\n" +
                        "        mantZeroB := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Result multiplexers:\n" +
                        "    if (nanA and mantZeroA and nanB and mantZeroB) = '1' then\n" +
                        "        res(63) := '1';\n" +
                        "    elsif (nanA and not mantZeroA) = '1' then\n" +
                        "        res(63) := signA;\n" +
                        "    elsif (nanB and not mantZeroB) = '1' then\n" +
                        "        res(63) := signB;\n" +
                        "    elsif (r.zeroA and r.zeroB) = '1' then\n" +
                        "        res(63) := '1';\n" +
                        "    else\n" +
                        "        res(63) := r.a(63) xor r.b(63);\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if nanB = '1' and mantZeroB = '0' then\n" +
                        "        res(62 downto 52) := r.b(62 downto 52);\n" +
                        "    elsif (r.underflow or r.zeroA) = '1' and r.zeroB = '0' then\n" +
                        "        res(62 downto 52) := (others => '0');\n" +
                        "    elsif (r.overflow or r.zeroB) = '1' then\n" +
                        "        res(62 downto 52) := (others => '1');\n" +
                        "    elsif nanA = '1' then\n" +
                        "        res(62 downto 52) := r.a(62 downto 52);\n" +
                        "    elsif ((nanB and mantZeroB) or r.expAlign(11)) = '1' then\n" +
                        "        res(62 downto 52) := (others => '0');\n" +
                        "    else\n" +
                        "        res(62 downto 52) := r.expAlign(10 downto 0)\n" +
                        "                       + (mantOnes and rndBit and not r.overflow);\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if (r.zeroA and r.zeroB) = '1'\n" +
                        "        or (nanA and mantZeroA and nanB and mantZeroB) = '1' then\n" +
                        "        res(51) := '1';\n" +
                        "        res(50 downto 0) := (others => '0');\n" +
                        "    elsif nanA = '1' and mantZeroA = '0' then\n" +
                        "        res(51) := '1';\n" +
                        "        res(50 downto 0) := r.a(50 downto 0);\n" +
                        "    elsif nanB = '1' and mantZeroB = '0'then\n" +
                        "        res(51) := '1';\n" +
                        "        res(50 downto 0) := r.b(50 downto 0);\n" +
                        "    elsif r.overflow = '1' or r.nanRes = '1' or (nanA and mantZeroA) = '1'\n" +
                        "          or (nanB and mantZeroB) = '1' then\n" +
                        "        res(51 downto 0) := (others => '0');\n" +
                        "    else\n" +
                        "        res(51 downto 0) := mantShort(51 downto 0) + rndBit;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if r.ena(3) = '1' then\n" +
                        "        v.result := res;\n" +
                        "        v.illegal_op := nanA or nanB;\n" +
                        "        v.busy := '0';\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  o_res <= r.result;\n" +
                        "  o_illegal_op <= r.illegal_op;\n" +
                        "  o_divbyzero <= r.zeroB;\n" +
                        "  o_overflow <= r.overflow;\n" +
                        "  o_underflow <= r.underflow;\n" +
                        "  o_valid <= r.ena(4);\n" +
                        "  o_busy <= r.busy;\n" +
                        "  \n" +
                        "  -- registers:\n" +
                        "  regs : process(i_nrst, i_clk)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
                                new GeneralFunctions().write_file(Project_Folder_File, data);
                            }

    private void generate_fadd_d_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.std_logic_arith.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "\n" +
                        "entity DoubleAdd is \n" +
                        "  generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_nrst       : in std_logic;\n" +
                        "    i_clk        : in std_logic;\n" +
                        "    i_ena        : in std_logic;\n" +
                        "    i_add        : in std_logic;\n" +
                        "    i_sub        : in std_logic;\n" +
                        "    i_eq         : in std_logic;\n" +
                        "    i_lt         : in std_logic;\n" +
                        "    i_le         : in std_logic;\n" +
                        "    i_max        : in std_logic;\n" +
                        "    i_min        : in std_logic;\n" +
                        "    i_a          : in std_logic_vector(63 downto 0);\n" +
                        "    i_b          : in std_logic_vector(63 downto 0);\n" +
                        "    o_res        : out std_logic_vector(63 downto 0);\n" +
                        "    o_illegal_op : out std_logic;\n" +
                        "    o_overflow   : out std_logic;\n" +
                        "    o_valid      : out std_logic;\n" +
                        "    o_busy       : out std_logic\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_DoubleAdd of DoubleAdd is\n" +
                        "\n" +
                        "	component FP_ADD_SUB_64 is\n" +
                        "		port (\n" +
                        "			clk    : in  std_logic                     := '0';             --    clk.clk\n" +
                        "			areset : in  std_logic                     := '0';             -- areset.reset\n" +
                        "			a      : in  std_logic_vector(63 downto 0) := (others => '0'); --      a.a\n" +
                        "			b      : in  std_logic_vector(63 downto 0) := (others => '0'); --      b.b\n" +
                        "			q      : out std_logic_vector(63 downto 0);                    --      q.q\n" +
                        "			opSel  : std_logic_vector(0 downto 0)      := (others => '0')  --  opSel.opSel\n" +
                        "		);\n" +
                        "	end component;\n" +
                        "    \n" +
                        "	component FP_EQ_64 is\n" +
                        "		port (\n" +
                        "			clk    : in  std_logic                     := '0';             --    clk.clk\n" +
                        "			areset : in  std_logic                     := '0';             -- areset.reset\n" +
                        "			a      : in  std_logic_vector(63 downto 0) := (others => '0'); --      a.a\n" +
                        "			b      : in  std_logic_vector(63 downto 0) := (others => '0'); --      b.b\n" +
                        "			q      : out std_logic_vector(0 downto 0)                      --      q.q\n" +
                        "		);\n" +
                        "	end component;\n" +
                        "    \n" +
                        "	component FP_LT_64 is\n" +
                        "		port (\n" +
                        "			clk    : in  std_logic                     := '0';             --    clk.clk\n" +
                        "			areset : in  std_logic                     := '0';             -- areset.reset\n" +
                        "			a      : in  std_logic_vector(63 downto 0) := (others => '0'); --      a.a\n" +
                        "			b      : in  std_logic_vector(63 downto 0) := (others => '0'); --      b.b\n" +
                        "			q      : out std_logic_vector(0 downto 0)                      --      q.q\n" +
                        "		);\n" +
                        "	end component;\n" +
                        "    \n" +
                        "	component FP_LE_64 is\n" +
                        "		port (\n" +
                        "			clk    : in  std_logic                     := '0';             --    clk.clk\n" +
                        "			areset : in  std_logic                     := '0';             -- areset.reset\n" +
                        "			a      : in  std_logic_vector(63 downto 0) := (others => '0'); --      a.a\n" +
                        "			b      : in  std_logic_vector(63 downto 0) := (others => '0'); --      b.b\n" +
                        "			q      : out std_logic_vector(0 downto 0)                      --      q.q\n" +
                        "		);\n" +
                        "	end component;\n" +
                        "    \n" +
                        "	component FP_MAX_64 is\n" +
                        "		port (\n" +
                        "			clk    : in  std_logic                     := '0';             --    clk.clk\n" +
                        "			areset : in  std_logic                     := '0';             -- areset.reset\n" +
                        "			a      : in  std_logic_vector(63 downto 0) := (others => '0'); --      a.a\n" +
                        "			b      : in  std_logic_vector(63 downto 0) := (others => '0'); --      b.b\n" +
                        "			q      : out std_logic_vector(63 downto 0)                     --      q.q\n" +
                        "		);\n" +
                        "	end component;\n" +
                        "\n" +
                        "	signal reset       : std_logic;\n" +
                        "	\n" +
                        "	signal s_o_res     : std_logic_vector(63 downto 0);\n" +
                        "	signal res_add_sub : std_logic_vector(63 downto 0);\n" +
                        "	signal res_eq      : std_logic_vector(0 downto 0);\n" +
                        "	signal res_lt      : std_logic_vector(0 downto 0);\n" +
                        "	signal res_le      : std_logic_vector(0 downto 0);\n" +
                        "	signal res_max     : std_logic_vector(63 downto 0);\n" +
                        "	\n" +
                        "	signal counter_st  : std_logic_vector(3 downto 0);\n" +
                        "	\n" +
                        "	signal en_stage    : std_logic;\n" +
                        "	signal en_add_sub  : std_logic;\n" +
                        "	signal en_eq       : std_logic;\n" +
                        "	signal en_lt       : std_logic;\n" +
                        "	signal en_le       : std_logic;\n" +
                        "	signal en_max_min  : std_logic;\n" +
                        "	\n" +
                        "	signal opSel       : std_logic_vector(0 downto 0);\n" +
                        "	\n" +
                        "	signal s_o_illegal_op : std_logic;\n" +
                        "	\n" +
                        "begin\n" +
                        "\n" +
                        "	reset   <= not(i_nrst);\n" +
                        "	o_res   <= s_o_res;\n" +
                        "\n" +
                        "	en_add_sub <= (en_stage and (i_add or i_sub)) or (i_ena and (i_add or i_sub));\n" +
                        "	en_eq      <= (en_stage and i_eq) or (i_ena and i_eq);\n" +
                        "	en_lt      <= (en_stage and i_lt) or (i_ena and i_lt);\n" +
                        "	en_le      <= (en_stage and i_le) or (i_ena and i_le);\n" +
                        "	en_max_min <= (en_stage and (i_max or i_min)) or (i_ena and (i_max or i_min));\n" +
                        "    \n" +
                        "	opSel(0) <= i_add and not(i_sub);\n" +
                        "    \n" +
                        "	o_overflow   <= '1' when s_o_res(63 downto 52) = X\"7FF\" else -- Not sure of this\n" +
                        "                   '0';\n" +
                        "	s_o_illegal_op <= '1' when (i_a(62 downto 52) = \"11111111111\") or (i_b(62 downto 52) = \"11111111111\") else\n" +
                        "                     '0';\n" +
                        "\n" +
                        "	FP_ADD_SUB_COMP_64 : FP_ADD_SUB_64 \n" +
                        "	port map(\n" +
                        "		clk    => i_clk,\n" +
                        "		areset => reset,\n" +
                        "		a      => i_a,\n" +
                        "		b      => i_b,\n" +
                        "		q      => res_add_sub,\n" +
                        "		opSel  => opSel\n" +
                        "    );\n" +
                        "        \n" +
                        "   FP_EQ_COMP_64 : FP_EQ_64 \n" +
                        "	port map(\n" +
                        "		clk    => i_clk,\n" +
                        "		areset => reset,\n" +
                        "		a      => i_a,\n" +
                        "		b      => i_b,\n" +
                        "		q      => res_eq\n" +
                        "    );\n" +
                        "    \n" +
                        "   FP_LT_COMP_64 : FP_LT_64 \n" +
                        "	port map(\n" +
                        "		clk    => i_clk,\n" +
                        "		areset => reset,\n" +
                        "		a      => i_a,\n" +
                        "		b      => i_b,\n" +
                        "		q      => res_lt\n" +
                        "    );\n" +
                        "    \n" +
                        "   FP_LE_COMP_64 : FP_LE_64 \n" +
                        "	port map(\n" +
                        "		clk    => i_clk,\n" +
                        "		areset => reset,\n" +
                        "		a      => i_a,\n" +
                        "		b      => i_b,\n" +
                        "		q      => res_le\n" +
                        "    );\n" +
                        "    \n" +
                        "   FP_MAX_COMM_64 : FP_MAX_64 \n" +
                        "	port map(\n" +
                        "		clk    => i_clk,\n" +
                        "		areset => reset,\n" +
                        "		a      => i_a,\n" +
                        "		b      => i_b,\n" +
                        "		q      => res_max\n" +
                        "	);\n" +
                        "	\n" +
                        "	process(i_nrst, i_clk)\n" +
                        "	begin\n" +
                        "		if i_nrst = '0' then\n" +
                        "			s_o_res        <= (others => '0');\n" +
                        "			o_valid        <= '0';\n" +
                        "			o_busy         <= '0';\n" +
                        "			o_illegal_op   <= '0';\n" +
                        "			\n" +
                        "			counter_st     <= (others => '0');\n" +
                        "			en_stage       <= '0';\n" +
                        "		elsif rising_edge(i_clk) then\n" +
                        "			if i_ena = '1' then\n" +
                        "				counter_st <= (others => '0');\n" +
                        "				if (i_add or i_sub or en_eq or en_lt or en_le or en_max_min) = '1' then\n" +
                        "					en_stage <= '1';\n" +
                        "					o_busy <= '1';\n" +
                        "				end if;\n" +
                        "			end if;\n" +
                        "			\n" +
                        "			if en_stage = '1' then\n" +
                        "				counter_st <= counter_st + \"0001\";\n" +
                        "				if counter_st = \"0000\" then\n" +
                        "					if en_eq = '1' then\n" +
                        "						o_valid <= '1';\n" +
                        "						o_illegal_op <= s_o_illegal_op;\n" +
                        "						o_busy <= '0';\n" +
                        "						s_o_res <= X\"000000000000000\"&\"000\"&res_eq(0);\n" +
                        "					elsif en_lt = '1' then\n" +
                        "						o_valid <= '1';\n" +
                        "						o_illegal_op <= s_o_illegal_op;\n" +
                        "						o_busy <= '0';\n" +
                        "						s_o_res <= X\"000000000000000\"&\"000\"&res_lt(0);\n" +
                        "					elsif en_le = '1' then\n" +
                        "						o_valid <= '1';\n" +
                        "						o_illegal_op <= s_o_illegal_op;\n" +
                        "						o_busy <= '0';\n" +
                        "						s_o_res <= X\"000000000000000\"&\"000\"&res_le(0);\n" +
                        "					elsif en_max_min = '1' and i_max = '1' then\n" +
                        "						o_valid <= '1';\n" +
                        "						o_illegal_op <= s_o_illegal_op;\n" +
                        "						o_busy <= '0';\n" +
                        "						s_o_res <= res_max;\n" +
                        "					elsif en_max_min = '1' and i_min = '1' then\n" +
                        "						o_valid <= '1';\n" +
                        "						o_illegal_op <= s_o_illegal_op;\n" +
                        "						o_busy <= '0';\n" +
                        "						if res_max = i_a then\n" +
                        "							s_o_res <= i_b;\n" +
                        "						else\n" +
                        "							s_o_res <= i_a;\n" +
                        "						end if;\n" +
                        "					end if;\n" +
                        "				elsif counter_st = \"0001\" and (en_eq or en_lt or en_le or en_max_min) = '1' then\n" +
                        "					en_stage <= '0';\n" +
                        "					o_valid <= '0';\n" +
                        "				elsif counter_st = \"1000\" and en_add_sub = '1' then\n" +
                        "					s_o_res <= res_add_sub;\n" +
                        "					o_valid <= '1';\n" +
                        "					o_illegal_op <= s_o_illegal_op;\n" +
                        "					o_busy <= '0';\n" +
                        "				elsif counter_st = \"1001\" and en_add_sub = '1' then\n" +
                        "					en_stage <= '0';\n" +
                        "					o_valid <= '0';\n" +
                        "				end if;\n" +
                        "			end if;\n" +
                        "		end if;\n" +
                        "    end process;\n" +
                        "\n" +
                        "end;";
                                new GeneralFunctions().write_file(Project_Folder_File, data);
                            }

    private void generate_divstage53_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "\n" +
                        "entity divstage53 is \n" +
                        "  port (\n" +
                        "    i_mux_ena    : in std_logic;  -- find first non-zero bit\n" +
                        "    i_muxind     : in std_logic_vector(55 downto 0);  -- bits indexes 8x7 bits bus\n" +
                        "    i_divident   : in std_logic_vector(60 downto 0);  -- integer value\n" +
                        "    i_divisor    : in std_logic_vector(52 downto 0);  -- integer value\n" +
                        "    o_dif        : out std_logic_vector(52 downto 0); -- residual value\n" +
                        "    o_bits       : out std_logic_vector(7 downto 0);  -- resulting bits\n" +
                        "    o_muxind     : out std_logic_vector(6 downto 0);  -- first found non-zero bit\n" +
                        "    o_muxind_rdy : out std_logic                      -- seeking was successfull\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_divstage53 of divstage53 is\n" +
                        "\n" +
                        "  type thresh_type is array (15 downto 0) of std_logic_vector(61 downto 0);\n" +
                        "  type dif_type is array (3 downto 0) of std_logic_vector(60 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  comb : process(i_mux_ena, i_muxind, i_divident, i_divisor)\n" +
                        "    variable wb_thresh : thresh_type;\n" +
                        "    variable wb_dif : dif_type;\n" +
                        "    variable wb_bits : std_logic_vector(7 downto 0);\n" +
                        "    variable wb_divx3 : std_logic_vector(54 downto 0);\n" +
                        "    variable wb_divx2 : std_logic_vector(54 downto 0);\n" +
                        "    variable wb_muxind : std_logic_vector(6 downto 0);\n" +
                        "    variable w_muxind_rdy : std_logic;\n" +
                        "  begin\n" +
                        "    wb_divx2 := '0' & i_divisor & '0';\n" +
                        "    wb_divx3 := wb_divx2 + (\"00\" & i_divisor);\n" +
                        "\n" +
                        "    -- stage 1 of 4\n" +
                        "    wb_thresh(15) := ('0' & i_divident) - ('0' & wb_divx3 & \"000000\");\n" +
                        "    wb_thresh(14) := ('0' & i_divident) - ('0' & wb_divx2 & \"000000\");\n" +
                        "    wb_thresh(13) := ('0' & i_divident) - (\"000\" & i_divisor & \"000000\");\n" +
                        "    wb_thresh(12) := ('0' & i_divident);\n" +
                        "\n" +
                        "    if wb_thresh(15)(61) = '0' then\n" +
                        "        wb_bits(7 downto 6) := \"11\";\n" +
                        "        wb_dif(0) := wb_thresh(15)(60 downto 0);\n" +
                        "    elsif wb_thresh(14)(61) = '0' then\n" +
                        "        wb_bits(7 downto 6) := \"10\";\n" +
                        "        wb_dif(0) := wb_thresh(14)(60 downto 0);\n" +
                        "    elsif wb_thresh(13)(61) = '0' then\n" +
                        "        wb_bits(7 downto 6) := \"01\";\n" +
                        "        wb_dif(0) := wb_thresh(13)(60 downto 0);\n" +
                        "    else\n" +
                        "        wb_bits(7 downto 6) := \"00\";\n" +
                        "        wb_dif(0) := wb_thresh(12)(60 downto 0);\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- stage 2 of 4\n" +
                        "    wb_thresh(11) := ('0' & wb_dif(0)) - (\"000\" & wb_divx3 & \"0000\");\n" +
                        "    wb_thresh(10) := ('0' & wb_dif(0)) - (\"000\" & wb_divx2 & \"0000\");\n" +
                        "    wb_thresh(9) := ('0' & wb_dif(0)) - (\"00000\" & i_divisor & \"0000\");\n" +
                        "    wb_thresh(8) := ('0' & wb_dif(0));\n" +
                        "\n" +
                        "    if wb_thresh(11)(61) = '0' then\n" +
                        "        wb_bits(5 downto 4) := \"11\";\n" +
                        "        wb_dif(1) := wb_thresh(11)(60 downto 0);\n" +
                        "    elsif wb_thresh(10)(61) = '0' then\n" +
                        "        wb_bits(5 downto 4) := \"10\";\n" +
                        "        wb_dif(1) := wb_thresh(10)(60 downto 0);\n" +
                        "    elsif wb_thresh(9)(61) = '0' then\n" +
                        "        wb_bits(5 downto 4) := \"01\";\n" +
                        "        wb_dif(1) := wb_thresh(9)(60 downto 0);\n" +
                        "    else\n" +
                        "        wb_bits(5 downto 4) := \"00\";\n" +
                        "        wb_dif(1) := wb_thresh(8)(60 downto 0);\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- stage 3 of 4\n" +
                        "    wb_thresh(7) := ('0' & wb_dif(1)) - (\"00000\" & wb_divx3 & \"00\");\n" +
                        "    wb_thresh(6) := ('0' & wb_dif(1)) - (\"00000\" & wb_divx2 & \"00\");\n" +
                        "    wb_thresh(5) := ('0' & wb_dif(1)) - (\"0000000\" & i_divisor & \"00\");\n" +
                        "    wb_thresh(4) := ('0' & wb_dif(1));\n" +
                        "\n" +
                        "    if wb_thresh(7)(61) = '0' then\n" +
                        "        wb_bits(3 downto 2) := \"11\";\n" +
                        "        wb_dif(2) := wb_thresh(7)(60 downto 0);\n" +
                        "    elsif wb_thresh(6)(61) = '0' then\n" +
                        "        wb_bits(3 downto 2) := \"10\";\n" +
                        "        wb_dif(2) := wb_thresh(6)(60 downto 0);\n" +
                        "    elsif wb_thresh(5)(61) = '0' then\n" +
                        "        wb_bits(3 downto 2) := \"01\";\n" +
                        "        wb_dif(2) := wb_thresh(5)(60 downto 0);\n" +
                        "    else\n" +
                        "        wb_bits(3 downto 2) := \"00\";\n" +
                        "        wb_dif(2) := wb_thresh(4)(60 downto 0);\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- stage 4 of 4\n" +
                        "    wb_thresh(3) := ('0' & wb_dif(2)) - (\"0000000\" & wb_divx3);\n" +
                        "    wb_thresh(2) := ('0' & wb_dif(2)) - (\"0000000\" & wb_divx2);\n" +
                        "    wb_thresh(1) := ('0' & wb_dif(2)) - (\"000000000\" & i_divisor);\n" +
                        "    wb_thresh(0) := ('0' & wb_dif(2));\n" +
                        "\n" +
                        "    if wb_thresh(3)(61) = '0' then\n" +
                        "        wb_bits(1 downto 0) := \"11\";\n" +
                        "        wb_dif(3) := wb_thresh(3)(60 downto 0);\n" +
                        "    elsif wb_thresh(2)(61) = '0' then\n" +
                        "        wb_bits(1 downto 0) := \"10\";\n" +
                        "        wb_dif(3) := wb_thresh(2)(60 downto 0);\n" +
                        "    elsif wb_thresh(1)(61) = '0' then\n" +
                        "        wb_bits(1 downto 0) := \"01\";\n" +
                        "        wb_dif(3) := wb_thresh(1)(60 downto 0);\n" +
                        "    else\n" +
                        "        wb_bits(1 downto 0) := \"00\";\n" +
                        "        wb_dif(3) := wb_thresh(0)(60 downto 0);\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Number multiplexor\n" +
                        "    wb_muxind := (others => '0');\n" +
                        "    if i_mux_ena = '1' then\n" +
                        "        if wb_thresh(15)(61) = '0' then\n" +
                        "            wb_muxind := i_muxind(55 downto 49);\n" +
                        "        elsif wb_thresh(14)(61) = '0' then\n" +
                        "            wb_muxind := i_muxind(55 downto 49);\n" +
                        "        elsif wb_thresh(13)(61) = '0' then\n" +
                        "            wb_muxind := i_muxind(48 downto 42);\n" +
                        "        elsif wb_thresh(11)(61) = '0' then\n" +
                        "            wb_muxind := i_muxind(41 downto 35);\n" +
                        "        elsif wb_thresh(10)(61) = '0' then\n" +
                        "            wb_muxind := i_muxind(41 downto 35);\n" +
                        "        elsif wb_thresh(9)(61) = '0' then\n" +
                        "            wb_muxind := i_muxind(34 downto 28);\n" +
                        "        elsif wb_thresh(7)(61) = '0' then\n" +
                        "            wb_muxind := i_muxind(27 downto 21);\n" +
                        "        elsif wb_thresh(6)(61) = '0' then\n" +
                        "            wb_muxind := i_muxind(27 downto 21);\n" +
                        "        elsif wb_thresh(5)(61) = '0' then\n" +
                        "            wb_muxind := i_muxind(20 downto 14);\n" +
                        "        elsif wb_thresh(3)(61) = '0' then\n" +
                        "            wb_muxind := i_muxind(13 downto 7);\n" +
                        "        elsif wb_thresh(2)(61) = '0' then\n" +
                        "            wb_muxind := i_muxind(13 downto 7);\n" +
                        "        elsif wb_thresh(1)(61) = '0' then\n" +
                        "            wb_muxind := i_muxind(6 downto 0);\n" +
                        "        else\n" +
                        "            wb_muxind := i_muxind(6 downto 0);\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    w_muxind_rdy := '0';\n" +
                        "    if i_mux_ena = '1' and wb_bits /= X\"00\" then\n" +
                        "        w_muxind_rdy := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    o_bits <= wb_bits;\n" +
                        "    o_dif <= wb_dif(3)(52 downto 0);\n" +
                        "    o_muxind <= wb_muxind;\n" +
                        "    o_muxind_rdy <= w_muxind_rdy;\n" +
                        "\n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
                                new GeneralFunctions().write_file(Project_Folder_File, data);
                            }

    private void generate_d2l_d_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "\n" +
                        "entity Double2Long is \n" +
                        "  generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_nrst       : in std_logic;\n" +
                        "    i_clk        : in std_logic;\n" +
                        "    i_ena        : in std_logic;\n" +
                        "    i_signed     : in std_logic;\n" +
                        "    i_w32        : in std_logic;\n" +
                        "    i_a          : in std_logic_vector(63 downto 0);\n" +
                        "    o_res        : out std_logic_vector(63 downto 0);\n" +
                        "    o_overflow   : out std_logic;\n" +
                        "    o_underflow  : out std_logic;\n" +
                        "    o_valid      : out std_logic;\n" +
                        "    o_busy       : out std_logic\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_Double2Long of Double2Long is\n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "    busy : std_logic;\n" +
                        "    ena : std_logic_vector(2 downto 0);\n" +
                        "    signA : std_logic;\n" +
                        "    expA : std_logic_vector(10 downto 0);\n" +
                        "    mantA : std_logic_vector(52 downto 0);\n" +
                        "    result : std_logic_vector(63 downto 0);\n" +
                        "    op_signed : std_logic;\n" +
                        "    w32 : std_logic;\n" +
                        "    mantPostScale : std_logic_vector(63 downto 0);\n" +
                        "    overflow : std_logic;\n" +
                        "    underflow : std_logic;\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "    '0', (others => '0'),                      -- busy, ena\n" +
                        "    '0', (others => '0'), (others => '0'),     -- signA, expA, mantA\n" +
                        "    (others => '0'), '0', '0',                 -- result, op_signed, w32\n" +
                        "    (others => '0'), '0', '0'                  -- mantPostScale, overflow, underflow\n" +
                        "  );\n" +
                        "\n" +
                        "  constant zero64 : std_logic_vector(63 downto 0) := (others => '0');\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  comb : process(i_nrst, i_ena, i_signed, i_w32, i_a, r)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable expDif : std_logic_vector(11 downto 0);\n" +
                        "    variable mantPreScale : std_logic_vector(63 downto 0);\n" +
                        "    variable mantPostScale : std_logic_vector(63 downto 0);\n" +
                        "    variable mantA : std_logic_vector(52 downto 0);\n" +
                        "    variable expDif_gr : std_logic;  -- greater than 1023 + 63\n" +
                        "    variable expDif_lt : std_logic;  -- less than 1023\n" +
                        "    variable overflow : std_logic;\n" +
                        "    variable underflow : std_logic;\n" +
                        "    variable expMax : std_logic_vector(10 downto 0);\n" +
                        "    variable expShift : std_logic_vector(5 downto 0);\n" +
                        "    variable resSign : std_logic;\n" +
                        "    variable resMant : std_logic_vector(63 downto 0);\n" +
                        "    variable res : std_logic_vector(63 downto 0);\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    v.ena := r.ena(1 downto 0) & (i_ena and not r.busy);\n" +
                        "\n" +
                        "    mantA(51 downto 0) := i_a(51 downto 0);\n" +
                        "    mantA(52) := '0';\n" +
                        "    if i_a(62 downto 52) /= zero64(10 downto 0) then\n" +
                        "        mantA(52) := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if i_ena = '1' then\n" +
                        "        v.busy := '1';\n" +
                        "        v.signA := i_a(63);\n" +
                        "        v.expA := i_a(62 downto 52);\n" +
                        "        v.mantA := mantA;\n" +
                        "        v.op_signed := i_signed;\n" +
                        "        v.w32 := i_w32;\n" +
                        "        v.overflow := '0';\n" +
                        "        v.underflow := '0';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- expShift = (1086 - expA)[5:0]\n" +
                        "    expShift := \"111110\" - r.expA(5 downto 0);\n" +
                        "    if r.w32 = '1' then\n" +
                        "        if r.op_signed = '1' then\n" +
                        "            expMax := conv_std_logic_vector(1053, 11);\n" +
                        "        else\n" +
                        "            expMax := conv_std_logic_vector(1085, 11);\n" +
                        "        end if;\n" +
                        "    else\n" +
                        "        if r.op_signed = '1' or r.signA = '1' then\n" +
                        "            expMax := conv_std_logic_vector(1085, 11);\n" +
                        "        else\n" +
                        "            expMax := conv_std_logic_vector(1086, 11);\n" +
                        "        end if;\n" +
                        "     end if;\n" +
                        "\n" +
                        "    expDif := ('0' & expMax) - ('0' & r.expA);\n" +
                        "    expDif_gr := expDif(11);\n" +
                        "    expDif_lt := '0';\n" +
                        "    if r.expA /= \"01111111111\" and r.expA(10) = '0' then\n" +
                        "        expDif_lt := '1';\n" +
                        "    end if;\n" +
                        "\n" +
                        "    mantPreScale := r.mantA & \"00000000000\";\n" +
                        "\n" +
                        "    mantPostScale := (others => '0');\n" +
                        "    if expDif_gr = '1' then\n" +
                        "        overflow := '1';\n" +
                        "        underflow := '0';\n" +
                        "    elsif expDif_lt = '1' then\n" +
                        "        overflow := '0';\n" +
                        "        underflow := '1';\n" +
                        "    else\n" +
                        "        overflow := '0';\n" +
                        "        underflow := '0';\n" +
                        "        -- Multiplexer, probably switch case in rtl\n" +
                        "        if expShift = \"000000\" then\n" +
                        "            mantPostScale := mantPreScale;\n" +
                        "        else\n" +
                        "            for i in 1 to 63 loop\n" +
                        "                if conv_integer(expShift) = i then\n" +
                        "                    mantPostScale := zero64(i-1 downto 0) & mantPreScale(63 downto i);\n" +
                        "                end if;\n" +
                        "            end loop;\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if r.ena(0) = '1' then\n" +
                        "        v.overflow := overflow;\n" +
                        "        v.underflow := underflow;\n" +
                        "        v.mantPostScale := mantPostScale;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    -- Result multiplexers:\n" +
                        "    resSign := (r.signA or r.overflow) and not r.underflow;\n" +
                        "    if r.signA = '1' then\n" +
                        "        resMant := not r.mantPostScale + 1;\n" +
                        "    else\n" +
                        "        resMant := r.mantPostScale;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    res := resMant;\n" +
                        "    if r.op_signed = '1' then\n" +
                        "        if resSign = '1' then\n" +
                        "            if r.w32 = '1' then\n" +
                        "                res(63 downto 31) := (others => '1');\n" +
                        "            else\n" +
                        "                res(63) := '1';\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    else\n" +
                        "        if r.w32 = '1' then\n" +
                        "            res(63 downto 32) := (others => '0');\n" +
                        "        elsif r.overflow = '1' then\n" +
                        "            res(63) := '1';\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if r.ena(1) = '1' then\n" +
                        "        v.result := res;\n" +
                        "        v.busy := '0';\n" +
                        "    end if;\n" +
                        "\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  o_res <= r.result;\n" +
                        "  o_overflow <= r.overflow;\n" +
                        "  o_underflow <= r.underflow;\n" +
                        "  o_valid <= r.ena(2);\n" +
                        "  o_busy <= r.busy;\n" +
                        "  \n" +
                        "  -- registers:\n" +
                        "  regs : process(i_nrst, i_clk)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_d2s_d_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "\n" +
                        "entity Double2Single is \n" +
                        "  generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_nrst       : in std_logic;\n" +
                        "    i_clk        : in std_logic;\n" +
                        "    i_ena        : in std_logic;\n" +
                        "    i_signed     : in std_logic;\n" +
                        "    i_w32        : in std_logic;\n" +
                        "    i_a          : in std_logic_vector(63 downto 0);\n" +
                        "    o_res        : out std_logic_vector(63 downto 0);\n" +
                        "    o_overflow   : out std_logic;\n" +
                        "    o_underflow  : out std_logic;\n" +
                        "    o_valid      : out std_logic;\n" +
                        "    o_busy       : out std_logic\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_Double2Single of Double2Single is\n" +
                        "\n" +
                        "	component FP_D2S is\n" +
                        "		port (\n" +
                        "			clk    : in  std_logic                     := '0';             --    clk.clk\n" +
                        "			areset : in  std_logic                     := '0';             -- areset.reset\n" +
                        "			a      : in  std_logic_vector(63 downto 0) := (others => '0'); --      a.a\n" +
                        "			q      : out std_logic_vector(31 downto 0)                     --      q.q\n" +
                        "		);\n" +
                        "	end component;\n" +
                        "	\n" +
                        "	signal reset    : std_logic;\n" +
                        "	signal o_res_32 : std_logic_vector(31 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "	reset   <= not(i_nrst);\n" +
                        "	o_overflow  <= '0';\n" +
                        "	o_underflow <= '0';\n" +
                        "	\n" +
                        "	FP_D2S_COMP : FP_D2S \n" +
                        "	port map(\n" +
                        "		clk    => i_clk,\n" +
                        "		areset => reset,\n" +
                        "		a      => i_a,\n" +
                        "		q      => o_res_32\n" +
                        "   );\n" +
                        "	 \n" +
                        "	o_res(31 downto 0 ) <= o_res_32;\n" +
                        "	o_res(63 downto 32) <= (others => '0');\n" +
                        "	o_busy              <= '0';\n" +
                        "\n" +
                        "	process(i_nrst, i_clk)\n" +
                        "	begin\n" +
                        "		if i_nrst = '0' then\n" +
                        "			o_valid <= '0';\n" +
                        "		elsif rising_edge(i_clk) then\n" +
                        "			if i_ena = '1' then\n" +
                        "				o_valid <= '1';\n" +
                        "			else\n" +
                        "				o_valid <= '0';\n" +
                        "			end if;\n" +
                        "		end if;\n" +
                        "    end process;\n" +
                        "\n" +
                        "  \n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_s2d_d_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "\n" +
                        "entity Single2Double is \n" +
                        "  generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_nrst       : in std_logic;\n" +
                        "    i_clk        : in std_logic;\n" +
                        "    i_ena        : in std_logic;\n" +
                        "    i_signed     : in std_logic;\n" +
                        "    i_w32        : in std_logic;\n" +
                        "    i_a          : in std_logic_vector(63 downto 0);\n" +
                        "    o_res        : out std_logic_vector(63 downto 0);\n" +
                        "    o_overflow   : out std_logic;\n" +
                        "    o_underflow  : out std_logic;\n" +
                        "    o_valid      : out std_logic;\n" +
                        "    o_busy       : out std_logic\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_Single2Double of Single2Double is\n" +
                        "\n" +
                        "	component FP_S2D is\n" +
                        "		port (\n" +
                        "			clk    : in  std_logic                     := '0';             --    clk.clk\n" +
                        "			areset : in  std_logic                     := '0';             -- areset.reset\n" +
                        "			a      : in  std_logic_vector(31 downto 0) := (others => '0'); --      a.a\n" +
                        "			q      : out std_logic_vector(63 downto 0)                     --      q.q\n" +
                        "		);\n" +
                        "	end component;\n" +
                        "	\n" +
                        "	signal reset  : std_logic;\n" +
                        "	signal i_a_32 : std_logic_vector(31 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "	reset   <= not(i_nrst);\n" +
                        "	o_overflow  <= '0';\n" +
                        "	o_underflow <= '0';\n" +
                        "	o_busy <= '0';\n" +
                        "	\n" +
                        "	FP_S2D_COMP : FP_S2D \n" +
                        "	port map(\n" +
                        "		clk    => i_clk,\n" +
                        "		areset => reset,\n" +
                        "		a      => i_a_32,\n" +
                        "		q      => o_res\n" +
                        "   );\n" +
                        "	 \n" +
                        "	i_a_32 <= i_a(31 downto 0);\n" +
                        "\n" +
                        "	process(i_nrst, i_clk)\n" +
                        "	begin\n" +
                        "		if i_nrst = '0' then\n" +
                        "			o_valid     <= '0';\n" +
                        "		elsif rising_edge(i_clk) then\n" +
                        "			if i_ena = '1' then\n" +
                        "				o_valid <= '1';\n" +
                        "			else\n" +
                        "				o_valid <= '0';\n" +
                        "			end if;\n" +
                        "		end if;\n" +
                        "    end process;\n" +
                        "\n" +
                        "  \n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_shift_vhd_file(String Project_Folder_File) {
        String data =   "-----------------------------------------------------------------------------\n" +
                        "--! @file\n" +
                        "--! @copyright Copyright 2016 GNSS Sensor Ltd. All right reserved.\n" +
                        "--! @author    Sergey Khabarov - sergeykhbr@gmail.com\n" +
                        "--! @brief     Left/Right shifter arithmetic/logic 32/64 bits.\n" +
                        "--! \n" +
                        "--! @details   Vivado synthesizer (2016.2) doesn't support shift\n" +
                        "--!            from dynamic value, so implement this mux.\n" +
                        "------------------------------------------------------------------------------\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use riverlib.river_cfg.all;\n" +
                        "\n" +
                        "\n" +
                        "entity Shifter is\n" +
                        "  port (\n" +
                        "    i_a1 : in std_logic_vector(RISCV_ARCH-1 downto 0);     -- Operand 1\n" +
                        "    i_a2 : in std_logic_vector(5 downto 0);                -- Shift bits number\n" +
                        "    o_sll : out std_logic_vector(RISCV_ARCH-1 downto 0);   -- Logical shift left 64-bits operand\n" +
                        "    o_sllw : out std_logic_vector(RISCV_ARCH-1 downto 0);  -- Logical shift left 32-bits operand\n" +
                        "    o_srl : out std_logic_vector(RISCV_ARCH-1 downto 0);   -- Logical shift 64 bits\n" +
                        "    o_sra : out std_logic_vector(RISCV_ARCH-1 downto 0);   -- Arith. shift 64 bits\n" +
                        "    o_srlw : out std_logic_vector(RISCV_ARCH-1 downto 0);  -- Logical shift 32 bits\n" +
                        "    o_sraw : out std_logic_vector(RISCV_ARCH-1 downto 0)   -- Arith. shift 32 bits\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_Shifter of Shifter is\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  comb : process(i_a1, i_a2)\n" +
                        "    variable wb_sll : std_logic_vector(63 downto 0);\n" +
                        "    variable wb_srl : std_logic_vector(63 downto 0);\n" +
                        "    variable wb_sra : std_logic_vector(63 downto 0);\n" +
                        "    variable wb_srlw : std_logic_vector(31 downto 0);\n" +
                        "    variable wb_sraw : std_logic_vector(63 downto 0);\n" +
                        "    variable v64 : std_logic_vector(63 downto 0);\n" +
                        "    variable v32 : std_logic_vector(31 downto 0);\n" +
                        "    variable msk64 : std_logic_vector(63 downto 0);\n" +
                        "    variable msk32 : std_logic_vector(63 downto 0);\n" +
                        "    variable shift64 : integer range 0 to 63;\n" +
                        "    variable shift32 : integer range 0 to 31;\n" +
                        "  begin\n" +
                        "\n" +
                        "    v64 := i_a1;\n" +
                        "    v32 := i_a1(31 downto 0);\n" +
                        "    msk64 := (others => i_a1(63));\n" +
                        "    msk32 := (others => i_a1(31));\n" +
                        "    shift64 := conv_integer(i_a2);\n" +
                        "    shift32 := conv_integer(i_a2(4 downto 0));\n" +
                        "\n" +
                        "    case shift64 is\n" +
                        "    when 0 =>\n" +
                        "        wb_sll := v64;\n" +
                        "        wb_srl := v64;\n" +
                        "        wb_sra := v64;\n" +
                        "    when 1 =>\n" +
                        "        wb_sll := v64(62 downto 0) & \"0\";\n" +
                        "        wb_srl := \"0\" & v64(63 downto 1);\n" +
                        "        wb_sra := (msk64(63 downto 63) & v64(63 downto 1));\n" +
                        "    when 2 =>\n" +
                        "        wb_sll := v64(61 downto 0) & \"00\";\n" +
                        "        wb_srl := \"00\" & v64(63 downto 2);\n" +
                        "        wb_sra := (msk64(63 downto 62) & v64(63 downto 2));\n" +
                        "    when 3 =>\n" +
                        "        wb_sll := v64(60 downto 0) & \"000\";\n" +
                        "        wb_srl := \"000\" & v64(63 downto 3);\n" +
                        "        wb_sra := (msk64(63 downto 61) & v64(63 downto 3));\n" +
                        "    when 4 =>\n" +
                        "        wb_sll := v64(59 downto 0) & X\"0\";\n" +
                        "        wb_srl := X\"0\" & v64(63 downto 4);\n" +
                        "        wb_sra := (msk64(63 downto 60) & v64(63 downto 4));\n" +
                        "    when 5 =>\n" +
                        "        wb_sll := v64(58 downto 0) & X\"0\" & \"0\";\n" +
                        "        wb_srl :=  X\"0\" & \"0\" & v64(63 downto 5);\n" +
                        "        wb_sra := (msk64(63 downto 59) & v64(63 downto 5));\n" +
                        "    when 6 =>\n" +
                        "        wb_sll := v64(57 downto 0) & X\"0\" & \"00\";\n" +
                        "        wb_srl := X\"0\" & \"00\" & v64(63 downto 6);\n" +
                        "        wb_sra := (msk64(63 downto 58) & v64(63 downto 6));\n" +
                        "    when 7 =>\n" +
                        "        wb_sll := v64(56 downto 0) & X\"0\" & \"000\";\n" +
                        "        wb_srl := X\"0\" & \"000\" & v64(63 downto 7);\n" +
                        "        wb_sra := (msk64(63 downto 57) & v64(63 downto 7));\n" +
                        "    when 8 =>\n" +
                        "        wb_sll := v64(55 downto 0) & X\"00\";\n" +
                        "        wb_srl := X\"00\" & v64(63 downto 8);\n" +
                        "        wb_sra := (msk64(63 downto 56) & v64(63 downto 8));\n" +
                        "    when 9 =>\n" +
                        "        wb_sll := v64(54 downto 0) & X\"00\" & \"0\";\n" +
                        "        wb_srl := X\"00\" & \"0\" & v64(63 downto 9);\n" +
                        "        wb_sra := (msk64(63 downto 55) & v64(63 downto 9));\n" +
                        "    when 10 =>\n" +
                        "        wb_sll := v64(53 downto 0) & X\"00\" & \"00\";\n" +
                        "        wb_srl := X\"00\" & \"00\" & v64(63 downto 10);\n" +
                        "        wb_sra := (msk64(63 downto 54) & v64(63 downto 10));\n" +
                        "    when 11 =>\n" +
                        "        wb_sll := v64(52 downto 0) & X\"00\" & \"000\";\n" +
                        "        wb_srl := X\"00\" & \"000\" & v64(63 downto 11);\n" +
                        "        wb_sra := (msk64(63 downto 53) & v64(63 downto 11));\n" +
                        "    when 12 =>\n" +
                        "        wb_sll := v64(51 downto 0) & X\"000\";\n" +
                        "        wb_srl := X\"000\" & v64(63 downto 12);\n" +
                        "        wb_sra := (msk64(63 downto 52) & v64(63 downto 12));\n" +
                        "    when 13 =>\n" +
                        "        wb_sll := v64(50 downto 0) & X\"000\" & \"0\";\n" +
                        "        wb_srl := X\"000\" & \"0\" & v64(63 downto 13);\n" +
                        "        wb_sra := (msk64(63 downto 51) & v64(63 downto 13));\n" +
                        "    when 14 =>\n" +
                        "        wb_sll := v64(49 downto 0) & X\"000\" & \"00\";\n" +
                        "        wb_srl := X\"000\" & \"00\" & v64(63 downto 14);\n" +
                        "        wb_sra := (msk64(63 downto 50) & v64(63 downto 14));\n" +
                        "    when 15 =>\n" +
                        "        wb_sll := v64(48 downto 0) & X\"000\" & \"000\";\n" +
                        "        wb_srl := X\"000\" & \"000\" & v64(63 downto 15);\n" +
                        "        wb_sra := (msk64(63 downto 49) & v64(63 downto 15));\n" +
                        "    when 16 =>\n" +
                        "        wb_sll := v64(47 downto 0) & X\"0000\";\n" +
                        "        wb_srl := X\"0000\" & v64(63 downto 16);\n" +
                        "        wb_sra := (msk64(63 downto 48) & v64(63 downto 16));\n" +
                        "    when 17 =>\n" +
                        "        wb_sll := v64(46 downto 0) & X\"0000\" & \"0\";\n" +
                        "        wb_srl := X\"0000\" & \"0\" & v64(63 downto 17);\n" +
                        "        wb_sra := (msk64(63 downto 47) & v64(63 downto 17));\n" +
                        "    when 18 =>\n" +
                        "        wb_sll := v64(45 downto 0) & X\"0000\" & \"00\";\n" +
                        "        wb_srl := X\"0000\" & \"00\" & v64(63 downto 18);\n" +
                        "        wb_sra := (msk64(63 downto 46) & v64(63 downto 18));\n" +
                        "    when 19 =>\n" +
                        "        wb_sll := v64(44 downto 0) & X\"0000\" & \"000\";\n" +
                        "        wb_srl := X\"0000\" & \"000\" & v64(63 downto 19);\n" +
                        "        wb_sra := (msk64(63 downto 45) & v64(63 downto 19));\n" +
                        "    when 20 =>\n" +
                        "        wb_sll := v64(43 downto 0) & X\"00000\";\n" +
                        "        wb_srl := X\"00000\" & v64(63 downto 20);\n" +
                        "        wb_sra := (msk64(63 downto 44) & v64(63 downto 20));\n" +
                        "    when 21 =>\n" +
                        "        wb_sll := v64(42 downto 0) & X\"00000\" & \"0\";\n" +
                        "        wb_srl := X\"00000\" & \"0\" & v64(63 downto 21);\n" +
                        "        wb_sra := (msk64(63 downto 43) & v64(63 downto 21));\n" +
                        "    when 22 =>\n" +
                        "        wb_sll := v64(41 downto 0) & X\"00000\" & \"00\";\n" +
                        "        wb_srl := X\"00000\" & \"00\" & v64(63 downto 22);\n" +
                        "        wb_sra := (msk64(63 downto 42) & v64(63 downto 22));\n" +
                        "    when 23 =>\n" +
                        "        wb_sll := v64(40 downto 0) & X\"00000\" & \"000\";\n" +
                        "        wb_srl := X\"00000\" & \"000\" & v64(63 downto 23);\n" +
                        "        wb_sra := (msk64(63 downto 41) & v64(63 downto 23));\n" +
                        "    when 24 =>\n" +
                        "        wb_sll := v64(39 downto 0) & X\"000000\";\n" +
                        "        wb_srl := X\"000000\" & v64(63 downto 24);\n" +
                        "        wb_sra := (msk64(63 downto 40) & v64(63 downto 24));\n" +
                        "    when 25 =>\n" +
                        "        wb_sll := v64(38 downto 0) & X\"000000\" & \"0\";\n" +
                        "        wb_srl := X\"000000\" & \"0\" & v64(63 downto 25);\n" +
                        "        wb_sra := (msk64(63 downto 39) & v64(63 downto 25));\n" +
                        "    when 26 =>\n" +
                        "        wb_sll := v64(37 downto 0) & X\"000000\" & \"00\";\n" +
                        "        wb_srl := X\"000000\" & \"00\" & v64(63 downto 26);\n" +
                        "        wb_sra := (msk64(63 downto 38) & v64(63 downto 26));\n" +
                        "    when 27 =>\n" +
                        "        wb_sll := v64(36 downto 0) & X\"000000\" & \"000\";\n" +
                        "        wb_srl := X\"000000\" & \"000\" & v64(63 downto 27);\n" +
                        "        wb_sra := (msk64(63 downto 37) & v64(63 downto 27));\n" +
                        "    when 28 =>\n" +
                        "        wb_sll := v64(35 downto 0) & X\"0000000\";\n" +
                        "        wb_srl := X\"0000000\" & v64(63 downto 28);\n" +
                        "        wb_sra := (msk64(63 downto 36) & v64(63 downto 28));\n" +
                        "    when 29 =>\n" +
                        "        wb_sll := v64(34 downto 0) & X\"0000000\" & \"0\";\n" +
                        "        wb_srl := X\"0000000\" & \"0\" & v64(63 downto 29);\n" +
                        "        wb_sra := (msk64(63 downto 35) & v64(63 downto 29));\n" +
                        "    when 30 =>\n" +
                        "        wb_sll := v64(33 downto 0) & X\"0000000\" & \"00\";\n" +
                        "        wb_srl := X\"0000000\" & \"00\" & v64(63 downto 30);\n" +
                        "        wb_sra := (msk64(63 downto 34) & v64(63 downto 30));\n" +
                        "    when 31 =>\n" +
                        "        wb_sll := v64(32 downto 0) & X\"0000000\" & \"000\";\n" +
                        "        wb_srl := X\"0000000\" & \"000\" & v64(63 downto 31);\n" +
                        "        wb_sra := (msk64(63 downto 33) & v64(63 downto 31));\n" +
                        "    when 32 =>\n" +
                        "        wb_sll := v64(31 downto 0) & X\"00000000\";\n" +
                        "        wb_srl := X\"00000000\" & v64(63 downto 32);\n" +
                        "        wb_sra := (msk64(63 downto 32) & v64(63 downto 32));\n" +
                        "    when 33 =>\n" +
                        "        wb_sll := v64(30 downto 0) & X\"00000000\" & \"0\";\n" +
                        "        wb_srl := X\"00000000\" & \"0\" & v64(63 downto 33);\n" +
                        "        wb_sra := (msk64(63 downto 31) & v64(63 downto 33));\n" +
                        "    when 34 =>\n" +
                        "        wb_sll := v64(29 downto 0) & X\"00000000\" & \"00\";\n" +
                        "        wb_srl := X\"00000000\" & \"00\" & v64(63 downto 34);\n" +
                        "        wb_sra := (msk64(63 downto 30) & v64(63 downto 34));\n" +
                        "    when 35 =>\n" +
                        "        wb_sll := v64(28 downto 0) & X\"00000000\" & \"000\";\n" +
                        "        wb_srl := X\"00000000\" & \"000\" & v64(63 downto 35);\n" +
                        "        wb_sra := (msk64(63 downto 29) & v64(63 downto 35));\n" +
                        "    when 36 =>\n" +
                        "        wb_sll := v64(27 downto 0) & X\"000000000\";\n" +
                        "        wb_srl := X\"000000000\" & v64(63 downto 36);\n" +
                        "        wb_sra := (msk64(63 downto 28) & v64(63 downto 36));\n" +
                        "    when 37 =>\n" +
                        "        wb_sll := v64(26 downto 0) & X\"000000000\" & \"0\";\n" +
                        "        wb_srl := X\"000000000\" & \"0\" & v64(63 downto 37);\n" +
                        "        wb_sra := (msk64(63 downto 27) & v64(63 downto 37));\n" +
                        "    when 38 =>\n" +
                        "        wb_sll := v64(25 downto 0) & X\"000000000\" & \"00\";\n" +
                        "        wb_srl := X\"000000000\" & \"00\" & v64(63 downto 38);\n" +
                        "        wb_sra := (msk64(63 downto 26) & v64(63 downto 38));\n" +
                        "    when 39 =>\n" +
                        "        wb_sll := v64(24 downto 0) & X\"000000000\" & \"000\";\n" +
                        "        wb_srl := X\"000000000\" & \"000\" & v64(63 downto 39);\n" +
                        "        wb_sra := (msk64(63 downto 25) & v64(63 downto 39));\n" +
                        "    when 40 =>\n" +
                        "        wb_sll := v64(23 downto 0) & X\"0000000000\";\n" +
                        "        wb_srl := X\"0000000000\" & v64(63 downto 40);\n" +
                        "        wb_sra := (msk64(63 downto 24) & v64(63 downto 40));\n" +
                        "    when 41 =>\n" +
                        "        wb_sll := v64(22 downto 0) & X\"0000000000\" & \"0\";\n" +
                        "        wb_srl := X\"0000000000\" & \"0\" & v64(63 downto 41);\n" +
                        "        wb_sra := (msk64(63 downto 23) & v64(63 downto 41));\n" +
                        "    when 42 =>\n" +
                        "        wb_sll := v64(21 downto 0) & X\"0000000000\" & \"00\";\n" +
                        "        wb_srl := X\"0000000000\" & \"00\" & v64(63 downto 42);\n" +
                        "        wb_sra := (msk64(63 downto 22) & v64(63 downto 42));\n" +
                        "    when 43 =>\n" +
                        "        wb_sll := v64(20 downto 0) & X\"0000000000\" & \"000\";\n" +
                        "        wb_srl := X\"0000000000\" & \"000\" & v64(63 downto 43);\n" +
                        "        wb_sra := (msk64(63 downto 21) & v64(63 downto 43));\n" +
                        "    when 44 =>\n" +
                        "        wb_sll := v64(19 downto 0) & X\"00000000000\";\n" +
                        "        wb_srl := X\"00000000000\" & v64(63 downto 44);\n" +
                        "        wb_sra := (msk64(63 downto 20) & v64(63 downto 44));\n" +
                        "    when 45 =>\n" +
                        "        wb_sll := v64(18 downto 0) & X\"00000000000\" & \"0\";\n" +
                        "        wb_srl := X\"00000000000\" & \"0\" & v64(63 downto 45);\n" +
                        "        wb_sra := (msk64(63 downto 19) & v64(63 downto 45));\n" +
                        "    when 46 =>\n" +
                        "        wb_sll := v64(17 downto 0) & X\"00000000000\" & \"00\";\n" +
                        "        wb_srl := X\"00000000000\" & \"00\" & v64(63 downto 46);\n" +
                        "        wb_sra := (msk64(63 downto 18) & v64(63 downto 46));\n" +
                        "    when 47 =>\n" +
                        "        wb_sll := v64(16 downto 0) & X\"00000000000\" & \"000\";\n" +
                        "        wb_srl := X\"00000000000\" & \"000\" & v64(63 downto 47);\n" +
                        "        wb_sra := (msk64(63 downto 17) & v64(63 downto 47));\n" +
                        "    when 48 =>\n" +
                        "        wb_sll := v64(15 downto 0) & X\"000000000000\";\n" +
                        "        wb_srl := X\"000000000000\" & v64(63 downto 48);\n" +
                        "        wb_sra := (msk64(63 downto 16) & v64(63 downto 48));\n" +
                        "    when 49 =>\n" +
                        "        wb_sll := v64(14 downto 0) & X\"000000000000\" & \"0\";\n" +
                        "        wb_srl := X\"000000000000\" & \"0\" & v64(63 downto 49);\n" +
                        "        wb_sra := (msk64(63 downto 15) & v64(63 downto 49));\n" +
                        "    when 50 =>\n" +
                        "        wb_sll := v64(13 downto 0) & X\"000000000000\" & \"00\";\n" +
                        "        wb_srl := X\"000000000000\" & \"00\" & v64(63 downto 50);\n" +
                        "        wb_sra := (msk64(63 downto 14) & v64(63 downto 50));\n" +
                        "    when 51 =>\n" +
                        "        wb_sll := v64(12 downto 0) & X\"000000000000\" & \"000\";\n" +
                        "        wb_srl := X\"000000000000\" & \"000\" & v64(63 downto 51);\n" +
                        "        wb_sra := (msk64(63 downto 13) & v64(63 downto 51));\n" +
                        "    when 52 =>\n" +
                        "        wb_sll := v64(11 downto 0) & X\"0000000000000\";\n" +
                        "        wb_srl := X\"0000000000000\" & v64(63 downto 52);\n" +
                        "        wb_sra := (msk64(63 downto 12) & v64(63 downto 52));\n" +
                        "    when 53 =>\n" +
                        "        wb_sll := v64(10 downto 0) & X\"0000000000000\" & \"0\";\n" +
                        "        wb_srl := X\"0000000000000\" & \"0\" & v64(63 downto 53);\n" +
                        "        wb_sra := (msk64(63 downto 11) & v64(63 downto 53));\n" +
                        "    when 54 =>\n" +
                        "        wb_sll := v64(9 downto 0) & X\"0000000000000\" & \"00\";\n" +
                        "        wb_srl := X\"0000000000000\" & \"00\" & v64(63 downto 54);\n" +
                        "        wb_sra := (msk64(63 downto 10) & v64(63 downto 54));\n" +
                        "    when 55 =>\n" +
                        "        wb_sll := v64(8 downto 0) & X\"0000000000000\" & \"000\";\n" +
                        "        wb_srl := X\"0000000000000\" & \"000\" & v64(63 downto 55);\n" +
                        "        wb_sra := (msk64(63 downto 9) & v64(63 downto 55));\n" +
                        "    when 56 =>\n" +
                        "        wb_sll := v64(7 downto 0) & X\"00000000000000\";\n" +
                        "        wb_srl := X\"00000000000000\" & v64(63 downto 56);\n" +
                        "        wb_sra := (msk64(63 downto 8) & v64(63 downto 56));\n" +
                        "    when 57 =>\n" +
                        "        wb_sll := v64(6 downto 0) & X\"00000000000000\" & \"0\";\n" +
                        "        wb_srl := X\"00000000000000\" & \"0\" & v64(63 downto 57);\n" +
                        "        wb_sra := (msk64(63 downto 7) & v64(63 downto 57));\n" +
                        "    when 58 =>\n" +
                        "        wb_sll := v64(5 downto 0) & X\"00000000000000\" & \"00\";\n" +
                        "        wb_srl := X\"00000000000000\" & \"00\" & v64(63 downto 58);\n" +
                        "        wb_sra := (msk64(63 downto 6) & v64(63 downto 58));\n" +
                        "    when 59 =>\n" +
                        "        wb_sll := v64(4 downto 0) & X\"00000000000000\" & \"000\";\n" +
                        "        wb_srl := X\"00000000000000\" & \"000\" & v64(63 downto 59);\n" +
                        "        wb_sra := (msk64(63 downto 5) & v64(63 downto 59));\n" +
                        "    when 60 =>\n" +
                        "        wb_sll := v64(3 downto 0) & X\"000000000000000\";\n" +
                        "        wb_srl := X\"000000000000000\" & v64(63 downto 60);\n" +
                        "        wb_sra := (msk64(63 downto 4) & v64(63 downto 60));\n" +
                        "    when 61 =>\n" +
                        "        wb_sll := v64(2 downto 0) & X\"000000000000000\" & \"0\";\n" +
                        "        wb_srl := X\"000000000000000\" & \"0\" & v64(63 downto 61);\n" +
                        "        wb_sra := (msk64(63 downto 3) & v64(63 downto 61));\n" +
                        "    when 62 =>\n" +
                        "        wb_sll := v64(1 downto 0) & X\"000000000000000\" & \"00\";\n" +
                        "        wb_srl := X\"000000000000000\" & \"00\" & v64(63 downto 62);\n" +
                        "        wb_sra := (msk64(63 downto 2) & v64(63 downto 62));\n" +
                        "    when 63 =>\n" +
                        "        wb_sll := v64(0) & X\"000000000000000\" & \"000\";\n" +
                        "        wb_srl := X\"000000000000000\" & \"000\" & v64(63);\n" +
                        "        wb_sra := (msk64(63 downto 1) & v64(63));\n" +
                        "    end case;\n" +
                        "\n" +
                        "    case shift32 is\n" +
                        "    when 0 =>\n" +
                        "        wb_srlw := v32;\n" +
                        "        wb_sraw := (msk32(63 downto 32) & v32);\n" +
                        "    when 1 =>\n" +
                        "        wb_srlw := \"0\" & v32(31 downto 1);\n" +
                        "        wb_sraw := (msk32(63 downto 31) & v32(31 downto 1));\n" +
                        "    when 2 =>\n" +
                        "        wb_srlw := \"00\" & v32(31 downto 2);\n" +
                        "        wb_sraw := (msk32(63 downto 30) & v32(31 downto 2));\n" +
                        "    when 3 =>\n" +
                        "        wb_srlw := \"000\" & v32(31 downto 3);\n" +
                        "        wb_sraw := (msk32(63 downto 29) & v32(31 downto 3));\n" +
                        "    when 4 =>\n" +
                        "        wb_srlw := X\"0\" & v32(31 downto 4);\n" +
                        "        wb_sraw := (msk32(63 downto 28) & v32(31 downto 4));\n" +
                        "    when 5 =>\n" +
                        "        wb_srlw := X\"0\" & \"0\" & v32(31 downto 5);\n" +
                        "        wb_sraw := (msk32(63 downto 27) & v32(31 downto 5));\n" +
                        "    when 6 =>\n" +
                        "        wb_srlw := X\"0\" & \"00\" & v32(31 downto 6);\n" +
                        "        wb_sraw := (msk32(63 downto 26) & v32(31 downto 6));\n" +
                        "    when 7 =>\n" +
                        "        wb_srlw := X\"0\" & \"000\" & v32(31 downto 7);\n" +
                        "        wb_sraw := (msk32(63 downto 25) & v32(31 downto 7));\n" +
                        "    when 8 =>\n" +
                        "        wb_srlw := X\"00\" & v32(31 downto 8);\n" +
                        "        wb_sraw := (msk32(63 downto 24) & v32(31 downto 8));\n" +
                        "    when 9 =>\n" +
                        "        wb_srlw := X\"00\" & \"0\" & v32(31 downto 9);\n" +
                        "        wb_sraw := (msk32(63 downto 23) & v32(31 downto 9));\n" +
                        "    when 10 =>\n" +
                        "        wb_srlw := X\"00\" & \"00\" & v32(31 downto 10);\n" +
                        "        wb_sraw := (msk32(63 downto 22) & v32(31 downto 10));\n" +
                        "    when 11 =>\n" +
                        "        wb_srlw := X\"00\" & \"000\" & v32(31 downto 11);\n" +
                        "        wb_sraw := (msk32(63 downto 21) & v32(31 downto 11));\n" +
                        "    when 12 =>\n" +
                        "        wb_srlw := X\"000\" & v32(31 downto 12);\n" +
                        "        wb_sraw := (msk32(63 downto 20) & v32(31 downto 12));\n" +
                        "    when 13 =>\n" +
                        "        wb_srlw := X\"000\" & \"0\" & v32(31 downto 13);\n" +
                        "        wb_sraw := (msk32(63 downto 19) & v32(31 downto 13));\n" +
                        "    when 14 =>\n" +
                        "        wb_srlw := X\"000\" & \"00\" & v32(31 downto 14);\n" +
                        "        wb_sraw := (msk32(63 downto 18) & v32(31 downto 14));\n" +
                        "    when 15 =>\n" +
                        "        wb_srlw := X\"000\" & \"000\" & v32(31 downto 15);\n" +
                        "        wb_sraw := (msk32(63 downto 17) & v32(31 downto 15));\n" +
                        "    when 16 =>\n" +
                        "        wb_srlw := X\"0000\" & v32(31 downto 16);\n" +
                        "        wb_sraw := (msk32(63 downto 16) & v32(31 downto 16));\n" +
                        "    when 17 =>\n" +
                        "        wb_srlw := X\"0000\" & \"0\" & v32(31 downto 17);\n" +
                        "        wb_sraw := (msk32(63 downto 15) & v32(31 downto 17));\n" +
                        "    when 18 =>\n" +
                        "        wb_srlw := X\"0000\" & \"00\" & v32(31 downto 18);\n" +
                        "        wb_sraw := (msk32(63 downto 14) & v32(31 downto 18));\n" +
                        "    when 19 =>\n" +
                        "        wb_srlw := X\"0000\" & \"000\" & v32(31 downto 19);\n" +
                        "        wb_sraw := (msk32(63 downto 13) & v32(31 downto 19));\n" +
                        "    when 20 =>\n" +
                        "        wb_srlw := X\"00000\" & v32(31 downto 20);\n" +
                        "        wb_sraw := (msk32(63 downto 12) & v32(31 downto 20));\n" +
                        "    when 21 =>\n" +
                        "        wb_srlw := X\"00000\" & \"0\" & v32(31 downto 21);\n" +
                        "        wb_sraw := (msk32(63 downto 11) & v32(31 downto 21));\n" +
                        "    when 22 =>\n" +
                        "        wb_srlw := X\"00000\" & \"00\" & v32(31 downto 22);\n" +
                        "        wb_sraw := (msk32(63 downto 10) & v32(31 downto 22));\n" +
                        "    when 23 =>\n" +
                        "        wb_srlw := X\"00000\" & \"000\" & v32(31 downto 23);\n" +
                        "        wb_sraw := (msk32(63 downto 9) & v32(31 downto 23));\n" +
                        "    when 24 =>\n" +
                        "        wb_srlw := X\"000000\" & v32(31 downto 24);\n" +
                        "        wb_sraw := (msk32(63 downto 8) & v32(31 downto 24));\n" +
                        "    when 25 =>\n" +
                        "        wb_srlw := X\"000000\" & \"0\" & v32(31 downto 25);\n" +
                        "        wb_sraw := (msk32(63 downto 7) & v32(31 downto 25));\n" +
                        "    when 26 =>\n" +
                        "        wb_srlw := X\"000000\" & \"00\" & v32(31 downto 26);\n" +
                        "        wb_sraw := (msk32(63 downto 6) & v32(31 downto 26));\n" +
                        "    when 27 =>\n" +
                        "        wb_srlw := X\"000000\" & \"000\" & v32(31 downto 27);\n" +
                        "        wb_sraw := (msk32(63 downto 5) & v32(31 downto 27));\n" +
                        "    when 28 =>\n" +
                        "        wb_srlw := X\"0000000\" & v32(31 downto 28);\n" +
                        "        wb_sraw := (msk32(63 downto 4) & v32(31 downto 28));\n" +
                        "    when 29 =>\n" +
                        "        wb_srlw := X\"0000000\" & \"0\" & v32(31 downto 29);\n" +
                        "        wb_sraw := (msk32(63 downto 3) & v32(31 downto 29));\n" +
                        "    when 30 =>\n" +
                        "        wb_srlw := X\"0000000\" & \"00\" & v32(31 downto 30);\n" +
                        "        wb_sraw := (msk32(63 downto 2) & v32(31 downto 30));\n" +
                        "    when 31 =>\n" +
                        "        wb_srlw := X\"0000000\" & \"000\" & v32(31 downto 31);\n" +
                        "        wb_sraw := (msk32(63 downto 1) & v32(31 downto 31));\n" +
                        "    end case;\n" +
                        "\n" +
                        "    o_sll <= wb_sll;\n" +
                        "    o_sllw(31 downto 0) <= wb_sll(31 downto 0);\n" +
                        "    o_sllw(63 downto 32) <= (others => wb_sll(31));\n" +
                        "    o_srl <= wb_srl;\n" +
                        "    o_sra <= wb_sra;\n" +
                        "    o_srlw <= X\"00000000\" & wb_srlw;\n" +
                        "    o_sraw <= wb_sraw;\n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_int_div_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use riverlib.river_cfg.all;\n" +
                        "\n" +
                        "\n" +
                        "entity IntDiv is generic (\n" +
                        "    async_reset : boolean := false\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk  : in std_logic;\n" +
                        "    i_nrst : in std_logic;                               -- Reset Active LOW\n" +
                        "    i_ena : in std_logic;                                -- Enable bit\n" +
                        "    i_unsigned : in std_logic;                           -- Unsigned operands\n" +
                        "    i_rv32 : in std_logic;                               -- 32-bits operands enable\n" +
                        "    i_residual : in std_logic;                           -- Compute: 0 =division; 1=residual\n" +
                        "    i_a1 : in std_logic_vector(RISCV_ARCH-1 downto 0);   -- Operand 1\n" +
                        "    i_a2 : in std_logic_vector(RISCV_ARCH-1 downto 0);   -- Operand 1\n" +
                        "    o_res : out std_logic_vector(RISCV_ARCH-1 downto 0); -- Result\n" +
                        "    o_valid : out std_logic;                             -- Result is valid\n" +
                        "    o_busy : out std_logic                               -- Multiclock instruction under processing\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_IntDiv of IntDiv is\n" +
                        "\n" +
                        "  component divstage64 is \n" +
                        "  port (\n" +
                        "    i_divident   : in std_logic_vector(63 downto 0);  -- integer value\n" +
                        "    i_divisor    : in std_logic_vector(123 downto 0); -- integer value\n" +
                        "    o_resid      : out std_logic_vector(63 downto 0); -- residual value\n" +
                        "    o_bits       : out std_logic_vector(3 downto 0)   -- resulting bits\n" +
                        "  );\n" +
                        "  end component; \n" +
                        "\n" +
                        "  type RegistersType is record\n" +
                        "      rv32 : std_logic;\n" +
                        "      resid : std_logic;                           -- Compute residual flag\n" +
                        "      invert : std_logic;                          -- invert result value before output\n" +
                        "      busy : std_logic;\n" +
                        "      ena : std_logic_vector(9 downto 0);\n" +
                        "      divident_i : std_logic_vector(63 downto 0);\n" +
                        "      divisor_i : std_logic_vector(119 downto 0);\n" +
                        "      bits_i : std_logic_vector(63 downto 0);\n" +
                        "      result : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "  end record;\n" +
                        "\n" +
                        "  constant R_RESET : RegistersType := (\n" +
                        "      '0', '0', '0', '0',                -- rv32, resid, invert, busy\n" +
                        "      (others => '0'), (others => '0'),  -- ena, divident_i\n" +
                        "      (others => '0'), (others => '0'),  -- divisor_i, bits_i\n" +
                        "      (others => '0')                    -- result\n" +
                        "  );\n" +
                        "\n" +
                        "  signal r, rin : RegistersType;\n" +
                        "\n" +
                        "  signal wb_divisor0_i : std_logic_vector(123 downto 0);\n" +
                        "  signal wb_divisor1_i : std_logic_vector(123 downto 0);\n" +
                        "  signal wb_resid0_o : std_logic_vector(63 downto 0);\n" +
                        "  signal wb_resid1_o : std_logic_vector(63 downto 0);\n" +
                        "  signal wb_bits0_o : std_logic_vector(3 downto 0);\n" +
                        "  signal wb_bits1_o : std_logic_vector(3 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  stage0 : divstage64 port map (\n" +
                        "    i_divident => r.divident_i,\n" +
                        "    i_divisor => wb_divisor0_i,\n" +
                        "    o_bits => wb_bits0_o,\n" +
                        "    o_resid => wb_resid0_o\n" +
                        "  );\n" +
                        "\n" +
                        "  stage1 : divstage64 port map (\n" +
                        "    i_divident => wb_resid0_o,\n" +
                        "    i_divisor => wb_divisor1_i,\n" +
                        "    o_bits => wb_bits1_o,\n" +
                        "    o_resid => wb_resid1_o\n" +
                        "  );\n" +
                        "\n" +
                        "  comb : process(i_nrst, i_ena, i_unsigned, i_residual, i_rv32, i_a1, i_a2, r,\n" +
                        "                 wb_resid0_o, wb_resid1_o, wb_bits0_o, wb_bits1_o)\n" +
                        "    variable v : RegistersType;\n" +
                        "    variable wb_a1 : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable wb_a2 : std_logic_vector(RISCV_ARCH-1 downto 0);\n" +
                        "    variable w_invert64 : std_logic;\n" +
                        "    variable w_invert32 : std_logic;\n" +
                        "  begin\n" +
                        "\n" +
                        "    v := r;\n" +
                        "\n" +
                        "    w_invert64 := '0';\n" +
                        "    w_invert32 := '0';\n" +
                        "\n" +
                        "    if i_rv32 = '1' then\n" +
                        "        wb_a1(63 downto 32) := (others => '0');\n" +
                        "        wb_a2(63 downto 32) := (others => '0');\n" +
                        "        if i_unsigned = '1' or i_a1(31) = '0' then\n" +
                        "            wb_a1(31 downto 0) := i_a1(31 downto 0);\n" +
                        "        else\n" +
                        "            wb_a1(31 downto 0) := (not i_a1(31 downto 0)) + 1;\n" +
                        "        end if;\n" +
                        "        if i_unsigned = '1' or i_a2(31) = '0' then\n" +
                        "            wb_a2(31 downto 0) := i_a2(31 downto 0);\n" +
                        "        else\n" +
                        "            wb_a2(31 downto 0) := (not i_a2(31 downto 0)) + 1;\n" +
                        "        end if;\n" +
                        "    else\n" +
                        "        if i_unsigned = '1' or i_a1(63) = '0' then\n" +
                        "            wb_a1 := i_a1;\n" +
                        "        else\n" +
                        "            wb_a1 := (not i_a1) + 1;\n" +
                        "        end if;\n" +
                        "        if i_unsigned = '1' or i_a2(63) = '0' then\n" +
                        "            wb_a2 := i_a2;\n" +
                        "        else\n" +
                        "            wb_a2 := (not i_a2) + 1;\n" +
                        "        end if;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    v.ena := r.ena(8 downto 0) & (i_ena and not r.busy);\n" +
                        "\n" +
                        "\n" +
                        "    if i_ena = '1' then\n" +
                        "        v.busy := '1';\n" +
                        "        v.rv32 := i_rv32;\n" +
                        "        v.resid := i_residual;\n" +
                        "\n" +
                        "        v.divident_i := wb_a1;\n" +
                        "        v.divisor_i := wb_a2 & X\"00000000000000\";\n" +
                        "\n" +
                        "        w_invert32 := not i_unsigned and\n" +
                        "                ((not i_residual and (i_a1(31) xor i_a2(31)))\n" +
                        "                or (i_residual and i_a1(31)));\n" +
                        "        w_invert64 := not i_unsigned and\n" +
                        "                ((not i_residual and (i_a1(63) xor i_a2(63)))\n" +
                        "                or (i_residual and i_a1(63)));\n" +
                        "        v.invert := (not i_rv32 and w_invert64) \n" +
                        "                or (i_rv32 and w_invert32);\n" +
                        "    elsif r.ena(8) = '1' then\n" +
                        "        v.busy := '0';\n" +
                        "        if r.resid = '1' then\n" +
                        "            if r.invert = '1' then\n" +
                        "                v.result := (not r.divident_i) + 1;\n" +
                        "            else\n" +
                        "                v.result := r.divident_i;\n" +
                        "            end if;\n" +
                        "        else\n" +
                        "            if r.invert = '1' then\n" +
                        "                v.result := (not r.bits_i) + 1;\n" +
                        "            else\n" +
                        "                v.result := r.bits_i;\n" +
                        "            end if;\n" +
                        "        end if;\n" +
                        "    elsif r.busy = '1' then\n" +
                        "        v.divident_i := wb_resid1_o;\n" +
                        "        v.divisor_i := X\"00\" & r.divisor_i(119 downto 8);\n" +
                        "        v.bits_i := r.bits_i(55 downto 0) & wb_bits0_o & wb_bits1_o;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    if not async_reset and i_nrst = '0' then\n" +
                        "        v := R_RESET;\n" +
                        "    end if;\n" +
                        "\n" +
                        "    wb_divisor0_i <= r.divisor_i & \"0000\";\n" +
                        "    wb_divisor1_i <= \"0000\" & r.divisor_i;\n" +
                        "\n" +
                        "    o_res <= r.result;\n" +
                        "    o_valid <= r.ena(9);\n" +
                        "    o_busy <= r.busy;\n" +
                        "    \n" +
                        "    rin <= v;\n" +
                        "  end process;\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  regs : process(i_clk, i_nrst)\n" +
                        "  begin \n" +
                        "     if async_reset and i_nrst = '0' then\n" +
                        "        r <= R_RESET;\n" +
                        "     elsif rising_edge(i_clk) then \n" +
                        "        r <= rin;\n" +
                        "     end if; \n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_int_mul_cyclone_v_vhd_file(String Project_Folder_File) {
        String data =   "-----------------------------------------------------------------------------\n" +
                        "--! @file\n" +
                        "--! @copyright Copyright 2016 GNSS Sensor Ltd. All right reserved.\n" +
                        "--! @author    Sergey Khabarov - sergeykhbr@gmail.com\n" +
                        "--! @brief     Integer multiplier.\n" +
                        "--! @details   Implemented algorithm provides 4 clocks per instruction\n" +
                        "------------------------------------------------------------------------------\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "--! RIVER CPU specific library.\n" +
                        "library riverlib;\n" +
                        "--! RIVER CPU configuration constants.\n" +
                        "use riverlib.river_cfg.all;\n" +
                        "LIBRARY lpm;\n" +
                        "USE lpm.all;\n" +
                        "\n" +
                        "entity IntMulCycloneV is generic (\n" +
                        "    async_reset : boolean\n" +
                        "  );\n" +
                        "  port (\n" +
                        "    i_clk  : in std_logic;\n" +
                        "    i_nrst : in std_logic;\n" +
                        "    i_ena : in std_logic;                                -- Enable bit\n" +
                        "    i_unsigned : in std_logic;                           -- Unsigned operands\n" +
                        "    i_high : in std_logic;                               -- High multiplied bits [127:64]\n" +
                        "    i_rv32 : in std_logic;                               -- 32-bits operands enable\n" +
                        "    i_a1 : in std_logic_vector(RISCV_ARCH-1 downto 0);   -- Operand 1\n" +
                        "    i_a2 : in std_logic_vector(RISCV_ARCH-1 downto 0);   -- Operand 1\n" +
                        "    o_res : out std_logic_vector(RISCV_ARCH-1 downto 0); -- Result\n" +
                        "    o_valid : out std_logic;                             -- Result is valid\n" +
                        "    o_busy : out std_logic                               -- Multiclock instruction under processing\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_IntMulCycloneV of IntMulCycloneV is\n" +
                        "\n" +
                        "	COMPONENT lpm_mult\n" +
                        "	GENERIC (\n" +
                        "		lpm_hint		: STRING;\n" +
                        "		lpm_representation		: STRING;\n" +
                        "		lpm_type		: STRING;\n" +
                        "		lpm_widtha		: NATURAL;\n" +
                        "		lpm_widthb		: NATURAL;\n" +
                        "		lpm_widthp		: NATURAL\n" +
                        "	);\n" +
                        "	PORT (\n" +
                        "			dataa	: IN STD_LOGIC_VECTOR (63 DOWNTO 0);\n" +
                        "			datab	: IN STD_LOGIC_VECTOR (63 DOWNTO 0);\n" +
                        "			result	: OUT STD_LOGIC_VECTOR (127 DOWNTO 0)\n" +
                        "	);\n" +
                        "	END COMPONENT;\n" +
                        "\n" +
                        "	signal result_s	: std_logic_vector ((RISCV_ARCH*2)-1 DOWNTO 0);\n" +
                        "	\n" +
                        "begin\n" +
                        "\n" +
                        "	lpm_mult_component : lpm_mult\n" +
                        "	GENERIC MAP (\n" +
                        "		lpm_hint => \"MAXIMIZE_SPEED=1\",\n" +
                        "		lpm_representation => \"SIGNED\",\n" +
                        "		lpm_type => \"LPM_MULT\",\n" +
                        "		lpm_widtha => 64,\n" +
                        "		lpm_widthb => 64,\n" +
                        "		lpm_widthp => 128\n" +
                        "	)\n" +
                        "	PORT MAP (\n" +
                        "		dataa => i_a1,\n" +
                        "		datab => i_a2,\n" +
                        "		result => result_s\n" +
                        "	);\n" +
                        "  \n" +
                        "	-- registers:\n" +
                        "	regs : process(i_clk, i_nrst)\n" +
                        "	begin \n" +
                        "		if async_reset and i_nrst = '0' then\n" +
                        "			o_res <= (others => '0');\n" +
                        "			o_valid <= '0';\n" +
                        "		elsif rising_edge(i_clk) then\n" +
                        "			if i_ena = '1' then\n" +
                        "				o_res <= result_s(RISCV_ARCH-1 DOWNTO 0);\n" +
                        "				o_valid <= '1';\n" +
                        "			else\n" +
                        "				o_valid <= '0';\n" +
                        "			end if;\n" +
                        "		end if; \n" +
                        "	end process;\n" +
                        "	\n" +
                        "	o_busy <= '0';\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_divstage64_vhd_file(String Project_Folder_File) {
        String data =   "--!\n" +
                        "--! Copyright 2019 Sergey Khabarov, sergeykhbr@gmail.com\n" +
                        "--!\n" +
                        "--! Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
                        "--! you may not use this file except in compliance with the License.\n" +
                        "--! You may obtain a copy of the License at\n" +
                        "--!\n" +
                        "--!     http://www.apache.org/licenses/LICENSE-2.0\n" +
                        "--!\n" +
                        "--! Unless required by applicable law or agreed to in writing, software\n" +
                        "--! distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
                        "--! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
                        "--! See the License for the specific language governing permissions and\n" +
                        "--! limitations under the License.\n" +
                        "--!\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.std_logic_misc.all;  -- or_reduce()\n" +
                        "library commonlib;\n" +
                        "use commonlib.types_common.all;\n" +
                        "\n" +
                        "entity divstage64 is \n" +
                        "  port (\n" +
                        "    i_divident   : in std_logic_vector(63 downto 0);  -- integer value\n" +
                        "    i_divisor    : in std_logic_vector(123 downto 0); -- integer value\n" +
                        "    o_resid      : out std_logic_vector(63 downto 0); -- residual value\n" +
                        "    o_bits       : out std_logic_vector(3 downto 0)   -- resulting bits\n" +
                        "  );\n" +
                        "end; \n" +
                        " \n" +
                        "architecture arch_divstage64 of divstage64 is\n" +
                        "\n" +
                        "  type thresh_type is array (15 downto 0) of std_logic_vector(65 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "  -- registers:\n" +
                        "  comb : process(i_divident, i_divisor)\n" +
                        "    variable wb_thresh : thresh_type;\n" +
                        "    variable wb_dif : std_logic_vector(63 downto 0);\n" +
                        "    variable wb_bits : std_logic_vector(3 downto 0);\n" +
                        "    variable wb_divident : std_logic_vector(64 downto 0);\n" +
                        "    variable wb_divx1 : std_logic_vector(64 downto 0);\n" +
                        "    variable wb_divx2 : std_logic_vector(64 downto 0);\n" +
                        "    variable wb_divx3 : std_logic_vector(64 downto 0);\n" +
                        "    variable wb_divx4 : std_logic_vector(64 downto 0);\n" +
                        "    variable wb_divx5 : std_logic_vector(64 downto 0);\n" +
                        "    variable wb_divx6 : std_logic_vector(64 downto 0);\n" +
                        "    variable wb_divx7 : std_logic_vector(64 downto 0);\n" +
                        "    variable wb_divx8 : std_logic_vector(64 downto 0);\n" +
                        "    variable wb_divx9 : std_logic_vector(64 downto 0);\n" +
                        "    variable wb_divx10 : std_logic_vector(64 downto 0);\n" +
                        "    variable wb_divx11 : std_logic_vector(64 downto 0);\n" +
                        "    variable wb_divx12 : std_logic_vector(64 downto 0);\n" +
                        "    variable wb_divx13 : std_logic_vector(64 downto 0);\n" +
                        "    variable wb_divx14 : std_logic_vector(64 downto 0);\n" +
                        "    variable wb_divx15 : std_logic_vector(64 downto 0);\n" +
                        "    variable wb_divx16 : std_logic_vector(64 downto 0);\n" +
                        "\n" +
                        "  begin\n" +
                        "    wb_divident := '0' & i_divident;\n" +
                        "\n" +
                        "    wb_divx1(63 downto 0) := i_divisor(63 downto 0);\n" +
                        "    wb_divx1(64) := or_reduce(i_divisor(123 downto 64));\n" +
                        "\n" +
                        "    wb_divx2(63 downto 0) := i_divisor(62 downto 0) & '0';\n" +
                        "    wb_divx2(64) := or_reduce(i_divisor(123 downto 63));\n" +
                        "\n" +
                        "    wb_divx3(64 downto 0) := ('0' & wb_divx2(63 downto 0)) + ('0' & wb_divx1(63 downto 0));\n" +
                        "    wb_divx3(64) := wb_divx3(64) or wb_divx2(64);\n" +
                        "\n" +
                        "    wb_divx4(63 downto 0) := i_divisor(61 downto 0) & \"00\";\n" +
                        "    wb_divx4(64) := or_reduce(i_divisor(123 downto 62));\n" +
                        "\n" +
                        "    wb_divx5(64 downto 0) := ('0' & wb_divx4(63 downto 0)) + ('0' & wb_divx1(63 downto 0));\n" +
                        "    wb_divx5(64) := wb_divx5(64) or wb_divx4(64);\n" +
                        "\n" +
                        "    wb_divx6(63 downto 0) := wb_divx3(62 downto 0) & '0';\n" +
                        "    wb_divx6(64) := wb_divx3(64) or wb_divx3(63);\n" +
                        "\n" +
                        "    wb_divx8(63 downto 0) := wb_divx1(60 downto 0) & \"000\";\n" +
                        "    wb_divx8(64) := or_reduce(i_divisor(123 downto 61));\n" +
                        "\n" +
                        "    -- 7 = 8 - 1\n" +
                        "    wb_divx7(64 downto 0) := wb_divx8(64 downto 0) - ('0' & wb_divx1(63 downto 0));\n" +
                        "    wb_divx7(64) := wb_divx7(64) or or_reduce(i_divisor(123 downto 62));\n" +
                        "\n" +
                        "    -- 9 = 8 + 1\n" +
                        "    wb_divx9(64 downto 0) := ('0' & wb_divx8(63 downto 0)) + ('0' & wb_divx1(63 downto 0));\n" +
                        "    wb_divx9(64) := wb_divx9(64) or or_reduce(i_divisor(123 downto 61));\n" +
                        "\n" +
                        "    -- 10 = 8 + 2\n" +
                        "    wb_divx10(64 downto 0) := ('0' & wb_divx8(63 downto 0)) + ('0' & wb_divx2(63 downto 0));\n" +
                        "    wb_divx10(64) := wb_divx10(64) or or_reduce(i_divisor(123 downto 61));\n" +
                        "\n" +
                        "    -- 11 = 8 + 3\n" +
                        "    wb_divx11(64 downto 0) := ('0' & wb_divx8(63 downto 0)) + ('0' & wb_divx3(63 downto 0));\n" +
                        "    wb_divx11(64) := wb_divx11(64) or or_reduce(i_divisor(123 downto 61));\n" +
                        "\n" +
                        "    -- 12 = 3 << 2\n" +
                        "    wb_divx12(63 downto 0) := wb_divx3(61 downto 0) & \"00\";\n" +
                        "    wb_divx12(64) := wb_divx3(64) or wb_divx3(63) or wb_divx3(62);\n" +
                        "\n" +
                        "    -- 16 = divisor << 4\n" +
                        "    wb_divx16(63 downto 0) := wb_divx1(59 downto 0) & \"0000\";\n" +
                        "    wb_divx16(64) := or_reduce(i_divisor(123 downto 60));\n" +
                        "\n" +
                        "    -- 13 = 16 - 3\n" +
                        "    wb_divx13(64 downto 0) := wb_divx16(64 downto 0) - ('0' & wb_divx3(63 downto 0));\n" +
                        "    wb_divx13(64) := wb_divx13(64) or or_reduce(i_divisor(123 downto 61));\n" +
                        "\n" +
                        "    -- 14 = 7 << 1\n" +
                        "    wb_divx14(63 downto 0) := wb_divx7(62 downto 0) & '0';\n" +
                        "    wb_divx14(64) := wb_divx7(64) or wb_divx7(63);\n" +
                        "\n" +
                        "    -- 15 = 16 - 1\n" +
                        "    wb_divx15(64 downto 0) := wb_divx16(64 downto 0) - ('0' & wb_divx1(63 downto 0));\n" +
                        "    wb_divx15(64) := wb_divx15(64) or or_reduce(i_divisor(123 downto 61));\n" +
                        "\n" +
                        "    wb_thresh(15) := ('0' & wb_divident) - ('0' & wb_divx15);\n" +
                        "    wb_thresh(14) := ('0' & wb_divident) - ('0' & wb_divx14);\n" +
                        "    wb_thresh(13) := ('0' & wb_divident) - ('0' & wb_divx13);\n" +
                        "    wb_thresh(12) := ('0' & wb_divident) - ('0' & wb_divx12);\n" +
                        "    wb_thresh(11) := ('0' & wb_divident) - ('0' & wb_divx11);\n" +
                        "    wb_thresh(10) := ('0' & wb_divident) - ('0' & wb_divx10);\n" +
                        "    wb_thresh(9) := ('0' & wb_divident) - ('0' & wb_divx9);\n" +
                        "    wb_thresh(8) := ('0' & wb_divident) - ('0' & wb_divx8);\n" +
                        "    wb_thresh(7) := ('0' & wb_divident) - ('0' & wb_divx7);\n" +
                        "    wb_thresh(6) := ('0' & wb_divident) - ('0' & wb_divx6);\n" +
                        "    wb_thresh(5) := ('0' & wb_divident) - ('0' & wb_divx5);\n" +
                        "    wb_thresh(4) := ('0' & wb_divident) - ('0' & wb_divx4);\n" +
                        "    wb_thresh(3) := ('0' & wb_divident) - ('0' & wb_divx3);\n" +
                        "    wb_thresh(2) := ('0' & wb_divident) - ('0' & wb_divx2);\n" +
                        "    wb_thresh(1) := ('0' & wb_divident) - ('0' & wb_divx1);\n" +
                        "    wb_thresh(0) := ('0' & wb_divident);\n" +
                        "\n" +
                        "    if wb_thresh(15)(65) = '0' then\n" +
                        "        wb_bits := X\"F\";\n" +
                        "        wb_dif := wb_thresh(15)(63 downto 0);\n" +
                        "    elsif wb_thresh(14)(65) = '0' then\n" +
                        "        wb_bits := X\"E\";\n" +
                        "        wb_dif := wb_thresh(14)(63 downto 0);\n" +
                        "    elsif wb_thresh(13)(65) = '0' then\n" +
                        "        wb_bits := X\"D\";\n" +
                        "        wb_dif := wb_thresh(13)(63 downto 0);\n" +
                        "    elsif wb_thresh(12)(65) = '0' then\n" +
                        "        wb_bits := X\"C\";\n" +
                        "        wb_dif := wb_thresh(12)(63 downto 0);\n" +
                        "    elsif wb_thresh(11)(65) = '0' then\n" +
                        "        wb_bits := X\"B\";\n" +
                        "        wb_dif := wb_thresh(11)(63 downto 0);\n" +
                        "    elsif wb_thresh(10)(65) = '0' then\n" +
                        "        wb_bits := X\"A\";\n" +
                        "        wb_dif := wb_thresh(10)(63 downto 0);\n" +
                        "    elsif wb_thresh(9)(65) = '0' then\n" +
                        "        wb_bits := X\"9\";\n" +
                        "        wb_dif := wb_thresh(9)(63 downto 0);\n" +
                        "    elsif wb_thresh(8)(65) = '0' then\n" +
                        "        wb_bits := X\"8\";\n" +
                        "        wb_dif := wb_thresh(8)(63 downto 0);\n" +
                        "    elsif wb_thresh(7)(65) = '0' then\n" +
                        "        wb_bits := X\"7\";\n" +
                        "        wb_dif := wb_thresh(7)(63 downto 0);\n" +
                        "    elsif wb_thresh(6)(65) = '0' then\n" +
                        "        wb_bits := X\"6\";\n" +
                        "        wb_dif := wb_thresh(6)(63 downto 0);\n" +
                        "    elsif wb_thresh(5)(65) = '0' then\n" +
                        "        wb_bits := X\"5\";\n" +
                        "        wb_dif := wb_thresh(5)(63 downto 0);\n" +
                        "    elsif wb_thresh(4)(65) = '0' then\n" +
                        "        wb_bits := X\"4\";\n" +
                        "        wb_dif := wb_thresh(4)(63 downto 0);\n" +
                        "    elsif wb_thresh(3)(65) = '0' then\n" +
                        "        wb_bits := X\"3\";\n" +
                        "        wb_dif := wb_thresh(3)(63 downto 0);\n" +
                        "    elsif wb_thresh(2)(65) = '0' then\n" +
                        "        wb_bits := X\"2\";\n" +
                        "        wb_dif := wb_thresh(2)(63 downto 0);\n" +
                        "    elsif wb_thresh(1)(65) = '0' then\n" +
                        "        wb_bits := X\"1\";\n" +
                        "        wb_dif := wb_thresh(1)(63 downto 0);\n" +
                        "    else\n" +
                        "        wb_bits := X\"0\";\n" +
                        "        wb_dif := wb_thresh(0)(63 downto 0);\n" +
                        "    end if;\n" +
                        "\n" +
                        "    o_bits <= wb_bits;\n" +
                        "    o_resid <= wb_dif;\n" +
                        "\n" +
                        "  end process;\n" +
                        "\n" +
                        "end;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_mul_int_64_vhd_file(String Project_Folder_File) {
        String data =   "-- megafunction wizard: %LPM_MULT%\n" +
                        "-- GENERATION: STANDARD\n" +
                        "-- VERSION: WM1.0\n" +
                        "-- MODULE: lpm_mult \n" +
                        "\n" +
                        "-- ============================================================\n" +
                        "-- File Name: mul_int_64.vhd\n" +
                        "-- Megafunction Name(s):\n" +
                        "-- 			lpm_mult\n" +
                        "--\n" +
                        "-- Simulation Library Files(s):\n" +
                        "-- 			lpm\n" +
                        "-- ============================================================\n" +
                        "-- ************************************************************\n" +
                        "-- THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!\n" +
                        "--\n" +
                        "-- 18.0.0 Build 614 04/24/2018 SJ Lite Edition\n" +
                        "-- ************************************************************\n" +
                        "\n" +
                        "\n" +
                        "--Copyright (C) 2018  Intel Corporation. All rights reserved.\n" +
                        "--Your use of Intel Corporation's design tools, logic functions \n" +
                        "--and other software and tools, and its AMPP partner logic \n" +
                        "--functions, and any output files from any of the foregoing \n" +
                        "--(including device programming or simulation files), and any \n" +
                        "--associated documentation or information are expressly subject \n" +
                        "--to the terms and conditions of the Intel Program License \n" +
                        "--Subscription Agreement, the Intel Quartus Prime License Agreement,\n" +
                        "--the Intel FPGA IP License Agreement, or other applicable license\n" +
                        "--agreement, including, without limitation, that your use is for\n" +
                        "--the sole purpose of programming logic devices manufactured by\n" +
                        "--Intel and sold by Intel or its authorized distributors.  Please\n" +
                        "--refer to the applicable agreement for further details.\n" +
                        "\n" +
                        "\n" +
                        "LIBRARY ieee;\n" +
                        "USE ieee.std_logic_1164.all;\n" +
                        "\n" +
                        "LIBRARY lpm;\n" +
                        "USE lpm.all;\n" +
                        "\n" +
                        "ENTITY mul_int_64 IS\n" +
                        "	PORT\n" +
                        "	(\n" +
                        "		dataa		: IN STD_LOGIC_VECTOR (63 DOWNTO 0);\n" +
                        "		datab		: IN STD_LOGIC_VECTOR (63 DOWNTO 0);\n" +
                        "		result		: OUT STD_LOGIC_VECTOR (127 DOWNTO 0)\n" +
                        "	);\n" +
                        "END mul_int_64;\n" +
                        "\n" +
                        "\n" +
                        "ARCHITECTURE SYN OF mul_int_64 IS\n" +
                        "\n" +
                        "	SIGNAL sub_wire0	: STD_LOGIC_VECTOR (127 DOWNTO 0);\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "	COMPONENT lpm_mult\n" +
                        "	GENERIC (\n" +
                        "		lpm_hint		: STRING;\n" +
                        "		lpm_representation		: STRING;\n" +
                        "		lpm_type		: STRING;\n" +
                        "		lpm_widtha		: NATURAL;\n" +
                        "		lpm_widthb		: NATURAL;\n" +
                        "		lpm_widthp		: NATURAL\n" +
                        "	);\n" +
                        "	PORT (\n" +
                        "			dataa	: IN STD_LOGIC_VECTOR (63 DOWNTO 0);\n" +
                        "			datab	: IN STD_LOGIC_VECTOR (63 DOWNTO 0);\n" +
                        "			result	: OUT STD_LOGIC_VECTOR (127 DOWNTO 0)\n" +
                        "	);\n" +
                        "	END COMPONENT;\n" +
                        "\n" +
                        "BEGIN\n" +
                        "	result    <= sub_wire0(127 DOWNTO 0);\n" +
                        "\n" +
                        "	lpm_mult_component : lpm_mult\n" +
                        "	GENERIC MAP (\n" +
                        "		lpm_hint => \"MAXIMIZE_SPEED=1\",\n" +
                        "		lpm_representation => \"SIGNED\",\n" +
                        "		lpm_type => \"LPM_MULT\",\n" +
                        "		lpm_widtha => 64,\n" +
                        "		lpm_widthb => 64,\n" +
                        "		lpm_widthp => 128\n" +
                        "	)\n" +
                        "	PORT MAP (\n" +
                        "		dataa => dataa,\n" +
                        "		datab => datab,\n" +
                        "		result => sub_wire0\n" +
                        "	);\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "END SYN;\n" +
                        "\n" +
                        "-- ============================================================\n" +
                        "-- CNX file retrieval info\n" +
                        "-- ============================================================\n" +
                        "-- Retrieval info: PRIVATE: AutoSizeResult NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: B_isConstant NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: ConstantB NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: INTENDED_DEVICE_FAMILY STRING \"Cyclone V\"\n" +
                        "-- Retrieval info: PRIVATE: LPM_PIPELINE NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: Latency NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: SYNTH_WRAPPER_GEN_POSTFIX STRING \"0\"\n" +
                        "-- Retrieval info: PRIVATE: SignedMult NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: USE_MULT NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: ValidConstant NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: WidthA NUMERIC \"64\"\n" +
                        "-- Retrieval info: PRIVATE: WidthB NUMERIC \"64\"\n" +
                        "-- Retrieval info: PRIVATE: WidthP NUMERIC \"128\"\n" +
                        "-- Retrieval info: PRIVATE: aclr NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: clken NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: new_diagram STRING \"1\"\n" +
                        "-- Retrieval info: PRIVATE: optimize NUMERIC \"2\"\n" +
                        "-- Retrieval info: LIBRARY: lpm lpm.lpm_components.all\n" +
                        "-- Retrieval info: CONSTANT: LPM_HINT STRING \"MAXIMIZE_SPEED=1\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_REPRESENTATION STRING \"SIGNED\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_TYPE STRING \"LPM_MULT\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_WIDTHA NUMERIC \"64\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_WIDTHB NUMERIC \"64\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_WIDTHP NUMERIC \"128\"\n" +
                        "-- Retrieval info: USED_PORT: dataa 0 0 64 0 INPUT NODEFVAL \"dataa[63..0]\"\n" +
                        "-- Retrieval info: USED_PORT: datab 0 0 64 0 INPUT NODEFVAL \"datab[63..0]\"\n" +
                        "-- Retrieval info: USED_PORT: result 0 0 128 0 OUTPUT NODEFVAL \"result[127..0]\"\n" +
                        "-- Retrieval info: CONNECT: @dataa 0 0 64 0 dataa 0 0 64 0\n" +
                        "-- Retrieval info: CONNECT: @datab 0 0 64 0 datab 0 0 64 0\n" +
                        "-- Retrieval info: CONNECT: result 0 0 128 0 @result 0 0 128 0\n" +
                        "-- Retrieval info: GEN_FILE: TYPE_NORMAL mul_int_64.vhd TRUE\n" +
                        "-- Retrieval info: GEN_FILE: TYPE_NORMAL mul_int_64.inc FALSE\n" +
                        "-- Retrieval info: GEN_FILE: TYPE_NORMAL mul_int_64.cmp FALSE\n" +
                        "-- Retrieval info: GEN_FILE: TYPE_NORMAL mul_int_64.bsf FALSE\n" +
                        "-- Retrieval info: GEN_FILE: TYPE_NORMAL mul_int_64_inst.vhd FALSE\n" +
                        "-- Retrieval info: LIB_FILE: lpm";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_mul_int_64_qip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -name IP_TOOL_NAME \"LPM_MULT\"\n" +
                        "set_global_assignment -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -name IP_GENERATED_DEVICE_FAMILY \"{Cyclone V}\"\n" +
                        "set_global_assignment -name VHDL_FILE [file join $::quartus(qip_path) \"mul_int_64.vhd\"]";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_mul_int_20_7_vhd_file(String Project_Folder_File) {
        String data =   "-- megafunction wizard: %LPM_MULT%\n" +
                        "-- GENERATION: STANDARD\n" +
                        "-- VERSION: WM1.0\n" +
                        "-- MODULE: lpm_mult \n" +
                        "\n" +
                        "-- ============================================================\n" +
                        "-- File Name: mul_int_20_7.vhd\n" +
                        "-- Megafunction Name(s):\n" +
                        "-- 			lpm_mult\n" +
                        "--\n" +
                        "-- Simulation Library Files(s):\n" +
                        "-- 			lpm\n" +
                        "-- ============================================================\n" +
                        "-- ************************************************************\n" +
                        "-- THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!\n" +
                        "--\n" +
                        "-- 18.0.0 Build 614 04/24/2018 SJ Lite Edition\n" +
                        "-- ************************************************************\n" +
                        "\n" +
                        "\n" +
                        "--Copyright (C) 2018  Intel Corporation. All rights reserved.\n" +
                        "--Your use of Intel Corporation's design tools, logic functions \n" +
                        "--and other software and tools, and its AMPP partner logic \n" +
                        "--functions, and any output files from any of the foregoing \n" +
                        "--(including device programming or simulation files), and any \n" +
                        "--associated documentation or information are expressly subject \n" +
                        "--to the terms and conditions of the Intel Program License \n" +
                        "--Subscription Agreement, the Intel Quartus Prime License Agreement,\n" +
                        "--the Intel FPGA IP License Agreement, or other applicable license\n" +
                        "--agreement, including, without limitation, that your use is for\n" +
                        "--the sole purpose of programming logic devices manufactured by\n" +
                        "--Intel and sold by Intel or its authorized distributors.  Please\n" +
                        "--refer to the applicable agreement for further details.\n" +
                        "\n" +
                        "\n" +
                        "LIBRARY ieee;\n" +
                        "USE ieee.std_logic_1164.all;\n" +
                        "\n" +
                        "LIBRARY lpm;\n" +
                        "USE lpm.all;\n" +
                        "\n" +
                        "ENTITY mul_int_20_7 IS\n" +
                        "	PORT\n" +
                        "	(\n" +
                        "		dataa		: IN STD_LOGIC_VECTOR (19 DOWNTO 0);\n" +
                        "		datab		: IN STD_LOGIC_VECTOR (6 DOWNTO 0);\n" +
                        "		result		: OUT STD_LOGIC_VECTOR (26 DOWNTO 0)\n" +
                        "	);\n" +
                        "END mul_int_20_7;\n" +
                        "\n" +
                        "\n" +
                        "ARCHITECTURE SYN OF mul_int_20_7 IS\n" +
                        "\n" +
                        "	SIGNAL sub_wire0	: STD_LOGIC_VECTOR (26 DOWNTO 0);\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "	COMPONENT lpm_mult\n" +
                        "	GENERIC (\n" +
                        "		lpm_hint		: STRING;\n" +
                        "		lpm_representation		: STRING;\n" +
                        "		lpm_type		: STRING;\n" +
                        "		lpm_widtha		: NATURAL;\n" +
                        "		lpm_widthb		: NATURAL;\n" +
                        "		lpm_widthp		: NATURAL\n" +
                        "	);\n" +
                        "	PORT (\n" +
                        "			dataa	: IN STD_LOGIC_VECTOR (19 DOWNTO 0);\n" +
                        "			datab	: IN STD_LOGIC_VECTOR (6 DOWNTO 0);\n" +
                        "			result	: OUT STD_LOGIC_VECTOR (26 DOWNTO 0)\n" +
                        "	);\n" +
                        "	END COMPONENT;\n" +
                        "\n" +
                        "BEGIN\n" +
                        "	result    <= sub_wire0(26 DOWNTO 0);\n" +
                        "\n" +
                        "	lpm_mult_component : lpm_mult\n" +
                        "	GENERIC MAP (\n" +
                        "		lpm_hint => \"DEDICATED_MULTIPLIER_CIRCUITRY=YES,MAXIMIZE_SPEED=9\",\n" +
                        "		lpm_representation => \"UNSIGNED\",\n" +
                        "		lpm_type => \"LPM_MULT\",\n" +
                        "		lpm_widtha => 20,\n" +
                        "		lpm_widthb => 7,\n" +
                        "		lpm_widthp => 27\n" +
                        "	)\n" +
                        "	PORT MAP (\n" +
                        "		dataa => dataa,\n" +
                        "		datab => datab,\n" +
                        "		result => sub_wire0\n" +
                        "	);\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "END SYN;\n" +
                        "\n" +
                        "-- ============================================================\n" +
                        "-- CNX file retrieval info\n" +
                        "-- ============================================================\n" +
                        "-- Retrieval info: PRIVATE: AutoSizeResult NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: B_isConstant NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: ConstantB NUMERIC \"100\"\n" +
                        "-- Retrieval info: PRIVATE: INTENDED_DEVICE_FAMILY STRING \"Cyclone V\"\n" +
                        "-- Retrieval info: PRIVATE: LPM_PIPELINE NUMERIC \"5\"\n" +
                        "-- Retrieval info: PRIVATE: Latency NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: SYNTH_WRAPPER_GEN_POSTFIX STRING \"0\"\n" +
                        "-- Retrieval info: PRIVATE: SignedMult NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: USE_MULT NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: ValidConstant NUMERIC \"1\"\n" +
                        "-- Retrieval info: PRIVATE: WidthA NUMERIC \"20\"\n" +
                        "-- Retrieval info: PRIVATE: WidthB NUMERIC \"7\"\n" +
                        "-- Retrieval info: PRIVATE: WidthP NUMERIC \"27\"\n" +
                        "-- Retrieval info: PRIVATE: aclr NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: clken NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: new_diagram STRING \"1\"\n" +
                        "-- Retrieval info: PRIVATE: optimize NUMERIC \"1\"\n" +
                        "-- Retrieval info: LIBRARY: lpm lpm.lpm_components.all\n" +
                        "-- Retrieval info: CONSTANT: LPM_HINT STRING \"DEDICATED_MULTIPLIER_CIRCUITRY=YES,MAXIMIZE_SPEED=9\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_REPRESENTATION STRING \"UNSIGNED\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_TYPE STRING \"LPM_MULT\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_WIDTHA NUMERIC \"20\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_WIDTHB NUMERIC \"7\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_WIDTHP NUMERIC \"27\"\n" +
                        "-- Retrieval info: USED_PORT: dataa 0 0 20 0 INPUT NODEFVAL \"dataa[19..0]\"\n" +
                        "-- Retrieval info: USED_PORT: datab 0 0 7 0 INPUT NODEFVAL \"datab[6..0]\"\n" +
                        "-- Retrieval info: USED_PORT: result 0 0 27 0 OUTPUT NODEFVAL \"result[26..0]\"\n" +
                        "-- Retrieval info: CONNECT: @dataa 0 0 20 0 dataa 0 0 20 0\n" +
                        "-- Retrieval info: CONNECT: @datab 0 0 7 0 datab 0 0 7 0\n" +
                        "-- Retrieval info: CONNECT: result 0 0 27 0 @result 0 0 27 0\n" +
                        "-- Retrieval info: LIB_FILE: lpm";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_mul_int_20_7_qip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -name IP_TOOL_NAME \"LPM_MULT\"\n" +
                        "set_global_assignment -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -name IP_GENERATED_DEVICE_FAMILY \"{Cyclone V}\"\n" +
                        "set_global_assignment -name VHDL_FILE [file join $::quartus(qip_path) \"mul_int_20_7.vhd\"]";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_div_int_20_7_speed_vhd_file(String Project_Folder_File) {
        String data =   "-- megafunction wizard: %LPM_DIVIDE%\n" +
                        "-- GENERATION: STANDARD\n" +
                        "-- VERSION: WM1.0\n" +
                        "-- MODULE: LPM_DIVIDE \n" +
                        "\n" +
                        "-- ============================================================\n" +
                        "-- File Name: div_int_20_7_speed.vhd\n" +
                        "-- Megafunction Name(s):\n" +
                        "-- 			LPM_DIVIDE\n" +
                        "--\n" +
                        "-- Simulation Library Files(s):\n" +
                        "-- 			lpm\n" +
                        "-- ============================================================\n" +
                        "-- ************************************************************\n" +
                        "-- THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!\n" +
                        "--\n" +
                        "-- 18.0.0 Build 614 04/24/2018 SJ Lite Edition\n" +
                        "-- ************************************************************\n" +
                        "\n" +
                        "\n" +
                        "--Copyright (C) 2018  Intel Corporation. All rights reserved.\n" +
                        "--Your use of Intel Corporation's design tools, logic functions \n" +
                        "--and other software and tools, and its AMPP partner logic \n" +
                        "--functions, and any output files from any of the foregoing \n" +
                        "--(including device programming or simulation files), and any \n" +
                        "--associated documentation or information are expressly subject \n" +
                        "--to the terms and conditions of the Intel Program License \n" +
                        "--Subscription Agreement, the Intel Quartus Prime License Agreement,\n" +
                        "--the Intel FPGA IP License Agreement, or other applicable license\n" +
                        "--agreement, including, without limitation, that your use is for\n" +
                        "--the sole purpose of programming logic devices manufactured by\n" +
                        "--Intel and sold by Intel or its authorized distributors.  Please\n" +
                        "--refer to the applicable agreement for further details.\n" +
                        "\n" +
                        "\n" +
                        "LIBRARY ieee;\n" +
                        "USE ieee.std_logic_1164.all;\n" +
                        "\n" +
                        "LIBRARY lpm;\n" +
                        "USE lpm.all;\n" +
                        "\n" +
                        "ENTITY div_int_20_7_speed IS\n" +
                        "	PORT\n" +
                        "	(\n" +
                        "		denom		: IN STD_LOGIC_VECTOR (6 DOWNTO 0);\n" +
                        "		numer		: IN STD_LOGIC_VECTOR (19 DOWNTO 0);\n" +
                        "		quotient		: OUT STD_LOGIC_VECTOR (19 DOWNTO 0);\n" +
                        "		remain		: OUT STD_LOGIC_VECTOR (6 DOWNTO 0)\n" +
                        "	);\n" +
                        "END div_int_20_7_speed;\n" +
                        "\n" +
                        "\n" +
                        "ARCHITECTURE SYN OF div_int_20_7_speed IS\n" +
                        "\n" +
                        "	SIGNAL sub_wire0	: STD_LOGIC_VECTOR (19 DOWNTO 0);\n" +
                        "	SIGNAL sub_wire1	: STD_LOGIC_VECTOR (6 DOWNTO 0);\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "	COMPONENT lpm_divide\n" +
                        "	GENERIC (\n" +
                        "		lpm_drepresentation		: STRING;\n" +
                        "		lpm_hint		: STRING;\n" +
                        "		lpm_nrepresentation		: STRING;\n" +
                        "		lpm_type		: STRING;\n" +
                        "		lpm_widthd		: NATURAL;\n" +
                        "		lpm_widthn		: NATURAL\n" +
                        "	);\n" +
                        "	PORT (\n" +
                        "			denom	: IN STD_LOGIC_VECTOR (6 DOWNTO 0);\n" +
                        "			numer	: IN STD_LOGIC_VECTOR (19 DOWNTO 0);\n" +
                        "			quotient	: OUT STD_LOGIC_VECTOR (19 DOWNTO 0);\n" +
                        "			remain	: OUT STD_LOGIC_VECTOR (6 DOWNTO 0)\n" +
                        "	);\n" +
                        "	END COMPONENT;\n" +
                        "\n" +
                        "BEGIN\n" +
                        "	quotient    <= sub_wire0(19 DOWNTO 0);\n" +
                        "	remain    <= sub_wire1(6 DOWNTO 0);\n" +
                        "\n" +
                        "	LPM_DIVIDE_component : LPM_DIVIDE\n" +
                        "	GENERIC MAP (\n" +
                        "		lpm_drepresentation => \"UNSIGNED\",\n" +
                        "		lpm_hint => \"MAXIMIZE_SPEED=6,LPM_REMAINDERPOSITIVE=TRUE\",\n" +
                        "		lpm_nrepresentation => \"UNSIGNED\",\n" +
                        "		lpm_type => \"LPM_DIVIDE\",\n" +
                        "		lpm_widthd => 7,\n" +
                        "		lpm_widthn => 20\n" +
                        "	)\n" +
                        "	PORT MAP (\n" +
                        "		denom => denom,\n" +
                        "		numer => numer,\n" +
                        "		quotient => sub_wire0,\n" +
                        "		remain => sub_wire1\n" +
                        "	);\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "END SYN;\n" +
                        "\n" +
                        "-- ============================================================\n" +
                        "-- CNX file retrieval info\n" +
                        "-- ============================================================\n" +
                        "-- Retrieval info: PRIVATE: INTENDED_DEVICE_FAMILY STRING \"Cyclone V\"\n" +
                        "-- Retrieval info: PRIVATE: PRIVATE_LPM_REMAINDERPOSITIVE STRING \"TRUE\"\n" +
                        "-- Retrieval info: PRIVATE: PRIVATE_MAXIMIZE_SPEED NUMERIC \"6\"\n" +
                        "-- Retrieval info: PRIVATE: SYNTH_WRAPPER_GEN_POSTFIX STRING \"0\"\n" +
                        "-- Retrieval info: PRIVATE: USING_PIPELINE NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: VERSION_NUMBER NUMERIC \"2\"\n" +
                        "-- Retrieval info: PRIVATE: new_diagram STRING \"1\"\n" +
                        "-- Retrieval info: LIBRARY: lpm lpm.lpm_components.all\n" +
                        "-- Retrieval info: CONSTANT: LPM_DREPRESENTATION STRING \"UNSIGNED\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_HINT STRING \"MAXIMIZE_SPEED=6,LPM_REMAINDERPOSITIVE=TRUE\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_NREPRESENTATION STRING \"UNSIGNED\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_TYPE STRING \"LPM_DIVIDE\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_WIDTHD NUMERIC \"7\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_WIDTHN NUMERIC \"20\"\n" +
                        "-- Retrieval info: USED_PORT: denom 0 0 7 0 INPUT NODEFVAL \"denom[6..0]\"\n" +
                        "-- Retrieval info: USED_PORT: numer 0 0 20 0 INPUT NODEFVAL \"numer[19..0]\"\n" +
                        "-- Retrieval info: USED_PORT: quotient 0 0 20 0 OUTPUT NODEFVAL \"quotient[19..0]\"\n" +
                        "-- Retrieval info: USED_PORT: remain 0 0 7 0 OUTPUT NODEFVAL \"remain[6..0]\"\n" +
                        "-- Retrieval info: CONNECT: @denom 0 0 7 0 denom 0 0 7 0\n" +
                        "-- Retrieval info: CONNECT: @numer 0 0 20 0 numer 0 0 20 0\n" +
                        "-- Retrieval info: CONNECT: quotient 0 0 20 0 @quotient 0 0 20 0\n" +
                        "-- Retrieval info: CONNECT: remain 0 0 7 0 @remain 0 0 7 0\n" +
                        "-- Retrieval info: LIB_FILE: lpm";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_div_int_20_7_speed_qip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -name IP_TOOL_NAME \"LPM_DIVIDE\"\n" +
                        "set_global_assignment -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -name IP_GENERATED_DEVICE_FAMILY \"{Cyclone V}\"\n" +
                        "set_global_assignment -name VHDL_FILE [file join $::quartus(qip_path) \"div_int_20_7_speed.vhd\"]";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_div_int_20_17_speed_vhd_file(String Project_Folder_File) {
        String data =   "-- megafunction wizard: %LPM_DIVIDE%\n" +
                        "-- GENERATION: STANDARD\n" +
                        "-- VERSION: WM1.0\n" +
                        "-- MODULE: LPM_DIVIDE \n" +
                        "\n" +
                        "-- ============================================================\n" +
                        "-- File Name: div_int_20_17_speed.vhd\n" +
                        "-- Megafunction Name(s):\n" +
                        "-- 			LPM_DIVIDE\n" +
                        "--\n" +
                        "-- Simulation Library Files(s):\n" +
                        "-- 			lpm\n" +
                        "-- ============================================================\n" +
                        "-- ************************************************************\n" +
                        "-- THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!\n" +
                        "--\n" +
                        "-- 18.0.0 Build 614 04/24/2018 SJ Lite Edition\n" +
                        "-- ************************************************************\n" +
                        "\n" +
                        "\n" +
                        "--Copyright (C) 2018  Intel Corporation. All rights reserved.\n" +
                        "--Your use of Intel Corporation's design tools, logic functions \n" +
                        "--and other software and tools, and its AMPP partner logic \n" +
                        "--functions, and any output files from any of the foregoing \n" +
                        "--(including device programming or simulation files), and any \n" +
                        "--associated documentation or information are expressly subject \n" +
                        "--to the terms and conditions of the Intel Program License \n" +
                        "--Subscription Agreement, the Intel Quartus Prime License Agreement,\n" +
                        "--the Intel FPGA IP License Agreement, or other applicable license\n" +
                        "--agreement, including, without limitation, that your use is for\n" +
                        "--the sole purpose of programming logic devices manufactured by\n" +
                        "--Intel and sold by Intel or its authorized distributors.  Please\n" +
                        "--refer to the applicable agreement for further details.\n" +
                        "\n" +
                        "\n" +
                        "LIBRARY ieee;\n" +
                        "USE ieee.std_logic_1164.all;\n" +
                        "\n" +
                        "LIBRARY lpm;\n" +
                        "USE lpm.all;\n" +
                        "\n" +
                        "ENTITY div_int_20_17_speed IS\n" +
                        "	PORT\n" +
                        "	(\n" +
                        "		denom		: IN STD_LOGIC_VECTOR (16 DOWNTO 0);\n" +
                        "		numer		: IN STD_LOGIC_VECTOR (19 DOWNTO 0);\n" +
                        "		quotient		: OUT STD_LOGIC_VECTOR (19 DOWNTO 0);\n" +
                        "		remain		: OUT STD_LOGIC_VECTOR (16 DOWNTO 0)\n" +
                        "	);\n" +
                        "END div_int_20_17_speed;\n" +
                        "\n" +
                        "\n" +
                        "ARCHITECTURE SYN OF div_int_20_17_speed IS\n" +
                        "\n" +
                        "	SIGNAL sub_wire0	: STD_LOGIC_VECTOR (19 DOWNTO 0);\n" +
                        "	SIGNAL sub_wire1	: STD_LOGIC_VECTOR (16 DOWNTO 0);\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "	COMPONENT lpm_divide\n" +
                        "	GENERIC (\n" +
                        "		lpm_drepresentation		: STRING;\n" +
                        "		lpm_hint		: STRING;\n" +
                        "		lpm_nrepresentation		: STRING;\n" +
                        "		lpm_type		: STRING;\n" +
                        "		lpm_widthd		: NATURAL;\n" +
                        "		lpm_widthn		: NATURAL\n" +
                        "	);\n" +
                        "	PORT (\n" +
                        "			denom	: IN STD_LOGIC_VECTOR (16 DOWNTO 0);\n" +
                        "			numer	: IN STD_LOGIC_VECTOR (19 DOWNTO 0);\n" +
                        "			quotient	: OUT STD_LOGIC_VECTOR (19 DOWNTO 0);\n" +
                        "			remain	: OUT STD_LOGIC_VECTOR (16 DOWNTO 0)\n" +
                        "	);\n" +
                        "	END COMPONENT;\n" +
                        "\n" +
                        "BEGIN\n" +
                        "	quotient    <= sub_wire0(19 DOWNTO 0);\n" +
                        "	remain    <= sub_wire1(16 DOWNTO 0);\n" +
                        "\n" +
                        "	LPM_DIVIDE_component : LPM_DIVIDE\n" +
                        "	GENERIC MAP (\n" +
                        "		lpm_drepresentation => \"UNSIGNED\",\n" +
                        "		lpm_hint => \"MAXIMIZE_SPEED=6,LPM_REMAINDERPOSITIVE=TRUE\",\n" +
                        "		lpm_nrepresentation => \"UNSIGNED\",\n" +
                        "		lpm_type => \"LPM_DIVIDE\",\n" +
                        "		lpm_widthd => 17,\n" +
                        "		lpm_widthn => 20\n" +
                        "	)\n" +
                        "	PORT MAP (\n" +
                        "		denom => denom,\n" +
                        "		numer => numer,\n" +
                        "		quotient => sub_wire0,\n" +
                        "		remain => sub_wire1\n" +
                        "	);\n" +
                        "\n" +
                        "\n" +
                        "\n" +
                        "END SYN;\n" +
                        "\n" +
                        "-- ============================================================\n" +
                        "-- CNX file retrieval info\n" +
                        "-- ============================================================\n" +
                        "-- Retrieval info: PRIVATE: INTENDED_DEVICE_FAMILY STRING \"Cyclone V\"\n" +
                        "-- Retrieval info: PRIVATE: PRIVATE_LPM_REMAINDERPOSITIVE STRING \"TRUE\"\n" +
                        "-- Retrieval info: PRIVATE: PRIVATE_MAXIMIZE_SPEED NUMERIC \"6\"\n" +
                        "-- Retrieval info: PRIVATE: SYNTH_WRAPPER_GEN_POSTFIX STRING \"0\"\n" +
                        "-- Retrieval info: PRIVATE: USING_PIPELINE NUMERIC \"0\"\n" +
                        "-- Retrieval info: PRIVATE: VERSION_NUMBER NUMERIC \"2\"\n" +
                        "-- Retrieval info: PRIVATE: new_diagram STRING \"1\"\n" +
                        "-- Retrieval info: LIBRARY: lpm lpm.lpm_components.all\n" +
                        "-- Retrieval info: CONSTANT: LPM_DREPRESENTATION STRING \"UNSIGNED\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_HINT STRING \"MAXIMIZE_SPEED=6,LPM_REMAINDERPOSITIVE=TRUE\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_NREPRESENTATION STRING \"UNSIGNED\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_TYPE STRING \"LPM_DIVIDE\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_WIDTHD NUMERIC \"17\"\n" +
                        "-- Retrieval info: CONSTANT: LPM_WIDTHN NUMERIC \"20\"\n" +
                        "-- Retrieval info: USED_PORT: denom 0 0 17 0 INPUT NODEFVAL \"denom[16..0]\"\n" +
                        "-- Retrieval info: USED_PORT: numer 0 0 20 0 INPUT NODEFVAL \"numer[19..0]\"\n" +
                        "-- Retrieval info: USED_PORT: quotient 0 0 20 0 OUTPUT NODEFVAL \"quotient[19..0]\"\n" +
                        "-- Retrieval info: USED_PORT: remain 0 0 17 0 OUTPUT NODEFVAL \"remain[16..0]\"\n" +
                        "-- Retrieval info: CONNECT: @denom 0 0 17 0 denom 0 0 17 0\n" +
                        "-- Retrieval info: CONNECT: @numer 0 0 20 0 numer 0 0 20 0\n" +
                        "-- Retrieval info: CONNECT: quotient 0 0 20 0 @quotient 0 0 20 0\n" +
                        "-- Retrieval info: CONNECT: remain 0 0 17 0 @remain 0 0 17 0\n" +
                        "-- Retrieval info: LIB_FILE: lpm";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_div_int_20_17_speed_qip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -name IP_TOOL_NAME \"LPM_DIVIDE\"\n" +
                        "set_global_assignment -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -name IP_GENERATED_DEVICE_FAMILY \"{Cyclone V}\"\n" +
                        "set_global_assignment -name VHDL_FILE [file join $::quartus(qip_path) \"div_int_20_17_speed.vhd\"]";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_FP_ADD_SUB_64_qip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -entity \"FP_ADD_SUB_64\" -library \"FP_ADD_SUB_64\" -name IP_TOOL_NAME \"altera_fp_functions\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64\" -library \"FP_ADD_SUB_64\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64\" -library \"FP_ADD_SUB_64\" -name IP_TOOL_ENV \"mwpim\"\n" +
                        "set_global_assignment -library \"FP_ADD_SUB_64\" -name MISC_FILE [file join $::quartus(qip_path) \"FP_ADD_SUB_64.cmp\"]\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64\" -library \"FP_ADD_SUB_64\" -name IP_TARGETED_DEVICE_FAMILY \"Cyclone V\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64\" -library \"FP_ADD_SUB_64\" -name IP_GENERATED_DEVICE_FAMILY \"{Cyclone V}\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64\" -library \"FP_ADD_SUB_64\" -name IP_QSYS_MODE \"UNKNOWN\"\n" +
                        "set_global_assignment -name SYNTHESIS_ONLY_QIP ON\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_NAME \"RlBfQUREX1NVQl82NA==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_DISPLAY_NAME \"QUxURVJBX0ZQX0ZVTkNUSU9OUw==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_REPORT_HIERARCHY \"Off\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_INTERNAL \"Off\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_AUTHOR \"QWx0ZXJhIENvcnBvcmF0aW9u\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_VERSION \"MTguMA==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_DESCRIPTION \"QSBjb2xsZWN0aW9uIG9mIGZsb2F0aW5nIHBvaW50IGZ1bmN0aW9ucw==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_NAME \"RlBfQUREX1NVQl82NF8wMDAy\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_DISPLAY_NAME \"QUxURVJBX0ZQX0ZVTkNUSU9OUw==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_REPORT_HIERARCHY \"Off\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_INTERNAL \"Off\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_AUTHOR \"QWx0ZXJhIENvcnBvcmF0aW9u\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_VERSION \"MTguMA==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_DESCRIPTION \"QSBjb2xsZWN0aW9uIG9mIGZsb2F0aW5nIHBvaW50IGZ1bmN0aW9ucw==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"RlVOQ1RJT05fRkFNSUxZ::QVJJVEg=::RmFtaWx5\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"QVJJVEhfZnVuY3Rpb24=::QUREU1VC::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"Q09OVkVSVF9mdW5jdGlvbg==::RlhQX0ZQ::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"QUxMX2Z1bmN0aW9u::QURE::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"RVhQX0xPR19mdW5jdGlvbg==::RVhQRQ==::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"VFJJR19mdW5jdGlvbg==::U0lO::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"Q09NUEFSRV9mdW5jdGlvbg==::TUlO::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"Uk9PVFNfZnVuY3Rpb24=::U1FSVA==::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"ZGVyaXZlZGZ1bmN0aW9u::QUREU1VC::ZGVyaXZlZGZ1bmN0aW9u\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"ZnBfZm9ybWF0::ZG91Ymxl::Rm9ybWF0\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"ZnBfZXhw::OA==::RXhwb25lbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"ZnBfZXhwX2Rlcml2ZWQ=::MTE=::ZnBfZXhwX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"ZnBfbWFu::MjM=::TWFudGlzc2E=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"ZnBfbWFuX2Rlcml2ZWQ=::NTI=::ZnBfbWFuX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"ZXhwb25lbnRfd2lkdGg=::MjM=::RXhwb25lbnQgV2lkdGg=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"ZnJlcXVlbmN5X3RhcmdldA==::MTAw::VGFyZ2V0\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"bGF0ZW5jeV90YXJnZXQ=::OQ==::VGFyZ2V0\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"cGVyZm9ybWFuY2VfZ29hbA==::ZnJlcXVlbmN5::R29hbA==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"cm91bmRpbmdfbW9kZQ==::bmVhcmVzdCB3aXRoIHRpZSBicmVha2luZyBhd2F5IGZyb20gemVybw==::TW9kZQ==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"cm91bmRpbmdfbW9kZV9kZXJpdmVk::bmVhcmVzdCB3aXRoIHRpZSBicmVha2luZyB0byBldmVu::TW9kZQ==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"dXNlX3JvdW5kaW5nX21vZGU=::dHJ1ZQ==::dXNlX3JvdW5kaW5nX21vZGU=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"ZmFpdGhmdWxfcm91bmRpbmc=::ZmFsc2U=::UmVsYXggcm91bmRpbmcgdG8gcm91bmQgdXAgb3IgZG93biB0byByZWR1Y2UgcmVzb3VyY2UgdXNhZ2U=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"Z2VuX2VuYWJsZQ==::ZmFsc2U=::R2VuZXJhdGUgYW4gZW5hYmxlIHBvcnQ=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"ZGl2aWRlX3R5cGU=::MA==::TWV0aG9k\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"c2VsZWN0X3NpZ25hbF9lbmFibGU=::dHJ1ZQ==::VXNlIFNlbGVjdCBTaWduYWw=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"c2NhbGVfYnlfcGk=::ZmFsc2U=::UmVwcmVzZW50IGFuZ2xlIGFzIG11bHRpcGxlIG9mIFBp\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"bnVtYmVyX29mX2lucHV0cw==::Mg==::SW5wdXQgVmVjdG9yIERpbWVuc2lvbg==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"dHJpZ19ub19yYW5nZV9yZWR1Y3Rpb24=::ZmFsc2U=::SW5wdXRzIGFyZSB3aXRoaW4gcmFuZ2UgLTJwaSB0byArMnBp\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"cmVwb3J0X3Jlc291cmNlc190b194bWw=::ZmFsc2U=::cmVwb3J0X3Jlc291cmNlc190b194bWw=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"ZnhwdF93aWR0aA==::MzI=::V2lkdGg=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"ZnhwdF9mcmFjdGlvbg==::MA==::RnJhY3Rpb24=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"ZnhwdF9zaWdu::MQ==::U2lnbg==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"ZnJlcXVlbmN5X2ZlZWRiYWNr::MTA2::ZnJlcXVlbmN5X2ZlZWRiYWNr\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"bGF0ZW5jeV9mZWVkYmFjaw==::OQ==::bGF0ZW5jeV9mZWVkYmFjaw==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"Zm9yY2VfZWxhYm9yYXRl::MQ==::Zm9yY2VfZWxhYm9yYXRl\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X2Zvcm1hdA==::c2luZ2xl::T3V0cHV0IEZvcm1hdA==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X2V4cA==::OA==::T3V0cHV0IEV4cG9uZW50\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X2V4cF9kZXJpdmVk::OA==::ZnBfb3V0X2V4cF9kZXJpdmVk\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X21hbg==::MjM=::T3V0cHV0IE1hbnRpc3Nh\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X21hbl9kZXJpdmVk::OA==::ZnBfb3V0X21hbl9kZXJpdmVk\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fZm9ybWF0::c2luZ2xl::SW5wdXQgRm9ybWF0\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fZXhw::OA==::SW5wdXQgRXhwb25lbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fZXhwX2Rlcml2ZWQ=::OA==::ZnBfaW5fZXhwX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fbWFu::MjM=::SW5wdXQgTWFudGlzc2E=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fbWFuX2Rlcml2ZWQ=::OA==::ZnBfaW5fbWFuX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"ZW5hYmxlX2hhcmRfZnA=::dHJ1ZQ==::RW5hYmxlIEhhcmQgRmxvYXRpbmcgUG9pbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"bWFudWFsX2RzcF9wbGFubmluZw==::dHJ1ZQ==::RW5hYmxlIEhhcmQgRmxvYXRpbmcgUG9pbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"Zm9yY2VSZWdpc3RlcnM=::MTExMQ==::Zm9yY2VSZWdpc3RlcnM=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"UkVTX0RTUF9wYXJhbQ==::MA==::TXVsdGlwbGllcw==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"UkVTX0xVVF9wYXJhbQ==::MTg5Mw==::TFVUcw==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"UkVTX01CSVRfcGFyYW0=::MA==::TWVtb3J5IEJpdHM=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"UkVTX01CTE9DS19wYXJhbQ==::MA==::TWVtb3J5IEJsb2Nrcw==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"c2VsZWN0ZWRfZGV2aWNlX2ZhbWlseQ==::Q3ljbG9uZSBW::c2VsZWN0ZWRfZGV2aWNlX2ZhbWlseQ==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"c2VsZWN0ZWRfZGV2aWNlX3NwZWVkZ3JhZGU=::Nw==::c2VsZWN0ZWRfZGV2aWNlX3NwZWVkZ3JhZGU=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_COMPONENT_PARAMETER \"dmFsaWRhdGlvbl9mYWlsZWQ=::ZmFsc2U=::dmFsaWRhdGlvbl9mYWlsZWQ=\"\n" +
                        "\n" +
                        "set_global_assignment -library \"FP_ADD_SUB_64\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_ADD_SUB_64.vhd\"]\n" +
                        "set_global_assignment -library \"FP_ADD_SUB_64\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_ADD_SUB_64/dspba_library_package.vhd\"]\n" +
                        "set_global_assignment -library \"FP_ADD_SUB_64\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_ADD_SUB_64/dspba_library.vhd\"]\n" +
                        "set_global_assignment -library \"FP_ADD_SUB_64\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_ADD_SUB_64/FP_ADD_SUB_64_0002.vhd\"]\n" +
                        "\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_TOOL_NAME \"altera_fp_functions\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64_0002\" -library \"FP_ADD_SUB_64\" -name IP_TOOL_ENV \"mwpim\"";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_FP_ADD_SUB_64_sip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -entity \"FP_ADD_SUB_64\" -library \"lib_FP_ADD_SUB_64\" -name IP_TOOL_NAME \"altera_fp_functions\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64\" -library \"lib_FP_ADD_SUB_64\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"FP_ADD_SUB_64\" -library \"lib_FP_ADD_SUB_64\" -name IP_TOOL_ENV \"mwpim\"\n" +
                        "set_global_assignment -library \"lib_FP_ADD_SUB_64\" -name SPD_FILE [file join $::quartus(sip_path) \"FP_ADD_SUB_64.spd\"]\n" +
                        "\n" +
                        "set_global_assignment -library \"lib_FP_ADD_SUB_64\" -name MISC_FILE [file join $::quartus(sip_path) \"FP_ADD_SUB_64_sim/dspba_library_package.vhd\"]\n" +
                        "set_global_assignment -library \"lib_FP_ADD_SUB_64\" -name MISC_FILE [file join $::quartus(sip_path) \"FP_ADD_SUB_64_sim/dspba_library.vhd\"]\n" +
                        "set_global_assignment -library \"lib_FP_ADD_SUB_64\" -name MISC_FILE [file join $::quartus(sip_path) \"FP_ADD_SUB_64_sim/FP_ADD_SUB_64.vhd\"]";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_FP_ADD_SUB_64_vhd_file(String Project_Folder_File) {
        String data =   "-- megafunction wizard: %ALTERA_FP_FUNCTIONS v18.0%\n" +
                        "-- GENERATION: XML\n" +
                        "-- FP_ADD_SUB_64.vhd\n" +
                        "\n" +
                        "-- Generated using ACDS version 18.0 614\n" +
                        "\n" +
                        "library IEEE;\n" +
                        "use IEEE.std_logic_1164.all;\n" +
                        "use IEEE.numeric_std.all;\n" +
                        "\n" +
                        "entity FP_ADD_SUB_64 is\n" +
                        "	port (\n" +
                        "		clk    : in  std_logic                     := '0';             --    clk.clk\n" +
                        "		areset : in  std_logic                     := '0';             -- areset.reset\n" +
                        "		a      : in  std_logic_vector(63 downto 0) := (others => '0'); --      a.a\n" +
                        "		b      : in  std_logic_vector(63 downto 0) := (others => '0'); --      b.b\n" +
                        "		q      : out std_logic_vector(63 downto 0);                    --      q.q\n" +
                        "		opSel  : in  std_logic_vector(0 downto 0)  := (others => '0')  --  opSel.opSel\n" +
                        "	);\n" +
                        "end entity FP_ADD_SUB_64;\n" +
                        "\n" +
                        "architecture rtl of FP_ADD_SUB_64 is\n" +
                        "	component FP_ADD_SUB_64_0002 is\n" +
                        "		port (\n" +
                        "			clk    : in  std_logic                     := 'X';             -- clk\n" +
                        "			areset : in  std_logic                     := 'X';             -- reset\n" +
                        "			a      : in  std_logic_vector(63 downto 0) := (others => 'X'); -- a\n" +
                        "			b      : in  std_logic_vector(63 downto 0) := (others => 'X'); -- b\n" +
                        "			q      : out std_logic_vector(63 downto 0);                    -- q\n" +
                        "			opSel  : in  std_logic_vector(0 downto 0)  := (others => 'X')  -- opSel\n" +
                        "		);\n" +
                        "	end component FP_ADD_SUB_64_0002;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "	fp_add_sub_64_inst : component FP_ADD_SUB_64_0002\n" +
                        "		port map (\n" +
                        "			clk    => clk,    --    clk.clk\n" +
                        "			areset => areset, -- areset.reset\n" +
                        "			a      => a,      --      a.a\n" +
                        "			b      => b,      --      b.b\n" +
                        "			q      => q,      --      q.q\n" +
                        "			opSel  => opSel   --  opSel.opSel\n" +
                        "		);\n" +
                        "\n" +
                        "end architecture rtl; -- of FP_ADD_SUB_64\n" +
                        "-- Retrieval info: <?xml version=\"1.0\"?>\n" +
                        "--<!--\n" +
                        "--	Generated by Altera MegaWizard Launcher Utility version 1.0\n" +
                        "--	************************************************************\n" +
                        "--	THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!\n" +
                        "--	************************************************************\n" +
                        "--	Copyright (C) 1991-2020 Altera Corporation\n" +
                        "--	Any megafunction design, and related net list (encrypted or decrypted),\n" +
                        "--	support information, device programming or simulation file, and any other\n" +
                        "--	associated documentation or information provided by Altera or a partner\n" +
                        "--	under Altera's Megafunction Partnership Program may be used only to\n" +
                        "--	program PLD devices (but not masked PLD devices) from Altera.  Any other\n" +
                        "--	use of such megafunction design, net list, support information, device\n" +
                        "--	programming or simulation file, or any other related documentation or\n" +
                        "--	information is prohibited for any other purpose, including, but not\n" +
                        "--	limited to modification, reverse engineering, de-compiling, or use with\n" +
                        "--	any other silicon devices, unless such use is explicitly licensed under\n" +
                        "--	a separate agreement with Altera or a megafunction partner.  Title to\n" +
                        "--	the intellectual property, including patents, copyrights, trademarks,\n" +
                        "--	trade secrets, or maskworks, embodied in any such megafunction design,\n" +
                        "--	net list, support information, device programming or simulation file, or\n" +
                        "--	any other related documentation or information provided by Altera or a\n" +
                        "--	megafunction partner, remains with Altera, the megafunction partner, or\n" +
                        "--	their respective licensors.  No other licenses, including any licenses\n" +
                        "--	needed under any third party's intellectual property, are provided herein.\n" +
                        "---->\n" +
                        "-- Retrieval info: <instance entity-name=\"altera_fp_functions\" version=\"18.0\" >\n" +
                        "-- Retrieval info: 	<generic name=\"FUNCTION_FAMILY\" value=\"ARITH\" />\n" +
                        "-- Retrieval info: 	<generic name=\"ARITH_function\" value=\"ADDSUB\" />\n" +
                        "-- Retrieval info: 	<generic name=\"CONVERT_function\" value=\"FXP_FP\" />\n" +
                        "-- Retrieval info: 	<generic name=\"ALL_function\" value=\"ADD\" />\n" +
                        "-- Retrieval info: 	<generic name=\"EXP_LOG_function\" value=\"EXPE\" />\n" +
                        "-- Retrieval info: 	<generic name=\"TRIG_function\" value=\"SIN\" />\n" +
                        "-- Retrieval info: 	<generic name=\"COMPARE_function\" value=\"MIN\" />\n" +
                        "-- Retrieval info: 	<generic name=\"ROOTS_function\" value=\"SQRT\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_format\" value=\"double\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_exp\" value=\"8\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_man\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"exponent_width\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"frequency_target\" value=\"100\" />\n" +
                        "-- Retrieval info: 	<generic name=\"latency_target\" value=\"9\" />\n" +
                        "-- Retrieval info: 	<generic name=\"performance_goal\" value=\"frequency\" />\n" +
                        "-- Retrieval info: 	<generic name=\"rounding_mode\" value=\"nearest with tie breaking away from zero\" />\n" +
                        "-- Retrieval info: 	<generic name=\"faithful_rounding\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gen_enable\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"divide_type\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"select_signal_enable\" value=\"true\" />\n" +
                        "-- Retrieval info: 	<generic name=\"scale_by_pi\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"number_of_inputs\" value=\"2\" />\n" +
                        "-- Retrieval info: 	<generic name=\"trig_no_range_reduction\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"report_resources_to_xml\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fxpt_width\" value=\"32\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fxpt_fraction\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fxpt_sign\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_out_format\" value=\"single\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_out_exp\" value=\"8\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_out_man\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_in_format\" value=\"single\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_in_exp\" value=\"8\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_in_man\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"enable_hard_fp\" value=\"true\" />\n" +
                        "-- Retrieval info: 	<generic name=\"manual_dsp_planning\" value=\"true\" />\n" +
                        "-- Retrieval info: 	<generic name=\"forceRegisters\" value=\"1111\" />\n" +
                        "-- Retrieval info: 	<generic name=\"selected_device_family\" value=\"Cyclone V\" />\n" +
                        "-- Retrieval info: 	<generic name=\"selected_device_speedgrade\" value=\"7\" />\n" +
                        "-- Retrieval info: </instance>\n" +
                        "-- IPFS_FILES : FP_ADD_SUB_64.vho\n" +
                        "-- RELATED_FILES: FP_ADD_SUB_64.vhd, dspba_library_package.vhd, dspba_library.vhd, FP_ADD_SUB_64_0002.vhd";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_FP_ADD_SUB_64_0002_64_vhd_file(String Project_Folder_File) {
        String data1 =  "-- ------------------------------------------------------------------------- \n" +
                        "-- High Level Design Compiler for Intel(R) FPGAs Version 18.0 (Release Build #614)\n" +
                        "-- Quartus Prime development tool and MATLAB/Simulink Interface\n" +
                        "-- \n" +
                        "-- Legal Notice: Copyright 2018 Intel Corporation.  All rights reserved.\n" +
                        "-- Your use of  Intel Corporation's design tools,  logic functions and other\n" +
                        "-- software and  tools, and its AMPP partner logic functions, and any output\n" +
                        "-- files any  of the foregoing (including  device programming  or simulation\n" +
                        "-- files), and  any associated  documentation  or information  are expressly\n" +
                        "-- subject  to the terms and  conditions of the  Intel FPGA Software License\n" +
                        "-- Agreement, Intel MegaCore Function License Agreement, or other applicable\n" +
                        "-- license agreement,  including,  without limitation,  that your use is for\n" +
                        "-- the  sole  purpose of  programming  logic devices  manufactured by  Intel\n" +
                        "-- and  sold by Intel  or its authorized  distributors. Please refer  to the\n" +
                        "-- applicable agreement for further details.\n" +
                        "-- ---------------------------------------------------------------------------\n" +
                        "\n" +
                        "-- VHDL created from FP_ADD_SUB_64_0002\n" +
                        "-- VHDL created on Thu Jun 25 09:18:55 2020\n" +
                        "\n" +
                        "\n" +
                        "library IEEE;\n" +
                        "use IEEE.std_logic_1164.all;\n" +
                        "use IEEE.NUMERIC_STD.all;\n" +
                        "use IEEE.MATH_REAL.all;\n" +
                        "use std.TextIO.all;\n" +
                        "use work.dspba_library_package.all;\n" +
                        "\n" +
                        "LIBRARY altera_mf;\n" +
                        "USE altera_mf.altera_mf_components.all;\n" +
                        "LIBRARY altera_lnsim;\n" +
                        "USE altera_lnsim.altera_lnsim_components.altera_syncram;\n" +
                        "LIBRARY lpm;\n" +
                        "USE lpm.lpm_components.all;\n" +
                        "\n" +
                        "entity FP_ADD_SUB_64_0002 is\n" +
                        "    port (\n" +
                        "        a : in std_logic_vector(63 downto 0);  -- float64_m52\n" +
                        "        b : in std_logic_vector(63 downto 0);  -- float64_m52\n" +
                        "        opSel : in std_logic_vector(0 downto 0);  -- ufix1\n" +
                        "        q : out std_logic_vector(63 downto 0);  -- float64_m52\n" +
                        "        clk : in std_logic;\n" +
                        "        areset : in std_logic\n" +
                        "    );\n" +
                        "end FP_ADD_SUB_64_0002;\n" +
                        "\n" +
                        "architecture normal of FP_ADD_SUB_64_0002 is\n" +
                        "\n" +
                        "    attribute altera_attribute : string;\n" +
                        "    attribute altera_attribute of normal : architecture is \"-name AUTO_SHIFT_REGISTER_RECOGNITION OFF; -name PHYSICAL_SYNTHESIS_REGISTER_DUPLICATION ON; -name MESSAGE_DISABLE 10036; -name MESSAGE_DISABLE 10037; -name MESSAGE_DISABLE 14130; -name MESSAGE_DISABLE 14320; -name MESSAGE_DISABLE 15400; -name MESSAGE_DISABLE 14130; -name MESSAGE_DISABLE 10036; -name MESSAGE_DISABLE 12020; -name MESSAGE_DISABLE 12030; -name MESSAGE_DISABLE 12010; -name MESSAGE_DISABLE 12110; -name MESSAGE_DISABLE 14320; -name MESSAGE_DISABLE 13410; -name MESSAGE_DISABLE 113007\";\n" +
                        "    \n" +
                        "    signal GND_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal VCC_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal signB_uid6_fpAddSubTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal restB_uid7_fpAddSubTest_b : STD_LOGIC_VECTOR (62 downto 0);\n" +
                        "    signal invSignB_uid8_fpAddSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal muxSignB_uid9_fpAddSubTest_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal muxSignB_uid9_fpAddSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal bOperand_uid10_fpAddSubTest_q : STD_LOGIC_VECTOR (63 downto 0);\n" +
                        "    signal expFracX_uid15_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (62 downto 0);\n" +
                        "    signal expFracY_uid16_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (62 downto 0);\n" +
                        "    signal xGTEy_uid17_fpAddSubTest_ieeeAdd_a : STD_LOGIC_VECTOR (64 downto 0);\n" +
                        "    signal xGTEy_uid17_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (64 downto 0);\n" +
                        "    signal xGTEy_uid17_fpAddSubTest_ieeeAdd_o : STD_LOGIC_VECTOR (64 downto 0);\n" +
                        "    signal xGTEy_uid17_fpAddSubTest_ieeeAdd_n : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracY_uid18_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal expY_uid19_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal sigY_uid20_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal ypn_uid21_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (63 downto 0);\n" +
                        "    signal aSig_uid25_fpAddSubTest_ieeeAdd_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal aSig_uid25_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (63 downto 0);\n" +
                        "    signal bSig_uid26_fpAddSubTest_ieeeAdd_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal bSig_uid26_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (63 downto 0);\n" +
                        "    signal cstAllOWE_uid27_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal cstZeroWF_uid28_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal cstAllZWE_uid29_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal exp_aSig_uid30_fpAddSubTest_ieeeAdd_in : STD_LOGIC_VECTOR (62 downto 0);\n" +
                        "    signal exp_aSig_uid30_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal frac_aSig_uid31_fpAddSubTest_ieeeAdd_in : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal frac_aSig_uid31_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal excZ_aSig_uid25_uid32_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expXIsMax_uid33_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsZero_uid34_fpAddSubTest_ieeeAdd_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsZero_uid34_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsNotZero_uid35_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excI_aSig_uid36_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excN_aSig_uid37_fpAddSubTest_ieeeAdd_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excN_aSig_uid37_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal invExpXIsMax_uid38_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal InvExpXIsZero_uid39_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excR_aSig_uid40_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal exp_bSig_uid44_fpAddSubTest_ieeeAdd_in : STD_LOGIC_VECTOR (62 downto 0);\n" +
                        "    signal exp_bSig_uid44_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal frac_bSig_uid45_fpAddSubTest_ieeeAdd_in : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal frac_bSig_uid45_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal excZ_bSig_uid26_uid46_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expXIsMax_uid47_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsZero_uid48_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsNotZero_uid49_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excI_bSig_uid50_fpAddSubTest_ieeeAdd_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excI_bSig_uid50_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excN_bSig_uid51_fpAddSubTest_ieeeAdd_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excN_bSig_uid51_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal invExpXIsMax_uid52_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal InvExpXIsZero_uid53_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excR_bSig_uid54_fpAddSubTest_ieeeAdd_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excR_bSig_uid54_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal sigA_uid59_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal sigB_uid60_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal effSub_uid61_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracBz_uid65_fpAddSubTest_ieeeAdd_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracBz_uid65_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal oFracB_uid68_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (52 downto 0);\n" +
                        "    signal expAmExpB_uid69_fpAddSubTest_ieeeAdd_a : STD_LOGIC_VECTOR (11 downto 0);\n" +
                        "    signal expAmExpB_uid69_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (11 downto 0);\n" +
                        "    signal expAmExpB_uid69_fpAddSubTest_ieeeAdd_o : STD_LOGIC_VECTOR (11 downto 0);\n" +
                        "    signal expAmExpB_uid69_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (11 downto 0);\n" +
                        "    signal cWFP2_uid70_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (5 downto 0);\n" +
                        "    signal shiftedOut_uid72_fpAddSubTest_ieeeAdd_a : STD_LOGIC_VECTOR (13 downto 0);\n" +
                        "    signal shiftedOut_uid72_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (13 downto 0);\n" +
                        "    signal shiftedOut_uid72_fpAddSubTest_ieeeAdd_o : STD_LOGIC_VECTOR (13 downto 0);\n" +
                        "    signal shiftedOut_uid72_fpAddSubTest_ieeeAdd_c : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal padConst_uid73_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (53 downto 0);\n" +
                        "    signal rightPaddedIn_uid74_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (106 downto 0);\n" +
                        "    signal iShiftedOut_uid76_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal alignFracBPostShiftOut_uid77_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (106 downto 0);\n" +
                        "    signal alignFracBPostShiftOut_uid77_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (106 downto 0);\n" +
                        "    signal cmpEQ_stickyBits_cZwF_uid80_fpAddSubTest_ieeeAdd_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal cmpEQ_stickyBits_cZwF_uid80_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal invCmpEQ_stickyBits_cZwF_uid81_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal effSubInvSticky_uid83_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal zocst_uid85_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal fracAAddOp_uid86_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (55 downto 0);\n" +
                        "    signal fracBAddOp_uid89_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (55 downto 0);\n" +
                        "    signal fracBAddOpPostXor_uid90_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (55 downto 0);\n" +
                        "    signal fracBAddOpPostXor_uid90_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (55 downto 0);\n" +
                        "    signal fracAddResult_uid91_fpAddSubTest_ieeeAdd_a : STD_LOGIC_VECTOR (56 downto 0);\n" +
                        "    signal fracAddResult_uid91_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (56 downto 0);\n" +
                        "    signal fracAddResult_uid91_fpAddSubTest_ieeeAdd_o : STD_LOGIC_VECTOR (56 downto 0);\n" +
                        "    signal fracAddResult_uid91_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (56 downto 0);\n" +
                        "    signal rangeFracAddResultMwfp3Dto0_uid92_fpAddSubTest_ieeeAdd_in : STD_LOGIC_VECTOR (55 downto 0);\n" +
                        "    signal rangeFracAddResultMwfp3Dto0_uid92_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (55 downto 0);\n" +
                        "    signal fracGRS_uid93_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (56 downto 0);\n" +
                        "    signal cAmA_uid95_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (5 downto 0);\n" +
                        "    signal aMinusA_uid96_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracPostNorm_uid98_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (55 downto 0);\n" +
                        "    signal oneCST_uid99_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal expInc_uid100_fpAddSubTest_ieeeAdd_a : STD_LOGIC_VECTOR (11 downto 0);\n" +
                        "    signal expInc_uid100_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (11 downto 0);\n" +
                        "    signal expInc_uid100_fpAddSubTest_ieeeAdd_o : STD_LOGIC_VECTOR (11 downto 0);\n" +
                        "    signal expInc_uid100_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (11 downto 0);\n" +
                        "    signal expPostNorm_uid101_fpAddSubTest_ieeeAdd_a : STD_LOGIC_VECTOR (12 downto 0);\n" +
                        "    signal expPostNorm_uid101_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (12 downto 0);\n" +
                        "    signal expPostNorm_uid101_fpAddSubTest_ieeeAdd_o : STD_LOGIC_VECTOR (12 downto 0);\n" +
                        "    signal expPostNorm_uid101_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (12 downto 0);\n" +
                        "    signal Sticky0_uid102_fpAddSubTest_ieeeAdd_in : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal Sticky0_uid102_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal Sticky1_uid103_fpAddSubTest_ieeeAdd_in : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal Sticky1_uid103_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal Round_uid104_fpAddSubTest_ieeeAdd_in : STD_LOGIC_VECTOR (2 downto 0);\n" +
                        "    signal Round_uid104_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal Guard_uid105_fpAddSubTest_ieeeAdd_in : STD_LOGIC_VECTOR (3 downto 0);\n" +
                        "    signal Guard_uid105_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal LSB_uid106_fpAddSubTest_ieeeAdd_in : STD_LOGIC_VECTOR (4 downto 0);\n" +
                        "    signal LSB_uid106_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rndBitCond_uid107_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (4 downto 0);\n" +
                        "    signal cRBit_uid108_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (4 downto 0);\n" +
                        "    signal rBi_uid109_fpAddSubTest_ieeeAdd_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rBi_uid109_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal roundBit_uid110_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracPostNormRndRange_uid111_fpAddSubTest_ieeeAdd_in : STD_LOGIC_VECTOR (54 downto 0);\n" +
                        "    signal fracPostNormRndRange_uid111_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (52 downto 0);\n" +
                        "    signal expFracR_uid112_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (65 downto 0);\n" +
                        "    signal rndExpFrac_uid113_fpAddSubTest_ieeeAdd_a : STD_LOGIC_VECTOR (66 downto 0);\n" +
                        "    signal rndExpFrac_uid113_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (66 downto 0);\n" +
                        "    signal rndExpFrac_uid113_fpAddSubTest_ieeeAdd_o : STD_LOGIC_VECTOR (66 downto 0);\n" +
                        "    signal rndExpFrac_uid113_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (66 downto 0);\n" +
                        "    signal wEP2AllOwE_uid114_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (12 downto 0);\n" +
                        "    signal rndExp_uid115_fpAddSubTest_ieeeAdd_in : STD_LOGIC_VECTOR (65 downto 0);\n" +
                        "    signal rndExp_uid115_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (12 downto 0);\n" +
                        "    signal rOvfEQMax_uid116_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rndExpFracOvfBits_uid118_fpAddSubTest_ieeeAdd_in : STD_LOGIC_VECTOR (65 downto 0);\n" +
                        "    signal rndExpFracOvfBits_uid118_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal rOvfExtraBits_uid119_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rOvf_uid120_fpAddSubTest_ieeeAdd_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rOvf_uid120_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal wEP2AllZ_uid121_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (12 downto 0);\n" +
                        "    signal rUdfEQMin_uid122_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rUdfExtraBit_uid123_fpAddSubTest_ieeeAdd_in : STD_LOGIC_VECTOR (65 downto 0);\n" +
                        "    signal rUdfExtraBit_uid123_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rUdf_uid124_fpAddSubTest_ieeeAdd_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rUdf_uid124_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracRPreExc_uid125_fpAddSubTest_ieeeAdd_in : STD_LOGIC_VECTOR (52 downto 0);\n" +
                        "    signal fracRPreExc_uid125_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal expRPreExc_uid126_fpAddSubTest_ieeeAdd_in : STD_LOGIC_VECTOR (63 downto 0);\n" +
                        "    signal expRPreExc_uid126_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal regInputs_uid127_fpAddSubTest_ieeeAdd_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal regInputs_uid127_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excRZeroVInC_uid128_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (4 downto 0);\n" +
                        "    signal excRZero_uid129_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rInfOvf_uid130_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excRInfVInC_uid131_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (5 downto 0);\n" +
                        "    signal excRInf_uid132_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excRNaN2_uid133_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excAIBISub_uid134_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excRNaN_uid135_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal concExc_uid136_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (2 downto 0);\n" +
                        "    signal excREnc_uid137_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal invAMinusA_uid138_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal signRReg_uid139_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal sigBBInf_uid140_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal sigAAInf_uid141_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal signRInf_uid142_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excAZBZSigASigB_uid143_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excBZARSigA_uid144_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal signRZero_uid145_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal signRInfRZRReg_uid146_fpAddSubTest_ieeeAdd_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal signRInfRZRReg_uid146_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal invExcRNaN_uid147_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal signRPostExc_uid148_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal oneFracRPostExc2_uid149_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal fracRPostExc_uid152_fpAddSubTest_ieeeAdd_s : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal fracRPostExc_uid152_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal expRPostExc_uid156_fpAddSubTest_ieeeAdd_s : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal expRPostExc_uid156_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal R_uid157_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (63 downto 0);\n" +
                        "    signal zs_uid159_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (31 downto 0);\n" +
                        "    signal rVStage_uid160_lzCountVal_uid94_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (31 downto 0);\n" +
                        "    signal vCount_uid161_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal mO_uid162_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (6 downto 0);\n" +
                        "    signal vStage_uid163_lzCountVal_uid94_fpAddSubTest_ieeeAdd_in : STD_LOGIC_VECTOR (24 downto 0);\n" +
                        "    signal vStage_uid163_lzCountVal_uid94_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (24 downto 0);\n" +
                        "    signal cStage_uid164_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (31 downto 0);\n" +
                        "    signal vStagei_uid166_lzCountVal_uid94_fpAddSubTest_ieeeAdd_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal vStagei_uid166_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (31 downto 0);\n" +
                        "    signal zs_uid167_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (15 downto 0);\n" +
                        "    signal vCount_uid169_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal vStagei_uid172_lzCountVal_uid94_fpAddSubTest_ieeeAdd_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal vStagei_uid172_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (15 downto 0);\n" +
                        "    signal zs_uid173_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal vCount_uid175_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal vStagei_uid178_lzCountVal_uid94_fpAddSubTest_ieeeAdd_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal vStagei_uid178_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal zs_uid179_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (3 downto 0);\n" +
                        "    signal vCount_uid181_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal vStagei_uid184_lzCountVal_uid94_fpAddSubTest_ieeeAdd_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal vStagei_uid184_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (3 downto 0);\n" +
                        "    signal zs_uid185_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal vCount_uid187_lzCountVal_uid94_fpAddSubTest_ieeeAdd_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal vCount_uid187_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal vStagei_uid190_lzCountVal_uid94_fpAddSubTest_ieeeAdd_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal vStagei_uid190_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal rVStage_uid192_lzCountVal_uid94_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal vCount_uid193_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal r_uid194_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (5 downto 0);\n" +
                        "    signal wIntCst_uid198_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (6 downto 0);\n" +
                        "    signal shiftedOut_uid199_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_a : STD_LOGIC_VECTOR (13 downto 0);\n" +
                        "    signal shiftedOut_uid199_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (13 downto 0);\n" +
                        "    signal shiftedOut_uid199_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_o : STD_LOGIC_VECTOR (13 downto 0);\n" +
                        "    signal shiftedOut_uid199_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_n : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rightShiftStage0Idx1Rng32_uid200_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (74 downto 0);\n" +
                        "    signal rightShiftStage0Idx1_uid202_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (106 downto 0);\n" +
                        "    signal rightShiftStage0Idx2Rng64_uid203_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (42 downto 0);\n" +
                        "    signal rightShiftStage0Idx2Pad64_uid204_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (63 downto 0);\n" +
                        "    signal rightShiftStage0Idx2_uid205_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (106 downto 0);\n" +
                        "    signal rightShiftStage0Idx3Rng96_uid206_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal rightShiftStage0Idx3Pad96_uid207_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (95 downto 0);\n" +
                        "    signal rightShiftStage0Idx3_uid208_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (106 downto 0);\n" +
                        "    signal rightShiftStage0_uid210_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_s : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal rightShiftStage0_uid210_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (106 downto 0);\n" +
                        "    signal rightShiftStage1Idx1Rng8_uid211_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (98 downto 0);\n" +
                        "    signal rightShiftStage1Idx1_uid213_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (106 downto 0);\n" +
                        "    signal rightShiftStage1Idx2Rng16_uid214_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (90 downto 0);\n" +
                        "    signal rightShiftStage1Idx2_uid216_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (106 downto 0);\n" +
                        "    signal rightShiftStage1Idx3Rng24_uid217_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (82 downto 0);\n" +
                        "    signal rightShiftStage1Idx3Pad24_uid218_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (23 downto 0);\n" +
                        "    signal rightShiftStage1Idx3_uid219_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (106 downto 0);\n" +
                        "    signal rightShiftStage1_uid221_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_s : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal rightShiftStage1_uid221_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (106 downto 0);\n" +
                        "    signal rightShiftStage2Idx1Rng2_uid222_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (104 downto 0);\n" +
                        "    signal rightShiftStage2Idx1_uid224_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (106 downto 0);\n" +
                        "    signal rightShiftStage2Idx2Rng4_uid225_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (102 downto 0);\n" +
                        "    signal rightShiftStage2Idx2_uid227_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (106 downto 0);\n" +
                        "    signal rightShiftStage2Idx3Rng6_uid228_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (100 downto 0);\n" +
                        "    signal rightShiftStage2Idx3Pad6_uid229_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (5 downto 0);\n" +
                        "    signal rightShiftStage2Idx3_uid230_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (106 downto 0);\n" +
                        "    signal rightShiftStage2_uid232_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_s : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal rightShiftStage2_uid232_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (106 downto 0);\n" +
                        "    signal rightShiftStage3Idx1Rng1_uid233_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (105 downto 0);\n" +
                        "    signal rightShiftStage3Idx1_uid235_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (106 downto 0);\n" +
                        "    signal rightShiftStage3_uid237_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rightShiftStage3_uid237_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (106 downto 0);\n" +
                        "    signal zeroOutCst_uid238_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (106 downto 0);\n" +
                        "    signal r_uid239_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal r_uid239_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (106 downto 0);\n" +
                        "    signal leftShiftStage0Idx1Rng16_uid244_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_in : STD_LOGIC_VECTOR (40 downto 0);\n" +
                        "    signal leftShiftStage0Idx1Rng16_uid244_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (40 downto 0);\n" +
                        "    signal leftShiftStage0Idx1_uid245_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (56 downto 0);\n" +
                        "    signal leftShiftStage0Idx2_uid248_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (56 downto 0);\n" +
                        "    signal leftShiftStage0Idx3Pad48_uid249_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (47 downto 0);\n" +
                        "    signal leftShiftStage0Idx3Rng48_uid250_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_in : STD_LOGIC_VECTOR (8 downto 0);\n" +
                        "    signal leftShiftStage0Idx3Rng48_uid250_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (8 downto 0);\n" +
                        "    signal leftShiftStage0Idx3_uid251_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (56 downto 0);\n" +
                        "    signal leftShiftStage0_uid253_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_s : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal leftShiftStage0_uid253_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (56 downto 0);\n" +
                        "    signal leftShiftStage1Idx1Rng4_uid255_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_in : STD_LOGIC_VECTOR (52 downto 0);\n" +
                        "    signal leftShiftStage1Idx1Rng4_uid255_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (52 downto 0);\n" +
                        "    signal leftShiftStage1Idx1_uid256_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (56 downto 0);\n" +
                        "    signal leftShiftStage1Idx2Rng8_uid258_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_in : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal leftShiftStage1Idx2Rng8_uid258_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal leftShiftStage1Idx2_uid259_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (56 downto 0);\n" +
                        "    signal leftShiftStage1Idx3Pad12_uid260_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (11 downto 0);\n" +
                        "    signal leftShiftStage1Idx3Rng12_uid261_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_in : STD_LOGIC_VECTOR (44 downto 0);\n" +
                        "    signal leftShiftStage1Idx3Rng12_uid261_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (44 downto 0);\n" +
                        "    signal leftShiftStage1Idx3_uid262_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (56 downto 0);\n" +
                        "    signal leftShiftStage1_uid264_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_s : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal leftShiftStage1_uid264_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (56 downto 0);\n" +
                        "    signal leftShiftStage2Idx1Rng1_uid266_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_in : STD_LOGIC_VECTOR (55 downto 0);\n" +
                        "    signal leftShiftStage2Idx1Rng1_uid266_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (55 downto 0);\n" +
                        "    signal leftShiftStage2Idx1_uid267_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (56 downto 0);\n" +
                        "    signal leftShiftStage2Idx2Rng2_uid269_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_in : STD_LOGIC_VECTOR (54 downto 0);\n" +
                        "    signal leftShiftStage2Idx2Rng2_uid269_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (54 downto 0);\n" +
                        "    signal leftShiftStage2Idx2_uid270_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (56 downto 0);\n" +
                        "    signal leftShiftStage2Idx3Pad3_uid271_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (2 downto 0);\n" +
                        "    signal leftShiftStage2Idx3Rng3_uid272_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_in : STD_LOGIC_VECTOR (53 downto 0);\n" +
                        "    signal leftShiftStage2Idx3Rng3_uid272_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_b : STD_LOGIC_VECTOR (53 downto 0);\n" +
                        "    signal leftShiftStage2Idx3_uid273_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (56 downto 0);\n" +
                        "    signal leftShiftStage2_uid275_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_s : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal leftShiftStage2_uid275_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q : STD_LOGIC_VECTOR (56 downto 0);\n" +
                        "    signal rightShiftStageSel6Dto5_uid209_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_merged_bit_select_in : STD_LOGIC_VECTOR (6 downto 0);\n" +
                        "    signal rightShiftStageSel6Dto5_uid209_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_merged_bit_select_b : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal rightShiftStageSel6Dto5_uid209_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_merged_bit_select_c : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal rightShiftStageSel6Dto5_uid209_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_merged_bit_select_d : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal rightShiftStageSel6Dto5_uid209_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_merged_bit_select_e : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal stickyBits_uid78_fpAddSubTest_ieeeAdd_merged_bit_select_b : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal stickyBits_uid78_fpAddSubTest_ieeeAdd_merged_bit_select_c : STD_LOGIC_VECTOR (54 downto 0);\n" +
                        "    signal rVStage_uid168_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_b : STD_LOGIC_VECTOR (15 downto 0);\n" +
                        "    signal rVStage_uid168_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_c : STD_LOGIC_VECTOR (15 downto 0);\n" +
                        "    signal rVStage_uid174_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_b : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal rVStage_uid174_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_c : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal rVStage_uid180_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_b : STD_LOGIC_VECTOR (3 downto 0);\n" +
                        "    signal rVStage_uid180_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_c : STD_LOGIC_VECTOR (3 downto 0);\n" +
                        "    signal rVStage_uid186_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_b : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal rVStage_uid186_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_c : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal leftShiftStageSel5Dto4_uid252_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_merged_bit_select_b : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal leftShiftStageSel5Dto4_uid252_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_merged_bit_select_c : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal leftShiftStageSel5Dto4_uid252_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_merged_bit_select_d : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal redist0_rVStage_uid186_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_b_1_q : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal redist1_rVStage_uid186_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_c_1_q : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal redist2_stickyBits_uid78_fpAddSubTest_ieeeAdd_merged_bit_select_c_1_q : STD_LOGIC_VECTOR (54 downto 0);\n" +
                        "    signal redist3_rightShiftStageSel6Dto5_uid209_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_merged_bit_select_c_1_q : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal redist4_rightShiftStageSel6Dto5_uid209_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_merged_bit_select_d_1_q : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal redist5_rightShiftStageSel6Dto5_uid209_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_merged_bit_select_e_1_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist6_vCount_uid181_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q_1_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist7_vCount_uid175_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q_1_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist8_vCount_uid169_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q_2_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist9_vStage_uid163_lzCountVal_uid94_fpAddSubTest_ieeeAdd_b_2_q : STD_LOGIC_VECTOR (24 downto 0);\n" +
                        "    signal redist10_vCount_uid161_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q_2_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist11_signRInfRZRReg_uid146_fpAddSubTest_ieeeAdd_q_2_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist12_regInputs_uid127_fpAddSubTest_ieeeAdd_q_2_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist13_expRPreExc_uid126_fpAddSubTest_ieeeAdd_b_1_q : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal redist14_fracRPreExc_uid125_fpAddSubTest_ieeeAdd_b_1_q : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal redist15_fracPostNormRndRange_uid111_fpAddSubTest_ieeeAdd_b_1_q : STD_LOGIC_VECTOR (52 downto 0);\n" +
                        "    signal redist16_aMinusA_uid96_fpAddSubTest_ieeeAdd_q_2_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist17_fracGRS_uid93_fpAddSubTest_ieeeAdd_q_2_q : STD_LOGIC_VECTOR (56 downto 0);\n" +
                        "    signal redist18_rangeFracAddResultMwfp3Dto0_uid92_fpAddSubTest_ieeeAdd_b_1_q : STD_LOGIC_VECTOR (55 downto 0);\n" +
                        "    signal redist19_cmpEQ_stickyBits_cZwF_uid80_fpAddSubTest_ieeeAdd_q_2_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist20_shiftedOut_uid72_fpAddSubTest_ieeeAdd_c_2_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist21_effSub_uid61_fpAddSubTest_ieeeAdd_q_5_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist22_sigB_uid60_fpAddSubTest_ieeeAdd_b_3_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist23_sigB_uid60_fpAddSubTest_ieeeAdd_b_6_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist24_sigA_uid59_fpAddSubTest_ieeeAdd_b_4_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist25_sigA_uid59_fpAddSubTest_ieeeAdd_b_7_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist26_excR_bSig_uid54_fpAddSubTest_ieeeAdd_q_6_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist27_excN_bSig_uid51_fpAddSubTest_ieeeAdd_q_8_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist28_excI_bSig_uid50_fpAddSubTest_ieeeAdd_q_6_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist29_excI_bSig_uid50_fpAddSubTest_ieeeAdd_q_8_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist30_excZ_bSig_uid26_uid46_fpAddSubTest_ieeeAdd_q_6_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist31_excZ_bSig_uid26_uid46_fpAddSubTest_ieeeAdd_q_8_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist32_excN_aSig_uid37_fpAddSubTest_ieeeAdd_q_2_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist33_excI_aSig_uid36_fpAddSubTest_ieeeAdd_q_2_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist34_fracXIsZero_uid34_fpAddSubTest_ieeeAdd_q_3_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist35_excZ_aSig_uid25_uid32_fpAddSubTest_ieeeAdd_q_2_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist36_frac_aSig_uid31_fpAddSubTest_ieeeAdd_b_4_q : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal redist37_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_1_q : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal redist36_frac_aSig_uid31_fpAddSubTest_ieeeAdd_b_4_inputreg_q : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal redist36_frac_aSig_uid31_fpAddSubTest_ieeeAdd_b_4_outputreg_q : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_outputreg_q : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_mem_reset0 : std_logic;\n" +
                        "    signal redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_mem_ia : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_mem_aa : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_mem_ab : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_mem_iq : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_mem_q : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_rdcnt_q : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_rdcnt_i : UNSIGNED (1 downto 0);\n" +
                        "    attribute preserve : boolean;\n";
        String data2 =  "    attribute preserve of redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_rdcnt_i : signal is true;\n" +
                        "    signal redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_wraddr_q : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_mem_last_q : STD_LOGIC_VECTOR (2 downto 0);\n" +
                        "    signal redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_cmp_b : STD_LOGIC_VECTOR (2 downto 0);\n" +
                        "    signal redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_cmp_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_cmpReg_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_notEnable_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_nor_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_sticky_ena_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    attribute preserve_syn_only : boolean;\n" +
                        "    attribute preserve_syn_only of redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_sticky_ena_q : signal is true;\n" +
                        "    signal redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_enaAnd_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "\n" +
                        "    -- cAmA_uid95_fpAddSubTest_ieeeAdd(CONSTANT,94)\n" +
                        "    cAmA_uid95_fpAddSubTest_ieeeAdd_q <= \"111001\";\n" +
                        "\n" +
                        "    -- zs_uid159_lzCountVal_uid94_fpAddSubTest_ieeeAdd(CONSTANT,158)\n" +
                        "    zs_uid159_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q <= \"00000000000000000000000000000000\";\n" +
                        "\n" +
                        "    -- signB_uid6_fpAddSubTest(BITSELECT,5)@0\n" +
                        "    signB_uid6_fpAddSubTest_b <= STD_LOGIC_VECTOR(b(63 downto 63));\n" +
                        "\n" +
                        "    -- invSignB_uid8_fpAddSubTest(LOGICAL,7)@0\n" +
                        "    invSignB_uid8_fpAddSubTest_q <= not (signB_uid6_fpAddSubTest_b);\n" +
                        "\n" +
                        "    -- muxSignB_uid9_fpAddSubTest(MUX,8)@0\n" +
                        "    muxSignB_uid9_fpAddSubTest_s <= opSel;\n" +
                        "    muxSignB_uid9_fpAddSubTest_combproc: PROCESS (muxSignB_uid9_fpAddSubTest_s, invSignB_uid8_fpAddSubTest_q, signB_uid6_fpAddSubTest_b)\n" +
                        "    BEGIN\n" +
                        "        CASE (muxSignB_uid9_fpAddSubTest_s) IS\n" +
                        "            WHEN \"0\" => muxSignB_uid9_fpAddSubTest_q <= invSignB_uid8_fpAddSubTest_q;\n" +
                        "            WHEN \"1\" => muxSignB_uid9_fpAddSubTest_q <= signB_uid6_fpAddSubTest_b;\n" +
                        "            WHEN OTHERS => muxSignB_uid9_fpAddSubTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- restB_uid7_fpAddSubTest(BITSELECT,6)@0\n" +
                        "    restB_uid7_fpAddSubTest_b <= b(62 downto 0);\n" +
                        "\n" +
                        "    -- bOperand_uid10_fpAddSubTest(BITJOIN,9)@0\n" +
                        "    bOperand_uid10_fpAddSubTest_q <= muxSignB_uid9_fpAddSubTest_q & restB_uid7_fpAddSubTest_b;\n" +
                        "\n" +
                        "    -- sigY_uid20_fpAddSubTest_ieeeAdd(BITSELECT,19)@0\n" +
                        "    sigY_uid20_fpAddSubTest_ieeeAdd_b <= STD_LOGIC_VECTOR(bOperand_uid10_fpAddSubTest_q(63 downto 63));\n" +
                        "\n" +
                        "    -- expY_uid19_fpAddSubTest_ieeeAdd(BITSELECT,18)@0\n" +
                        "    expY_uid19_fpAddSubTest_ieeeAdd_b <= bOperand_uid10_fpAddSubTest_q(62 downto 52);\n" +
                        "\n" +
                        "    -- fracY_uid18_fpAddSubTest_ieeeAdd(BITSELECT,17)@0\n" +
                        "    fracY_uid18_fpAddSubTest_ieeeAdd_b <= bOperand_uid10_fpAddSubTest_q(51 downto 0);\n" +
                        "\n" +
                        "    -- ypn_uid21_fpAddSubTest_ieeeAdd(BITJOIN,20)@0\n" +
                        "    ypn_uid21_fpAddSubTest_ieeeAdd_q <= sigY_uid20_fpAddSubTest_ieeeAdd_b & expY_uid19_fpAddSubTest_ieeeAdd_b & fracY_uid18_fpAddSubTest_ieeeAdd_b;\n" +
                        "\n" +
                        "    -- GND(CONSTANT,0)\n" +
                        "    GND_q <= \"0\";\n" +
                        "\n" +
                        "    -- expFracY_uid16_fpAddSubTest_ieeeAdd(BITSELECT,15)@0\n" +
                        "    expFracY_uid16_fpAddSubTest_ieeeAdd_b <= bOperand_uid10_fpAddSubTest_q(62 downto 0);\n" +
                        "\n" +
                        "    -- expFracX_uid15_fpAddSubTest_ieeeAdd(BITSELECT,14)@0\n" +
                        "    expFracX_uid15_fpAddSubTest_ieeeAdd_b <= a(62 downto 0);\n" +
                        "\n" +
                        "    -- xGTEy_uid17_fpAddSubTest_ieeeAdd(COMPARE,16)@0\n" +
                        "    xGTEy_uid17_fpAddSubTest_ieeeAdd_a <= STD_LOGIC_VECTOR(\"00\" & expFracX_uid15_fpAddSubTest_ieeeAdd_b);\n" +
                        "    xGTEy_uid17_fpAddSubTest_ieeeAdd_b <= STD_LOGIC_VECTOR(\"00\" & expFracY_uid16_fpAddSubTest_ieeeAdd_b);\n" +
                        "    xGTEy_uid17_fpAddSubTest_ieeeAdd_o <= STD_LOGIC_VECTOR(UNSIGNED(xGTEy_uid17_fpAddSubTest_ieeeAdd_a) - UNSIGNED(xGTEy_uid17_fpAddSubTest_ieeeAdd_b));\n" +
                        "    xGTEy_uid17_fpAddSubTest_ieeeAdd_n(0) <= not (xGTEy_uid17_fpAddSubTest_ieeeAdd_o(64));\n" +
                        "\n" +
                        "    -- bSig_uid26_fpAddSubTest_ieeeAdd(MUX,25)@0 + 1\n" +
                        "    bSig_uid26_fpAddSubTest_ieeeAdd_s <= xGTEy_uid17_fpAddSubTest_ieeeAdd_n;\n" +
                        "    bSig_uid26_fpAddSubTest_ieeeAdd_clkproc: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            bSig_uid26_fpAddSubTest_ieeeAdd_q <= (others => '0');\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            CASE (bSig_uid26_fpAddSubTest_ieeeAdd_s) IS\n" +
                        "                WHEN \"0\" => bSig_uid26_fpAddSubTest_ieeeAdd_q <= a;\n" +
                        "                WHEN \"1\" => bSig_uid26_fpAddSubTest_ieeeAdd_q <= ypn_uid21_fpAddSubTest_ieeeAdd_q;\n" +
                        "                WHEN OTHERS => bSig_uid26_fpAddSubTest_ieeeAdd_q <= (others => '0');\n" +
                        "            END CASE;\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- sigB_uid60_fpAddSubTest_ieeeAdd(BITSELECT,59)@1\n" +
                        "    sigB_uid60_fpAddSubTest_ieeeAdd_b <= STD_LOGIC_VECTOR(bSig_uid26_fpAddSubTest_ieeeAdd_q(63 downto 63));\n" +
                        "\n" +
                        "    -- redist22_sigB_uid60_fpAddSubTest_ieeeAdd_b_3(DELAY,305)\n" +
                        "    redist22_sigB_uid60_fpAddSubTest_ieeeAdd_b_3 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 3, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => sigB_uid60_fpAddSubTest_ieeeAdd_b, xout => redist22_sigB_uid60_fpAddSubTest_ieeeAdd_b_3_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- aSig_uid25_fpAddSubTest_ieeeAdd(MUX,24)@0\n" +
                        "    aSig_uid25_fpAddSubTest_ieeeAdd_s <= xGTEy_uid17_fpAddSubTest_ieeeAdd_n;\n" +
                        "    aSig_uid25_fpAddSubTest_ieeeAdd_combproc: PROCESS (aSig_uid25_fpAddSubTest_ieeeAdd_s, ypn_uid21_fpAddSubTest_ieeeAdd_q, a)\n" +
                        "    BEGIN\n" +
                        "        CASE (aSig_uid25_fpAddSubTest_ieeeAdd_s) IS\n" +
                        "            WHEN \"0\" => aSig_uid25_fpAddSubTest_ieeeAdd_q <= ypn_uid21_fpAddSubTest_ieeeAdd_q;\n" +
                        "            WHEN \"1\" => aSig_uid25_fpAddSubTest_ieeeAdd_q <= a;\n" +
                        "            WHEN OTHERS => aSig_uid25_fpAddSubTest_ieeeAdd_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- sigA_uid59_fpAddSubTest_ieeeAdd(BITSELECT,58)@0\n" +
                        "    sigA_uid59_fpAddSubTest_ieeeAdd_b <= STD_LOGIC_VECTOR(aSig_uid25_fpAddSubTest_ieeeAdd_q(63 downto 63));\n" +
                        "\n" +
                        "    -- redist24_sigA_uid59_fpAddSubTest_ieeeAdd_b_4(DELAY,307)\n" +
                        "    redist24_sigA_uid59_fpAddSubTest_ieeeAdd_b_4 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 4, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => sigA_uid59_fpAddSubTest_ieeeAdd_b, xout => redist24_sigA_uid59_fpAddSubTest_ieeeAdd_b_4_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- effSub_uid61_fpAddSubTest_ieeeAdd(LOGICAL,60)@4\n" +
                        "    effSub_uid61_fpAddSubTest_ieeeAdd_q <= redist24_sigA_uid59_fpAddSubTest_ieeeAdd_b_4_q xor redist22_sigB_uid60_fpAddSubTest_ieeeAdd_b_3_q;\n" +
                        "\n" +
                        "    -- exp_bSig_uid44_fpAddSubTest_ieeeAdd(BITSELECT,43)@1\n" +
                        "    exp_bSig_uid44_fpAddSubTest_ieeeAdd_in <= bSig_uid26_fpAddSubTest_ieeeAdd_q(62 downto 0);\n" +
                        "    exp_bSig_uid44_fpAddSubTest_ieeeAdd_b <= exp_bSig_uid44_fpAddSubTest_ieeeAdd_in(62 downto 52);\n" +
                        "\n" +
                        "    -- exp_aSig_uid30_fpAddSubTest_ieeeAdd(BITSELECT,29)@0\n" +
                        "    exp_aSig_uid30_fpAddSubTest_ieeeAdd_in <= aSig_uid25_fpAddSubTest_ieeeAdd_q(62 downto 0);\n" +
                        "    exp_aSig_uid30_fpAddSubTest_ieeeAdd_b <= exp_aSig_uid30_fpAddSubTest_ieeeAdd_in(62 downto 52);\n" +
                        "\n" +
                        "    -- redist37_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_1(DELAY,320)\n" +
                        "    redist37_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 11, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => exp_aSig_uid30_fpAddSubTest_ieeeAdd_b, xout => redist37_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- expAmExpB_uid69_fpAddSubTest_ieeeAdd(SUB,68)@1\n" +
                        "    expAmExpB_uid69_fpAddSubTest_ieeeAdd_a <= STD_LOGIC_VECTOR(\"0\" & redist37_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_1_q);\n" +
                        "    expAmExpB_uid69_fpAddSubTest_ieeeAdd_b <= STD_LOGIC_VECTOR(\"0\" & exp_bSig_uid44_fpAddSubTest_ieeeAdd_b);\n" +
                        "    expAmExpB_uid69_fpAddSubTest_ieeeAdd_o <= STD_LOGIC_VECTOR(UNSIGNED(expAmExpB_uid69_fpAddSubTest_ieeeAdd_a) - UNSIGNED(expAmExpB_uid69_fpAddSubTest_ieeeAdd_b));\n" +
                        "    expAmExpB_uid69_fpAddSubTest_ieeeAdd_q <= expAmExpB_uid69_fpAddSubTest_ieeeAdd_o(11 downto 0);\n" +
                        "\n" +
                        "    -- cWFP2_uid70_fpAddSubTest_ieeeAdd(CONSTANT,69)\n" +
                        "    cWFP2_uid70_fpAddSubTest_ieeeAdd_q <= \"110110\";\n" +
                        "\n" +
                        "    -- shiftedOut_uid72_fpAddSubTest_ieeeAdd(COMPARE,71)@1 + 1\n" +
                        "    shiftedOut_uid72_fpAddSubTest_ieeeAdd_a <= STD_LOGIC_VECTOR(\"00000000\" & cWFP2_uid70_fpAddSubTest_ieeeAdd_q);\n" +
                        "    shiftedOut_uid72_fpAddSubTest_ieeeAdd_b <= STD_LOGIC_VECTOR(\"00\" & expAmExpB_uid69_fpAddSubTest_ieeeAdd_q);\n" +
                        "    shiftedOut_uid72_fpAddSubTest_ieeeAdd_clkproc: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            shiftedOut_uid72_fpAddSubTest_ieeeAdd_o <= (others => '0');\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            shiftedOut_uid72_fpAddSubTest_ieeeAdd_o <= STD_LOGIC_VECTOR(UNSIGNED(shiftedOut_uid72_fpAddSubTest_ieeeAdd_a) - UNSIGNED(shiftedOut_uid72_fpAddSubTest_ieeeAdd_b));\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "    shiftedOut_uid72_fpAddSubTest_ieeeAdd_c(0) <= shiftedOut_uid72_fpAddSubTest_ieeeAdd_o(13);\n" +
                        "\n" +
                        "    -- redist20_shiftedOut_uid72_fpAddSubTest_ieeeAdd_c_2(DELAY,303)\n" +
                        "    redist20_shiftedOut_uid72_fpAddSubTest_ieeeAdd_c_2 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => shiftedOut_uid72_fpAddSubTest_ieeeAdd_c, xout => redist20_shiftedOut_uid72_fpAddSubTest_ieeeAdd_c_2_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- iShiftedOut_uid76_fpAddSubTest_ieeeAdd(LOGICAL,75)@3\n" +
                        "    iShiftedOut_uid76_fpAddSubTest_ieeeAdd_q <= not (redist20_shiftedOut_uid72_fpAddSubTest_ieeeAdd_c_2_q);\n" +
                        "\n" +
                        "    -- zeroOutCst_uid238_alignmentShifter_uid73_fpAddSubTest_ieeeAdd(CONSTANT,237)\n" +
                        "    zeroOutCst_uid238_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= \"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\";\n" +
                        "\n" +
                        "    -- rightShiftStage3Idx1Rng1_uid233_alignmentShifter_uid73_fpAddSubTest_ieeeAdd(BITSELECT,232)@2\n" +
                        "    rightShiftStage3Idx1Rng1_uid233_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_b <= rightShiftStage2_uid232_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q(106 downto 1);\n" +
                        "\n" +
                        "    -- rightShiftStage3Idx1_uid235_alignmentShifter_uid73_fpAddSubTest_ieeeAdd(BITJOIN,234)@2\n" +
                        "    rightShiftStage3Idx1_uid235_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= GND_q & rightShiftStage3Idx1Rng1_uid233_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_b;\n" +
                        "\n" +
                        "    -- rightShiftStage2Idx3Pad6_uid229_alignmentShifter_uid73_fpAddSubTest_ieeeAdd(CONSTANT,228)\n" +
                        "    rightShiftStage2Idx3Pad6_uid229_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= \"000000\";\n" +
                        "\n" +
                        "    -- rightShiftStage2Idx3Rng6_uid228_alignmentShifter_uid73_fpAddSubTest_ieeeAdd(BITSELECT,227)@2\n" +
                        "    rightShiftStage2Idx3Rng6_uid228_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_b <= rightShiftStage1_uid221_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q(106 downto 6);\n" +
                        "\n" +
                        "    -- rightShiftStage2Idx3_uid230_alignmentShifter_uid73_fpAddSubTest_ieeeAdd(BITJOIN,229)@2\n" +
                        "    rightShiftStage2Idx3_uid230_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= rightShiftStage2Idx3Pad6_uid229_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q & rightShiftStage2Idx3Rng6_uid228_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_b;\n" +
                        "\n" +
                        "    -- zs_uid179_lzCountVal_uid94_fpAddSubTest_ieeeAdd(CONSTANT,178)\n" +
                        "    zs_uid179_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q <= \"0000\";\n" +
                        "\n" +
                        "    -- rightShiftStage2Idx2Rng4_uid225_alignmentShifter_uid73_fpAddSubTest_ieeeAdd(BITSELECT,224)@2\n" +
                        "    rightShiftStage2Idx2Rng4_uid225_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_b <= rightShiftStage1_uid221_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q(106 downto 4);\n" +
                        "\n" +
                        "    -- rightShiftStage2Idx2_uid227_alignmentShifter_uid73_fpAddSubTest_ieeeAdd(BITJOIN,226)@2\n" +
                        "    rightShiftStage2Idx2_uid227_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= zs_uid179_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q & rightShiftStage2Idx2Rng4_uid225_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_b;\n" +
                        "\n" +
                        "    -- zs_uid185_lzCountVal_uid94_fpAddSubTest_ieeeAdd(CONSTANT,184)\n" +
                        "    zs_uid185_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q <= \"00\";\n" +
                        "\n" +
                        "    -- rightShiftStage2Idx1Rng2_uid222_alignmentShifter_uid73_fpAddSubTest_ieeeAdd(BITSELECT,221)@2\n" +
                        "    rightShiftStage2Idx1Rng2_uid222_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_b <= rightShiftStage1_uid221_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q(106 downto 2);\n" +
                        "\n" +
                        "    -- rightShiftStage2Idx1_uid224_alignmentShifter_uid73_fpAddSubTest_ieeeAdd(BITJOIN,223)@2\n" +
                        "    rightShiftStage2Idx1_uid224_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= zs_uid185_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q & rightShiftStage2Idx1Rng2_uid222_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_b;\n" +
                        "\n" +
                        "    -- rightShiftStage1Idx3Pad24_uid218_alignmentShifter_uid73_fpAddSubTest_ieeeAdd(CONSTANT,217)\n" +
                        "    rightShiftStage1Idx3Pad24_uid218_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= \"000000000000000000000000\";\n" +
                        "\n" +
                        "    -- rightShiftStage1Idx3Rng24_uid217_alignmentShifter_uid73_fpAddSubTest_ieeeAdd(BITSELECT,216)@2\n" +
                        "    rightShiftStage1Idx3Rng24_uid217_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_b <= rightShiftStage0_uid210_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q(106 downto 24);\n" +
                        "\n" +
                        "    -- rightShiftStage1Idx3_uid219_alignmentShifter_uid73_fpAddSubTest_ieeeAdd(BITJOIN,218)@2\n" +
                        "    rightShiftStage1Idx3_uid219_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= rightShiftStage1Idx3Pad24_uid218_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q & rightShiftStage1Idx3Rng24_uid217_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_b;\n" +
                        "\n" +
                        "    -- zs_uid167_lzCountVal_uid94_fpAddSubTest_ieeeAdd(CONSTANT,166)\n" +
                        "    zs_uid167_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q <= \"0000000000000000\";\n" +
                        "\n" +
                        "    -- rightShiftStage1Idx2Rng16_uid214_alignmentShifter_uid73_fpAddSubTest_ieeeAdd(BITSELECT,213)@2\n" +
                        "    rightShiftStage1Idx2Rng16_uid214_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_b <= rightShiftStage0_uid210_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q(106 downto 16);\n" +
                        "\n" +
                        "    -- rightShiftStage1Idx2_uid216_alignmentShifter_uid73_fpAddSubTest_ieeeAdd(BITJOIN,215)@2\n" +
                        "    rightShiftStage1Idx2_uid216_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= zs_uid167_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q & rightShiftStage1Idx2Rng16_uid214_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_b;\n" +
                        "\n" +
                        "    -- zs_uid173_lzCountVal_uid94_fpAddSubTest_ieeeAdd(CONSTANT,172)\n" +
                        "    zs_uid173_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q <= \"00000000\";\n" +
                        "\n" +
                        "    -- rightShiftStage1Idx1Rng8_uid211_alignmentShifter_uid73_fpAddSubTest_ieeeAdd(BITSELECT,210)@2\n" +
                        "    rightShiftStage1Idx1Rng8_uid211_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_b <= rightShiftStage0_uid210_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q(106 downto 8);\n" +
                        "\n" +
                        "    -- rightShiftStage1Idx1_uid213_alignmentShifter_uid73_fpAddSubTest_ieeeAdd(BITJOIN,212)@2\n" +
                        "    rightShiftStage1Idx1_uid213_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= zs_uid173_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q & rightShiftStage1Idx1Rng8_uid211_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_b;\n" +
                        "\n" +
                        "    -- rightShiftStage0Idx3Pad96_uid207_alignmentShifter_uid73_fpAddSubTest_ieeeAdd(CONSTANT,206)\n" +
                        "    rightShiftStage0Idx3Pad96_uid207_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\";\n" +
                        "\n" +
                        "    -- rightShiftStage0Idx3Rng96_uid206_alignmentShifter_uid73_fpAddSubTest_ieeeAdd(BITSELECT,205)@1\n" +
                        "    rightShiftStage0Idx3Rng96_uid206_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_b <= rightPaddedIn_uid74_fpAddSubTest_ieeeAdd_q(106 downto 96);\n" +
                        "\n" +
                        "    -- rightShiftStage0Idx3_uid208_alignmentShifter_uid73_fpAddSubTest_ieeeAdd(BITJOIN,207)@1\n" +
                        "    rightShiftStage0Idx3_uid208_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= rightShiftStage0Idx3Pad96_uid207_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q & rightShiftStage0Idx3Rng96_uid206_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_b;\n" +
                        "\n" +
                        "    -- rightShiftStage0Idx2Pad64_uid204_alignmentShifter_uid73_fpAddSubTest_ieeeAdd(CONSTANT,203)\n" +
                        "    rightShiftStage0Idx2Pad64_uid204_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= \"0000000000000000000000000000000000000000000000000000000000000000\";\n" +
                        "\n" +
                        "    -- rightShiftStage0Idx2Rng64_uid203_alignmentShifter_uid73_fpAddSubTest_ieeeAdd(BITSELECT,202)@1\n" +
                        "    rightShiftStage0Idx2Rng64_uid203_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_b <= rightPaddedIn_uid74_fpAddSubTest_ieeeAdd_q(106 downto 64);\n" +
                        "\n" +
                        "    -- rightShiftStage0Idx2_uid205_alignmentShifter_uid73_fpAddSubTest_ieeeAdd(BITJOIN,204)@1\n" +
                        "    rightShiftStage0Idx2_uid205_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= rightShiftStage0Idx2Pad64_uid204_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q & rightShiftStage0Idx2Rng64_uid203_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_b;\n" +
                        "\n" +
                        "    -- rightShiftStage0Idx1Rng32_uid200_alignmentShifter_uid73_fpAddSubTest_ieeeAdd(BITSELECT,199)@1\n" +
                        "    rightShiftStage0Idx1Rng32_uid200_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_b <= rightPaddedIn_uid74_fpAddSubTest_ieeeAdd_q(106 downto 32);\n" +
                        "\n" +
                        "    -- rightShiftStage0Idx1_uid202_alignmentShifter_uid73_fpAddSubTest_ieeeAdd(BITJOIN,201)@1\n" +
                        "    rightShiftStage0Idx1_uid202_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= zs_uid159_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q & rightShiftStage0Idx1Rng32_uid200_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_b;\n" +
                        "\n" +
                        "    -- cstAllZWE_uid29_fpAddSubTest_ieeeAdd(CONSTANT,28)\n" +
                        "    cstAllZWE_uid29_fpAddSubTest_ieeeAdd_q <= \"00000000000\";\n" +
                        "\n" +
                        "    -- excZ_bSig_uid26_uid46_fpAddSubTest_ieeeAdd(LOGICAL,45)@1\n" +
                        "    excZ_bSig_uid26_uid46_fpAddSubTest_ieeeAdd_q <= \"1\" WHEN exp_bSig_uid44_fpAddSubTest_ieeeAdd_b = cstAllZWE_uid29_fpAddSubTest_ieeeAdd_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- InvExpXIsZero_uid53_fpAddSubTest_ieeeAdd(LOGICAL,52)@1\n" +
                        "    InvExpXIsZero_uid53_fpAddSubTest_ieeeAdd_q <= not (excZ_bSig_uid26_uid46_fpAddSubTest_ieeeAdd_q);\n" +
                        "\n" +
                        "    -- cstZeroWF_uid28_fpAddSubTest_ieeeAdd(CONSTANT,27)\n" +
                        "    cstZeroWF_uid28_fpAddSubTest_ieeeAdd_q <= \"0000000000000000000000000000000000000000000000000000\";\n" +
                        "\n" +
                        "    -- frac_bSig_uid45_fpAddSubTest_ieeeAdd(BITSELECT,44)@1\n" +
                        "    frac_bSig_uid45_fpAddSubTest_ieeeAdd_in <= bSig_uid26_fpAddSubTest_ieeeAdd_q(51 downto 0);\n" +
                        "    frac_bSig_uid45_fpAddSubTest_ieeeAdd_b <= frac_bSig_uid45_fpAddSubTest_ieeeAdd_in(51 downto 0);\n" +
                        "\n" +
                        "    -- fracBz_uid65_fpAddSubTest_ieeeAdd(MUX,64)@1\n" +
                        "    fracBz_uid65_fpAddSubTest_ieeeAdd_s <= excZ_bSig_uid26_uid46_fpAddSubTest_ieeeAdd_q;\n" +
                        "    fracBz_uid65_fpAddSubTest_ieeeAdd_combproc: PROCESS (fracBz_uid65_fpAddSubTest_ieeeAdd_s, frac_bSig_uid45_fpAddSubTest_ieeeAdd_b, cstZeroWF_uid28_fpAddSubTest_ieeeAdd_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (fracBz_uid65_fpAddSubTest_ieeeAdd_s) IS\n" +
                        "            WHEN \"0\" => fracBz_uid65_fpAddSubTest_ieeeAdd_q <= frac_bSig_uid45_fpAddSubTest_ieeeAdd_b;\n" +
                        "            WHEN \"1\" => fracBz_uid65_fpAddSubTest_ieeeAdd_q <= cstZeroWF_uid28_fpAddSubTest_ieeeAdd_q;\n" +
                        "            WHEN OTHERS => fracBz_uid65_fpAddSubTest_ieeeAdd_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- oFracB_uid68_fpAddSubTest_ieeeAdd(BITJOIN,67)@1\n" +
                        "    oFracB_uid68_fpAddSubTest_ieeeAdd_q <= InvExpXIsZero_uid53_fpAddSubTest_ieeeAdd_q & fracBz_uid65_fpAddSubTest_ieeeAdd_q;\n" +
                        "\n" +
                        "    -- padConst_uid73_fpAddSubTest_ieeeAdd(CONSTANT,72)\n" +
                        "    padConst_uid73_fpAddSubTest_ieeeAdd_q <= \"000000000000000000000000000000000000000000000000000000\";\n" +
                        "\n" +
                        "    -- rightPaddedIn_uid74_fpAddSubTest_ieeeAdd(BITJOIN,73)@1\n" +
                        "    rightPaddedIn_uid74_fpAddSubTest_ieeeAdd_q <= oFracB_uid68_fpAddSubTest_ieeeAdd_q & padConst_uid73_fpAddSubTest_ieeeAdd_q;\n" +
                        "\n" +
                        "    -- rightShiftStageSel6Dto5_uid209_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_merged_bit_select(BITSELECT,276)@1\n" +
                        "    rightShiftStageSel6Dto5_uid209_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_merged_bit_select_in <= expAmExpB_uid69_fpAddSubTest_ieeeAdd_q(6 downto 0);\n" +
                        "    rightShiftStageSel6Dto5_uid209_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_merged_bit_select_b <= rightShiftStageSel6Dto5_uid209_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_merged_bit_select_in(6 downto 5);\n" +
                        "    rightShiftStageSel6Dto5_uid209_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_merged_bit_select_c <= rightShiftStageSel6Dto5_uid209_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_merged_bit_select_in(4 downto 3);\n" +
                        "    rightShiftStageSel6Dto5_uid209_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_merged_bit_select_d <= rightShiftStageSel6Dto5_uid209_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_merged_bit_select_in(2 downto 1);\n" +
                        "    rightShiftStageSel6Dto5_uid209_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_merged_bit_select_e <= rightShiftStageSel6Dto5_uid209_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_merged_bit_select_in(0 downto 0);\n" +
                        "\n" +
                        "    -- rightShiftStage0_uid210_alignmentShifter_uid73_fpAddSubTest_ieeeAdd(MUX,209)@1 + 1\n" +
                        "    rightShiftStage0_uid210_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_s <= rightShiftStageSel6Dto5_uid209_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_merged_bit_select_b;\n" +
                        "    rightShiftStage0_uid210_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_clkproc: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            rightShiftStage0_uid210_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= (others => '0');\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            CASE (rightShiftStage0_uid210_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_s) IS\n" +
                        "                WHEN \"00\" => rightShiftStage0_uid210_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= rightPaddedIn_uid74_fpAddSubTest_ieeeAdd_q;\n" +
                        "                WHEN \"01\" => rightShiftStage0_uid210_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= rightShiftStage0Idx1_uid202_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q;\n" +
                        "                WHEN \"10\" => rightShiftStage0_uid210_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= rightShiftStage0Idx2_uid205_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q;\n" +
                        "                WHEN \"11\" => rightShiftStage0_uid210_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= rightShiftStage0Idx3_uid208_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q;\n" +
                        "                WHEN OTHERS => rightShiftStage0_uid210_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= (others => '0');\n" +
                        "            END CASE;\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- redist3_rightShiftStageSel6Dto5_uid209_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_merged_bit_select_c_1(DELAY,286)\n" +
                        "    redist3_rightShiftStageSel6Dto5_uid209_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_merged_bit_select_c_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 2, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => rightShiftStageSel6Dto5_uid209_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_merged_bit_select_c, xout => redist3_rightShiftStageSel6Dto5_uid209_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_merged_bit_select_c_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- rightShiftStage1_uid221_alignmentShifter_uid73_fpAddSubTest_ieeeAdd(MUX,220)@2\n" +
                        "    rightShiftStage1_uid221_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_s <= redist3_rightShiftStageSel6Dto5_uid209_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_merged_bit_select_c_1_q;\n" +
                        "    rightShiftStage1_uid221_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_combproc: PROCESS (rightShiftStage1_uid221_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_s, rightShiftStage0_uid210_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q, rightShiftStage1Idx1_uid213_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q, rightShiftStage1Idx2_uid216_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q, rightShiftStage1Idx3_uid219_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (rightShiftStage1_uid221_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_s) IS\n" +
                        "            WHEN \"00\" => rightShiftStage1_uid221_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= rightShiftStage0_uid210_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q;\n" +
                        "            WHEN \"01\" => rightShiftStage1_uid221_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= rightShiftStage1Idx1_uid213_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q;\n" +
                        "            WHEN \"10\" => rightShiftStage1_uid221_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= rightShiftStage1Idx2_uid216_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q;\n" +
                        "            WHEN \"11\" => rightShiftStage1_uid221_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= rightShiftStage1Idx3_uid219_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q;\n" +
                        "            WHEN OTHERS => rightShiftStage1_uid221_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- redist4_rightShiftStageSel6Dto5_uid209_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_merged_bit_select_d_1(DELAY,287)\n" +
                        "    redist4_rightShiftStageSel6Dto5_uid209_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_merged_bit_select_d_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 2, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => rightShiftStageSel6Dto5_uid209_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_merged_bit_select_d, xout => redist4_rightShiftStageSel6Dto5_uid209_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_merged_bit_select_d_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- rightShiftStage2_uid232_alignmentShifter_uid73_fpAddSubTest_ieeeAdd(MUX,231)@2\n" +
                        "    rightShiftStage2_uid232_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_s <= redist4_rightShiftStageSel6Dto5_uid209_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_merged_bit_select_d_1_q;\n" +
                        "    rightShiftStage2_uid232_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_combproc: PROCESS (rightShiftStage2_uid232_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_s, rightShiftStage1_uid221_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q, rightShiftStage2Idx1_uid224_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q, rightShiftStage2Idx2_uid227_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q, rightShiftStage2Idx3_uid230_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (rightShiftStage2_uid232_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_s) IS\n" +
                        "            WHEN \"00\" => rightShiftStage2_uid232_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= rightShiftStage1_uid221_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q;\n" +
                        "            WHEN \"01\" => rightShiftStage2_uid232_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= rightShiftStage2Idx1_uid224_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q;\n" +
                        "            WHEN \"10\" => rightShiftStage2_uid232_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= rightShiftStage2Idx2_uid227_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q;\n" +
                        "            WHEN \"11\" => rightShiftStage2_uid232_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= rightShiftStage2Idx3_uid230_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q;\n" +
                        "            WHEN OTHERS => rightShiftStage2_uid232_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- redist5_rightShiftStageSel6Dto5_uid209_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_merged_bit_select_e_1(DELAY,288)\n" +
                        "    redist5_rightShiftStageSel6Dto5_uid209_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_merged_bit_select_e_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => rightShiftStageSel6Dto5_uid209_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_merged_bit_select_e, xout => redist5_rightShiftStageSel6Dto5_uid209_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_merged_bit_select_e_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- rightShiftStage3_uid237_alignmentShifter_uid73_fpAddSubTest_ieeeAdd(MUX,236)@2\n" +
                        "    rightShiftStage3_uid237_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_s <= redist5_rightShiftStageSel6Dto5_uid209_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_merged_bit_select_e_1_q;\n" +
                        "    rightShiftStage3_uid237_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_combproc: PROCESS (rightShiftStage3_uid237_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_s, rightShiftStage2_uid232_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q, rightShiftStage3Idx1_uid235_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (rightShiftStage3_uid237_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_s) IS\n" +
                        "            WHEN \"0\" => rightShiftStage3_uid237_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= rightShiftStage2_uid232_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q;\n" +
                        "            WHEN \"1\" => rightShiftStage3_uid237_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= rightShiftStage3Idx1_uid235_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q;\n" +
                        "            WHEN OTHERS => rightShiftStage3_uid237_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- wIntCst_uid198_alignmentShifter_uid73_fpAddSubTest_ieeeAdd(CONSTANT,197)\n" +
                        "    wIntCst_uid198_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= \"1101011\";\n" +
                        "\n" +
                        "    -- shiftedOut_uid199_alignmentShifter_uid73_fpAddSubTest_ieeeAdd(COMPARE,198)@1 + 1\n" +
                        "    shiftedOut_uid199_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_a <= STD_LOGIC_VECTOR(\"00\" & expAmExpB_uid69_fpAddSubTest_ieeeAdd_q);\n" +
                        "    shiftedOut_uid199_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_b <= STD_LOGIC_VECTOR(\"0000000\" & wIntCst_uid198_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q);\n" +
                        "    shiftedOut_uid199_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_clkproc: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            shiftedOut_uid199_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_o <= (others => '0');\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            shiftedOut_uid199_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_o <= STD_LOGIC_VECTOR(UNSIGNED(shiftedOut_uid199_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_a) - UNSIGNED(shiftedOut_uid199_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_b));\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "    shiftedOut_uid199_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_n(0) <= not (shiftedOut_uid199_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_o(13));\n" +
                        "\n" +
                        "    -- r_uid239_alignmentShifter_uid73_fpAddSubTest_ieeeAdd(MUX,238)@2 + 1\n" +
                        "    r_uid239_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_s <= shiftedOut_uid199_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_n;\n" +
                        "    r_uid239_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_clkproc: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            r_uid239_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= (others => '0');\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            CASE (r_uid239_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_s) IS\n" +
                        "                WHEN \"0\" => r_uid239_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= rightShiftStage3_uid237_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q;\n" +
                        "                WHEN \"1\" => r_uid239_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= zeroOutCst_uid238_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q;\n" +
                        "                WHEN OTHERS => r_uid239_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q <= (others => '0');\n" +
                        "            END CASE;\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- alignFracBPostShiftOut_uid77_fpAddSubTest_ieeeAdd(LOGICAL,76)@3\n" +
                        "    alignFracBPostShiftOut_uid77_fpAddSubTest_ieeeAdd_b <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR((106 downto 1 => iShiftedOut_uid76_fpAddSubTest_ieeeAdd_q(0)) & iShiftedOut_uid76_fpAddSubTest_ieeeAdd_q));\n" +
                        "    alignFracBPostShiftOut_uid77_fpAddSubTest_ieeeAdd_q <= r_uid239_alignmentShifter_uid73_fpAddSubTest_ieeeAdd_q and alignFracBPostShiftOut_uid77_fpAddSubTest_ieeeAdd_b;\n" +
                        "\n" +
                        "    -- stickyBits_uid78_fpAddSubTest_ieeeAdd_merged_bit_select(BITSELECT,277)@3\n" +
                        "    stickyBits_uid78_fpAddSubTest_ieeeAdd_merged_bit_select_b <= alignFracBPostShiftOut_uid77_fpAddSubTest_ieeeAdd_q(51 downto 0);\n" +
                        "    stickyBits_uid78_fpAddSubTest_ieeeAdd_merged_bit_select_c <= alignFracBPostShiftOut_uid77_fpAddSubTest_ieeeAdd_q(106 downto 52);\n" +
                        "\n" +
                        "    -- redist2_stickyBits_uid78_fpAddSubTest_ieeeAdd_merged_bit_select_c_1(DELAY,285)\n" +
                        "    redist2_stickyBits_uid78_fpAddSubTest_ieeeAdd_merged_bit_select_c_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 55, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => stickyBits_uid78_fpAddSubTest_ieeeAdd_merged_bit_select_c, xout => redist2_stickyBits_uid78_fpAddSubTest_ieeeAdd_merged_bit_select_c_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- fracBAddOp_uid89_fpAddSubTest_ieeeAdd(BITJOIN,88)@4\n" +
                        "    fracBAddOp_uid89_fpAddSubTest_ieeeAdd_q <= GND_q & redist2_stickyBits_uid78_fpAddSubTest_ieeeAdd_merged_bit_select_c_1_q;\n" +
                        "\n" +
                        "    -- fracBAddOpPostXor_uid90_fpAddSubTest_ieeeAdd(LOGICAL,89)@4\n" +
                        "    fracBAddOpPostXor_uid90_fpAddSubTest_ieeeAdd_b <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR((55 downto 1 => effSub_uid61_fpAddSubTest_ieeeAdd_q(0)) & effSub_uid61_fpAddSubTest_ieeeAdd_q));\n" +
                        "    fracBAddOpPostXor_uid90_fpAddSubTest_ieeeAdd_q <= fracBAddOp_uid89_fpAddSubTest_ieeeAdd_q xor fracBAddOpPostXor_uid90_fpAddSubTest_ieeeAdd_b;\n" +
                        "\n" +
                        "    -- zocst_uid85_fpAddSubTest_ieeeAdd(CONSTANT,84)\n" +
                        "    zocst_uid85_fpAddSubTest_ieeeAdd_q <= \"01\";\n" +
                        "\n" +
                        "    -- frac_aSig_uid31_fpAddSubTest_ieeeAdd(BITSELECT,30)@0\n" +
                        "    frac_aSig_uid31_fpAddSubTest_ieeeAdd_in <= aSig_uid25_fpAddSubTest_ieeeAdd_q(51 downto 0);\n" +
                        "    frac_aSig_uid31_fpAddSubTest_ieeeAdd_b <= frac_aSig_uid31_fpAddSubTest_ieeeAdd_in(51 downto 0);\n" +
                        "\n" +
                        "    -- redist36_frac_aSig_uid31_fpAddSubTest_ieeeAdd_b_4_inputreg(DELAY,322)\n" +
                        "    redist36_frac_aSig_uid31_fpAddSubTest_ieeeAdd_b_4_inputreg : dspba_delay\n" +
                        "    GENERIC MAP ( width => 52, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => frac_aSig_uid31_fpAddSubTest_ieeeAdd_b, xout => redist36_frac_aSig_uid31_fpAddSubTest_ieeeAdd_b_4_inputreg_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist36_frac_aSig_uid31_fpAddSubTest_ieeeAdd_b_4(DELAY,319)\n" +
                        "    redist36_frac_aSig_uid31_fpAddSubTest_ieeeAdd_b_4 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 52, depth => 2, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => redist36_frac_aSig_uid31_fpAddSubTest_ieeeAdd_b_4_inputreg_q, xout => redist36_frac_aSig_uid31_fpAddSubTest_ieeeAdd_b_4_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist36_frac_aSig_uid31_fpAddSubTest_ieeeAdd_b_4_outputreg(DELAY,323)\n" +
                        "    redist36_frac_aSig_uid31_fpAddSubTest_ieeeAdd_b_4_outputreg : dspba_delay\n" +
                        "    GENERIC MAP ( width => 52, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => redist36_frac_aSig_uid31_fpAddSubTest_ieeeAdd_b_4_q, xout => redist36_frac_aSig_uid31_fpAddSubTest_ieeeAdd_b_4_outputreg_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- cmpEQ_stickyBits_cZwF_uid80_fpAddSubTest_ieeeAdd(LOGICAL,79)@3 + 1\n" +
                        "    cmpEQ_stickyBits_cZwF_uid80_fpAddSubTest_ieeeAdd_qi <= \"1\" WHEN stickyBits_uid78_fpAddSubTest_ieeeAdd_merged_bit_select_b = cstZeroWF_uid28_fpAddSubTest_ieeeAdd_q ELSE \"0\";\n" +
                        "    cmpEQ_stickyBits_cZwF_uid80_fpAddSubTest_ieeeAdd_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => cmpEQ_stickyBits_cZwF_uid80_fpAddSubTest_ieeeAdd_qi, xout => cmpEQ_stickyBits_cZwF_uid80_fpAddSubTest_ieeeAdd_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- effSubInvSticky_uid83_fpAddSubTest_ieeeAdd(LOGICAL,82)@4\n" +
                        "    effSubInvSticky_uid83_fpAddSubTest_ieeeAdd_q <= effSub_uid61_fpAddSubTest_ieeeAdd_q and cmpEQ_stickyBits_cZwF_uid80_fpAddSubTest_ieeeAdd_q;\n" +
                        "\n" +
                        "    -- fracAAddOp_uid86_fpAddSubTest_ieeeAdd(BITJOIN,85)@4\n" +
                        "    fracAAddOp_uid86_fpAddSubTest_ieeeAdd_q <= zocst_uid85_fpAddSubTest_ieeeAdd_q & redist36_frac_aSig_uid31_fpAddSubTest_ieeeAdd_b_4_outputreg_q & GND_q & effSubInvSticky_uid83_fpAddSubTest_ieeeAdd_q;\n" +
                        "\n" +
                        "    -- fracAddResult_uid91_fpAddSubTest_ieeeAdd(ADD,90)@4\n" +
                        "    fracAddResult_uid91_fpAddSubTest_ieeeAdd_a <= STD_LOGIC_VECTOR(\"0\" & fracAAddOp_uid86_fpAddSubTest_ieeeAdd_q);\n" +
                        "    fracAddResult_uid91_fpAddSubTest_ieeeAdd_b <= STD_LOGIC_VECTOR(\"0\" & fracBAddOpPostXor_uid90_fpAddSubTest_ieeeAdd_q);\n" +
                        "    fracAddResult_uid91_fpAddSubTest_ieeeAdd_o <= STD_LOGIC_VECTOR(UNSIGNED(fracAddResult_uid91_fpAddSubTest_ieeeAdd_a) + UNSIGNED(fracAddResult_uid91_fpAddSubTest_ieeeAdd_b));\n" +
                        "    fracAddResult_uid91_fpAddSubTest_ieeeAdd_q <= fracAddResult_uid91_fpAddSubTest_ieeeAdd_o(56 downto 0);\n" +
                        "\n" +
                        "    -- rangeFracAddResultMwfp3Dto0_uid92_fpAddSubTest_ieeeAdd(BITSELECT,91)@4\n" +
                        "    rangeFracAddResultMwfp3Dto0_uid92_fpAddSubTest_ieeeAdd_in <= fracAddResult_uid91_fpAddSubTest_ieeeAdd_q(55 downto 0);\n" +
                        "    rangeFracAddResultMwfp3Dto0_uid92_fpAddSubTest_ieeeAdd_b <= rangeFracAddResultMwfp3Dto0_uid92_fpAddSubTest_ieeeAdd_in(55 downto 0);\n" +
                        "\n" +
                        "    -- redist18_rangeFracAddResultMwfp3Dto0_uid92_fpAddSubTest_ieeeAdd_b_1(DELAY,301)\n" +
                        "    redist18_rangeFracAddResultMwfp3Dto0_uid92_fpAddSubTest_ieeeAdd_b_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 56, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => rangeFracAddResultMwfp3Dto0_uid92_fpAddSubTest_ieeeAdd_b, xout => redist18_rangeFracAddResultMwfp3Dto0_uid92_fpAddSubTest_ieeeAdd_b_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist19_cmpEQ_stickyBits_cZwF_uid80_fpAddSubTest_ieeeAdd_q_2(DELAY,302)\n" +
                        "    redist19_cmpEQ_stickyBits_cZwF_uid80_fpAddSubTest_ieeeAdd_q_2 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => cmpEQ_stickyBits_cZwF_uid80_fpAddSubTest_ieeeAdd_q, xout => redist19_cmpEQ_stickyBits_cZwF_uid80_fpAddSubTest_ieeeAdd_q_2_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- invCmpEQ_stickyBits_cZwF_uid81_fpAddSubTest_ieeeAdd(LOGICAL,80)@5\n" +
                        "    invCmpEQ_stickyBits_cZwF_uid81_fpAddSubTest_ieeeAdd_q <= not (redist19_cmpEQ_stickyBits_cZwF_uid80_fpAddSubTest_ieeeAdd_q_2_q);\n" +
                        "\n" +
                        "    -- fracGRS_uid93_fpAddSubTest_ieeeAdd(BITJOIN,92)@5\n" +
                        "    fracGRS_uid93_fpAddSubTest_ieeeAdd_q <= redist18_rangeFracAddResultMwfp3Dto0_uid92_fpAddSubTest_ieeeAdd_b_1_q & invCmpEQ_stickyBits_cZwF_uid81_fpAddSubTest_ieeeAdd_q;\n" +
                        "\n" +
                        "    -- rVStage_uid160_lzCountVal_uid94_fpAddSubTest_ieeeAdd(BITSELECT,159)@5\n" +
                        "    rVStage_uid160_lzCountVal_uid94_fpAddSubTest_ieeeAdd_b <= fracGRS_uid93_fpAddSubTest_ieeeAdd_q(56 downto 25);\n" +
                        "\n" +
                        "    -- vCount_uid161_lzCountVal_uid94_fpAddSubTest_ieeeAdd(LOGICAL,160)@5\n" +
                        "    vCount_uid161_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q <= \"1\" WHEN rVStage_uid160_lzCountVal_uid94_fpAddSubTest_ieeeAdd_b = zs_uid159_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- redist10_vCount_uid161_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q_2(DELAY,293)\n" +
                        "    redist10_vCount_uid161_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q_2 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 2, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => vCount_uid161_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q, xout => redist10_vCount_uid161_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q_2_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- vStage_uid163_lzCountVal_uid94_fpAddSubTest_ieeeAdd(BITSELECT,162)@5\n" +
                        "    vStage_uid163_lzCountVal_uid94_fpAddSubTest_ieeeAdd_in <= fracGRS_uid93_fpAddSubTest_ieeeAdd_q(24 downto 0);\n" +
                        "    vStage_uid163_lzCountVal_uid94_fpAddSubTest_ieeeAdd_b <= vStage_uid163_lzCountVal_uid94_fpAddSubTest_ieeeAdd_in(24 downto 0);\n" +
                        "\n" +
                        "    -- mO_uid162_lzCountVal_uid94_fpAddSubTest_ieeeAdd(CONSTANT,161)\n" +
                        "    mO_uid162_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q <= \"1111111\";\n" +
                        "\n" +
                        "    -- cStage_uid164_lzCountVal_uid94_fpAddSubTest_ieeeAdd(BITJOIN,163)@5\n" +
                        "    cStage_uid164_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q <= vStage_uid163_lzCountVal_uid94_fpAddSubTest_ieeeAdd_b & mO_uid162_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q;\n" +
                        "\n" +
                        "    -- vStagei_uid166_lzCountVal_uid94_fpAddSubTest_ieeeAdd(MUX,165)@5\n" +
                        "    vStagei_uid166_lzCountVal_uid94_fpAddSubTest_ieeeAdd_s <= vCount_uid161_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q;\n" +
                        "    vStagei_uid166_lzCountVal_uid94_fpAddSubTest_ieeeAdd_combproc: PROCESS (vStagei_uid166_lzCountVal_uid94_fpAddSubTest_ieeeAdd_s, rVStage_uid160_lzCountVal_uid94_fpAddSubTest_ieeeAdd_b, cStage_uid164_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (vStagei_uid166_lzCountVal_uid94_fpAddSubTest_ieeeAdd_s) IS\n" +
                        "            WHEN \"0\" => vStagei_uid166_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q <= rVStage_uid160_lzCountVal_uid94_fpAddSubTest_ieeeAdd_b;\n" +
                        "            WHEN \"1\" => vStagei_uid166_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q <= cStage_uid164_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q;\n" +
                        "            WHEN OTHERS => vStagei_uid166_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- rVStage_uid168_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select(BITSELECT,278)@5\n" +
                        "    rVStage_uid168_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_b <= vStagei_uid166_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q(31 downto 16);\n" +
                        "    rVStage_uid168_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_c <= vStagei_uid166_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q(15 downto 0);\n" +
                        "\n" +
                        "    -- vCount_uid169_lzCountVal_uid94_fpAddSubTest_ieeeAdd(LOGICAL,168)@5\n" +
                        "    vCount_uid169_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q <= \"1\" WHEN rVStage_uid168_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_b = zs_uid167_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- redist8_vCount_uid169_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q_2(DELAY,291)\n" +
                        "    redist8_vCount_uid169_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q_2 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 2, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => vCount_uid169_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q, xout => redist8_vCount_uid169_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q_2_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- vStagei_uid172_lzCountVal_uid94_fpAddSubTest_ieeeAdd(MUX,171)@5 + 1\n" +
                        "    vStagei_uid172_lzCountVal_uid94_fpAddSubTest_ieeeAdd_s <= vCount_uid169_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q;\n" +
                        "    vStagei_uid172_lzCountVal_uid94_fpAddSubTest_ieeeAdd_clkproc: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            vStagei_uid172_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q <= (others => '0');\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            CASE (vStagei_uid172_lzCountVal_uid94_fpAddSubTest_ieeeAdd_s) IS\n" +
                        "                WHEN \"0\" => vStagei_uid172_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q <= rVStage_uid168_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_b;\n" +
                        "                WHEN \"1\" => vStagei_uid172_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q <= rVStage_uid168_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_c;\n" +
                        "                WHEN OTHERS => vStagei_uid172_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q <= (others => '0');\n" +
                        "            END CASE;\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- rVStage_uid174_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select(BITSELECT,279)@6\n" +
                        "    rVStage_uid174_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_b <= vStagei_uid172_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q(15 downto 8);\n" +
                        "    rVStage_uid174_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_c <= vStagei_uid172_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q(7 downto 0);\n" +
                        "\n" +
                        "    -- vCount_uid175_lzCountVal_uid94_fpAddSubTest_ieeeAdd(LOGICAL,174)@6\n" +
                        "    vCount_uid175_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q <= \"1\" WHEN rVStage_uid174_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_b = zs_uid173_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- redist7_vCount_uid175_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q_1(DELAY,290)\n" +
                        "    redist7_vCount_uid175_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => vCount_uid175_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q, xout => redist7_vCount_uid175_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- vStagei_uid178_lzCountVal_uid94_fpAddSubTest_ieeeAdd(MUX,177)@6\n" +
                        "    vStagei_uid178_lzCountVal_uid94_fpAddSubTest_ieeeAdd_s <= vCount_uid175_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q;\n" +
                        "    vStagei_uid178_lzCountVal_uid94_fpAddSubTest_ieeeAdd_combproc: PROCESS (vStagei_uid178_lzCountVal_uid94_fpAddSubTest_ieeeAdd_s, rVStage_uid174_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_b, rVStage_uid174_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_c)\n" +
                        "    BEGIN\n" +
                        "        CASE (vStagei_uid178_lzCountVal_uid94_fpAddSubTest_ieeeAdd_s) IS\n" +
                        "            WHEN \"0\" => vStagei_uid178_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q <= rVStage_uid174_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_b;\n" +
                        "            WHEN \"1\" => vStagei_uid178_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q <= rVStage_uid174_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_c;\n" +
                        "            WHEN OTHERS => vStagei_uid178_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- rVStage_uid180_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select(BITSELECT,280)@6\n" +
                        "    rVStage_uid180_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_b <= vStagei_uid178_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q(7 downto 4);\n" +
                        "    rVStage_uid180_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_c <= vStagei_uid178_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q(3 downto 0);\n" +
                        "\n" +
                        "    -- vCount_uid181_lzCountVal_uid94_fpAddSubTest_ieeeAdd(LOGICAL,180)@6\n" +
                        "    vCount_uid181_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q <= \"1\" WHEN rVStage_uid180_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_b = zs_uid179_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- redist6_vCount_uid181_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q_1(DELAY,289)\n" +
                        "    redist6_vCount_uid181_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => vCount_uid181_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q, xout => redist6_vCount_uid181_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- vStagei_uid184_lzCountVal_uid94_fpAddSubTest_ieeeAdd(MUX,183)@6\n" +
                        "    vStagei_uid184_lzCountVal_uid94_fpAddSubTest_ieeeAdd_s <= vCount_uid181_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q;\n" +
                        "    vStagei_uid184_lzCountVal_uid94_fpAddSubTest_ieeeAdd_combproc: PROCESS (vStagei_uid184_lzCountVal_uid94_fpAddSubTest_ieeeAdd_s, rVStage_uid180_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_b, rVStage_uid180_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_c)\n" +
                        "    BEGIN\n" +
                        "        CASE (vStagei_uid184_lzCountVal_uid94_fpAddSubTest_ieeeAdd_s) IS\n" +
                        "            WHEN \"0\" => vStagei_uid184_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q <= rVStage_uid180_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_b;\n" +
                        "            WHEN \"1\" => vStagei_uid184_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q <= rVStage_uid180_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_c;\n" +
                        "            WHEN OTHERS => vStagei_uid184_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- rVStage_uid186_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select(BITSELECT,281)@6\n" +
                        "    rVStage_uid186_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_b <= vStagei_uid184_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q(3 downto 2);\n" +
                        "    rVStage_uid186_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_c <= vStagei_uid184_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q(1 downto 0);\n" +
                        "\n" +
                        "    -- vCount_uid187_lzCountVal_uid94_fpAddSubTest_ieeeAdd(LOGICAL,186)@6 + 1\n" +
                        "    vCount_uid187_lzCountVal_uid94_fpAddSubTest_ieeeAdd_qi <= \"1\" WHEN rVStage_uid186_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_b = zs_uid185_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q ELSE \"0\";\n" +
                        "    vCount_uid187_lzCountVal_uid94_fpAddSubTest_ieeeAdd_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => vCount_uid187_lzCountVal_uid94_fpAddSubTest_ieeeAdd_qi, xout => vCount_uid187_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist1_rVStage_uid186_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_c_1(DELAY,284)\n" +
                        "    redist1_rVStage_uid186_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_c_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 2, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => rVStage_uid186_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_c, xout => redist1_rVStage_uid186_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_c_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist0_rVStage_uid186_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_b_1(DELAY,283)\n" +
                        "    redist0_rVStage_uid186_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_b_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 2, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => rVStage_uid186_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_b, xout => redist0_rVStage_uid186_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_b_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- vStagei_uid190_lzCountVal_uid94_fpAddSubTest_ieeeAdd(MUX,189)@7\n" +
                        "    vStagei_uid190_lzCountVal_uid94_fpAddSubTest_ieeeAdd_s <= vCount_uid187_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q;\n" +
                        "    vStagei_uid190_lzCountVal_uid94_fpAddSubTest_ieeeAdd_combproc: PROCESS (vStagei_uid190_lzCountVal_uid94_fpAddSubTest_ieeeAdd_s, redist0_rVStage_uid186_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_b_1_q, redist1_rVStage_uid186_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_c_1_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (vStagei_uid190_lzCountVal_uid94_fpAddSubTest_ieeeAdd_s) IS\n" +
                        "            WHEN \"0\" => vStagei_uid190_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q <= redist0_rVStage_uid186_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_b_1_q;\n" +
                        "            WHEN \"1\" => vStagei_uid190_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q <= redist1_rVStage_uid186_lzCountVal_uid94_fpAddSubTest_ieeeAdd_merged_bit_select_c_1_q;\n" +
                        "            WHEN OTHERS => vStagei_uid190_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- rVStage_uid192_lzCountVal_uid94_fpAddSubTest_ieeeAdd(BITSELECT,191)@7\n" +
                        "    rVStage_uid192_lzCountVal_uid94_fpAddSubTest_ieeeAdd_b <= vStagei_uid190_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q(1 downto 1);\n" +
                        "\n" +
                        "    -- vCount_uid193_lzCountVal_uid94_fpAddSubTest_ieeeAdd(LOGICAL,192)@7\n" +
                        "    vCount_uid193_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q <= \"1\" WHEN rVStage_uid192_lzCountVal_uid94_fpAddSubTest_ieeeAdd_b = GND_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- r_uid194_lzCountVal_uid94_fpAddSubTest_ieeeAdd(BITJOIN,193)@7\n" +
                        "    r_uid194_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q <= redist10_vCount_uid161_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q_2_q & redist8_vCount_uid169_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q_2_q & redist7_vCount_uid175_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q_1_q & redist6_vCount_uid181_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q_1_q & vCount_uid187_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q & vCount_uid193_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q;\n" +
                        "\n" +
                        "    -- aMinusA_uid96_fpAddSubTest_ieeeAdd(LOGICAL,95)@7\n" +
                        "    aMinusA_uid96_fpAddSubTest_ieeeAdd_q <= \"1\" WHEN r_uid194_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q = cAmA_uid95_fpAddSubTest_ieeeAdd_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- invAMinusA_uid138_fpAddSubTest_ieeeAdd(LOGICAL,137)@7\n" +
                        "    invAMinusA_uid138_fpAddSubTest_ieeeAdd_q <= not (aMinusA_uid96_fpAddSubTest_ieeeAdd_q);\n" +
                        "\n" +
                        "    -- redist25_sigA_uid59_fpAddSubTest_ieeeAdd_b_7(DELAY,308)\n" +
                        "    redist25_sigA_uid59_fpAddSubTest_ieeeAdd_b_7 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 3, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => redist24_sigA_uid59_fpAddSubTest_ieeeAdd_b_4_q, xout => redist25_sigA_uid59_fpAddSubTest_ieeeAdd_b_7_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- cstAllOWE_uid27_fpAddSubTest_ieeeAdd(CONSTANT,26)\n" +
                        "    cstAllOWE_uid27_fpAddSubTest_ieeeAdd_q <= \"11111111111\";\n" +
                        "\n" +
                        "    -- expXIsMax_uid47_fpAddSubTest_ieeeAdd(LOGICAL,46)@1\n" +
                        "    expXIsMax_uid47_fpAddSubTest_ieeeAdd_q <= \"1\" WHEN exp_bSig_uid44_fpAddSubTest_ieeeAdd_b = cstAllOWE_uid27_fpAddSubTest_ieeeAdd_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- invExpXIsMax_uid52_fpAddSubTest_ieeeAdd(LOGICAL,51)@1\n" +
                        "    invExpXIsMax_uid52_fpAddSubTest_ieeeAdd_q <= not (expXIsMax_uid47_fpAddSubTest_ieeeAdd_q);\n" +
                        "\n" +
                        "    -- excR_bSig_uid54_fpAddSubTest_ieeeAdd(LOGICAL,53)@1 + 1\n" +
                        "    excR_bSig_uid54_fpAddSubTest_ieeeAdd_qi <= InvExpXIsZero_uid53_fpAddSubTest_ieeeAdd_q and invExpXIsMax_uid52_fpAddSubTest_ieeeAdd_q;\n" +
                        "    excR_bSig_uid54_fpAddSubTest_ieeeAdd_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => excR_bSig_uid54_fpAddSubTest_ieeeAdd_qi, xout => excR_bSig_uid54_fpAddSubTest_ieeeAdd_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist26_excR_bSig_uid54_fpAddSubTest_ieeeAdd_q_6(DELAY,309)\n" +
                        "    redist26_excR_bSig_uid54_fpAddSubTest_ieeeAdd_q_6 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 5, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => excR_bSig_uid54_fpAddSubTest_ieeeAdd_q, xout => redist26_excR_bSig_uid54_fpAddSubTest_ieeeAdd_q_6_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_notEnable(LOGICAL,331)\n" +
                        "    redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_notEnable_q <= STD_LOGIC_VECTOR(not (VCC_q));\n" +
                        "\n" +
                        "    -- redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_nor(LOGICAL,332)\n" +
                        "    redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_nor_q <= not (redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_notEnable_q or redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_sticky_ena_q);\n" +
                        "\n" +
                        "    -- redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_mem_last(CONSTANT,328)\n" +
                        "    redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_mem_last_q <= \"010\";\n" +
                        "\n" +
                        "    -- redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_cmp(LOGICAL,329)\n" +
                        "    redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_cmp_b <= STD_LOGIC_VECTOR(\"0\" & redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_rdcnt_q);\n" +
                        "    redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_cmp_q <= \"1\" WHEN redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_mem_last_q = redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_cmp_b ELSE \"0\";\n" +
                        "\n" +
                        "    -- redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_cmpReg(REG,330)\n" +
                        "    redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_cmpReg_clkproc: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_cmpReg_q <= \"0\";\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_cmpReg_q <= STD_LOGIC_VECTOR(redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_cmp_q);\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_sticky_ena(REG,333)\n" +
                        "    redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_sticky_ena_clkproc: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_sticky_ena_q <= \"0\";\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            IF (redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_nor_q = \"1\") THEN\n" +
                        "                redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_sticky_ena_q <= STD_LOGIC_VECTOR(redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_cmpReg_q);\n" +
                        "            END IF;\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_enaAnd(LOGICAL,334)\n" +
                        "    redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_enaAnd_q <= redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_sticky_ena_q and VCC_q;\n" +
                        "\n" +
                        "    -- redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_rdcnt(COUNTER,326)\n" +
                        "    -- low=0, high=3, step=1, init=0\n" +
                        "    redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_rdcnt_clkproc: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_rdcnt_i <= TO_UNSIGNED(0, 2);\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_rdcnt_i <= redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_rdcnt_i + 1;\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "    redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_rdcnt_q <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR(RESIZE(redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_rdcnt_i, 2)));\n" +
                        "\n" +
                        "    -- redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_wraddr(REG,327)\n" +
                        "    redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_wraddr_clkproc: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_wraddr_q <= \"11\";\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_wraddr_q <= STD_LOGIC_VECTOR(redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_rdcnt_q);\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_mem(DUALMEM,325)\n" +
                        "    redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_mem_ia <= STD_LOGIC_VECTOR(redist37_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_1_q);\n" +
                        "    redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_mem_aa <= redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_wraddr_q;\n" +
                        "    redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_mem_ab <= redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_rdcnt_q;\n" +
                        "    redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_mem_reset0 <= areset;\n" +
                        "    redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_mem_dmem : altera_syncram\n" +
                        "    GENERIC MAP (\n" +
                        "        ram_block_type => \"MLAB\",\n" +
                        "        operation_mode => \"DUAL_PORT\",\n" +
                        "        width_a => 11,\n" +
                        "        widthad_a => 2,\n" +
                        "        numwords_a => 4,\n" +
                        "        width_b => 11,\n" +
                        "        widthad_b => 2,\n" +
                        "        numwords_b => 4,\n" +
                        "        lpm_type => \"altera_syncram\",\n" +
                        "        width_byteena_a => 1,\n" +
                        "        address_reg_b => \"CLOCK0\",\n" +
                        "        indata_reg_b => \"CLOCK0\",\n" +
                        "        rdcontrol_reg_b => \"CLOCK0\",\n" +
                        "        byteena_reg_b => \"CLOCK0\",\n" +
                        "        outdata_reg_b => \"CLOCK1\",\n" +
                        "        outdata_aclr_b => \"CLEAR1\",\n" +
                        "        clock_enable_input_a => \"NORMAL\",\n" +
                        "        clock_enable_input_b => \"NORMAL\",\n" +
                        "        clock_enable_output_b => \"NORMAL\",\n" +
                        "        read_during_write_mode_mixed_ports => \"DONT_CARE\",\n" +
                        "        power_up_uninitialized => \"TRUE\",\n" +
                        "        intended_device_family => \"Cyclone V\"\n" +
                        "    )\n" +
                        "    PORT MAP (\n" +
                        "        clocken1 => redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_enaAnd_q(0),\n" +
                        "        clocken0 => VCC_q(0),\n" +
                        "        clock0 => clk,\n" +
                        "        aclr1 => redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_mem_reset0,\n" +
                        "        clock1 => clk,\n" +
                        "        address_a => redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_mem_aa,\n" +
                        "        data_a => redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_mem_ia,\n" +
                        "        wren_a => VCC_q(0),\n" +
                        "        address_b => redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_mem_ab,\n" +
                        "        q_b => redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_mem_iq\n" +
                        "    );\n" +
                        "    redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_mem_q <= redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_mem_iq(10 downto 0);\n" +
                        "\n" +
                        "    -- redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_outputreg(DELAY,324)\n" +
                        "    redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_outputreg : dspba_delay\n" +
                        "    GENERIC MAP ( width => 11, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_mem_q, xout => redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_outputreg_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- expXIsMax_uid33_fpAddSubTest_ieeeAdd(LOGICAL,32)@7\n" +
                        "    expXIsMax_uid33_fpAddSubTest_ieeeAdd_q <= \"1\" WHEN redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_outputreg_q = cstAllOWE_uid27_fpAddSubTest_ieeeAdd_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- invExpXIsMax_uid38_fpAddSubTest_ieeeAdd(LOGICAL,37)@7\n" +
                        "    invExpXIsMax_uid38_fpAddSubTest_ieeeAdd_q <= not (expXIsMax_uid33_fpAddSubTest_ieeeAdd_q);\n" +
                        "\n" +
                        "    -- excZ_aSig_uid25_uid32_fpAddSubTest_ieeeAdd(LOGICAL,31)@7\n" +
                        "    excZ_aSig_uid25_uid32_fpAddSubTest_ieeeAdd_q <= \"1\" WHEN redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_outputreg_q = cstAllZWE_uid29_fpAddSubTest_ieeeAdd_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- InvExpXIsZero_uid39_fpAddSubTest_ieeeAdd(LOGICAL,38)@7\n" +
                        "    InvExpXIsZero_uid39_fpAddSubTest_ieeeAdd_q <= not (excZ_aSig_uid25_uid32_fpAddSubTest_ieeeAdd_q);\n" +
                        "\n" +
                        "    -- excR_aSig_uid40_fpAddSubTest_ieeeAdd(LOGICAL,39)@7\n" +
                        "    excR_aSig_uid40_fpAddSubTest_ieeeAdd_q <= InvExpXIsZero_uid39_fpAddSubTest_ieeeAdd_q and invExpXIsMax_uid38_fpAddSubTest_ieeeAdd_q;\n" +
                        "\n" +
                        "    -- signRReg_uid139_fpAddSubTest_ieeeAdd(LOGICAL,138)@7\n" +
                        "    signRReg_uid139_fpAddSubTest_ieeeAdd_q <= excR_aSig_uid40_fpAddSubTest_ieeeAdd_q and redist26_excR_bSig_uid54_fpAddSubTest_ieeeAdd_q_6_q and redist25_sigA_uid59_fpAddSubTest_ieeeAdd_b_7_q and invAMinusA_uid138_fpAddSubTest_ieeeAdd_q;\n" +
                        "\n" +
                        "    -- redist23_sigB_uid60_fpAddSubTest_ieeeAdd_b_6(DELAY,306)\n" +
                        "    redist23_sigB_uid60_fpAddSubTest_ieeeAdd_b_6 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 3, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => redist22_sigB_uid60_fpAddSubTest_ieeeAdd_b_3_q, xout => redist23_sigB_uid60_fpAddSubTest_ieeeAdd_b_6_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist30_excZ_bSig_uid26_uid46_fpAddSubTest_ieeeAdd_q_6(DELAY,313)\n" +
                        "    redist30_excZ_bSig_uid26_uid46_fpAddSubTest_ieeeAdd_q_6 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 6, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => excZ_bSig_uid26_uid46_fpAddSubTest_ieeeAdd_q, xout => redist30_excZ_bSig_uid26_uid46_fpAddSubTest_ieeeAdd_q_6_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- excAZBZSigASigB_uid143_fpAddSubTest_ieeeAdd(LOGICAL,142)@7\n" +
                        "    excAZBZSigASigB_uid143_fpAddSubTest_ieeeAdd_q <= excZ_aSig_uid25_uid32_fpAddSubTest_ieeeAdd_q and redist30_excZ_bSig_uid26_uid46_fpAddSubTest_ieeeAdd_q_6_q and redist25_sigA_uid59_fpAddSubTest_ieeeAdd_b_7_q and redist23_sigB_uid60_fpAddSubTest_ieeeAdd_b_6_q;\n" +
                        "\n" +
                        "    -- excBZARSigA_uid144_fpAddSubTest_ieeeAdd(LOGICAL,143)@7\n" +
                        "    excBZARSigA_uid144_fpAddSubTest_ieeeAdd_q <= redist30_excZ_bSig_uid26_uid46_fpAddSubTest_ieeeAdd_q_6_q and excR_aSig_uid40_fpAddSubTest_ieeeAdd_q and redist25_sigA_uid59_fpAddSubTest_ieeeAdd_b_7_q;\n" +
                        "\n" +
                        "    -- signRZero_uid145_fpAddSubTest_ieeeAdd(LOGICAL,144)@7\n" +
                        "    signRZero_uid145_fpAddSubTest_ieeeAdd_q <= excBZARSigA_uid144_fpAddSubTest_ieeeAdd_q or excAZBZSigASigB_uid143_fpAddSubTest_ieeeAdd_q;\n" +
                        "\n" +
                        "    -- fracXIsZero_uid48_fpAddSubTest_ieeeAdd(LOGICAL,47)@1\n" +
                        "    fracXIsZero_uid48_fpAddSubTest_ieeeAdd_q <= \"1\" WHEN cstZeroWF_uid28_fpAddSubTest_ieeeAdd_q = frac_bSig_uid45_fpAddSubTest_ieeeAdd_b ELSE \"0\";\n" +
                        "\n" +
                        "    -- excI_bSig_uid50_fpAddSubTest_ieeeAdd(LOGICAL,49)@1 + 1\n" +
                        "    excI_bSig_uid50_fpAddSubTest_ieeeAdd_qi <= expXIsMax_uid47_fpAddSubTest_ieeeAdd_q and fracXIsZero_uid48_fpAddSubTest_ieeeAdd_q;\n" +
                        "    excI_bSig_uid50_fpAddSubTest_ieeeAdd_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => excI_bSig_uid50_fpAddSubTest_ieeeAdd_qi, xout => excI_bSig_uid50_fpAddSubTest_ieeeAdd_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist28_excI_bSig_uid50_fpAddSubTest_ieeeAdd_q_6(DELAY,311)\n" +
                        "    redist28_excI_bSig_uid50_fpAddSubTest_ieeeAdd_q_6 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 5, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => excI_bSig_uid50_fpAddSubTest_ieeeAdd_q, xout => redist28_excI_bSig_uid50_fpAddSubTest_ieeeAdd_q_6_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- sigBBInf_uid140_fpAddSubTest_ieeeAdd(LOGICAL,139)@7\n" +
                        "    sigBBInf_uid140_fpAddSubTest_ieeeAdd_q <= redist23_sigB_uid60_fpAddSubTest_ieeeAdd_b_6_q and redist28_excI_bSig_uid50_fpAddSubTest_ieeeAdd_q_6_q;\n" +
                        "\n" +
                        "    -- fracXIsZero_uid34_fpAddSubTest_ieeeAdd(LOGICAL,33)@4 + 1\n" +
                        "    fracXIsZero_uid34_fpAddSubTest_ieeeAdd_qi <= \"1\" WHEN cstZeroWF_uid28_fpAddSubTest_ieeeAdd_q = redist36_frac_aSig_uid31_fpAddSubTest_ieeeAdd_b_4_outputreg_q ELSE \"0\";\n" +
                        "    fracXIsZero_uid34_fpAddSubTest_ieeeAdd_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => fracXIsZero_uid34_fpAddSubTest_ieeeAdd_qi, xout => fracXIsZero_uid34_fpAddSubTest_ieeeAdd_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist34_fracXIsZero_uid34_fpAddSubTest_ieeeAdd_q_3(DELAY,317)\n" +
                        "    redist34_fracXIsZero_uid34_fpAddSubTest_ieeeAdd_q_3 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 2, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => fracXIsZero_uid34_fpAddSubTest_ieeeAdd_q, xout => redist34_fracXIsZero_uid34_fpAddSubTest_ieeeAdd_q_3_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- excI_aSig_uid36_fpAddSubTest_ieeeAdd(LOGICAL,35)@7\n" +
                        "    excI_aSig_uid36_fpAddSubTest_ieeeAdd_q <= expXIsMax_uid33_fpAddSubTest_ieeeAdd_q and redist34_fracXIsZero_uid34_fpAddSubTest_ieeeAdd_q_3_q;\n" +
                        "\n" +
                        "    -- sigAAInf_uid141_fpAddSubTest_ieeeAdd(LOGICAL,140)@7\n" +
                        "    sigAAInf_uid141_fpAddSubTest_ieeeAdd_q <= redist25_sigA_uid59_fpAddSubTest_ieeeAdd_b_7_q and excI_aSig_uid36_fpAddSubTest_ieeeAdd_q;\n" +
                        "\n" +
                        "    -- signRInf_uid142_fpAddSubTest_ieeeAdd(LOGICAL,141)@7\n" +
                        "    signRInf_uid142_fpAddSubTest_ieeeAdd_q <= sigAAInf_uid141_fpAddSubTest_ieeeAdd_q or sigBBInf_uid140_fpAddSubTest_ieeeAdd_q;\n" +
                        "\n" +
                        "    -- signRInfRZRReg_uid146_fpAddSubTest_ieeeAdd(LOGICAL,145)@7 + 1\n" +
                        "    signRInfRZRReg_uid146_fpAddSubTest_ieeeAdd_qi <= signRInf_uid142_fpAddSubTest_ieeeAdd_q or signRZero_uid145_fpAddSubTest_ieeeAdd_q or signRReg_uid139_fpAddSubTest_ieeeAdd_q;\n" +
                        "    signRInfRZRReg_uid146_fpAddSubTest_ieeeAdd_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => signRInfRZRReg_uid146_fpAddSubTest_ieeeAdd_qi, xout => signRInfRZRReg_uid146_fpAddSubTest_ieeeAdd_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist11_signRInfRZRReg_uid146_fpAddSubTest_ieeeAdd_q_2(DELAY,294)\n" +
                        "    redist11_signRInfRZRReg_uid146_fpAddSubTest_ieeeAdd_q_2 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => signRInfRZRReg_uid146_fpAddSubTest_ieeeAdd_q, xout => redist11_signRInfRZRReg_uid146_fpAddSubTest_ieeeAdd_q_2_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- fracXIsNotZero_uid49_fpAddSubTest_ieeeAdd(LOGICAL,48)@1\n" +
                        "    fracXIsNotZero_uid49_fpAddSubTest_ieeeAdd_q <= not (fracXIsZero_uid48_fpAddSubTest_ieeeAdd_q);\n" +
                        "\n" +
                        "    -- excN_bSig_uid51_fpAddSubTest_ieeeAdd(LOGICAL,50)@1 + 1\n" +
                        "    excN_bSig_uid51_fpAddSubTest_ieeeAdd_qi <= expXIsMax_uid47_fpAddSubTest_ieeeAdd_q and fracXIsNotZero_uid49_fpAddSubTest_ieeeAdd_q;\n" +
                        "    excN_bSig_uid51_fpAddSubTest_ieeeAdd_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => excN_bSig_uid51_fpAddSubTest_ieeeAdd_qi, xout => excN_bSig_uid51_fpAddSubTest_ieeeAdd_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist27_excN_bSig_uid51_fpAddSubTest_ieeeAdd_q_8(DELAY,310)\n" +
                        "    redist27_excN_bSig_uid51_fpAddSubTest_ieeeAdd_q_8 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 7, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => excN_bSig_uid51_fpAddSubTest_ieeeAdd_q, xout => redist27_excN_bSig_uid51_fpAddSubTest_ieeeAdd_q_8_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- fracXIsNotZero_uid35_fpAddSubTest_ieeeAdd(LOGICAL,34)@7\n" +
                        "    fracXIsNotZero_uid35_fpAddSubTest_ieeeAdd_q <= not (redist34_fracXIsZero_uid34_fpAddSubTest_ieeeAdd_q_3_q);\n" +
                        "\n" +
                        "    -- excN_aSig_uid37_fpAddSubTest_ieeeAdd(LOGICAL,36)@7 + 1\n" +
                        "    excN_aSig_uid37_fpAddSubTest_ieeeAdd_qi <= expXIsMax_uid33_fpAddSubTest_ieeeAdd_q and fracXIsNotZero_uid35_fpAddSubTest_ieeeAdd_q;\n";
        String data3 =  "    excN_aSig_uid37_fpAddSubTest_ieeeAdd_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => excN_aSig_uid37_fpAddSubTest_ieeeAdd_qi, xout => excN_aSig_uid37_fpAddSubTest_ieeeAdd_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist32_excN_aSig_uid37_fpAddSubTest_ieeeAdd_q_2(DELAY,315)\n" +
                        "    redist32_excN_aSig_uid37_fpAddSubTest_ieeeAdd_q_2 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => excN_aSig_uid37_fpAddSubTest_ieeeAdd_q, xout => redist32_excN_aSig_uid37_fpAddSubTest_ieeeAdd_q_2_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- excRNaN2_uid133_fpAddSubTest_ieeeAdd(LOGICAL,132)@9\n" +
                        "    excRNaN2_uid133_fpAddSubTest_ieeeAdd_q <= redist32_excN_aSig_uid37_fpAddSubTest_ieeeAdd_q_2_q or redist27_excN_bSig_uid51_fpAddSubTest_ieeeAdd_q_8_q;\n" +
                        "\n" +
                        "    -- redist21_effSub_uid61_fpAddSubTest_ieeeAdd_q_5(DELAY,304)\n" +
                        "    redist21_effSub_uid61_fpAddSubTest_ieeeAdd_q_5 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 5, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => effSub_uid61_fpAddSubTest_ieeeAdd_q, xout => redist21_effSub_uid61_fpAddSubTest_ieeeAdd_q_5_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist29_excI_bSig_uid50_fpAddSubTest_ieeeAdd_q_8(DELAY,312)\n" +
                        "    redist29_excI_bSig_uid50_fpAddSubTest_ieeeAdd_q_8 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 2, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => redist28_excI_bSig_uid50_fpAddSubTest_ieeeAdd_q_6_q, xout => redist29_excI_bSig_uid50_fpAddSubTest_ieeeAdd_q_8_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist33_excI_aSig_uid36_fpAddSubTest_ieeeAdd_q_2(DELAY,316)\n" +
                        "    redist33_excI_aSig_uid36_fpAddSubTest_ieeeAdd_q_2 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 2, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => excI_aSig_uid36_fpAddSubTest_ieeeAdd_q, xout => redist33_excI_aSig_uid36_fpAddSubTest_ieeeAdd_q_2_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- excAIBISub_uid134_fpAddSubTest_ieeeAdd(LOGICAL,133)@9\n" +
                        "    excAIBISub_uid134_fpAddSubTest_ieeeAdd_q <= redist33_excI_aSig_uid36_fpAddSubTest_ieeeAdd_q_2_q and redist29_excI_bSig_uid50_fpAddSubTest_ieeeAdd_q_8_q and redist21_effSub_uid61_fpAddSubTest_ieeeAdd_q_5_q;\n" +
                        "\n" +
                        "    -- excRNaN_uid135_fpAddSubTest_ieeeAdd(LOGICAL,134)@9\n" +
                        "    excRNaN_uid135_fpAddSubTest_ieeeAdd_q <= excAIBISub_uid134_fpAddSubTest_ieeeAdd_q or excRNaN2_uid133_fpAddSubTest_ieeeAdd_q;\n" +
                        "\n" +
                        "    -- invExcRNaN_uid147_fpAddSubTest_ieeeAdd(LOGICAL,146)@9\n" +
                        "    invExcRNaN_uid147_fpAddSubTest_ieeeAdd_q <= not (excRNaN_uid135_fpAddSubTest_ieeeAdd_q);\n" +
                        "\n" +
                        "    -- VCC(CONSTANT,1)\n" +
                        "    VCC_q <= \"1\";\n" +
                        "\n" +
                        "    -- signRPostExc_uid148_fpAddSubTest_ieeeAdd(LOGICAL,147)@9\n" +
                        "    signRPostExc_uid148_fpAddSubTest_ieeeAdd_q <= invExcRNaN_uid147_fpAddSubTest_ieeeAdd_q and redist11_signRInfRZRReg_uid146_fpAddSubTest_ieeeAdd_q_2_q;\n" +
                        "\n" +
                        "    -- cRBit_uid108_fpAddSubTest_ieeeAdd(CONSTANT,107)\n" +
                        "    cRBit_uid108_fpAddSubTest_ieeeAdd_q <= \"01000\";\n" +
                        "\n" +
                        "    -- leftShiftStage2Idx3Rng3_uid272_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd(BITSELECT,271)@7\n" +
                        "    leftShiftStage2Idx3Rng3_uid272_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_in <= leftShiftStage1_uid264_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q(53 downto 0);\n" +
                        "    leftShiftStage2Idx3Rng3_uid272_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_b <= leftShiftStage2Idx3Rng3_uid272_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_in(53 downto 0);\n" +
                        "\n" +
                        "    -- leftShiftStage2Idx3Pad3_uid271_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd(CONSTANT,270)\n" +
                        "    leftShiftStage2Idx3Pad3_uid271_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q <= \"000\";\n" +
                        "\n" +
                        "    -- leftShiftStage2Idx3_uid273_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd(BITJOIN,272)@7\n" +
                        "    leftShiftStage2Idx3_uid273_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q <= leftShiftStage2Idx3Rng3_uid272_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_b & leftShiftStage2Idx3Pad3_uid271_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q;\n" +
                        "\n" +
                        "    -- leftShiftStage2Idx2Rng2_uid269_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd(BITSELECT,268)@7\n" +
                        "    leftShiftStage2Idx2Rng2_uid269_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_in <= leftShiftStage1_uid264_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q(54 downto 0);\n" +
                        "    leftShiftStage2Idx2Rng2_uid269_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_b <= leftShiftStage2Idx2Rng2_uid269_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_in(54 downto 0);\n" +
                        "\n" +
                        "    -- leftShiftStage2Idx2_uid270_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd(BITJOIN,269)@7\n" +
                        "    leftShiftStage2Idx2_uid270_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q <= leftShiftStage2Idx2Rng2_uid269_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_b & zs_uid185_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q;\n" +
                        "\n" +
                        "    -- leftShiftStage2Idx1Rng1_uid266_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd(BITSELECT,265)@7\n" +
                        "    leftShiftStage2Idx1Rng1_uid266_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_in <= leftShiftStage1_uid264_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q(55 downto 0);\n" +
                        "    leftShiftStage2Idx1Rng1_uid266_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_b <= leftShiftStage2Idx1Rng1_uid266_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_in(55 downto 0);\n" +
                        "\n" +
                        "    -- leftShiftStage2Idx1_uid267_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd(BITJOIN,266)@7\n" +
                        "    leftShiftStage2Idx1_uid267_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q <= leftShiftStage2Idx1Rng1_uid266_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_b & GND_q;\n" +
                        "\n" +
                        "    -- leftShiftStage1Idx3Rng12_uid261_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd(BITSELECT,260)@7\n" +
                        "    leftShiftStage1Idx3Rng12_uid261_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_in <= leftShiftStage0_uid253_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q(44 downto 0);\n" +
                        "    leftShiftStage1Idx3Rng12_uid261_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_b <= leftShiftStage1Idx3Rng12_uid261_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_in(44 downto 0);\n" +
                        "\n" +
                        "    -- leftShiftStage1Idx3Pad12_uid260_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd(CONSTANT,259)\n" +
                        "    leftShiftStage1Idx3Pad12_uid260_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q <= \"000000000000\";\n" +
                        "\n" +
                        "    -- leftShiftStage1Idx3_uid262_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd(BITJOIN,261)@7\n" +
                        "    leftShiftStage1Idx3_uid262_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q <= leftShiftStage1Idx3Rng12_uid261_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_b & leftShiftStage1Idx3Pad12_uid260_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q;\n" +
                        "\n" +
                        "    -- leftShiftStage1Idx2Rng8_uid258_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd(BITSELECT,257)@7\n" +
                        "    leftShiftStage1Idx2Rng8_uid258_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_in <= leftShiftStage0_uid253_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q(48 downto 0);\n" +
                        "    leftShiftStage1Idx2Rng8_uid258_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_b <= leftShiftStage1Idx2Rng8_uid258_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_in(48 downto 0);\n" +
                        "\n" +
                        "    -- leftShiftStage1Idx2_uid259_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd(BITJOIN,258)@7\n" +
                        "    leftShiftStage1Idx2_uid259_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q <= leftShiftStage1Idx2Rng8_uid258_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_b & zs_uid173_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q;\n" +
                        "\n" +
                        "    -- leftShiftStage1Idx1Rng4_uid255_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd(BITSELECT,254)@7\n" +
                        "    leftShiftStage1Idx1Rng4_uid255_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_in <= leftShiftStage0_uid253_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q(52 downto 0);\n" +
                        "    leftShiftStage1Idx1Rng4_uid255_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_b <= leftShiftStage1Idx1Rng4_uid255_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_in(52 downto 0);\n" +
                        "\n" +
                        "    -- leftShiftStage1Idx1_uid256_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd(BITJOIN,255)@7\n" +
                        "    leftShiftStage1Idx1_uid256_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q <= leftShiftStage1Idx1Rng4_uid255_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_b & zs_uid179_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q;\n" +
                        "\n" +
                        "    -- leftShiftStage0Idx3Rng48_uid250_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd(BITSELECT,249)@7\n" +
                        "    leftShiftStage0Idx3Rng48_uid250_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_in <= redist17_fracGRS_uid93_fpAddSubTest_ieeeAdd_q_2_q(8 downto 0);\n" +
                        "    leftShiftStage0Idx3Rng48_uid250_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_b <= leftShiftStage0Idx3Rng48_uid250_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_in(8 downto 0);\n" +
                        "\n" +
                        "    -- leftShiftStage0Idx3Pad48_uid249_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd(CONSTANT,248)\n" +
                        "    leftShiftStage0Idx3Pad48_uid249_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q <= \"000000000000000000000000000000000000000000000000\";\n" +
                        "\n" +
                        "    -- leftShiftStage0Idx3_uid251_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd(BITJOIN,250)@7\n" +
                        "    leftShiftStage0Idx3_uid251_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q <= leftShiftStage0Idx3Rng48_uid250_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_b & leftShiftStage0Idx3Pad48_uid249_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q;\n" +
                        "\n" +
                        "    -- redist9_vStage_uid163_lzCountVal_uid94_fpAddSubTest_ieeeAdd_b_2(DELAY,292)\n" +
                        "    redist9_vStage_uid163_lzCountVal_uid94_fpAddSubTest_ieeeAdd_b_2 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 25, depth => 2, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => vStage_uid163_lzCountVal_uid94_fpAddSubTest_ieeeAdd_b, xout => redist9_vStage_uid163_lzCountVal_uid94_fpAddSubTest_ieeeAdd_b_2_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- leftShiftStage0Idx2_uid248_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd(BITJOIN,247)@7\n" +
                        "    leftShiftStage0Idx2_uid248_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q <= redist9_vStage_uid163_lzCountVal_uid94_fpAddSubTest_ieeeAdd_b_2_q & zs_uid159_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q;\n" +
                        "\n" +
                        "    -- leftShiftStage0Idx1Rng16_uid244_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd(BITSELECT,243)@7\n" +
                        "    leftShiftStage0Idx1Rng16_uid244_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_in <= redist17_fracGRS_uid93_fpAddSubTest_ieeeAdd_q_2_q(40 downto 0);\n" +
                        "    leftShiftStage0Idx1Rng16_uid244_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_b <= leftShiftStage0Idx1Rng16_uid244_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_in(40 downto 0);\n" +
                        "\n" +
                        "    -- leftShiftStage0Idx1_uid245_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd(BITJOIN,244)@7\n" +
                        "    leftShiftStage0Idx1_uid245_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q <= leftShiftStage0Idx1Rng16_uid244_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_b & zs_uid167_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q;\n" +
                        "\n" +
                        "    -- redist17_fracGRS_uid93_fpAddSubTest_ieeeAdd_q_2(DELAY,300)\n" +
                        "    redist17_fracGRS_uid93_fpAddSubTest_ieeeAdd_q_2 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 57, depth => 2, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => fracGRS_uid93_fpAddSubTest_ieeeAdd_q, xout => redist17_fracGRS_uid93_fpAddSubTest_ieeeAdd_q_2_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- leftShiftStage0_uid253_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd(MUX,252)@7\n" +
                        "    leftShiftStage0_uid253_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_s <= leftShiftStageSel5Dto4_uid252_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_merged_bit_select_b;\n" +
                        "    leftShiftStage0_uid253_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_combproc: PROCESS (leftShiftStage0_uid253_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_s, redist17_fracGRS_uid93_fpAddSubTest_ieeeAdd_q_2_q, leftShiftStage0Idx1_uid245_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q, leftShiftStage0Idx2_uid248_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q, leftShiftStage0Idx3_uid251_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (leftShiftStage0_uid253_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_s) IS\n" +
                        "            WHEN \"00\" => leftShiftStage0_uid253_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q <= redist17_fracGRS_uid93_fpAddSubTest_ieeeAdd_q_2_q;\n" +
                        "            WHEN \"01\" => leftShiftStage0_uid253_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q <= leftShiftStage0Idx1_uid245_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q;\n" +
                        "            WHEN \"10\" => leftShiftStage0_uid253_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q <= leftShiftStage0Idx2_uid248_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q;\n" +
                        "            WHEN \"11\" => leftShiftStage0_uid253_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q <= leftShiftStage0Idx3_uid251_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q;\n" +
                        "            WHEN OTHERS => leftShiftStage0_uid253_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- leftShiftStage1_uid264_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd(MUX,263)@7\n" +
                        "    leftShiftStage1_uid264_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_s <= leftShiftStageSel5Dto4_uid252_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_merged_bit_select_c;\n" +
                        "    leftShiftStage1_uid264_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_combproc: PROCESS (leftShiftStage1_uid264_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_s, leftShiftStage0_uid253_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q, leftShiftStage1Idx1_uid256_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q, leftShiftStage1Idx2_uid259_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q, leftShiftStage1Idx3_uid262_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (leftShiftStage1_uid264_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_s) IS\n" +
                        "            WHEN \"00\" => leftShiftStage1_uid264_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q <= leftShiftStage0_uid253_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q;\n" +
                        "            WHEN \"01\" => leftShiftStage1_uid264_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q <= leftShiftStage1Idx1_uid256_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q;\n" +
                        "            WHEN \"10\" => leftShiftStage1_uid264_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q <= leftShiftStage1Idx2_uid259_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q;\n" +
                        "            WHEN \"11\" => leftShiftStage1_uid264_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q <= leftShiftStage1Idx3_uid262_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q;\n" +
                        "            WHEN OTHERS => leftShiftStage1_uid264_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- leftShiftStageSel5Dto4_uid252_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_merged_bit_select(BITSELECT,282)@7\n" +
                        "    leftShiftStageSel5Dto4_uid252_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_merged_bit_select_b <= r_uid194_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q(5 downto 4);\n" +
                        "    leftShiftStageSel5Dto4_uid252_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_merged_bit_select_c <= r_uid194_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q(3 downto 2);\n" +
                        "    leftShiftStageSel5Dto4_uid252_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_merged_bit_select_d <= r_uid194_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q(1 downto 0);\n" +
                        "\n" +
                        "    -- leftShiftStage2_uid275_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd(MUX,274)@7\n" +
                        "    leftShiftStage2_uid275_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_s <= leftShiftStageSel5Dto4_uid252_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_merged_bit_select_d;\n" +
                        "    leftShiftStage2_uid275_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_combproc: PROCESS (leftShiftStage2_uid275_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_s, leftShiftStage1_uid264_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q, leftShiftStage2Idx1_uid267_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q, leftShiftStage2Idx2_uid270_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q, leftShiftStage2Idx3_uid273_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (leftShiftStage2_uid275_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_s) IS\n" +
                        "            WHEN \"00\" => leftShiftStage2_uid275_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q <= leftShiftStage1_uid264_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q;\n" +
                        "            WHEN \"01\" => leftShiftStage2_uid275_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q <= leftShiftStage2Idx1_uid267_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q;\n" +
                        "            WHEN \"10\" => leftShiftStage2_uid275_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q <= leftShiftStage2Idx2_uid270_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q;\n" +
                        "            WHEN \"11\" => leftShiftStage2_uid275_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q <= leftShiftStage2Idx3_uid273_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q;\n" +
                        "            WHEN OTHERS => leftShiftStage2_uid275_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- LSB_uid106_fpAddSubTest_ieeeAdd(BITSELECT,105)@7\n" +
                        "    LSB_uid106_fpAddSubTest_ieeeAdd_in <= STD_LOGIC_VECTOR(leftShiftStage2_uid275_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q(4 downto 0));\n" +
                        "    LSB_uid106_fpAddSubTest_ieeeAdd_b <= STD_LOGIC_VECTOR(LSB_uid106_fpAddSubTest_ieeeAdd_in(4 downto 4));\n" +
                        "\n" +
                        "    -- Guard_uid105_fpAddSubTest_ieeeAdd(BITSELECT,104)@7\n" +
                        "    Guard_uid105_fpAddSubTest_ieeeAdd_in <= STD_LOGIC_VECTOR(leftShiftStage2_uid275_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q(3 downto 0));\n" +
                        "    Guard_uid105_fpAddSubTest_ieeeAdd_b <= STD_LOGIC_VECTOR(Guard_uid105_fpAddSubTest_ieeeAdd_in(3 downto 3));\n" +
                        "\n" +
                        "    -- Round_uid104_fpAddSubTest_ieeeAdd(BITSELECT,103)@7\n" +
                        "    Round_uid104_fpAddSubTest_ieeeAdd_in <= STD_LOGIC_VECTOR(leftShiftStage2_uid275_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q(2 downto 0));\n" +
                        "    Round_uid104_fpAddSubTest_ieeeAdd_b <= STD_LOGIC_VECTOR(Round_uid104_fpAddSubTest_ieeeAdd_in(2 downto 2));\n" +
                        "\n" +
                        "    -- Sticky1_uid103_fpAddSubTest_ieeeAdd(BITSELECT,102)@7\n" +
                        "    Sticky1_uid103_fpAddSubTest_ieeeAdd_in <= STD_LOGIC_VECTOR(leftShiftStage2_uid275_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q(1 downto 0));\n" +
                        "    Sticky1_uid103_fpAddSubTest_ieeeAdd_b <= STD_LOGIC_VECTOR(Sticky1_uid103_fpAddSubTest_ieeeAdd_in(1 downto 1));\n" +
                        "\n" +
                        "    -- Sticky0_uid102_fpAddSubTest_ieeeAdd(BITSELECT,101)@7\n" +
                        "    Sticky0_uid102_fpAddSubTest_ieeeAdd_in <= STD_LOGIC_VECTOR(leftShiftStage2_uid275_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q(0 downto 0));\n" +
                        "    Sticky0_uid102_fpAddSubTest_ieeeAdd_b <= STD_LOGIC_VECTOR(Sticky0_uid102_fpAddSubTest_ieeeAdd_in(0 downto 0));\n" +
                        "\n" +
                        "    -- rndBitCond_uid107_fpAddSubTest_ieeeAdd(BITJOIN,106)@7\n" +
                        "    rndBitCond_uid107_fpAddSubTest_ieeeAdd_q <= LSB_uid106_fpAddSubTest_ieeeAdd_b & Guard_uid105_fpAddSubTest_ieeeAdd_b & Round_uid104_fpAddSubTest_ieeeAdd_b & Sticky1_uid103_fpAddSubTest_ieeeAdd_b & Sticky0_uid102_fpAddSubTest_ieeeAdd_b;\n" +
                        "\n" +
                        "    -- rBi_uid109_fpAddSubTest_ieeeAdd(LOGICAL,108)@7 + 1\n" +
                        "    rBi_uid109_fpAddSubTest_ieeeAdd_qi <= \"1\" WHEN rndBitCond_uid107_fpAddSubTest_ieeeAdd_q = cRBit_uid108_fpAddSubTest_ieeeAdd_q ELSE \"0\";\n" +
                        "    rBi_uid109_fpAddSubTest_ieeeAdd_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => rBi_uid109_fpAddSubTest_ieeeAdd_qi, xout => rBi_uid109_fpAddSubTest_ieeeAdd_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- roundBit_uid110_fpAddSubTest_ieeeAdd(LOGICAL,109)@8\n" +
                        "    roundBit_uid110_fpAddSubTest_ieeeAdd_q <= not (rBi_uid109_fpAddSubTest_ieeeAdd_q);\n" +
                        "\n" +
                        "    -- oneCST_uid99_fpAddSubTest_ieeeAdd(CONSTANT,98)\n" +
                        "    oneCST_uid99_fpAddSubTest_ieeeAdd_q <= \"00000000001\";\n" +
                        "\n" +
                        "    -- expInc_uid100_fpAddSubTest_ieeeAdd(ADD,99)@7\n" +
                        "    expInc_uid100_fpAddSubTest_ieeeAdd_a <= STD_LOGIC_VECTOR(\"0\" & redist38_exp_aSig_uid30_fpAddSubTest_ieeeAdd_b_7_outputreg_q);\n" +
                        "    expInc_uid100_fpAddSubTest_ieeeAdd_b <= STD_LOGIC_VECTOR(\"0\" & oneCST_uid99_fpAddSubTest_ieeeAdd_q);\n" +
                        "    expInc_uid100_fpAddSubTest_ieeeAdd_o <= STD_LOGIC_VECTOR(UNSIGNED(expInc_uid100_fpAddSubTest_ieeeAdd_a) + UNSIGNED(expInc_uid100_fpAddSubTest_ieeeAdd_b));\n" +
                        "    expInc_uid100_fpAddSubTest_ieeeAdd_q <= expInc_uid100_fpAddSubTest_ieeeAdd_o(11 downto 0);\n" +
                        "\n" +
                        "    -- expPostNorm_uid101_fpAddSubTest_ieeeAdd(SUB,100)@7 + 1\n" +
                        "    expPostNorm_uid101_fpAddSubTest_ieeeAdd_a <= STD_LOGIC_VECTOR(\"0\" & expInc_uid100_fpAddSubTest_ieeeAdd_q);\n" +
                        "    expPostNorm_uid101_fpAddSubTest_ieeeAdd_b <= STD_LOGIC_VECTOR(\"0000000\" & r_uid194_lzCountVal_uid94_fpAddSubTest_ieeeAdd_q);\n" +
                        "    expPostNorm_uid101_fpAddSubTest_ieeeAdd_clkproc: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            expPostNorm_uid101_fpAddSubTest_ieeeAdd_o <= (others => '0');\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            expPostNorm_uid101_fpAddSubTest_ieeeAdd_o <= STD_LOGIC_VECTOR(UNSIGNED(expPostNorm_uid101_fpAddSubTest_ieeeAdd_a) - UNSIGNED(expPostNorm_uid101_fpAddSubTest_ieeeAdd_b));\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "    expPostNorm_uid101_fpAddSubTest_ieeeAdd_q <= expPostNorm_uid101_fpAddSubTest_ieeeAdd_o(12 downto 0);\n" +
                        "\n" +
                        "    -- fracPostNorm_uid98_fpAddSubTest_ieeeAdd(BITSELECT,97)@7\n" +
                        "    fracPostNorm_uid98_fpAddSubTest_ieeeAdd_b <= leftShiftStage2_uid275_fracPostNormExt_uid97_fpAddSubTest_ieeeAdd_q(56 downto 1);\n" +
                        "\n" +
                        "    -- fracPostNormRndRange_uid111_fpAddSubTest_ieeeAdd(BITSELECT,110)@7\n" +
                        "    fracPostNormRndRange_uid111_fpAddSubTest_ieeeAdd_in <= fracPostNorm_uid98_fpAddSubTest_ieeeAdd_b(54 downto 0);\n" +
                        "    fracPostNormRndRange_uid111_fpAddSubTest_ieeeAdd_b <= fracPostNormRndRange_uid111_fpAddSubTest_ieeeAdd_in(54 downto 2);\n" +
                        "\n" +
                        "    -- redist15_fracPostNormRndRange_uid111_fpAddSubTest_ieeeAdd_b_1(DELAY,298)\n" +
                        "    redist15_fracPostNormRndRange_uid111_fpAddSubTest_ieeeAdd_b_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 53, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => fracPostNormRndRange_uid111_fpAddSubTest_ieeeAdd_b, xout => redist15_fracPostNormRndRange_uid111_fpAddSubTest_ieeeAdd_b_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- expFracR_uid112_fpAddSubTest_ieeeAdd(BITJOIN,111)@8\n" +
                        "    expFracR_uid112_fpAddSubTest_ieeeAdd_q <= expPostNorm_uid101_fpAddSubTest_ieeeAdd_q & redist15_fracPostNormRndRange_uid111_fpAddSubTest_ieeeAdd_b_1_q;\n" +
                        "\n" +
                        "    -- rndExpFrac_uid113_fpAddSubTest_ieeeAdd(ADD,112)@8\n" +
                        "    rndExpFrac_uid113_fpAddSubTest_ieeeAdd_a <= STD_LOGIC_VECTOR(\"0\" & expFracR_uid112_fpAddSubTest_ieeeAdd_q);\n" +
                        "    rndExpFrac_uid113_fpAddSubTest_ieeeAdd_b <= STD_LOGIC_VECTOR(\"000000000000000000000000000000000000000000000000000000000000000000\" & roundBit_uid110_fpAddSubTest_ieeeAdd_q);\n" +
                        "    rndExpFrac_uid113_fpAddSubTest_ieeeAdd_o <= STD_LOGIC_VECTOR(UNSIGNED(rndExpFrac_uid113_fpAddSubTest_ieeeAdd_a) + UNSIGNED(rndExpFrac_uid113_fpAddSubTest_ieeeAdd_b));\n" +
                        "    rndExpFrac_uid113_fpAddSubTest_ieeeAdd_q <= rndExpFrac_uid113_fpAddSubTest_ieeeAdd_o(66 downto 0);\n" +
                        "\n" +
                        "    -- expRPreExc_uid126_fpAddSubTest_ieeeAdd(BITSELECT,125)@8\n" +
                        "    expRPreExc_uid126_fpAddSubTest_ieeeAdd_in <= rndExpFrac_uid113_fpAddSubTest_ieeeAdd_q(63 downto 0);\n" +
                        "    expRPreExc_uid126_fpAddSubTest_ieeeAdd_b <= expRPreExc_uid126_fpAddSubTest_ieeeAdd_in(63 downto 53);\n" +
                        "\n" +
                        "    -- redist13_expRPreExc_uid126_fpAddSubTest_ieeeAdd_b_1(DELAY,296)\n" +
                        "    redist13_expRPreExc_uid126_fpAddSubTest_ieeeAdd_b_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 11, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => expRPreExc_uid126_fpAddSubTest_ieeeAdd_b, xout => redist13_expRPreExc_uid126_fpAddSubTest_ieeeAdd_b_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- rndExpFracOvfBits_uid118_fpAddSubTest_ieeeAdd(BITSELECT,117)@8\n" +
                        "    rndExpFracOvfBits_uid118_fpAddSubTest_ieeeAdd_in <= rndExpFrac_uid113_fpAddSubTest_ieeeAdd_q(65 downto 0);\n" +
                        "    rndExpFracOvfBits_uid118_fpAddSubTest_ieeeAdd_b <= rndExpFracOvfBits_uid118_fpAddSubTest_ieeeAdd_in(65 downto 64);\n" +
                        "\n" +
                        "    -- rOvfExtraBits_uid119_fpAddSubTest_ieeeAdd(LOGICAL,118)@8\n" +
                        "    rOvfExtraBits_uid119_fpAddSubTest_ieeeAdd_q <= \"1\" WHEN rndExpFracOvfBits_uid118_fpAddSubTest_ieeeAdd_b = zocst_uid85_fpAddSubTest_ieeeAdd_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- wEP2AllOwE_uid114_fpAddSubTest_ieeeAdd(CONSTANT,113)\n" +
                        "    wEP2AllOwE_uid114_fpAddSubTest_ieeeAdd_q <= \"0011111111111\";\n" +
                        "\n" +
                        "    -- rndExp_uid115_fpAddSubTest_ieeeAdd(BITSELECT,114)@8\n" +
                        "    rndExp_uid115_fpAddSubTest_ieeeAdd_in <= rndExpFrac_uid113_fpAddSubTest_ieeeAdd_q(65 downto 0);\n" +
                        "    rndExp_uid115_fpAddSubTest_ieeeAdd_b <= rndExp_uid115_fpAddSubTest_ieeeAdd_in(65 downto 53);\n" +
                        "\n" +
                        "    -- rOvfEQMax_uid116_fpAddSubTest_ieeeAdd(LOGICAL,115)@8\n" +
                        "    rOvfEQMax_uid116_fpAddSubTest_ieeeAdd_q <= \"1\" WHEN rndExp_uid115_fpAddSubTest_ieeeAdd_b = wEP2AllOwE_uid114_fpAddSubTest_ieeeAdd_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- rOvf_uid120_fpAddSubTest_ieeeAdd(LOGICAL,119)@8 + 1\n" +
                        "    rOvf_uid120_fpAddSubTest_ieeeAdd_qi <= rOvfEQMax_uid116_fpAddSubTest_ieeeAdd_q or rOvfExtraBits_uid119_fpAddSubTest_ieeeAdd_q;\n" +
                        "    rOvf_uid120_fpAddSubTest_ieeeAdd_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => rOvf_uid120_fpAddSubTest_ieeeAdd_qi, xout => rOvf_uid120_fpAddSubTest_ieeeAdd_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- regInputs_uid127_fpAddSubTest_ieeeAdd(LOGICAL,126)@7 + 1\n" +
                        "    regInputs_uid127_fpAddSubTest_ieeeAdd_qi <= excR_aSig_uid40_fpAddSubTest_ieeeAdd_q and redist26_excR_bSig_uid54_fpAddSubTest_ieeeAdd_q_6_q;\n" +
                        "    regInputs_uid127_fpAddSubTest_ieeeAdd_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => regInputs_uid127_fpAddSubTest_ieeeAdd_qi, xout => regInputs_uid127_fpAddSubTest_ieeeAdd_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist12_regInputs_uid127_fpAddSubTest_ieeeAdd_q_2(DELAY,295)\n" +
                        "    redist12_regInputs_uid127_fpAddSubTest_ieeeAdd_q_2 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => regInputs_uid127_fpAddSubTest_ieeeAdd_q, xout => redist12_regInputs_uid127_fpAddSubTest_ieeeAdd_q_2_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- rInfOvf_uid130_fpAddSubTest_ieeeAdd(LOGICAL,129)@9\n" +
                        "    rInfOvf_uid130_fpAddSubTest_ieeeAdd_q <= redist12_regInputs_uid127_fpAddSubTest_ieeeAdd_q_2_q and rOvf_uid120_fpAddSubTest_ieeeAdd_q;\n" +
                        "\n" +
                        "    -- excRInfVInC_uid131_fpAddSubTest_ieeeAdd(BITJOIN,130)@9\n" +
                        "    excRInfVInC_uid131_fpAddSubTest_ieeeAdd_q <= rInfOvf_uid130_fpAddSubTest_ieeeAdd_q & redist27_excN_bSig_uid51_fpAddSubTest_ieeeAdd_q_8_q & redist32_excN_aSig_uid37_fpAddSubTest_ieeeAdd_q_2_q & redist29_excI_bSig_uid50_fpAddSubTest_ieeeAdd_q_8_q & redist33_excI_aSig_uid36_fpAddSubTest_ieeeAdd_q_2_q & redist21_effSub_uid61_fpAddSubTest_ieeeAdd_q_5_q;\n" +
                        "\n" +
                        "    -- excRInf_uid132_fpAddSubTest_ieeeAdd(LOOKUP,131)@9\n" +
                        "    excRInf_uid132_fpAddSubTest_ieeeAdd_combproc: PROCESS (excRInfVInC_uid131_fpAddSubTest_ieeeAdd_q)\n" +
                        "    BEGIN\n" +
                        "        -- Begin reserved scope level\n" +
                        "        CASE (excRInfVInC_uid131_fpAddSubTest_ieeeAdd_q) IS\n" +
                        "            WHEN \"000000\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"000001\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"000010\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"1\";\n" +
                        "            WHEN \"000011\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"1\";\n" +
                        "            WHEN \"000100\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"1\";\n" +
                        "            WHEN \"000101\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"1\";\n" +
                        "            WHEN \"000110\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"1\";\n" +
                        "            WHEN \"000111\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"001000\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"001001\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"001010\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"001011\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"001100\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"001101\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"001110\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"001111\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"010000\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"010001\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"010010\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"010011\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"010100\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"010101\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"010110\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"010111\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"011000\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"011001\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"011010\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"011011\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"011100\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"011101\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"011110\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"011111\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"100000\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"1\";\n" +
                        "            WHEN \"100001\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"100010\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"100011\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"100100\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"100101\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"100110\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"100111\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"101000\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"101001\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"101010\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"101011\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"101100\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"101101\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"101110\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"101111\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"110000\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"110001\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"110010\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"110011\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"110100\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"110101\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"110110\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"110111\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"111000\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"111001\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"111010\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"111011\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"111100\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"111101\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"111110\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"111111\" => excRInf_uid132_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN OTHERS => -- unreachable\n" +
                        "                           excRInf_uid132_fpAddSubTest_ieeeAdd_q <= (others => '-');\n" +
                        "        END CASE;\n" +
                        "        -- End reserved scope level\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- redist16_aMinusA_uid96_fpAddSubTest_ieeeAdd_q_2(DELAY,299)\n" +
                        "    redist16_aMinusA_uid96_fpAddSubTest_ieeeAdd_q_2 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 2, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => aMinusA_uid96_fpAddSubTest_ieeeAdd_q, xout => redist16_aMinusA_uid96_fpAddSubTest_ieeeAdd_q_2_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- rUdfExtraBit_uid123_fpAddSubTest_ieeeAdd(BITSELECT,122)@8\n" +
                        "    rUdfExtraBit_uid123_fpAddSubTest_ieeeAdd_in <= STD_LOGIC_VECTOR(rndExpFrac_uid113_fpAddSubTest_ieeeAdd_q(65 downto 0));\n" +
                        "    rUdfExtraBit_uid123_fpAddSubTest_ieeeAdd_b <= STD_LOGIC_VECTOR(rUdfExtraBit_uid123_fpAddSubTest_ieeeAdd_in(65 downto 65));\n" +
                        "\n" +
                        "    -- wEP2AllZ_uid121_fpAddSubTest_ieeeAdd(CONSTANT,120)\n" +
                        "    wEP2AllZ_uid121_fpAddSubTest_ieeeAdd_q <= \"0000000000000\";\n" +
                        "\n" +
                        "    -- rUdfEQMin_uid122_fpAddSubTest_ieeeAdd(LOGICAL,121)@8\n" +
                        "    rUdfEQMin_uid122_fpAddSubTest_ieeeAdd_q <= \"1\" WHEN rndExp_uid115_fpAddSubTest_ieeeAdd_b = wEP2AllZ_uid121_fpAddSubTest_ieeeAdd_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- rUdf_uid124_fpAddSubTest_ieeeAdd(LOGICAL,123)@8 + 1\n" +
                        "    rUdf_uid124_fpAddSubTest_ieeeAdd_qi <= rUdfEQMin_uid122_fpAddSubTest_ieeeAdd_q or rUdfExtraBit_uid123_fpAddSubTest_ieeeAdd_b;\n" +
                        "    rUdf_uid124_fpAddSubTest_ieeeAdd_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => rUdf_uid124_fpAddSubTest_ieeeAdd_qi, xout => rUdf_uid124_fpAddSubTest_ieeeAdd_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist31_excZ_bSig_uid26_uid46_fpAddSubTest_ieeeAdd_q_8(DELAY,314)\n" +
                        "    redist31_excZ_bSig_uid26_uid46_fpAddSubTest_ieeeAdd_q_8 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 2, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => redist30_excZ_bSig_uid26_uid46_fpAddSubTest_ieeeAdd_q_6_q, xout => redist31_excZ_bSig_uid26_uid46_fpAddSubTest_ieeeAdd_q_8_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist35_excZ_aSig_uid25_uid32_fpAddSubTest_ieeeAdd_q_2(DELAY,318)\n" +
                        "    redist35_excZ_aSig_uid25_uid32_fpAddSubTest_ieeeAdd_q_2 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 2, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => excZ_aSig_uid25_uid32_fpAddSubTest_ieeeAdd_q, xout => redist35_excZ_aSig_uid25_uid32_fpAddSubTest_ieeeAdd_q_2_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- excRZeroVInC_uid128_fpAddSubTest_ieeeAdd(BITJOIN,127)@9\n" +
                        "    excRZeroVInC_uid128_fpAddSubTest_ieeeAdd_q <= redist16_aMinusA_uid96_fpAddSubTest_ieeeAdd_q_2_q & rUdf_uid124_fpAddSubTest_ieeeAdd_q & redist12_regInputs_uid127_fpAddSubTest_ieeeAdd_q_2_q & redist31_excZ_bSig_uid26_uid46_fpAddSubTest_ieeeAdd_q_8_q & redist35_excZ_aSig_uid25_uid32_fpAddSubTest_ieeeAdd_q_2_q;\n" +
                        "\n" +
                        "    -- excRZero_uid129_fpAddSubTest_ieeeAdd(LOOKUP,128)@9\n" +
                        "    excRZero_uid129_fpAddSubTest_ieeeAdd_combproc: PROCESS (excRZeroVInC_uid128_fpAddSubTest_ieeeAdd_q)\n" +
                        "    BEGIN\n" +
                        "        -- Begin reserved scope level\n" +
                        "        CASE (excRZeroVInC_uid128_fpAddSubTest_ieeeAdd_q) IS\n" +
                        "            WHEN \"00000\" => excRZero_uid129_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"00001\" => excRZero_uid129_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"00010\" => excRZero_uid129_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"00011\" => excRZero_uid129_fpAddSubTest_ieeeAdd_q <= \"1\";\n" +
                        "            WHEN \"00100\" => excRZero_uid129_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"00101\" => excRZero_uid129_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"00110\" => excRZero_uid129_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"00111\" => excRZero_uid129_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"01000\" => excRZero_uid129_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"01001\" => excRZero_uid129_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"01010\" => excRZero_uid129_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"01011\" => excRZero_uid129_fpAddSubTest_ieeeAdd_q <= \"1\";\n" +
                        "            WHEN \"01100\" => excRZero_uid129_fpAddSubTest_ieeeAdd_q <= \"1\";\n" +
                        "            WHEN \"01101\" => excRZero_uid129_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"01110\" => excRZero_uid129_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"01111\" => excRZero_uid129_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"10000\" => excRZero_uid129_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"10001\" => excRZero_uid129_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"10010\" => excRZero_uid129_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"10011\" => excRZero_uid129_fpAddSubTest_ieeeAdd_q <= \"1\";\n" +
                        "            WHEN \"10100\" => excRZero_uid129_fpAddSubTest_ieeeAdd_q <= \"1\";\n" +
                        "            WHEN \"10101\" => excRZero_uid129_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"10110\" => excRZero_uid129_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"10111\" => excRZero_uid129_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"11000\" => excRZero_uid129_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"11001\" => excRZero_uid129_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"11010\" => excRZero_uid129_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"11011\" => excRZero_uid129_fpAddSubTest_ieeeAdd_q <= \"1\";\n" +
                        "            WHEN \"11100\" => excRZero_uid129_fpAddSubTest_ieeeAdd_q <= \"1\";\n" +
                        "            WHEN \"11101\" => excRZero_uid129_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"11110\" => excRZero_uid129_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN \"11111\" => excRZero_uid129_fpAddSubTest_ieeeAdd_q <= \"0\";\n" +
                        "            WHEN OTHERS => -- unreachable\n" +
                        "                           excRZero_uid129_fpAddSubTest_ieeeAdd_q <= (others => '-');\n" +
                        "        END CASE;\n" +
                        "        -- End reserved scope level\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- concExc_uid136_fpAddSubTest_ieeeAdd(BITJOIN,135)@9\n" +
                        "    concExc_uid136_fpAddSubTest_ieeeAdd_q <= excRNaN_uid135_fpAddSubTest_ieeeAdd_q & excRInf_uid132_fpAddSubTest_ieeeAdd_q & excRZero_uid129_fpAddSubTest_ieeeAdd_q;\n" +
                        "\n" +
                        "    -- excREnc_uid137_fpAddSubTest_ieeeAdd(LOOKUP,136)@9\n" +
                        "    excREnc_uid137_fpAddSubTest_ieeeAdd_combproc: PROCESS (concExc_uid136_fpAddSubTest_ieeeAdd_q)\n" +
                        "    BEGIN\n" +
                        "        -- Begin reserved scope level\n" +
                        "        CASE (concExc_uid136_fpAddSubTest_ieeeAdd_q) IS\n" +
                        "            WHEN \"000\" => excREnc_uid137_fpAddSubTest_ieeeAdd_q <= \"01\";\n" +
                        "            WHEN \"001\" => excREnc_uid137_fpAddSubTest_ieeeAdd_q <= \"00\";\n" +
                        "            WHEN \"010\" => excREnc_uid137_fpAddSubTest_ieeeAdd_q <= \"10\";\n" +
                        "            WHEN \"011\" => excREnc_uid137_fpAddSubTest_ieeeAdd_q <= \"10\";\n" +
                        "            WHEN \"100\" => excREnc_uid137_fpAddSubTest_ieeeAdd_q <= \"11\";\n" +
                        "            WHEN \"101\" => excREnc_uid137_fpAddSubTest_ieeeAdd_q <= \"11\";\n" +
                        "            WHEN \"110\" => excREnc_uid137_fpAddSubTest_ieeeAdd_q <= \"11\";\n" +
                        "            WHEN \"111\" => excREnc_uid137_fpAddSubTest_ieeeAdd_q <= \"11\";\n" +
                        "            WHEN OTHERS => -- unreachable\n" +
                        "                           excREnc_uid137_fpAddSubTest_ieeeAdd_q <= (others => '-');\n" +
                        "        END CASE;\n" +
                        "        -- End reserved scope level\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- expRPostExc_uid156_fpAddSubTest_ieeeAdd(MUX,155)@9\n" +
                        "    expRPostExc_uid156_fpAddSubTest_ieeeAdd_s <= excREnc_uid137_fpAddSubTest_ieeeAdd_q;\n" +
                        "    expRPostExc_uid156_fpAddSubTest_ieeeAdd_combproc: PROCESS (expRPostExc_uid156_fpAddSubTest_ieeeAdd_s, cstAllZWE_uid29_fpAddSubTest_ieeeAdd_q, redist13_expRPreExc_uid126_fpAddSubTest_ieeeAdd_b_1_q, cstAllOWE_uid27_fpAddSubTest_ieeeAdd_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (expRPostExc_uid156_fpAddSubTest_ieeeAdd_s) IS\n" +
                        "            WHEN \"00\" => expRPostExc_uid156_fpAddSubTest_ieeeAdd_q <= cstAllZWE_uid29_fpAddSubTest_ieeeAdd_q;\n" +
                        "            WHEN \"01\" => expRPostExc_uid156_fpAddSubTest_ieeeAdd_q <= redist13_expRPreExc_uid126_fpAddSubTest_ieeeAdd_b_1_q;\n" +
                        "            WHEN \"10\" => expRPostExc_uid156_fpAddSubTest_ieeeAdd_q <= cstAllOWE_uid27_fpAddSubTest_ieeeAdd_q;\n" +
                        "            WHEN \"11\" => expRPostExc_uid156_fpAddSubTest_ieeeAdd_q <= cstAllOWE_uid27_fpAddSubTest_ieeeAdd_q;\n" +
                        "            WHEN OTHERS => expRPostExc_uid156_fpAddSubTest_ieeeAdd_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- oneFracRPostExc2_uid149_fpAddSubTest_ieeeAdd(CONSTANT,148)\n" +
                        "    oneFracRPostExc2_uid149_fpAddSubTest_ieeeAdd_q <= \"0000000000000000000000000000000000000000000000000001\";\n" +
                        "\n" +
                        "    -- fracRPreExc_uid125_fpAddSubTest_ieeeAdd(BITSELECT,124)@8\n" +
                        "    fracRPreExc_uid125_fpAddSubTest_ieeeAdd_in <= rndExpFrac_uid113_fpAddSubTest_ieeeAdd_q(52 downto 0);\n" +
                        "    fracRPreExc_uid125_fpAddSubTest_ieeeAdd_b <= fracRPreExc_uid125_fpAddSubTest_ieeeAdd_in(52 downto 1);\n" +
                        "\n" +
                        "    -- redist14_fracRPreExc_uid125_fpAddSubTest_ieeeAdd_b_1(DELAY,297)\n" +
                        "    redist14_fracRPreExc_uid125_fpAddSubTest_ieeeAdd_b_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 52, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => fracRPreExc_uid125_fpAddSubTest_ieeeAdd_b, xout => redist14_fracRPreExc_uid125_fpAddSubTest_ieeeAdd_b_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- fracRPostExc_uid152_fpAddSubTest_ieeeAdd(MUX,151)@9\n" +
                        "    fracRPostExc_uid152_fpAddSubTest_ieeeAdd_s <= excREnc_uid137_fpAddSubTest_ieeeAdd_q;\n" +
                        "    fracRPostExc_uid152_fpAddSubTest_ieeeAdd_combproc: PROCESS (fracRPostExc_uid152_fpAddSubTest_ieeeAdd_s, cstZeroWF_uid28_fpAddSubTest_ieeeAdd_q, redist14_fracRPreExc_uid125_fpAddSubTest_ieeeAdd_b_1_q, oneFracRPostExc2_uid149_fpAddSubTest_ieeeAdd_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (fracRPostExc_uid152_fpAddSubTest_ieeeAdd_s) IS\n" +
                        "            WHEN \"00\" => fracRPostExc_uid152_fpAddSubTest_ieeeAdd_q <= cstZeroWF_uid28_fpAddSubTest_ieeeAdd_q;\n" +
                        "            WHEN \"01\" => fracRPostExc_uid152_fpAddSubTest_ieeeAdd_q <= redist14_fracRPreExc_uid125_fpAddSubTest_ieeeAdd_b_1_q;\n" +
                        "            WHEN \"10\" => fracRPostExc_uid152_fpAddSubTest_ieeeAdd_q <= cstZeroWF_uid28_fpAddSubTest_ieeeAdd_q;\n" +
                        "            WHEN \"11\" => fracRPostExc_uid152_fpAddSubTest_ieeeAdd_q <= oneFracRPostExc2_uid149_fpAddSubTest_ieeeAdd_q;\n" +
                        "            WHEN OTHERS => fracRPostExc_uid152_fpAddSubTest_ieeeAdd_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- R_uid157_fpAddSubTest_ieeeAdd(BITJOIN,156)@9\n" +
                        "    R_uid157_fpAddSubTest_ieeeAdd_q <= signRPostExc_uid148_fpAddSubTest_ieeeAdd_q & expRPostExc_uid156_fpAddSubTest_ieeeAdd_q & fracRPostExc_uid152_fpAddSubTest_ieeeAdd_q;\n" +
                        "\n" +
                        "    -- xOut(GPOUT,4)@9\n" +
                        "    q <= R_uid157_fpAddSubTest_ieeeAdd_q;\n" +
                        "\n" +
                        "END normal;";
        new GeneralFunctions().write_file(Project_Folder_File, data1, data2, data3);
    }
    
    private void generate_dspba_library_vhd_file(String Project_Folder_File) {
        String data =   "-- Legal Notice: Copyright 2017 Intel Corporation.  All rights reserved.\n" +
                        "-- Your use of  Intel  Corporation's design tools,  logic functions and other\n" +
                        "-- software and tools,  and its AMPP  partner logic functions, and  any output\n" +
                        "-- files  any of the  foregoing  device programming or simulation files),  and\n" +
                        "-- any associated  documentation or information are expressly subject  to  the\n" +
                        "-- terms and conditions  of the Intel FPGA Software License Agreement,\n" +
                        "-- Intel  MegaCore  Function  License  Agreement, or other applicable license\n" +
                        "-- agreement,  including,  without limitation,  that your use  is for the sole\n" +
                        "-- purpose of  programming  logic  devices  manufactured by Intel and sold by\n" +
                        "-- Intel or its authorized  distributors.  Please  refer  to  the  applicable\n" +
                        "-- agreement for further details.\n" +
                        "\n" +
                        "\n" +
                        "library IEEE;\n" +
                        "use IEEE.std_logic_1164.all;\n" +
                        "use work.dspba_library_package.all;\n" +
                        "\n" +
                        "entity dspba_delay is\n" +
                        "    generic (\n" +
                        "        width : natural := 8;\n" +
                        "        depth : natural := 1;\n" +
                        "        reset_high : std_logic := '1';\n" +
                        "        reset_kind : string := \"ASYNC\"\n" +
                        "    );\n" +
                        "    port (\n" +
                        "        clk   : in  std_logic;\n" +
                        "        aclr  : in  std_logic;\n" +
                        "        ena   : in  std_logic := '1';\n" +
                        "        xin   : in  std_logic_vector(width-1 downto 0);\n" +
                        "        xout  : out std_logic_vector(width-1 downto 0)\n" +
                        "    );\n" +
                        "end dspba_delay;\n" +
                        "\n" +
                        "architecture delay of dspba_delay is\n" +
                        "    type delay_array is array (depth downto 0) of std_logic_vector(width-1 downto 0);\n" +
                        "    signal delay_signals : delay_array;\n" +
                        "begin\n" +
                        "    delay_signals(depth) <= xin;\n" +
                        "\n" +
                        "    delay_block: if 0 < depth generate\n" +
                        "    begin\n" +
                        "        delay_loop: for i in depth-1 downto 0 generate\n" +
                        "        begin\n" +
                        "            async_reset: if reset_kind = \"ASYNC\" generate\n" +
                        "                process(clk, aclr)\n" +
                        "                begin\n" +
                        "                    if aclr=reset_high then\n" +
                        "                        delay_signals(i) <= (others => '0');\n" +
                        "                    elsif clk'event and clk='1' then\n" +
                        "                        if ena='1' then\n" +
                        "                            delay_signals(i) <= delay_signals(i + 1);\n" +
                        "                        end if;\n" +
                        "                    end if;\n" +
                        "                end process;\n" +
                        "            end generate;\n" +
                        "\n" +
                        "            sync_reset: if reset_kind = \"SYNC\" generate\n" +
                        "                process(clk)\n" +
                        "                begin\n" +
                        "                    if clk'event and clk='1' then\n" +
                        "                        if aclr=reset_high then\n" +
                        "                            delay_signals(i) <= (others => '0');\n" +
                        "                        elsif ena='1' then\n" +
                        "                            delay_signals(i) <= delay_signals(i + 1);\n" +
                        "                        end if;\n" +
                        "                    end if;\n" +
                        "                end process;\n" +
                        "            end generate;\n" +
                        "\n" +
                        "            no_reset: if reset_kind = \"NONE\" generate\n" +
                        "                process(clk)\n" +
                        "                begin\n" +
                        "                    if clk'event and clk='1' then\n" +
                        "                        if ena='1' then\n" +
                        "                            delay_signals(i) <= delay_signals(i + 1);\n" +
                        "                        end if;\n" +
                        "                    end if;\n" +
                        "                end process;\n" +
                        "            end generate;\n" +
                        "        end generate;\n" +
                        "    end generate;\n" +
                        "\n" +
                        "    xout <= delay_signals(0);\n" +
                        "end delay;\n" +
                        "\n" +
                        "--------------------------------------------------------------------------------\n" +
                        "\n" +
                        "library IEEE;\n" +
                        "use IEEE.std_logic_1164.all;\n" +
                        "use IEEE.NUMERIC_STD.all;\n" +
                        "use work.dspba_library_package.all;\n" +
                        "\n" +
                        "entity dspba_sync_reg is\n" +
                        "    generic (\n" +
                        "        width1 : natural := 8;\n" +
                        "        init_value : std_logic_vector;\n" +
                        "        width2 : natural := 8;\n" +
                        "        depth : natural := 2;\n" +
                        "        pulse_multiplier : natural := 1;\n" +
                        "        counter_width : natural := 8;\n" +
                        "        reset1_high : std_logic := '1';\n" +
                        "        reset2_high : std_logic := '1';\n" +
                        "        reset_kind : string := \"ASYNC\"\n" +
                        "    );\n" +
                        "    port (\n" +
                        "        clk1    : in std_logic;\n" +
                        "        aclr1   : in std_logic;\n" +
                        "        ena     : in std_logic_vector(0 downto 0);\n" +
                        "        xin     : in std_logic_vector(width1-1 downto 0);\n" +
                        "        xout    : out std_logic_vector(width1-1 downto 0);\n" +
                        "        clk2    : in std_logic;\n" +
                        "        aclr2   : in std_logic;\n" +
                        "        sxout   : out std_logic_vector(width2-1 downto 0)\n" +
                        "    );\n" +
                        "end entity;\n" +
                        "\n" +
                        "architecture sync_reg of dspba_sync_reg is\n" +
                        "    type bit_array is array (depth-1 downto 0) of std_logic;\n" +
                        "\n" +
                        "    signal iclk_enable : std_logic;\n" +
                        "    signal iclk_data : std_logic_vector(width1-1 downto 0);\n" +
                        "    signal oclk_data : std_logic_vector(width2-1 downto 0); \n" +
                        "\n" +
                        "    -- For Synthesis this means: preserve this registers and do not merge any other flip-flops with synchronizer flip-flops \n" +
                        "    -- For TimeQuest this means: identify these flip-flops as synchronizer to enable automatic MTBF analysis\n" +
                        "    signal sync_regs : bit_array;\n" +
                        "    attribute altera_attribute : string;\n" +
                        "    attribute altera_attribute of sync_regs : signal is \"-name ADV_NETLIST_OPT_ALLOWED NEVER_ALLOW; -name SYNCHRONIZER_IDENTIFICATION FORCED; -name DONT_MERGE_REGISTER ON; -name PRESERVE_REGISTER ON\";\n" +
                        "\n" +
                        "    signal oclk_enable : std_logic;\n" +
                        "\n" +
                        "    constant init_value_internal : std_logic_vector(width1-1 downto 0) := init_value;\n" +
                        "    \n" +
                        "    signal counter : UNSIGNED(counter_width-1 downto 0);\n" +
                        "    signal ena_internal : std_logic;\n" +
                        "begin\n" +
                        "    oclk_enable <= sync_regs(depth-1);  \n" +
                        "\n" +
                        "    no_multiplication: if pulse_multiplier=1 generate\n" +
                        "        ena_internal <= ena(0);\n" +
                        "    end generate;\n" +
                        "\n" +
                        "    async_reset: if reset_kind=\"ASYNC\" generate\n" +
                        "        \n" +
                        "        multiply_ena: if pulse_multiplier>1 generate\n" +
                        "            ena_internal <= '1' when counter>0 else ena(0);\n" +
                        "            process (clk1, aclr1)\n" +
                        "	        begin	\n" +
                        "                if aclr1=reset1_high then\n" +
                        "                    counter <= (others => '0');\n" +
                        "                elsif clk1'event and clk1='1' then\n" +
                        "                    if counter>0 then\n" +
                        "                        if counter=pulse_multiplier-1 then\n" +
                        "                            counter <= (others => '0');\n" +
                        "                        else \n" +
                        "                            counter <= counter + TO_UNSIGNED(1, counter_width);\n" +
                        "                        end if;\n" +
                        "                    else\n" +
                        "                        if ena(0)='1' then\n" +
                        "                            counter <= TO_UNSIGNED(1, counter_width);\n" +
                        "                        end if;\n" +
                        "                    end if;\n" +
                        "                end if;\n" +
                        "            end process;\n" +
                        "        end generate;\n" +
                        "        \n" +
                        "        process (clk1, aclr1)\n" +
                        "        begin\n" +
                        "            if aclr1=reset1_high then\n" +
                        "                iclk_enable <= '0';\n" +
                        "                iclk_data <= init_value_internal;\n" +
                        "            elsif clk1'event and clk1='1' then\n" +
                        "                iclk_enable <= ena_internal;\n" +
                        "                if ena(0)='1' then\n" +
                        "                    iclk_data <= xin;\n" +
                        "                end if;\n" +
                        "            end if;\n" +
                        "        end process;\n" +
                        "        \n" +
                        "        sync_reg_loop: for i in 0 to depth-1 generate\n" +
                        "            process (clk2, aclr2) \n" +
                        "            begin\n" +
                        "                if aclr2=reset2_high then\n" +
                        "                    sync_regs(i) <= '0';\n" +
                        "                elsif clk2'event and clk2='1' then\n" +
                        "                    if i>0 then\n" +
                        "                        sync_regs(i) <= sync_regs(i-1); \n" +
                        "                    else\n" +
                        "                        sync_regs(i) <= iclk_enable; \n" +
                        "                    end if;\n" +
                        "                end if;\n" +
                        "            end process;\n" +
                        "        end generate;\n" +
                        "    \n" +
                        "        process (clk2, aclr2)\n" +
                        "        begin\n" +
                        "            if aclr2=reset2_high then\n" +
                        "                oclk_data <= init_value_internal(width2-1 downto 0);\n" +
                        "            elsif clk2'event and clk2='1' then\n" +
                        "                if oclk_enable='1' then\n" +
                        "                    oclk_data <= iclk_data(width2-1 downto 0);\n" +
                        "                end if;\n" +
                        "            end if;\n" +
                        "        end process;\n" +
                        "    end generate;\n" +
                        "\n" +
                        "    sync_reset: if reset_kind=\"SYNC\" generate\n" +
                        "\n" +
                        "        multiply_ena: if pulse_multiplier>1 generate\n" +
                        "            ena_internal <= '1' when counter>0 else ena(0);\n" +
                        "            process (clk1)\n" +
                        "	        begin\n" +
                        "                if clk1'event and clk1='1' then\n" +
                        "                    if aclr1=reset1_high then\n" +
                        "                        counter <= (others => '0');\n" +
                        "                    else\n" +
                        "                        if counter>0 then\n" +
                        "                            if counter=pulse_multiplier-1 then\n" +
                        "                                counter <= (others => '0');\n" +
                        "                            else \n" +
                        "                                counter <= counter + TO_UNSIGNED(1, counter_width);\n" +
                        "                            end if;\n" +
                        "                        else\n" +
                        "                            if ena(0)='1' then\n" +
                        "                                counter <= TO_UNSIGNED(1, counter_width);\n" +
                        "                            end if;\n" +
                        "                        end if;\n" +
                        "                    end if;\n" +
                        "                end if;\n" +
                        "            end process;\n" +
                        "        end generate;\n" +
                        "\n" +
                        "        process (clk1)\n" +
                        "        begin\n" +
                        "            if clk1'event and clk1='1' then\n" +
                        "                if aclr1=reset1_high then\n" +
                        "                    iclk_enable <= '0';\n" +
                        "                    iclk_data <= init_value_internal;\n" +
                        "                else \n" +
                        "                    iclk_enable <= ena_internal;\n" +
                        "                    if ena(0)='1' then\n" +
                        "                        iclk_data <= xin;\n" +
                        "                    end if;\n" +
                        "                end if;\n" +
                        "            end if;\n" +
                        "        end process;\n" +
                        "        \n" +
                        "        sync_reg_loop: for i in 0 to depth-1 generate\n" +
                        "            process (clk2) \n" +
                        "            begin\n" +
                        "                if clk2'event and clk2='1' then\n" +
                        "                    if aclr2=reset2_high then\n" +
                        "                        sync_regs(i) <= '0';\n" +
                        "                    else \n" +
                        "                        if i>0 then\n" +
                        "                            sync_regs(i) <= sync_regs(i-1); \n" +
                        "                        else\n" +
                        "                            sync_regs(i) <= iclk_enable; \n" +
                        "                        end if;\n" +
                        "                    end if;\n" +
                        "                end if;\n" +
                        "            end process;\n" +
                        "        end generate;\n" +
                        "    \n" +
                        "        process (clk2)\n" +
                        "        begin\n" +
                        "            if clk2'event and clk2='1' then\n" +
                        "                if aclr2=reset2_high then\n" +
                        "                    oclk_data <= init_value_internal(width2-1 downto 0);\n" +
                        "                elsif oclk_enable='1' then\n" +
                        "                    oclk_data <= iclk_data(width2-1 downto 0);\n" +
                        "                end if;\n" +
                        "            end if;\n" +
                        "        end process;\n" +
                        "    end generate;\n" +
                        "\n" +
                        "    none_reset: if reset_kind=\"NONE\" generate\n" +
                        "        \n" +
                        "        multiply_ena: if pulse_multiplier>1 generate\n" +
                        "            ena_internal <= '1' when counter>0 else ena(0);\n" +
                        "            process (clk1, aclr1) \n" +
                        "	        begin\n" +
                        "                if clk1'event and clk1='1' then\n" +
                        "                    if counter>0 then\n" +
                        "                        if counter=pulse_multiplier-1 then\n" +
                        "                            counter <= (others => '0');\n" +
                        "                        else \n" +
                        "                            counter <= counter + TO_UNSIGNED(1, counter_width);\n" +
                        "                        end if;\n" +
                        "                    else\n" +
                        "                        if ena(0)='1' then\n" +
                        "                            counter <= TO_UNSIGNED(1, counter_width);\n" +
                        "                        end if;\n" +
                        "                    end if;\n" +
                        "                end if;\n" +
                        "            end process;\n" +
                        "        end generate;\n" +
                        "\n" +
                        "        process (clk1)\n" +
                        "        begin\n" +
                        "            if clk1'event and clk1='1' then\n" +
                        "                iclk_enable <= ena_internal;\n" +
                        "                if ena(0)='1' then\n" +
                        "                    iclk_data <= xin;\n" +
                        "                end if;\n" +
                        "            end if;\n" +
                        "        end process;\n" +
                        "        \n" +
                        "        sync_reg_loop: for i in 0 to depth-1 generate\n" +
                        "            process (clk2) \n" +
                        "            begin\n" +
                        "                if clk2'event and clk2='1' then\n" +
                        "                    if i>0 then\n" +
                        "                        sync_regs(i) <= sync_regs(i-1); \n" +
                        "                    else\n" +
                        "                        sync_regs(i) <= iclk_enable; \n" +
                        "                    end if;\n" +
                        "                end if;\n" +
                        "            end process;\n" +
                        "        end generate;\n" +
                        "    \n" +
                        "        process (clk2)\n" +
                        "        begin\n" +
                        "            if clk2'event and clk2='1' then\n" +
                        "                if oclk_enable='1' then\n" +
                        "                    oclk_data <= iclk_data(width2-1 downto 0);\n" +
                        "                end if;\n" +
                        "            end if;\n" +
                        "        end process;\n" +
                        "    end generate;\n" +
                        "\n" +
                        "    xout <= iclk_data;\n" +
                        "    sxout <= oclk_data;\n" +
                        "\n" +
                        "end sync_reg;\n" +
                        "\n" +
                        "--------------------------------------------------------------------------------\n" +
                        "\n" +
                        "library ieee;\n" +
                        "use ieee.std_logic_1164.all;\n" +
                        "use ieee.numeric_std.all;\n" +
                        "\n" +
                        "entity dspba_pipe is\n" +
                        "    generic(\n" +
                        "        num_bits   : positive  := 8;\n" +
                        "        num_stages : natural   := 0;\n" +
                        "        init_value : std_logic := 'X'\n" +
                        "    );\n" +
                        "    port(\n" +
                        "        clk: in    std_logic;\n" +
                        "        d  : in    std_logic_vector(num_bits-1 downto 0);\n" +
                        "        q  :   out std_logic_vector(num_bits-1 downto 0)\n" +
                        "    );\n" +
                        "end entity dspba_pipe;\n" +
                        "\n" +
                        "architecture rtl of dspba_pipe is\n" +
                        "    attribute altera_attribute : string;\n" +
                        "    attribute altera_attribute of rtl : architecture is \"-name AUTO_SHIFT_REGISTER_RECOGNITION off\";\n" +
                        "\n" +
                        "    type stage_array_type is array(0 to num_stages) of std_logic_vector(num_bits-1 downto 0);\n" +
                        "    signal stage_array : stage_array_type := (others => (others => init_value));\n" +
                        "begin\n" +
                        "    stage_array(0) <= d;\n" +
                        "\n" +
                        "    g_pipe : for i in 1 to num_stages generate\n" +
                        "        p_stage : process (clk) is\n" +
                        "        begin\n" +
                        "            if rising_edge(clk) then\n" +
                        "                stage_array(i) <= stage_array(i-1);\n" +
                        "            end if;\n" +
                        "        end process p_stage;\n" +
                        "    end generate g_pipe;\n" +
                        "\n" +
                        "    q <= stage_array(num_stages);\n" +
                        "\n" +
                        "end rtl;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_dspba_library_package_vhd_file(String Project_Folder_File) {
        String data =   "-- Legal Notice: Copyright 2017 Intel Corporation.  All rights reserved.\n" +
                        "-- Your use of  Intel  Corporation's design tools,  logic functions and other\n" +
                        "-- software and tools,  and its AMPP  partner logic functions, and  any output\n" +
                        "-- files  any of the  foregoing  device programming or simulation files),  and\n" +
                        "-- any associated  documentation or information are expressly subject  to  the\n" +
                        "-- terms and conditions  of the Intel FPGA Software License Agreement,\n" +
                        "-- Intel  MegaCore  Function  License  Agreement, or other applicable license\n" +
                        "-- agreement,  including,  without limitation,  that your use  is for the sole\n" +
                        "-- purpose of  programming  logic  devices  manufactured by Intel and sold by\n" +
                        "-- Intel or its authorized  distributors.  Please  refer  to  the  applicable\n" +
                        "-- agreement for further details.\n" +
                        "\n" +
                        "\n" +
                        "library IEEE;\n" +
                        "use IEEE.std_logic_1164.all;\n" +
                        "\n" +
                        "package dspba_library_package is\n" +
                        "\n" +
                        "    component dspba_delay is\n" +
                        "        generic (\n" +
                        "            width : natural := 8;\n" +
                        "            depth : natural := 1;\n" +
                        "            reset_high : std_logic := '1';\n" +
                        "            reset_kind : string := \"ASYNC\" \n" +
                        "        );\n" +
                        "        port (\n" +
                        "            clk   : in  std_logic;\n" +
                        "            aclr  : in  std_logic;\n" +
                        "            ena   : in  std_logic := '1';\n" +
                        "            xin   : in  std_logic_vector(width-1 downto 0);\n" +
                        "            xout  : out std_logic_vector(width-1 downto 0)\n" +
                        "        );\n" +
                        "    end component;\n" +
                        "\n" +
                        "    component dspba_sync_reg is\n" +
                        "        generic (\n" +
                        "            width1 : natural := 8;\n" +
                        "            width2 : natural := 8;\n" +
                        "            depth : natural := 2;\n" +
                        "            init_value : std_logic_vector;\n" +
                        "            pulse_multiplier : natural := 1;\n" +
                        "            counter_width : natural := 8;\n" +
                        "            reset1_high : std_logic := '1';\n" +
                        "            reset2_high : std_logic := '1';\n" +
                        "            reset_kind : string := \"ASYNC\"\n" +
                        "        );\n" +
                        "        port (\n" +
                        "            clk1    : in std_logic;\n" +
                        "            aclr1   : in std_logic;\n" +
                        "            ena     : in std_logic_vector(0 downto 0);\n" +
                        "            xin     : in std_logic_vector(width1-1 downto 0);\n" +
                        "            xout    : out std_logic_vector(width1-1 downto 0);\n" +
                        "            clk2    : in std_logic;\n" +
                        "            aclr2   : in std_logic;\n" +
                        "            sxout   : out std_logic_vector(width2-1 downto 0)\n" +
                        "        );\n" +
                        "    end component;\n" +
                        "\n" +
                        "    component dspba_pipe is\n" +
                        "        generic(\n" +
                        "            num_bits   : positive;\n" +
                        "            num_stages : natural;\n" +
                        "            init_value : std_logic := 'X'\n" +
                        "        );\n" +
                        "        port(\n" +
                        "            clk: in    std_logic;\n" +
                        "            d  : in    std_logic_vector(num_bits-1 downto 0);\n" +
                        "            q  :   out std_logic_vector(num_bits-1 downto 0)\n" +
                        "        );\n" +
                        "    end component dspba_pipe;\n" +
                        "\n" +
                        "end dspba_library_package;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_FP_EQ_64_qip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -entity \"FP_EQ_64\" -library \"FP_EQ_64\" -name IP_TOOL_NAME \"altera_fp_functions\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64\" -library \"FP_EQ_64\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64\" -library \"FP_EQ_64\" -name IP_TOOL_ENV \"mwpim\"\n" +
                        "set_global_assignment -library \"FP_EQ_64\" -name MISC_FILE [file join $::quartus(qip_path) \"FP_EQ_64.cmp\"]\n" +
                        "set_global_assignment -entity \"FP_EQ_64\" -library \"FP_EQ_64\" -name IP_TARGETED_DEVICE_FAMILY \"Cyclone V\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64\" -library \"FP_EQ_64\" -name IP_GENERATED_DEVICE_FAMILY \"{Cyclone V}\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64\" -library \"FP_EQ_64\" -name IP_QSYS_MODE \"UNKNOWN\"\n" +
                        "set_global_assignment -name SYNTHESIS_ONLY_QIP ON\n" +
                        "set_global_assignment -entity \"FP_EQ_64\" -library \"FP_EQ_64\" -name IP_COMPONENT_NAME \"RlBfRVFfNjQ=\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64\" -library \"FP_EQ_64\" -name IP_COMPONENT_DISPLAY_NAME \"QUxURVJBX0ZQX0ZVTkNUSU9OUw==\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64\" -library \"FP_EQ_64\" -name IP_COMPONENT_REPORT_HIERARCHY \"Off\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64\" -library \"FP_EQ_64\" -name IP_COMPONENT_INTERNAL \"Off\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64\" -library \"FP_EQ_64\" -name IP_COMPONENT_AUTHOR \"QWx0ZXJhIENvcnBvcmF0aW9u\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64\" -library \"FP_EQ_64\" -name IP_COMPONENT_VERSION \"MTguMA==\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64\" -library \"FP_EQ_64\" -name IP_COMPONENT_DESCRIPTION \"QSBjb2xsZWN0aW9uIG9mIGZsb2F0aW5nIHBvaW50IGZ1bmN0aW9ucw==\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_NAME \"RlBfRVFfNjRfMDAwMg==\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_DISPLAY_NAME \"QUxURVJBX0ZQX0ZVTkNUSU9OUw==\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_REPORT_HIERARCHY \"Off\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_INTERNAL \"Off\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_AUTHOR \"QWx0ZXJhIENvcnBvcmF0aW9u\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_VERSION \"MTguMA==\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_DESCRIPTION \"QSBjb2xsZWN0aW9uIG9mIGZsb2F0aW5nIHBvaW50IGZ1bmN0aW9ucw==\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"RlVOQ1RJT05fRkFNSUxZ::Q09NUEFSRQ==::RmFtaWx5\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"QVJJVEhfZnVuY3Rpb24=::QURE::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"Q09OVkVSVF9mdW5jdGlvbg==::RlhQX0ZQ::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"QUxMX2Z1bmN0aW9u::QURE::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"RVhQX0xPR19mdW5jdGlvbg==::RVhQRQ==::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"VFJJR19mdW5jdGlvbg==::U0lO::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"Q09NUEFSRV9mdW5jdGlvbg==::RVE=::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"Uk9PVFNfZnVuY3Rpb24=::U1FSVA==::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"ZGVyaXZlZGZ1bmN0aW9u::RVE=::ZGVyaXZlZGZ1bmN0aW9u\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"ZnBfZm9ybWF0::ZG91Ymxl::Rm9ybWF0\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"ZnBfZXhw::OA==::RXhwb25lbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"ZnBfZXhwX2Rlcml2ZWQ=::MTE=::ZnBfZXhwX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"ZnBfbWFu::MjM=::TWFudGlzc2E=\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"ZnBfbWFuX2Rlcml2ZWQ=::NTI=::ZnBfbWFuX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"ZXhwb25lbnRfd2lkdGg=::MjM=::RXhwb25lbnQgV2lkdGg=\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"ZnJlcXVlbmN5X3RhcmdldA==::OTI=::VGFyZ2V0\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"bGF0ZW5jeV90YXJnZXQ=::MA==::VGFyZ2V0\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"cGVyZm9ybWFuY2VfZ29hbA==::ZnJlcXVlbmN5::R29hbA==\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"cm91bmRpbmdfbW9kZQ==::bmVhcmVzdCB3aXRoIHRpZSBicmVha2luZyBhd2F5IGZyb20gemVybw==::TW9kZQ==\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"cm91bmRpbmdfbW9kZV9kZXJpdmVk::bmVhcmVzdCB3aXRoIHRpZSBicmVha2luZyBhd2F5IGZyb20gemVybw==::TW9kZQ==\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"dXNlX3JvdW5kaW5nX21vZGU=::ZmFsc2U=::dXNlX3JvdW5kaW5nX21vZGU=\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"ZmFpdGhmdWxfcm91bmRpbmc=::ZmFsc2U=::UmVsYXggcm91bmRpbmcgdG8gcm91bmQgdXAgb3IgZG93biB0byByZWR1Y2UgcmVzb3VyY2UgdXNhZ2U=\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"Z2VuX2VuYWJsZQ==::ZmFsc2U=::R2VuZXJhdGUgYW4gZW5hYmxlIHBvcnQ=\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"ZGl2aWRlX3R5cGU=::MA==::TWV0aG9k\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"c2VsZWN0X3NpZ25hbF9lbmFibGU=::ZmFsc2U=::VXNlIFNlbGVjdCBTaWduYWw=\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"c2NhbGVfYnlfcGk=::ZmFsc2U=::UmVwcmVzZW50IGFuZ2xlIGFzIG11bHRpcGxlIG9mIFBp\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"bnVtYmVyX29mX2lucHV0cw==::Mg==::SW5wdXQgVmVjdG9yIERpbWVuc2lvbg==\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"dHJpZ19ub19yYW5nZV9yZWR1Y3Rpb24=::ZmFsc2U=::SW5wdXRzIGFyZSB3aXRoaW4gcmFuZ2UgLTJwaSB0byArMnBp\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"cmVwb3J0X3Jlc291cmNlc190b194bWw=::ZmFsc2U=::cmVwb3J0X3Jlc291cmNlc190b194bWw=\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"ZnhwdF93aWR0aA==::MzI=::V2lkdGg=\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"ZnhwdF9mcmFjdGlvbg==::MA==::RnJhY3Rpb24=\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"ZnhwdF9zaWdu::MQ==::U2lnbg==\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"ZnJlcXVlbmN5X2ZlZWRiYWNr::MA==::ZnJlcXVlbmN5X2ZlZWRiYWNr\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"bGF0ZW5jeV9mZWVkYmFjaw==::MA==::bGF0ZW5jeV9mZWVkYmFjaw==\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"Zm9yY2VfZWxhYm9yYXRl::MA==::Zm9yY2VfZWxhYm9yYXRl\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X2Zvcm1hdA==::c2luZ2xl::T3V0cHV0IEZvcm1hdA==\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X2V4cA==::OA==::T3V0cHV0IEV4cG9uZW50\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X2V4cF9kZXJpdmVk::OA==::ZnBfb3V0X2V4cF9kZXJpdmVk\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X21hbg==::MjM=::T3V0cHV0IE1hbnRpc3Nh\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X21hbl9kZXJpdmVk::OA==::ZnBfb3V0X21hbl9kZXJpdmVk\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fZm9ybWF0::c2luZ2xl::SW5wdXQgRm9ybWF0\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fZXhw::OA==::SW5wdXQgRXhwb25lbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fZXhwX2Rlcml2ZWQ=::OA==::ZnBfaW5fZXhwX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fbWFu::MjM=::SW5wdXQgTWFudGlzc2E=\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fbWFuX2Rlcml2ZWQ=::OA==::ZnBfaW5fbWFuX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"ZW5hYmxlX2hhcmRfZnA=::dHJ1ZQ==::RW5hYmxlIEhhcmQgRmxvYXRpbmcgUG9pbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"bWFudWFsX2RzcF9wbGFubmluZw==::dHJ1ZQ==::RW5hYmxlIEhhcmQgRmxvYXRpbmcgUG9pbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"Zm9yY2VSZWdpc3RlcnM=::MTExMQ==::Zm9yY2VSZWdpc3RlcnM=\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"UkVTX0RTUF9wYXJhbQ==::MA==::TXVsdGlwbGllcw==\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"UkVTX0xVVF9wYXJhbQ==::NzI=::TFVUcw==\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"UkVTX01CSVRfcGFyYW0=::MA==::TWVtb3J5IEJpdHM=\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"UkVTX01CTE9DS19wYXJhbQ==::MA==::TWVtb3J5IEJsb2Nrcw==\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"c2VsZWN0ZWRfZGV2aWNlX2ZhbWlseQ==::Q3ljbG9uZSBW::c2VsZWN0ZWRfZGV2aWNlX2ZhbWlseQ==\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"c2VsZWN0ZWRfZGV2aWNlX3NwZWVkZ3JhZGU=::Nw==::c2VsZWN0ZWRfZGV2aWNlX3NwZWVkZ3JhZGU=\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_COMPONENT_PARAMETER \"dmFsaWRhdGlvbl9mYWlsZWQ=::ZmFsc2U=::dmFsaWRhdGlvbl9mYWlsZWQ=\"\n" +
                        "\n" +
                        "set_global_assignment -library \"FP_EQ_64\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_EQ_64.vhd\"]\n" +
                        "set_global_assignment -library \"FP_EQ_64\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_EQ_64/dspba_library_package.vhd\"]\n" +
                        "set_global_assignment -library \"FP_EQ_64\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_EQ_64/dspba_library.vhd\"]\n" +
                        "set_global_assignment -library \"FP_EQ_64\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_EQ_64/FP_EQ_64_0002.vhd\"]\n" +
                        "\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_TOOL_NAME \"altera_fp_functions\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64_0002\" -library \"FP_EQ_64\" -name IP_TOOL_ENV \"mwpim\"";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_FP_EQ_64_sip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -entity \"FP_EQ_64\" -library \"lib_FP_EQ_64\" -name IP_TOOL_NAME \"altera_fp_functions\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64\" -library \"lib_FP_EQ_64\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"FP_EQ_64\" -library \"lib_FP_EQ_64\" -name IP_TOOL_ENV \"mwpim\"\n" +
                        "set_global_assignment -library \"lib_FP_EQ_64\" -name SPD_FILE [file join $::quartus(sip_path) \"FP_EQ_64.spd\"]\n" +
                        "\n" +
                        "set_global_assignment -library \"lib_FP_EQ_64\" -name MISC_FILE [file join $::quartus(sip_path) \"FP_EQ_64_sim/dspba_library_package.vhd\"]\n" +
                        "set_global_assignment -library \"lib_FP_EQ_64\" -name MISC_FILE [file join $::quartus(sip_path) \"FP_EQ_64_sim/dspba_library.vhd\"]\n" +
                        "set_global_assignment -library \"lib_FP_EQ_64\" -name MISC_FILE [file join $::quartus(sip_path) \"FP_EQ_64_sim/FP_EQ_64.vhd\"]";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_FP_EQ_64_vhd_file(String Project_Folder_File) {
        String data =   "-- megafunction wizard: %ALTERA_FP_FUNCTIONS v18.0%\n" +
                        "-- GENERATION: XML\n" +
                        "-- FP_EQ_64.vhd\n" +
                        "\n" +
                        "-- Generated using ACDS version 18.0 614\n" +
                        "\n" +
                        "library IEEE;\n" +
                        "use IEEE.std_logic_1164.all;\n" +
                        "use IEEE.numeric_std.all;\n" +
                        "\n" +
                        "entity FP_EQ_64 is\n" +
                        "	port (\n" +
                        "		clk    : in  std_logic                     := '0';             --    clk.clk\n" +
                        "		areset : in  std_logic                     := '0';             -- areset.reset\n" +
                        "		a      : in  std_logic_vector(63 downto 0) := (others => '0'); --      a.a\n" +
                        "		b      : in  std_logic_vector(63 downto 0) := (others => '0'); --      b.b\n" +
                        "		q      : out std_logic_vector(0 downto 0)                      --      q.q\n" +
                        "	);\n" +
                        "end entity FP_EQ_64;\n" +
                        "\n" +
                        "architecture rtl of FP_EQ_64 is\n" +
                        "	component FP_EQ_64_0002 is\n" +
                        "		port (\n" +
                        "			clk    : in  std_logic                     := 'X';             -- clk\n" +
                        "			areset : in  std_logic                     := 'X';             -- reset\n" +
                        "			a      : in  std_logic_vector(63 downto 0) := (others => 'X'); -- a\n" +
                        "			b      : in  std_logic_vector(63 downto 0) := (others => 'X'); -- b\n" +
                        "			q      : out std_logic_vector(0 downto 0)                      -- q\n" +
                        "		);\n" +
                        "	end component FP_EQ_64_0002;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "	fp_eq_64_inst : component FP_EQ_64_0002\n" +
                        "		port map (\n" +
                        "			clk    => clk,    --    clk.clk\n" +
                        "			areset => areset, -- areset.reset\n" +
                        "			a      => a,      --      a.a\n" +
                        "			b      => b,      --      b.b\n" +
                        "			q      => q       --      q.q\n" +
                        "		);\n" +
                        "\n" +
                        "end architecture rtl; -- of FP_EQ_64\n" +
                        "-- Retrieval info: <?xml version=\"1.0\"?>\n" +
                        "--<!--\n" +
                        "--	Generated by Altera MegaWizard Launcher Utility version 1.0\n" +
                        "--	************************************************************\n" +
                        "--	THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!\n" +
                        "--	************************************************************\n" +
                        "--	Copyright (C) 1991-2020 Altera Corporation\n" +
                        "--	Any megafunction design, and related net list (encrypted or decrypted),\n" +
                        "--	support information, device programming or simulation file, and any other\n" +
                        "--	associated documentation or information provided by Altera or a partner\n" +
                        "--	under Altera's Megafunction Partnership Program may be used only to\n" +
                        "--	program PLD devices (but not masked PLD devices) from Altera.  Any other\n" +
                        "--	use of such megafunction design, net list, support information, device\n" +
                        "--	programming or simulation file, or any other related documentation or\n" +
                        "--	information is prohibited for any other purpose, including, but not\n" +
                        "--	limited to modification, reverse engineering, de-compiling, or use with\n" +
                        "--	any other silicon devices, unless such use is explicitly licensed under\n" +
                        "--	a separate agreement with Altera or a megafunction partner.  Title to\n" +
                        "--	the intellectual property, including patents, copyrights, trademarks,\n" +
                        "--	trade secrets, or maskworks, embodied in any such megafunction design,\n" +
                        "--	net list, support information, device programming or simulation file, or\n" +
                        "--	any other related documentation or information provided by Altera or a\n" +
                        "--	megafunction partner, remains with Altera, the megafunction partner, or\n" +
                        "--	their respective licensors.  No other licenses, including any licenses\n" +
                        "--	needed under any third party's intellectual property, are provided herein.\n" +
                        "---->\n" +
                        "-- Retrieval info: <instance entity-name=\"altera_fp_functions\" version=\"18.0\" >\n" +
                        "-- Retrieval info: 	<generic name=\"FUNCTION_FAMILY\" value=\"COMPARE\" />\n" +
                        "-- Retrieval info: 	<generic name=\"ARITH_function\" value=\"ADD\" />\n" +
                        "-- Retrieval info: 	<generic name=\"CONVERT_function\" value=\"FXP_FP\" />\n" +
                        "-- Retrieval info: 	<generic name=\"ALL_function\" value=\"ADD\" />\n" +
                        "-- Retrieval info: 	<generic name=\"EXP_LOG_function\" value=\"EXPE\" />\n" +
                        "-- Retrieval info: 	<generic name=\"TRIG_function\" value=\"SIN\" />\n" +
                        "-- Retrieval info: 	<generic name=\"COMPARE_function\" value=\"EQ\" />\n" +
                        "-- Retrieval info: 	<generic name=\"ROOTS_function\" value=\"SQRT\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_format\" value=\"double\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_exp\" value=\"8\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_man\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"exponent_width\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"frequency_target\" value=\"92\" />\n" +
                        "-- Retrieval info: 	<generic name=\"latency_target\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"performance_goal\" value=\"frequency\" />\n" +
                        "-- Retrieval info: 	<generic name=\"rounding_mode\" value=\"nearest with tie breaking away from zero\" />\n" +
                        "-- Retrieval info: 	<generic name=\"faithful_rounding\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gen_enable\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"divide_type\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"select_signal_enable\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"scale_by_pi\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"number_of_inputs\" value=\"2\" />\n" +
                        "-- Retrieval info: 	<generic name=\"trig_no_range_reduction\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"report_resources_to_xml\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fxpt_width\" value=\"32\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fxpt_fraction\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fxpt_sign\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_out_format\" value=\"single\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_out_exp\" value=\"8\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_out_man\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_in_format\" value=\"single\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_in_exp\" value=\"8\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_in_man\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"enable_hard_fp\" value=\"true\" />\n" +
                        "-- Retrieval info: 	<generic name=\"manual_dsp_planning\" value=\"true\" />\n" +
                        "-- Retrieval info: 	<generic name=\"forceRegisters\" value=\"1111\" />\n" +
                        "-- Retrieval info: 	<generic name=\"selected_device_family\" value=\"Cyclone V\" />\n" +
                        "-- Retrieval info: 	<generic name=\"selected_device_speedgrade\" value=\"7\" />\n" +
                        "-- Retrieval info: </instance>\n" +
                        "-- IPFS_FILES : FP_EQ_64.vho\n" +
                        "-- RELATED_FILES: FP_EQ_64.vhd, dspba_library_package.vhd, dspba_library.vhd, FP_EQ_64_0002.vhd";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_FP_EQ_64_0002_vhd_file(String Project_Folder_File) {
        String data =   "-- ------------------------------------------------------------------------- \n" +
                        "-- High Level Design Compiler for Intel(R) FPGAs Version 18.0 (Release Build #614)\n" +
                        "-- Quartus Prime development tool and MATLAB/Simulink Interface\n" +
                        "-- \n" +
                        "-- Legal Notice: Copyright 2018 Intel Corporation.  All rights reserved.\n" +
                        "-- Your use of  Intel Corporation's design tools,  logic functions and other\n" +
                        "-- software and  tools, and its AMPP partner logic functions, and any output\n" +
                        "-- files any  of the foregoing (including  device programming  or simulation\n" +
                        "-- files), and  any associated  documentation  or information  are expressly\n" +
                        "-- subject  to the terms and  conditions of the  Intel FPGA Software License\n" +
                        "-- Agreement, Intel MegaCore Function License Agreement, or other applicable\n" +
                        "-- license agreement,  including,  without limitation,  that your use is for\n" +
                        "-- the  sole  purpose of  programming  logic devices  manufactured by  Intel\n" +
                        "-- and  sold by Intel  or its authorized  distributors. Please refer  to the\n" +
                        "-- applicable agreement for further details.\n" +
                        "-- ---------------------------------------------------------------------------\n" +
                        "\n" +
                        "-- VHDL created from FP_EQ_64_0002\n" +
                        "-- VHDL created on Tue Jul 21 19:11:42 2020\n" +
                        "\n" +
                        "\n" +
                        "library IEEE;\n" +
                        "use IEEE.std_logic_1164.all;\n" +
                        "use IEEE.NUMERIC_STD.all;\n" +
                        "use IEEE.MATH_REAL.all;\n" +
                        "use std.TextIO.all;\n" +
                        "use work.dspba_library_package.all;\n" +
                        "\n" +
                        "LIBRARY altera_mf;\n" +
                        "USE altera_mf.altera_mf_components.all;\n" +
                        "LIBRARY altera_lnsim;\n" +
                        "USE altera_lnsim.altera_lnsim_components.altera_syncram;\n" +
                        "LIBRARY lpm;\n" +
                        "USE lpm.lpm_components.all;\n" +
                        "\n" +
                        "entity FP_EQ_64_0002 is\n" +
                        "    port (\n" +
                        "        a : in std_logic_vector(63 downto 0);  -- float64_m52\n" +
                        "        b : in std_logic_vector(63 downto 0);  -- float64_m52\n" +
                        "        q : out std_logic_vector(0 downto 0);  -- ufix1\n" +
                        "        clk : in std_logic;\n" +
                        "        areset : in std_logic\n" +
                        "    );\n" +
                        "end FP_EQ_64_0002;\n" +
                        "\n" +
                        "architecture normal of FP_EQ_64_0002 is\n" +
                        "\n" +
                        "    attribute altera_attribute : string;\n" +
                        "    attribute altera_attribute of normal : architecture is \"-name AUTO_SHIFT_REGISTER_RECOGNITION OFF; -name PHYSICAL_SYNTHESIS_REGISTER_DUPLICATION ON; -name MESSAGE_DISABLE 10036; -name MESSAGE_DISABLE 10037; -name MESSAGE_DISABLE 14130; -name MESSAGE_DISABLE 14320; -name MESSAGE_DISABLE 15400; -name MESSAGE_DISABLE 14130; -name MESSAGE_DISABLE 10036; -name MESSAGE_DISABLE 12020; -name MESSAGE_DISABLE 12030; -name MESSAGE_DISABLE 12010; -name MESSAGE_DISABLE 12110; -name MESSAGE_DISABLE 14320; -name MESSAGE_DISABLE 13410; -name MESSAGE_DISABLE 113007\";\n" +
                        "    \n" +
                        "    signal GND_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal VCC_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal cstAllOWE_uid6_fpCompareTest_q : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal cstZeroWF_uid7_fpCompareTest_q : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal cstAllZWE_uid8_fpCompareTest_q : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal excZ_x_uid11_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expXIsMax_uid12_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsZero_uid13_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsNotZero_uid14_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excN_x_uid16_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excZ_y_uid25_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expXIsMax_uid26_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsZero_uid27_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsNotZero_uid28_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excN_y_uid30_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal oneIsNaN_uid34_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal bothZero_uid54_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rCmp_uid57_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal r_uid58_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rPostExc_uid59_fpCompareTest_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rPostExc_uid59_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal exp_x_uid9_fpCompareTest_merged_bit_select_b : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal exp_x_uid9_fpCompareTest_merged_bit_select_c : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal exp_y_uid23_fpCompareTest_merged_bit_select_b : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal exp_y_uid23_fpCompareTest_merged_bit_select_c : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "\n" +
                        "    -- GND(CONSTANT,0)\n" +
                        "    GND_q <= \"0\";\n" +
                        "\n" +
                        "    -- cstAllZWE_uid8_fpCompareTest(CONSTANT,7)\n" +
                        "    cstAllZWE_uid8_fpCompareTest_q <= \"00000000000\";\n" +
                        "\n" +
                        "    -- exp_y_uid23_fpCompareTest_merged_bit_select(BITSELECT,61)@0\n" +
                        "    exp_y_uid23_fpCompareTest_merged_bit_select_b <= STD_LOGIC_VECTOR(b(62 downto 52));\n" +
                        "    exp_y_uid23_fpCompareTest_merged_bit_select_c <= STD_LOGIC_VECTOR(b(51 downto 0));\n" +
                        "\n" +
                        "    -- excZ_y_uid25_fpCompareTest(LOGICAL,24)@0\n" +
                        "    excZ_y_uid25_fpCompareTest_q <= \"1\" WHEN exp_y_uid23_fpCompareTest_merged_bit_select_b = cstAllZWE_uid8_fpCompareTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- exp_x_uid9_fpCompareTest_merged_bit_select(BITSELECT,60)@0\n" +
                        "    exp_x_uid9_fpCompareTest_merged_bit_select_b <= STD_LOGIC_VECTOR(a(62 downto 52));\n" +
                        "    exp_x_uid9_fpCompareTest_merged_bit_select_c <= STD_LOGIC_VECTOR(a(51 downto 0));\n" +
                        "\n" +
                        "    -- excZ_x_uid11_fpCompareTest(LOGICAL,10)@0\n" +
                        "    excZ_x_uid11_fpCompareTest_q <= \"1\" WHEN exp_x_uid9_fpCompareTest_merged_bit_select_b = cstAllZWE_uid8_fpCompareTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- bothZero_uid54_fpCompareTest(LOGICAL,53)@0\n" +
                        "    bothZero_uid54_fpCompareTest_q <= excZ_x_uid11_fpCompareTest_q and excZ_y_uid25_fpCompareTest_q;\n" +
                        "\n" +
                        "    -- rCmp_uid57_fpCompareTest(LOGICAL,56)@0\n" +
                        "    rCmp_uid57_fpCompareTest_q <= \"1\" WHEN a = b ELSE \"0\";\n" +
                        "\n" +
                        "    -- r_uid58_fpCompareTest(LOGICAL,57)@0\n" +
                        "    r_uid58_fpCompareTest_q <= rCmp_uid57_fpCompareTest_q or bothZero_uid54_fpCompareTest_q;\n" +
                        "\n" +
                        "    -- cstZeroWF_uid7_fpCompareTest(CONSTANT,6)\n" +
                        "    cstZeroWF_uid7_fpCompareTest_q <= \"0000000000000000000000000000000000000000000000000000\";\n" +
                        "\n" +
                        "    -- fracXIsZero_uid27_fpCompareTest(LOGICAL,26)@0\n" +
                        "    fracXIsZero_uid27_fpCompareTest_q <= \"1\" WHEN cstZeroWF_uid7_fpCompareTest_q = exp_y_uid23_fpCompareTest_merged_bit_select_c ELSE \"0\";\n" +
                        "\n" +
                        "    -- fracXIsNotZero_uid28_fpCompareTest(LOGICAL,27)@0\n" +
                        "    fracXIsNotZero_uid28_fpCompareTest_q <= not (fracXIsZero_uid27_fpCompareTest_q);\n" +
                        "\n" +
                        "    -- cstAllOWE_uid6_fpCompareTest(CONSTANT,5)\n" +
                        "    cstAllOWE_uid6_fpCompareTest_q <= \"11111111111\";\n" +
                        "\n" +
                        "    -- expXIsMax_uid26_fpCompareTest(LOGICAL,25)@0\n" +
                        "    expXIsMax_uid26_fpCompareTest_q <= \"1\" WHEN exp_y_uid23_fpCompareTest_merged_bit_select_b = cstAllOWE_uid6_fpCompareTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- excN_y_uid30_fpCompareTest(LOGICAL,29)@0\n" +
                        "    excN_y_uid30_fpCompareTest_q <= expXIsMax_uid26_fpCompareTest_q and fracXIsNotZero_uid28_fpCompareTest_q;\n" +
                        "\n" +
                        "    -- fracXIsZero_uid13_fpCompareTest(LOGICAL,12)@0\n" +
                        "    fracXIsZero_uid13_fpCompareTest_q <= \"1\" WHEN cstZeroWF_uid7_fpCompareTest_q = exp_x_uid9_fpCompareTest_merged_bit_select_c ELSE \"0\";\n" +
                        "\n" +
                        "    -- fracXIsNotZero_uid14_fpCompareTest(LOGICAL,13)@0\n" +
                        "    fracXIsNotZero_uid14_fpCompareTest_q <= not (fracXIsZero_uid13_fpCompareTest_q);\n" +
                        "\n" +
                        "    -- expXIsMax_uid12_fpCompareTest(LOGICAL,11)@0\n" +
                        "    expXIsMax_uid12_fpCompareTest_q <= \"1\" WHEN exp_x_uid9_fpCompareTest_merged_bit_select_b = cstAllOWE_uid6_fpCompareTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- excN_x_uid16_fpCompareTest(LOGICAL,15)@0\n" +
                        "    excN_x_uid16_fpCompareTest_q <= expXIsMax_uid12_fpCompareTest_q and fracXIsNotZero_uid14_fpCompareTest_q;\n" +
                        "\n" +
                        "    -- oneIsNaN_uid34_fpCompareTest(LOGICAL,33)@0\n" +
                        "    oneIsNaN_uid34_fpCompareTest_q <= excN_x_uid16_fpCompareTest_q or excN_y_uid30_fpCompareTest_q;\n" +
                        "\n" +
                        "    -- VCC(CONSTANT,1)\n" +
                        "    VCC_q <= \"1\";\n" +
                        "\n" +
                        "    -- rPostExc_uid59_fpCompareTest(MUX,58)@0\n" +
                        "    rPostExc_uid59_fpCompareTest_s <= oneIsNaN_uid34_fpCompareTest_q;\n" +
                        "    rPostExc_uid59_fpCompareTest_combproc: PROCESS (rPostExc_uid59_fpCompareTest_s, r_uid58_fpCompareTest_q, GND_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (rPostExc_uid59_fpCompareTest_s) IS\n" +
                        "            WHEN \"0\" => rPostExc_uid59_fpCompareTest_q <= r_uid58_fpCompareTest_q;\n" +
                        "            WHEN \"1\" => rPostExc_uid59_fpCompareTest_q <= GND_q;\n" +
                        "            WHEN OTHERS => rPostExc_uid59_fpCompareTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- xOut(GPOUT,4)@0\n" +
                        "    q <= rPostExc_uid59_fpCompareTest_q;\n" +
                        "\n" +
                        "END normal;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_FP_LE_64_qip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -entity \"FP_LE_64\" -library \"FP_LE_64\" -name IP_TOOL_NAME \"altera_fp_functions\"\n" +
                        "set_global_assignment -entity \"FP_LE_64\" -library \"FP_LE_64\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"FP_LE_64\" -library \"FP_LE_64\" -name IP_TOOL_ENV \"mwpim\"\n" +
                        "set_global_assignment -library \"FP_LE_64\" -name MISC_FILE [file join $::quartus(qip_path) \"FP_LE_64.cmp\"]\n" +
                        "set_global_assignment -entity \"FP_LE_64\" -library \"FP_LE_64\" -name IP_TARGETED_DEVICE_FAMILY \"Cyclone V\"\n" +
                        "set_global_assignment -entity \"FP_LE_64\" -library \"FP_LE_64\" -name IP_GENERATED_DEVICE_FAMILY \"{Cyclone V}\"\n" +
                        "set_global_assignment -entity \"FP_LE_64\" -library \"FP_LE_64\" -name IP_QSYS_MODE \"UNKNOWN\"\n" +
                        "set_global_assignment -name SYNTHESIS_ONLY_QIP ON\n" +
                        "set_global_assignment -entity \"FP_LE_64\" -library \"FP_LE_64\" -name IP_COMPONENT_NAME \"RlBfTEVfNjQ=\"\n" +
                        "set_global_assignment -entity \"FP_LE_64\" -library \"FP_LE_64\" -name IP_COMPONENT_DISPLAY_NAME \"QUxURVJBX0ZQX0ZVTkNUSU9OUw==\"\n" +
                        "set_global_assignment -entity \"FP_LE_64\" -library \"FP_LE_64\" -name IP_COMPONENT_REPORT_HIERARCHY \"Off\"\n" +
                        "set_global_assignment -entity \"FP_LE_64\" -library \"FP_LE_64\" -name IP_COMPONENT_INTERNAL \"Off\"\n" +
                        "set_global_assignment -entity \"FP_LE_64\" -library \"FP_LE_64\" -name IP_COMPONENT_AUTHOR \"QWx0ZXJhIENvcnBvcmF0aW9u\"\n" +
                        "set_global_assignment -entity \"FP_LE_64\" -library \"FP_LE_64\" -name IP_COMPONENT_VERSION \"MTguMA==\"\n" +
                        "set_global_assignment -entity \"FP_LE_64\" -library \"FP_LE_64\" -name IP_COMPONENT_DESCRIPTION \"QSBjb2xsZWN0aW9uIG9mIGZsb2F0aW5nIHBvaW50IGZ1bmN0aW9ucw==\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_NAME \"RlBfTEVfNjRfMDAwMg==\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_DISPLAY_NAME \"QUxURVJBX0ZQX0ZVTkNUSU9OUw==\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_REPORT_HIERARCHY \"Off\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_INTERNAL \"Off\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_AUTHOR \"QWx0ZXJhIENvcnBvcmF0aW9u\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_VERSION \"MTguMA==\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_DESCRIPTION \"QSBjb2xsZWN0aW9uIG9mIGZsb2F0aW5nIHBvaW50IGZ1bmN0aW9ucw==\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"RlVOQ1RJT05fRkFNSUxZ::Q09NUEFSRQ==::RmFtaWx5\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"QVJJVEhfZnVuY3Rpb24=::QURE::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"Q09OVkVSVF9mdW5jdGlvbg==::RlhQX0ZQ::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"QUxMX2Z1bmN0aW9u::QURE::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"RVhQX0xPR19mdW5jdGlvbg==::RVhQRQ==::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"VFJJR19mdW5jdGlvbg==::U0lO::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"Q09NUEFSRV9mdW5jdGlvbg==::TEU=::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"Uk9PVFNfZnVuY3Rpb24=::U1FSVA==::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"ZGVyaXZlZGZ1bmN0aW9u::TEU=::ZGVyaXZlZGZ1bmN0aW9u\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"ZnBfZm9ybWF0::ZG91Ymxl::Rm9ybWF0\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"ZnBfZXhw::OA==::RXhwb25lbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"ZnBfZXhwX2Rlcml2ZWQ=::MTE=::ZnBfZXhwX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"ZnBfbWFu::MjM=::TWFudGlzc2E=\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"ZnBfbWFuX2Rlcml2ZWQ=::NTI=::ZnBfbWFuX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"ZXhwb25lbnRfd2lkdGg=::MjM=::RXhwb25lbnQgV2lkdGg=\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"ZnJlcXVlbmN5X3RhcmdldA==::NzU=::VGFyZ2V0\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"bGF0ZW5jeV90YXJnZXQ=::MQ==::VGFyZ2V0\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"cGVyZm9ybWFuY2VfZ29hbA==::ZnJlcXVlbmN5::R29hbA==\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"cm91bmRpbmdfbW9kZQ==::bmVhcmVzdCB3aXRoIHRpZSBicmVha2luZyBhd2F5IGZyb20gemVybw==::TW9kZQ==\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"cm91bmRpbmdfbW9kZV9kZXJpdmVk::bmVhcmVzdCB3aXRoIHRpZSBicmVha2luZyB0byBldmVu::TW9kZQ==\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"dXNlX3JvdW5kaW5nX21vZGU=::ZmFsc2U=::dXNlX3JvdW5kaW5nX21vZGU=\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"ZmFpdGhmdWxfcm91bmRpbmc=::ZmFsc2U=::UmVsYXggcm91bmRpbmcgdG8gcm91bmQgdXAgb3IgZG93biB0byByZWR1Y2UgcmVzb3VyY2UgdXNhZ2U=\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"Z2VuX2VuYWJsZQ==::ZmFsc2U=::R2VuZXJhdGUgYW4gZW5hYmxlIHBvcnQ=\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"ZGl2aWRlX3R5cGU=::MA==::TWV0aG9k\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"c2VsZWN0X3NpZ25hbF9lbmFibGU=::ZmFsc2U=::VXNlIFNlbGVjdCBTaWduYWw=\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"c2NhbGVfYnlfcGk=::ZmFsc2U=::UmVwcmVzZW50IGFuZ2xlIGFzIG11bHRpcGxlIG9mIFBp\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"bnVtYmVyX29mX2lucHV0cw==::Mg==::SW5wdXQgVmVjdG9yIERpbWVuc2lvbg==\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"dHJpZ19ub19yYW5nZV9yZWR1Y3Rpb24=::ZmFsc2U=::SW5wdXRzIGFyZSB3aXRoaW4gcmFuZ2UgLTJwaSB0byArMnBp\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"cmVwb3J0X3Jlc291cmNlc190b194bWw=::ZmFsc2U=::cmVwb3J0X3Jlc291cmNlc190b194bWw=\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"ZnhwdF93aWR0aA==::MzI=::V2lkdGg=\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"ZnhwdF9mcmFjdGlvbg==::MA==::RnJhY3Rpb24=\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"ZnhwdF9zaWdu::MQ==::U2lnbg==\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"ZnJlcXVlbmN5X2ZlZWRiYWNr::MTEy::ZnJlcXVlbmN5X2ZlZWRiYWNr\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"bGF0ZW5jeV9mZWVkYmFjaw==::MQ==::bGF0ZW5jeV9mZWVkYmFjaw==\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"Zm9yY2VfZWxhYm9yYXRl::MQ==::Zm9yY2VfZWxhYm9yYXRl\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X2Zvcm1hdA==::c2luZ2xl::T3V0cHV0IEZvcm1hdA==\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X2V4cA==::OA==::T3V0cHV0IEV4cG9uZW50\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X2V4cF9kZXJpdmVk::OA==::ZnBfb3V0X2V4cF9kZXJpdmVk\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X21hbg==::MjM=::T3V0cHV0IE1hbnRpc3Nh\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X21hbl9kZXJpdmVk::OA==::ZnBfb3V0X21hbl9kZXJpdmVk\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fZm9ybWF0::c2luZ2xl::SW5wdXQgRm9ybWF0\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fZXhw::OA==::SW5wdXQgRXhwb25lbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fZXhwX2Rlcml2ZWQ=::OA==::ZnBfaW5fZXhwX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fbWFu::MjM=::SW5wdXQgTWFudGlzc2E=\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fbWFuX2Rlcml2ZWQ=::OA==::ZnBfaW5fbWFuX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"ZW5hYmxlX2hhcmRfZnA=::dHJ1ZQ==::RW5hYmxlIEhhcmQgRmxvYXRpbmcgUG9pbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"bWFudWFsX2RzcF9wbGFubmluZw==::dHJ1ZQ==::RW5hYmxlIEhhcmQgRmxvYXRpbmcgUG9pbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"Zm9yY2VSZWdpc3RlcnM=::MTExMQ==::Zm9yY2VSZWdpc3RlcnM=\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"UkVTX0RTUF9wYXJhbQ==::MA==::TXVsdGlwbGllcw==\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"UkVTX0xVVF9wYXJhbQ==::MjIy::TFVUcw==\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"UkVTX01CSVRfcGFyYW0=::MA==::TWVtb3J5IEJpdHM=\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"UkVTX01CTE9DS19wYXJhbQ==::MA==::TWVtb3J5IEJsb2Nrcw==\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"c2VsZWN0ZWRfZGV2aWNlX2ZhbWlseQ==::Q3ljbG9uZSBW::c2VsZWN0ZWRfZGV2aWNlX2ZhbWlseQ==\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"c2VsZWN0ZWRfZGV2aWNlX3NwZWVkZ3JhZGU=::Nw==::c2VsZWN0ZWRfZGV2aWNlX3NwZWVkZ3JhZGU=\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_COMPONENT_PARAMETER \"dmFsaWRhdGlvbl9mYWlsZWQ=::ZmFsc2U=::dmFsaWRhdGlvbl9mYWlsZWQ=\"\n" +
                        "\n" +
                        "set_global_assignment -library \"FP_LE_64\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_LE_64.vhd\"]\n" +
                        "set_global_assignment -library \"FP_LE_64\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_LE_64/dspba_library_package.vhd\"]\n" +
                        "set_global_assignment -library \"FP_LE_64\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_LE_64/dspba_library.vhd\"]\n" +
                        "set_global_assignment -library \"FP_LE_64\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_LE_64/FP_LE_64_0002.vhd\"]\n" +
                        "\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_TOOL_NAME \"altera_fp_functions\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"FP_LE_64_0002\" -library \"FP_LE_64\" -name IP_TOOL_ENV \"mwpim\"";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_FP_LE_64_sip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -entity \"FP_LE_64\" -library \"lib_FP_LE_64\" -name IP_TOOL_NAME \"altera_fp_functions\"\n" +
                        "set_global_assignment -entity \"FP_LE_64\" -library \"lib_FP_LE_64\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"FP_LE_64\" -library \"lib_FP_LE_64\" -name IP_TOOL_ENV \"mwpim\"\n" +
                        "set_global_assignment -library \"lib_FP_LE_64\" -name SPD_FILE [file join $::quartus(sip_path) \"FP_LE_64.spd\"]\n" +
                        "\n" +
                        "set_global_assignment -library \"lib_FP_LE_64\" -name MISC_FILE [file join $::quartus(sip_path) \"FP_LE_64_sim/dspba_library_package.vhd\"]\n" +
                        "set_global_assignment -library \"lib_FP_LE_64\" -name MISC_FILE [file join $::quartus(sip_path) \"FP_LE_64_sim/dspba_library.vhd\"]\n" +
                        "set_global_assignment -library \"lib_FP_LE_64\" -name MISC_FILE [file join $::quartus(sip_path) \"FP_LE_64_sim/FP_LE_64.vhd\"]";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_FP_LE_64_vhd_file(String Project_Folder_File) {
        String data =   "-- megafunction wizard: %ALTERA_FP_FUNCTIONS v18.0%\n" +
                        "-- GENERATION: XML\n" +
                        "-- FP_LE_64.vhd\n" +
                        "\n" +
                        "-- Generated using ACDS version 18.0 614\n" +
                        "\n" +
                        "library IEEE;\n" +
                        "use IEEE.std_logic_1164.all;\n" +
                        "use IEEE.numeric_std.all;\n" +
                        "\n" +
                        "entity FP_LE_64 is\n" +
                        "	port (\n" +
                        "		clk    : in  std_logic                     := '0';             --    clk.clk\n" +
                        "		areset : in  std_logic                     := '0';             -- areset.reset\n" +
                        "		a      : in  std_logic_vector(63 downto 0) := (others => '0'); --      a.a\n" +
                        "		b      : in  std_logic_vector(63 downto 0) := (others => '0'); --      b.b\n" +
                        "		q      : out std_logic_vector(0 downto 0)                      --      q.q\n" +
                        "	);\n" +
                        "end entity FP_LE_64;\n" +
                        "\n" +
                        "architecture rtl of FP_LE_64 is\n" +
                        "	component FP_LE_64_0002 is\n" +
                        "		port (\n" +
                        "			clk    : in  std_logic                     := 'X';             -- clk\n" +
                        "			areset : in  std_logic                     := 'X';             -- reset\n" +
                        "			a      : in  std_logic_vector(63 downto 0) := (others => 'X'); -- a\n" +
                        "			b      : in  std_logic_vector(63 downto 0) := (others => 'X'); -- b\n" +
                        "			q      : out std_logic_vector(0 downto 0)                      -- q\n" +
                        "		);\n" +
                        "	end component FP_LE_64_0002;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "	fp_le_64_inst : component FP_LE_64_0002\n" +
                        "		port map (\n" +
                        "			clk    => clk,    --    clk.clk\n" +
                        "			areset => areset, -- areset.reset\n" +
                        "			a      => a,      --      a.a\n" +
                        "			b      => b,      --      b.b\n" +
                        "			q      => q       --      q.q\n" +
                        "		);\n" +
                        "\n" +
                        "end architecture rtl; -- of FP_LE_64\n" +
                        "-- Retrieval info: <?xml version=\"1.0\"?>\n" +
                        "--<!--\n" +
                        "--	Generated by Altera MegaWizard Launcher Utility version 1.0\n" +
                        "--	************************************************************\n" +
                        "--	THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!\n" +
                        "--	************************************************************\n" +
                        "--	Copyright (C) 1991-2020 Altera Corporation\n" +
                        "--	Any megafunction design, and related net list (encrypted or decrypted),\n" +
                        "--	support information, device programming or simulation file, and any other\n" +
                        "--	associated documentation or information provided by Altera or a partner\n" +
                        "--	under Altera's Megafunction Partnership Program may be used only to\n" +
                        "--	program PLD devices (but not masked PLD devices) from Altera.  Any other\n" +
                        "--	use of such megafunction design, net list, support information, device\n" +
                        "--	programming or simulation file, or any other related documentation or\n" +
                        "--	information is prohibited for any other purpose, including, but not\n" +
                        "--	limited to modification, reverse engineering, de-compiling, or use with\n" +
                        "--	any other silicon devices, unless such use is explicitly licensed under\n" +
                        "--	a separate agreement with Altera or a megafunction partner.  Title to\n" +
                        "--	the intellectual property, including patents, copyrights, trademarks,\n" +
                        "--	trade secrets, or maskworks, embodied in any such megafunction design,\n" +
                        "--	net list, support information, device programming or simulation file, or\n" +
                        "--	any other related documentation or information provided by Altera or a\n" +
                        "--	megafunction partner, remains with Altera, the megafunction partner, or\n" +
                        "--	their respective licensors.  No other licenses, including any licenses\n" +
                        "--	needed under any third party's intellectual property, are provided herein.\n" +
                        "---->\n" +
                        "-- Retrieval info: <instance entity-name=\"altera_fp_functions\" version=\"18.0\" >\n" +
                        "-- Retrieval info: 	<generic name=\"FUNCTION_FAMILY\" value=\"COMPARE\" />\n" +
                        "-- Retrieval info: 	<generic name=\"ARITH_function\" value=\"ADD\" />\n" +
                        "-- Retrieval info: 	<generic name=\"CONVERT_function\" value=\"FXP_FP\" />\n" +
                        "-- Retrieval info: 	<generic name=\"ALL_function\" value=\"ADD\" />\n" +
                        "-- Retrieval info: 	<generic name=\"EXP_LOG_function\" value=\"EXPE\" />\n" +
                        "-- Retrieval info: 	<generic name=\"TRIG_function\" value=\"SIN\" />\n" +
                        "-- Retrieval info: 	<generic name=\"COMPARE_function\" value=\"LE\" />\n" +
                        "-- Retrieval info: 	<generic name=\"ROOTS_function\" value=\"SQRT\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_format\" value=\"double\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_exp\" value=\"8\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_man\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"exponent_width\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"frequency_target\" value=\"75\" />\n" +
                        "-- Retrieval info: 	<generic name=\"latency_target\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"performance_goal\" value=\"frequency\" />\n" +
                        "-- Retrieval info: 	<generic name=\"rounding_mode\" value=\"nearest with tie breaking away from zero\" />\n" +
                        "-- Retrieval info: 	<generic name=\"faithful_rounding\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gen_enable\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"divide_type\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"select_signal_enable\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"scale_by_pi\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"number_of_inputs\" value=\"2\" />\n" +
                        "-- Retrieval info: 	<generic name=\"trig_no_range_reduction\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"report_resources_to_xml\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fxpt_width\" value=\"32\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fxpt_fraction\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fxpt_sign\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_out_format\" value=\"single\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_out_exp\" value=\"8\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_out_man\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_in_format\" value=\"single\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_in_exp\" value=\"8\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_in_man\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"enable_hard_fp\" value=\"true\" />\n" +
                        "-- Retrieval info: 	<generic name=\"manual_dsp_planning\" value=\"true\" />\n" +
                        "-- Retrieval info: 	<generic name=\"forceRegisters\" value=\"1111\" />\n" +
                        "-- Retrieval info: 	<generic name=\"selected_device_family\" value=\"Cyclone V\" />\n" +
                        "-- Retrieval info: 	<generic name=\"selected_device_speedgrade\" value=\"7\" />\n" +
                        "-- Retrieval info: </instance>\n" +
                        "-- IPFS_FILES : FP_LE_64.vho\n" +
                        "-- RELATED_FILES: FP_LE_64.vhd, dspba_library_package.vhd, dspba_library.vhd, FP_LE_64_0002.vhd";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_FP_LE_64_0002_vhd_file(String Project_Folder_File) {
        String data =   "-- ------------------------------------------------------------------------- \n" +
                        "-- High Level Design Compiler for Intel(R) FPGAs Version 18.0 (Release Build #614)\n" +
                        "-- Quartus Prime development tool and MATLAB/Simulink Interface\n" +
                        "-- \n" +
                        "-- Legal Notice: Copyright 2018 Intel Corporation.  All rights reserved.\n" +
                        "-- Your use of  Intel Corporation's design tools,  logic functions and other\n" +
                        "-- software and  tools, and its AMPP partner logic functions, and any output\n" +
                        "-- files any  of the foregoing (including  device programming  or simulation\n" +
                        "-- files), and  any associated  documentation  or information  are expressly\n" +
                        "-- subject  to the terms and  conditions of the  Intel FPGA Software License\n" +
                        "-- Agreement, Intel MegaCore Function License Agreement, or other applicable\n" +
                        "-- license agreement,  including,  without limitation,  that your use is for\n" +
                        "-- the  sole  purpose of  programming  logic devices  manufactured by  Intel\n" +
                        "-- and  sold by Intel  or its authorized  distributors. Please refer  to the\n" +
                        "-- applicable agreement for further details.\n" +
                        "-- ---------------------------------------------------------------------------\n" +
                        "\n" +
                        "-- VHDL created from FP_LE_64_0002\n" +
                        "-- VHDL created on Sun Jun 21 03:56:53 2020\n" +
                        "\n" +
                        "\n" +
                        "library IEEE;\n" +
                        "use IEEE.std_logic_1164.all;\n" +
                        "use IEEE.NUMERIC_STD.all;\n" +
                        "use IEEE.MATH_REAL.all;\n" +
                        "use std.TextIO.all;\n" +
                        "use work.dspba_library_package.all;\n" +
                        "\n" +
                        "LIBRARY altera_mf;\n" +
                        "USE altera_mf.altera_mf_components.all;\n" +
                        "LIBRARY altera_lnsim;\n" +
                        "USE altera_lnsim.altera_lnsim_components.altera_syncram;\n" +
                        "LIBRARY lpm;\n" +
                        "USE lpm.lpm_components.all;\n" +
                        "\n" +
                        "entity FP_LE_64_0002 is\n" +
                        "    port (\n" +
                        "        a : in std_logic_vector(63 downto 0);  -- float64_m52\n" +
                        "        b : in std_logic_vector(63 downto 0);  -- float64_m52\n" +
                        "        q : out std_logic_vector(0 downto 0);  -- ufix1\n" +
                        "        clk : in std_logic;\n" +
                        "        areset : in std_logic\n" +
                        "    );\n" +
                        "end FP_LE_64_0002;\n" +
                        "\n" +
                        "architecture normal of FP_LE_64_0002 is\n" +
                        "\n" +
                        "    attribute altera_attribute : string;\n" +
                        "    attribute altera_attribute of normal : architecture is \"-name AUTO_SHIFT_REGISTER_RECOGNITION OFF; -name PHYSICAL_SYNTHESIS_REGISTER_DUPLICATION ON; -name MESSAGE_DISABLE 10036; -name MESSAGE_DISABLE 10037; -name MESSAGE_DISABLE 14130; -name MESSAGE_DISABLE 14320; -name MESSAGE_DISABLE 15400; -name MESSAGE_DISABLE 14130; -name MESSAGE_DISABLE 10036; -name MESSAGE_DISABLE 12020; -name MESSAGE_DISABLE 12030; -name MESSAGE_DISABLE 12010; -name MESSAGE_DISABLE 12110; -name MESSAGE_DISABLE 14320; -name MESSAGE_DISABLE 13410; -name MESSAGE_DISABLE 113007\";\n" +
                        "    \n" +
                        "    signal GND_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal VCC_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal cstAllOWE_uid6_fpCompareTest_q : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal cstZeroWF_uid7_fpCompareTest_q : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal cstAllZWE_uid8_fpCompareTest_q : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal exp_x_uid9_fpCompareTest_b : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal frac_x_uid10_fpCompareTest_b : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal excZ_x_uid11_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expXIsMax_uid12_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsZero_uid13_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsNotZero_uid14_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excN_x_uid16_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal exp_y_uid23_fpCompareTest_b : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal frac_y_uid24_fpCompareTest_b : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal excZ_y_uid25_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expXIsMax_uid26_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsZero_uid27_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsNotZero_uid28_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excN_y_uid30_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal oneIsNaN_uid34_fpCompareTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal oneIsNaN_uid34_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal xNotZero_uid39_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal yNotZero_uid40_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXPS_uid41_fpCompareTest_b : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal fracXPS_uid41_fpCompareTest_q : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal fracYPS_uid42_fpCompareTest_b : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal fracYPS_uid42_fpCompareTest_q : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal expFracX_uid43_fpCompareTest_q : STD_LOGIC_VECTOR (62 downto 0);\n" +
                        "    signal expFracY_uid45_fpCompareTest_q : STD_LOGIC_VECTOR (62 downto 0);\n" +
                        "    signal efxGTEefy_uid49_fpCompareTest_a : STD_LOGIC_VECTOR (64 downto 0);\n" +
                        "    signal efxGTEefy_uid49_fpCompareTest_b : STD_LOGIC_VECTOR (64 downto 0);\n" +
                        "    signal efxGTEefy_uid49_fpCompareTest_o : STD_LOGIC_VECTOR (64 downto 0);\n" +
                        "    signal efxGTEefy_uid49_fpCompareTest_n : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal efxLTEefy_uid50_fpCompareTest_a : STD_LOGIC_VECTOR (64 downto 0);\n" +
                        "    signal efxLTEefy_uid50_fpCompareTest_b : STD_LOGIC_VECTOR (64 downto 0);\n" +
                        "    signal efxLTEefy_uid50_fpCompareTest_o : STD_LOGIC_VECTOR (64 downto 0);\n" +
                        "    signal efxLTEefy_uid50_fpCompareTest_n : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal zeroInputs_uid51_fpCompareTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal zeroInputs_uid51_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal signX_uid52_fpCompareTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal signY_uid53_fpCompareTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal two_uid54_fpCompareTest_q : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal concSXSY_uid55_fpCompareTest_q : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal sxLTsy_uid56_fpCompareTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal sxLTsy_uid56_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal xorSigns_uid57_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal sxEQsy_uid58_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expFracCompMux_uid59_fpCompareTest_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expFracCompMux_uid59_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal sxEQsyExpFracCompMux_uid60_fpCompareTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal sxEQsyExpFracCompMux_uid60_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal r_uid61_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rPostExc_uid62_fpCompareTest_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rPostExc_uid62_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "\n" +
                        "    -- GND(CONSTANT,0)\n" +
                        "    GND_q <= \"0\";\n" +
                        "\n" +
                        "    -- cstAllZWE_uid8_fpCompareTest(CONSTANT,7)\n" +
                        "    cstAllZWE_uid8_fpCompareTest_q <= \"00000000000\";\n" +
                        "\n" +
                        "    -- exp_y_uid23_fpCompareTest(BITSELECT,22)@0\n" +
                        "    exp_y_uid23_fpCompareTest_b <= b(62 downto 52);\n" +
                        "\n" +
                        "    -- excZ_y_uid25_fpCompareTest(LOGICAL,24)@0\n" +
                        "    excZ_y_uid25_fpCompareTest_q <= \"1\" WHEN exp_y_uid23_fpCompareTest_b = cstAllZWE_uid8_fpCompareTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- exp_x_uid9_fpCompareTest(BITSELECT,8)@0\n" +
                        "    exp_x_uid9_fpCompareTest_b <= a(62 downto 52);\n" +
                        "\n" +
                        "    -- excZ_x_uid11_fpCompareTest(LOGICAL,10)@0\n" +
                        "    excZ_x_uid11_fpCompareTest_q <= \"1\" WHEN exp_x_uid9_fpCompareTest_b = cstAllZWE_uid8_fpCompareTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- zeroInputs_uid51_fpCompareTest(LOGICAL,50)@0 + 1\n" +
                        "    zeroInputs_uid51_fpCompareTest_qi <= excZ_x_uid11_fpCompareTest_q and excZ_y_uid25_fpCompareTest_q;\n" +
                        "    zeroInputs_uid51_fpCompareTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => zeroInputs_uid51_fpCompareTest_qi, xout => zeroInputs_uid51_fpCompareTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- two_uid54_fpCompareTest(CONSTANT,53)\n" +
                        "    two_uid54_fpCompareTest_q <= \"10\";\n" +
                        "\n" +
                        "    -- signX_uid52_fpCompareTest(BITSELECT,51)@0\n" +
                        "    signX_uid52_fpCompareTest_b <= STD_LOGIC_VECTOR(a(63 downto 63));\n" +
                        "\n" +
                        "    -- signY_uid53_fpCompareTest(BITSELECT,52)@0\n" +
                        "    signY_uid53_fpCompareTest_b <= STD_LOGIC_VECTOR(b(63 downto 63));\n" +
                        "\n" +
                        "    -- concSXSY_uid55_fpCompareTest(BITJOIN,54)@0\n" +
                        "    concSXSY_uid55_fpCompareTest_q <= signX_uid52_fpCompareTest_b & signY_uid53_fpCompareTest_b;\n" +
                        "\n" +
                        "    -- sxLTsy_uid56_fpCompareTest(LOGICAL,55)@0 + 1\n" +
                        "    sxLTsy_uid56_fpCompareTest_qi <= \"1\" WHEN concSXSY_uid55_fpCompareTest_q = two_uid54_fpCompareTest_q ELSE \"0\";\n" +
                        "    sxLTsy_uid56_fpCompareTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => sxLTsy_uid56_fpCompareTest_qi, xout => sxLTsy_uid56_fpCompareTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- yNotZero_uid40_fpCompareTest(LOGICAL,39)@0\n" +
                        "    yNotZero_uid40_fpCompareTest_q <= not (excZ_y_uid25_fpCompareTest_q);\n" +
                        "\n" +
                        "    -- frac_y_uid24_fpCompareTest(BITSELECT,23)@0\n" +
                        "    frac_y_uid24_fpCompareTest_b <= b(51 downto 0);\n" +
                        "\n" +
                        "    -- fracYPS_uid42_fpCompareTest(LOGICAL,41)@0\n" +
                        "    fracYPS_uid42_fpCompareTest_b <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR((51 downto 1 => yNotZero_uid40_fpCompareTest_q(0)) & yNotZero_uid40_fpCompareTest_q));\n" +
                        "    fracYPS_uid42_fpCompareTest_q <= frac_y_uid24_fpCompareTest_b and fracYPS_uid42_fpCompareTest_b;\n" +
                        "\n" +
                        "    -- expFracY_uid45_fpCompareTest(BITJOIN,44)@0\n" +
                        "    expFracY_uid45_fpCompareTest_q <= exp_y_uid23_fpCompareTest_b & fracYPS_uid42_fpCompareTest_q;\n" +
                        "\n" +
                        "    -- xNotZero_uid39_fpCompareTest(LOGICAL,38)@0\n" +
                        "    xNotZero_uid39_fpCompareTest_q <= not (excZ_x_uid11_fpCompareTest_q);\n" +
                        "\n" +
                        "    -- frac_x_uid10_fpCompareTest(BITSELECT,9)@0\n" +
                        "    frac_x_uid10_fpCompareTest_b <= a(51 downto 0);\n" +
                        "\n" +
                        "    -- fracXPS_uid41_fpCompareTest(LOGICAL,40)@0\n" +
                        "    fracXPS_uid41_fpCompareTest_b <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR((51 downto 1 => xNotZero_uid39_fpCompareTest_q(0)) & xNotZero_uid39_fpCompareTest_q));\n" +
                        "    fracXPS_uid41_fpCompareTest_q <= frac_x_uid10_fpCompareTest_b and fracXPS_uid41_fpCompareTest_b;\n" +
                        "\n" +
                        "    -- expFracX_uid43_fpCompareTest(BITJOIN,42)@0\n" +
                        "    expFracX_uid43_fpCompareTest_q <= exp_x_uid9_fpCompareTest_b & fracXPS_uid41_fpCompareTest_q;\n" +
                        "\n" +
                        "    -- efxGTEefy_uid49_fpCompareTest(COMPARE,48)@0\n" +
                        "    efxGTEefy_uid49_fpCompareTest_a <= STD_LOGIC_VECTOR(\"00\" & expFracX_uid43_fpCompareTest_q);\n" +
                        "    efxGTEefy_uid49_fpCompareTest_b <= STD_LOGIC_VECTOR(\"00\" & expFracY_uid45_fpCompareTest_q);\n" +
                        "    efxGTEefy_uid49_fpCompareTest_o <= STD_LOGIC_VECTOR(UNSIGNED(efxGTEefy_uid49_fpCompareTest_a) - UNSIGNED(efxGTEefy_uid49_fpCompareTest_b));\n" +
                        "    efxGTEefy_uid49_fpCompareTest_n(0) <= not (efxGTEefy_uid49_fpCompareTest_o(64));\n" +
                        "\n" +
                        "    -- efxLTEefy_uid50_fpCompareTest(COMPARE,49)@0\n" +
                        "    efxLTEefy_uid50_fpCompareTest_a <= STD_LOGIC_VECTOR(\"00\" & expFracY_uid45_fpCompareTest_q);\n" +
                        "    efxLTEefy_uid50_fpCompareTest_b <= STD_LOGIC_VECTOR(\"00\" & expFracX_uid43_fpCompareTest_q);\n" +
                        "    efxLTEefy_uid50_fpCompareTest_o <= STD_LOGIC_VECTOR(UNSIGNED(efxLTEefy_uid50_fpCompareTest_a) - UNSIGNED(efxLTEefy_uid50_fpCompareTest_b));\n" +
                        "    efxLTEefy_uid50_fpCompareTest_n(0) <= not (efxLTEefy_uid50_fpCompareTest_o(64));\n" +
                        "\n" +
                        "    -- expFracCompMux_uid59_fpCompareTest(MUX,58)@0\n" +
                        "    expFracCompMux_uid59_fpCompareTest_s <= signX_uid52_fpCompareTest_b;\n" +
                        "    expFracCompMux_uid59_fpCompareTest_combproc: PROCESS (expFracCompMux_uid59_fpCompareTest_s, efxLTEefy_uid50_fpCompareTest_n, efxGTEefy_uid49_fpCompareTest_n)\n" +
                        "    BEGIN\n" +
                        "        CASE (expFracCompMux_uid59_fpCompareTest_s) IS\n" +
                        "            WHEN \"0\" => expFracCompMux_uid59_fpCompareTest_q <= efxLTEefy_uid50_fpCompareTest_n;\n" +
                        "            WHEN \"1\" => expFracCompMux_uid59_fpCompareTest_q <= efxGTEefy_uid49_fpCompareTest_n;\n" +
                        "            WHEN OTHERS => expFracCompMux_uid59_fpCompareTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- xorSigns_uid57_fpCompareTest(LOGICAL,56)@0\n" +
                        "    xorSigns_uid57_fpCompareTest_q <= signX_uid52_fpCompareTest_b xor signY_uid53_fpCompareTest_b;\n" +
                        "\n" +
                        "    -- sxEQsy_uid58_fpCompareTest(LOGICAL,57)@0\n" +
                        "    sxEQsy_uid58_fpCompareTest_q <= not (xorSigns_uid57_fpCompareTest_q);\n" +
                        "\n" +
                        "    -- sxEQsyExpFracCompMux_uid60_fpCompareTest(LOGICAL,59)@0 + 1\n" +
                        "    sxEQsyExpFracCompMux_uid60_fpCompareTest_qi <= sxEQsy_uid58_fpCompareTest_q and expFracCompMux_uid59_fpCompareTest_q;\n" +
                        "    sxEQsyExpFracCompMux_uid60_fpCompareTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => sxEQsyExpFracCompMux_uid60_fpCompareTest_qi, xout => sxEQsyExpFracCompMux_uid60_fpCompareTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- r_uid61_fpCompareTest(LOGICAL,60)@1\n" +
                        "    r_uid61_fpCompareTest_q <= sxEQsyExpFracCompMux_uid60_fpCompareTest_q or sxLTsy_uid56_fpCompareTest_q or zeroInputs_uid51_fpCompareTest_q;\n" +
                        "\n" +
                        "    -- cstZeroWF_uid7_fpCompareTest(CONSTANT,6)\n" +
                        "    cstZeroWF_uid7_fpCompareTest_q <= \"0000000000000000000000000000000000000000000000000000\";\n" +
                        "\n" +
                        "    -- fracXIsZero_uid27_fpCompareTest(LOGICAL,26)@0\n" +
                        "    fracXIsZero_uid27_fpCompareTest_q <= \"1\" WHEN cstZeroWF_uid7_fpCompareTest_q = frac_y_uid24_fpCompareTest_b ELSE \"0\";\n" +
                        "\n" +
                        "    -- fracXIsNotZero_uid28_fpCompareTest(LOGICAL,27)@0\n" +
                        "    fracXIsNotZero_uid28_fpCompareTest_q <= not (fracXIsZero_uid27_fpCompareTest_q);\n" +
                        "\n" +
                        "    -- cstAllOWE_uid6_fpCompareTest(CONSTANT,5)\n" +
                        "    cstAllOWE_uid6_fpCompareTest_q <= \"11111111111\";\n" +
                        "\n" +
                        "    -- expXIsMax_uid26_fpCompareTest(LOGICAL,25)@0\n" +
                        "    expXIsMax_uid26_fpCompareTest_q <= \"1\" WHEN exp_y_uid23_fpCompareTest_b = cstAllOWE_uid6_fpCompareTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- excN_y_uid30_fpCompareTest(LOGICAL,29)@0\n" +
                        "    excN_y_uid30_fpCompareTest_q <= expXIsMax_uid26_fpCompareTest_q and fracXIsNotZero_uid28_fpCompareTest_q;\n" +
                        "\n" +
                        "    -- fracXIsZero_uid13_fpCompareTest(LOGICAL,12)@0\n" +
                        "    fracXIsZero_uid13_fpCompareTest_q <= \"1\" WHEN cstZeroWF_uid7_fpCompareTest_q = frac_x_uid10_fpCompareTest_b ELSE \"0\";\n" +
                        "\n" +
                        "    -- fracXIsNotZero_uid14_fpCompareTest(LOGICAL,13)@0\n" +
                        "    fracXIsNotZero_uid14_fpCompareTest_q <= not (fracXIsZero_uid13_fpCompareTest_q);\n" +
                        "\n" +
                        "    -- expXIsMax_uid12_fpCompareTest(LOGICAL,11)@0\n" +
                        "    expXIsMax_uid12_fpCompareTest_q <= \"1\" WHEN exp_x_uid9_fpCompareTest_b = cstAllOWE_uid6_fpCompareTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- excN_x_uid16_fpCompareTest(LOGICAL,15)@0\n" +
                        "    excN_x_uid16_fpCompareTest_q <= expXIsMax_uid12_fpCompareTest_q and fracXIsNotZero_uid14_fpCompareTest_q;\n" +
                        "\n" +
                        "    -- oneIsNaN_uid34_fpCompareTest(LOGICAL,33)@0 + 1\n" +
                        "    oneIsNaN_uid34_fpCompareTest_qi <= excN_x_uid16_fpCompareTest_q or excN_y_uid30_fpCompareTest_q;\n" +
                        "    oneIsNaN_uid34_fpCompareTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => oneIsNaN_uid34_fpCompareTest_qi, xout => oneIsNaN_uid34_fpCompareTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- VCC(CONSTANT,1)\n" +
                        "    VCC_q <= \"1\";\n" +
                        "\n" +
                        "    -- rPostExc_uid62_fpCompareTest(MUX,61)@1\n" +
                        "    rPostExc_uid62_fpCompareTest_s <= oneIsNaN_uid34_fpCompareTest_q;\n" +
                        "    rPostExc_uid62_fpCompareTest_combproc: PROCESS (rPostExc_uid62_fpCompareTest_s, r_uid61_fpCompareTest_q, GND_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (rPostExc_uid62_fpCompareTest_s) IS\n" +
                        "            WHEN \"0\" => rPostExc_uid62_fpCompareTest_q <= r_uid61_fpCompareTest_q;\n" +
                        "            WHEN \"1\" => rPostExc_uid62_fpCompareTest_q <= GND_q;\n" +
                        "            WHEN OTHERS => rPostExc_uid62_fpCompareTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- xOut(GPOUT,4)@1\n" +
                        "    q <= rPostExc_uid62_fpCompareTest_q;\n" +
                        "\n" +
                        "END normal;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_FP_LT_64_qip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -entity \"FP_LT_64\" -library \"FP_LT_64\" -name IP_TOOL_NAME \"altera_fp_functions\"\n" +
                        "set_global_assignment -entity \"FP_LT_64\" -library \"FP_LT_64\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"FP_LT_64\" -library \"FP_LT_64\" -name IP_TOOL_ENV \"mwpim\"\n" +
                        "set_global_assignment -library \"FP_LT_64\" -name MISC_FILE [file join $::quartus(qip_path) \"FP_LT_64.cmp\"]\n" +
                        "set_global_assignment -entity \"FP_LT_64\" -library \"FP_LT_64\" -name IP_TARGETED_DEVICE_FAMILY \"Cyclone V\"\n" +
                        "set_global_assignment -entity \"FP_LT_64\" -library \"FP_LT_64\" -name IP_GENERATED_DEVICE_FAMILY \"{Cyclone V}\"\n" +
                        "set_global_assignment -entity \"FP_LT_64\" -library \"FP_LT_64\" -name IP_QSYS_MODE \"UNKNOWN\"\n" +
                        "set_global_assignment -name SYNTHESIS_ONLY_QIP ON\n" +
                        "set_global_assignment -entity \"FP_LT_64\" -library \"FP_LT_64\" -name IP_COMPONENT_NAME \"RlBfTFRfNjQ=\"\n" +
                        "set_global_assignment -entity \"FP_LT_64\" -library \"FP_LT_64\" -name IP_COMPONENT_DISPLAY_NAME \"QUxURVJBX0ZQX0ZVTkNUSU9OUw==\"\n" +
                        "set_global_assignment -entity \"FP_LT_64\" -library \"FP_LT_64\" -name IP_COMPONENT_REPORT_HIERARCHY \"Off\"\n" +
                        "set_global_assignment -entity \"FP_LT_64\" -library \"FP_LT_64\" -name IP_COMPONENT_INTERNAL \"Off\"\n" +
                        "set_global_assignment -entity \"FP_LT_64\" -library \"FP_LT_64\" -name IP_COMPONENT_AUTHOR \"QWx0ZXJhIENvcnBvcmF0aW9u\"\n" +
                        "set_global_assignment -entity \"FP_LT_64\" -library \"FP_LT_64\" -name IP_COMPONENT_VERSION \"MTguMA==\"\n" +
                        "set_global_assignment -entity \"FP_LT_64\" -library \"FP_LT_64\" -name IP_COMPONENT_DESCRIPTION \"QSBjb2xsZWN0aW9uIG9mIGZsb2F0aW5nIHBvaW50IGZ1bmN0aW9ucw==\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_NAME \"RlBfTFRfNjRfMDAwMg==\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_DISPLAY_NAME \"QUxURVJBX0ZQX0ZVTkNUSU9OUw==\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_REPORT_HIERARCHY \"Off\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_INTERNAL \"Off\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_AUTHOR \"QWx0ZXJhIENvcnBvcmF0aW9u\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_VERSION \"MTguMA==\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_DESCRIPTION \"QSBjb2xsZWN0aW9uIG9mIGZsb2F0aW5nIHBvaW50IGZ1bmN0aW9ucw==\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"RlVOQ1RJT05fRkFNSUxZ::Q09NUEFSRQ==::RmFtaWx5\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"QVJJVEhfZnVuY3Rpb24=::QURE::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"Q09OVkVSVF9mdW5jdGlvbg==::RlhQX0ZQ::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"QUxMX2Z1bmN0aW9u::QURE::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"RVhQX0xPR19mdW5jdGlvbg==::RVhQRQ==::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"VFJJR19mdW5jdGlvbg==::U0lO::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"Q09NUEFSRV9mdW5jdGlvbg==::TFQ=::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"Uk9PVFNfZnVuY3Rpb24=::U1FSVA==::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"ZGVyaXZlZGZ1bmN0aW9u::TFQ=::ZGVyaXZlZGZ1bmN0aW9u\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"ZnBfZm9ybWF0::ZG91Ymxl::Rm9ybWF0\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"ZnBfZXhw::OA==::RXhwb25lbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"ZnBfZXhwX2Rlcml2ZWQ=::MTE=::ZnBfZXhwX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"ZnBfbWFu::MjM=::TWFudGlzc2E=\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"ZnBfbWFuX2Rlcml2ZWQ=::NTI=::ZnBfbWFuX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"ZXhwb25lbnRfd2lkdGg=::MjM=::RXhwb25lbnQgV2lkdGg=\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"ZnJlcXVlbmN5X3RhcmdldA==::NzU=::VGFyZ2V0\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"bGF0ZW5jeV90YXJnZXQ=::MQ==::VGFyZ2V0\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"cGVyZm9ybWFuY2VfZ29hbA==::ZnJlcXVlbmN5::R29hbA==\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"cm91bmRpbmdfbW9kZQ==::bmVhcmVzdCB3aXRoIHRpZSBicmVha2luZyBhd2F5IGZyb20gemVybw==::TW9kZQ==\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"cm91bmRpbmdfbW9kZV9kZXJpdmVk::bmVhcmVzdCB3aXRoIHRpZSBicmVha2luZyB0byBldmVu::TW9kZQ==\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"dXNlX3JvdW5kaW5nX21vZGU=::ZmFsc2U=::dXNlX3JvdW5kaW5nX21vZGU=\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"ZmFpdGhmdWxfcm91bmRpbmc=::ZmFsc2U=::UmVsYXggcm91bmRpbmcgdG8gcm91bmQgdXAgb3IgZG93biB0byByZWR1Y2UgcmVzb3VyY2UgdXNhZ2U=\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"Z2VuX2VuYWJsZQ==::ZmFsc2U=::R2VuZXJhdGUgYW4gZW5hYmxlIHBvcnQ=\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"ZGl2aWRlX3R5cGU=::MA==::TWV0aG9k\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"c2VsZWN0X3NpZ25hbF9lbmFibGU=::ZmFsc2U=::VXNlIFNlbGVjdCBTaWduYWw=\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"c2NhbGVfYnlfcGk=::ZmFsc2U=::UmVwcmVzZW50IGFuZ2xlIGFzIG11bHRpcGxlIG9mIFBp\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"bnVtYmVyX29mX2lucHV0cw==::Mg==::SW5wdXQgVmVjdG9yIERpbWVuc2lvbg==\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"dHJpZ19ub19yYW5nZV9yZWR1Y3Rpb24=::ZmFsc2U=::SW5wdXRzIGFyZSB3aXRoaW4gcmFuZ2UgLTJwaSB0byArMnBp\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"cmVwb3J0X3Jlc291cmNlc190b194bWw=::ZmFsc2U=::cmVwb3J0X3Jlc291cmNlc190b194bWw=\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"ZnhwdF93aWR0aA==::MzI=::V2lkdGg=\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"ZnhwdF9mcmFjdGlvbg==::MA==::RnJhY3Rpb24=\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"ZnhwdF9zaWdu::MQ==::U2lnbg==\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"ZnJlcXVlbmN5X2ZlZWRiYWNr::MTEy::ZnJlcXVlbmN5X2ZlZWRiYWNr\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"bGF0ZW5jeV9mZWVkYmFjaw==::MQ==::bGF0ZW5jeV9mZWVkYmFjaw==\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"Zm9yY2VfZWxhYm9yYXRl::MQ==::Zm9yY2VfZWxhYm9yYXRl\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X2Zvcm1hdA==::c2luZ2xl::T3V0cHV0IEZvcm1hdA==\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X2V4cA==::OA==::T3V0cHV0IEV4cG9uZW50\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X2V4cF9kZXJpdmVk::OA==::ZnBfb3V0X2V4cF9kZXJpdmVk\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X21hbg==::MjM=::T3V0cHV0IE1hbnRpc3Nh\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X21hbl9kZXJpdmVk::OA==::ZnBfb3V0X21hbl9kZXJpdmVk\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fZm9ybWF0::c2luZ2xl::SW5wdXQgRm9ybWF0\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fZXhw::OA==::SW5wdXQgRXhwb25lbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fZXhwX2Rlcml2ZWQ=::OA==::ZnBfaW5fZXhwX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fbWFu::MjM=::SW5wdXQgTWFudGlzc2E=\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fbWFuX2Rlcml2ZWQ=::OA==::ZnBfaW5fbWFuX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"ZW5hYmxlX2hhcmRfZnA=::dHJ1ZQ==::RW5hYmxlIEhhcmQgRmxvYXRpbmcgUG9pbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"bWFudWFsX2RzcF9wbGFubmluZw==::dHJ1ZQ==::RW5hYmxlIEhhcmQgRmxvYXRpbmcgUG9pbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"Zm9yY2VSZWdpc3RlcnM=::MTExMQ==::Zm9yY2VSZWdpc3RlcnM=\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"UkVTX0RTUF9wYXJhbQ==::MA==::TXVsdGlwbGllcw==\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"UkVTX0xVVF9wYXJhbQ==::MjIy::TFVUcw==\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"UkVTX01CSVRfcGFyYW0=::MA==::TWVtb3J5IEJpdHM=\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"UkVTX01CTE9DS19wYXJhbQ==::MA==::TWVtb3J5IEJsb2Nrcw==\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"c2VsZWN0ZWRfZGV2aWNlX2ZhbWlseQ==::Q3ljbG9uZSBW::c2VsZWN0ZWRfZGV2aWNlX2ZhbWlseQ==\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"c2VsZWN0ZWRfZGV2aWNlX3NwZWVkZ3JhZGU=::Nw==::c2VsZWN0ZWRfZGV2aWNlX3NwZWVkZ3JhZGU=\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_COMPONENT_PARAMETER \"dmFsaWRhdGlvbl9mYWlsZWQ=::ZmFsc2U=::dmFsaWRhdGlvbl9mYWlsZWQ=\"\n" +
                        "\n" +
                        "set_global_assignment -library \"FP_LT_64\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_LT_64.vhd\"]\n" +
                        "set_global_assignment -library \"FP_LT_64\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_LT_64/dspba_library_package.vhd\"]\n" +
                        "set_global_assignment -library \"FP_LT_64\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_LT_64/dspba_library.vhd\"]\n" +
                        "set_global_assignment -library \"FP_LT_64\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_LT_64/FP_LT_64_0002.vhd\"]\n" +
                        "\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_TOOL_NAME \"altera_fp_functions\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"FP_LT_64_0002\" -library \"FP_LT_64\" -name IP_TOOL_ENV \"mwpim\"";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_FP_LT_64_sip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -entity \"FP_LT_64\" -library \"lib_FP_LT_64\" -name IP_TOOL_NAME \"altera_fp_functions\"\n" +
                        "set_global_assignment -entity \"FP_LT_64\" -library \"lib_FP_LT_64\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"FP_LT_64\" -library \"lib_FP_LT_64\" -name IP_TOOL_ENV \"mwpim\"\n" +
                        "set_global_assignment -library \"lib_FP_LT_64\" -name SPD_FILE [file join $::quartus(sip_path) \"FP_LT_64.spd\"]\n" +
                        "\n" +
                        "set_global_assignment -library \"lib_FP_LT_64\" -name MISC_FILE [file join $::quartus(sip_path) \"FP_LT_64_sim/dspba_library_package.vhd\"]\n" +
                        "set_global_assignment -library \"lib_FP_LT_64\" -name MISC_FILE [file join $::quartus(sip_path) \"FP_LT_64_sim/dspba_library.vhd\"]\n" +
                        "set_global_assignment -library \"lib_FP_LT_64\" -name MISC_FILE [file join $::quartus(sip_path) \"FP_LT_64_sim/FP_LT_64.vhd\"]";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_FP_LT_64_vhd_file(String Project_Folder_File) {
        String data =   "-- megafunction wizard: %ALTERA_FP_FUNCTIONS v18.0%\n" +
                        "-- GENERATION: XML\n" +
                        "-- FP_LT_64.vhd\n" +
                        "\n" +
                        "-- Generated using ACDS version 18.0 614\n" +
                        "\n" +
                        "library IEEE;\n" +
                        "use IEEE.std_logic_1164.all;\n" +
                        "use IEEE.numeric_std.all;\n" +
                        "\n" +
                        "entity FP_LT_64 is\n" +
                        "	port (\n" +
                        "		clk    : in  std_logic                     := '0';             --    clk.clk\n" +
                        "		areset : in  std_logic                     := '0';             -- areset.reset\n" +
                        "		a      : in  std_logic_vector(63 downto 0) := (others => '0'); --      a.a\n" +
                        "		b      : in  std_logic_vector(63 downto 0) := (others => '0'); --      b.b\n" +
                        "		q      : out std_logic_vector(0 downto 0)                      --      q.q\n" +
                        "	);\n" +
                        "end entity FP_LT_64;\n" +
                        "\n" +
                        "architecture rtl of FP_LT_64 is\n" +
                        "	component FP_LT_64_0002 is\n" +
                        "		port (\n" +
                        "			clk    : in  std_logic                     := 'X';             -- clk\n" +
                        "			areset : in  std_logic                     := 'X';             -- reset\n" +
                        "			a      : in  std_logic_vector(63 downto 0) := (others => 'X'); -- a\n" +
                        "			b      : in  std_logic_vector(63 downto 0) := (others => 'X'); -- b\n" +
                        "			q      : out std_logic_vector(0 downto 0)                      -- q\n" +
                        "		);\n" +
                        "	end component FP_LT_64_0002;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "	fp_lt_64_inst : component FP_LT_64_0002\n" +
                        "		port map (\n" +
                        "			clk    => clk,    --    clk.clk\n" +
                        "			areset => areset, -- areset.reset\n" +
                        "			a      => a,      --      a.a\n" +
                        "			b      => b,      --      b.b\n" +
                        "			q      => q       --      q.q\n" +
                        "		);\n" +
                        "\n" +
                        "end architecture rtl; -- of FP_LT_64\n" +
                        "-- Retrieval info: <?xml version=\"1.0\"?>\n" +
                        "--<!--\n" +
                        "--	Generated by Altera MegaWizard Launcher Utility version 1.0\n" +
                        "--	************************************************************\n" +
                        "--	THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!\n" +
                        "--	************************************************************\n" +
                        "--	Copyright (C) 1991-2020 Altera Corporation\n" +
                        "--	Any megafunction design, and related net list (encrypted or decrypted),\n" +
                        "--	support information, device programming or simulation file, and any other\n" +
                        "--	associated documentation or information provided by Altera or a partner\n" +
                        "--	under Altera's Megafunction Partnership Program may be used only to\n" +
                        "--	program PLD devices (but not masked PLD devices) from Altera.  Any other\n" +
                        "--	use of such megafunction design, net list, support information, device\n" +
                        "--	programming or simulation file, or any other related documentation or\n" +
                        "--	information is prohibited for any other purpose, including, but not\n" +
                        "--	limited to modification, reverse engineering, de-compiling, or use with\n" +
                        "--	any other silicon devices, unless such use is explicitly licensed under\n" +
                        "--	a separate agreement with Altera or a megafunction partner.  Title to\n" +
                        "--	the intellectual property, including patents, copyrights, trademarks,\n" +
                        "--	trade secrets, or maskworks, embodied in any such megafunction design,\n" +
                        "--	net list, support information, device programming or simulation file, or\n" +
                        "--	any other related documentation or information provided by Altera or a\n" +
                        "--	megafunction partner, remains with Altera, the megafunction partner, or\n" +
                        "--	their respective licensors.  No other licenses, including any licenses\n" +
                        "--	needed under any third party's intellectual property, are provided herein.\n" +
                        "---->\n" +
                        "-- Retrieval info: <instance entity-name=\"altera_fp_functions\" version=\"18.0\" >\n" +
                        "-- Retrieval info: 	<generic name=\"FUNCTION_FAMILY\" value=\"COMPARE\" />\n" +
                        "-- Retrieval info: 	<generic name=\"ARITH_function\" value=\"ADD\" />\n" +
                        "-- Retrieval info: 	<generic name=\"CONVERT_function\" value=\"FXP_FP\" />\n" +
                        "-- Retrieval info: 	<generic name=\"ALL_function\" value=\"ADD\" />\n" +
                        "-- Retrieval info: 	<generic name=\"EXP_LOG_function\" value=\"EXPE\" />\n" +
                        "-- Retrieval info: 	<generic name=\"TRIG_function\" value=\"SIN\" />\n" +
                        "-- Retrieval info: 	<generic name=\"COMPARE_function\" value=\"LT\" />\n" +
                        "-- Retrieval info: 	<generic name=\"ROOTS_function\" value=\"SQRT\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_format\" value=\"double\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_exp\" value=\"8\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_man\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"exponent_width\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"frequency_target\" value=\"75\" />\n" +
                        "-- Retrieval info: 	<generic name=\"latency_target\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"performance_goal\" value=\"frequency\" />\n" +
                        "-- Retrieval info: 	<generic name=\"rounding_mode\" value=\"nearest with tie breaking away from zero\" />\n" +
                        "-- Retrieval info: 	<generic name=\"faithful_rounding\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gen_enable\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"divide_type\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"select_signal_enable\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"scale_by_pi\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"number_of_inputs\" value=\"2\" />\n" +
                        "-- Retrieval info: 	<generic name=\"trig_no_range_reduction\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"report_resources_to_xml\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fxpt_width\" value=\"32\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fxpt_fraction\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fxpt_sign\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_out_format\" value=\"single\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_out_exp\" value=\"8\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_out_man\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_in_format\" value=\"single\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_in_exp\" value=\"8\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_in_man\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"enable_hard_fp\" value=\"true\" />\n" +
                        "-- Retrieval info: 	<generic name=\"manual_dsp_planning\" value=\"true\" />\n" +
                        "-- Retrieval info: 	<generic name=\"forceRegisters\" value=\"1111\" />\n" +
                        "-- Retrieval info: 	<generic name=\"selected_device_family\" value=\"Cyclone V\" />\n" +
                        "-- Retrieval info: 	<generic name=\"selected_device_speedgrade\" value=\"7\" />\n" +
                        "-- Retrieval info: </instance>\n" +
                        "-- IPFS_FILES : FP_LT_64.vho\n" +
                        "-- RELATED_FILES: FP_LT_64.vhd, dspba_library_package.vhd, dspba_library.vhd, FP_LT_64_0002.vhd";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_FP_LT_64_0002_vhd_file(String Project_Folder_File) {
        String data =   "-- ------------------------------------------------------------------------- \n" +
                        "-- High Level Design Compiler for Intel(R) FPGAs Version 18.0 (Release Build #614)\n" +
                        "-- Quartus Prime development tool and MATLAB/Simulink Interface\n" +
                        "-- \n" +
                        "-- Legal Notice: Copyright 2018 Intel Corporation.  All rights reserved.\n" +
                        "-- Your use of  Intel Corporation's design tools,  logic functions and other\n" +
                        "-- software and  tools, and its AMPP partner logic functions, and any output\n" +
                        "-- files any  of the foregoing (including  device programming  or simulation\n" +
                        "-- files), and  any associated  documentation  or information  are expressly\n" +
                        "-- subject  to the terms and  conditions of the  Intel FPGA Software License\n" +
                        "-- Agreement, Intel MegaCore Function License Agreement, or other applicable\n" +
                        "-- license agreement,  including,  without limitation,  that your use is for\n" +
                        "-- the  sole  purpose of  programming  logic devices  manufactured by  Intel\n" +
                        "-- and  sold by Intel  or its authorized  distributors. Please refer  to the\n" +
                        "-- applicable agreement for further details.\n" +
                        "-- ---------------------------------------------------------------------------\n" +
                        "\n" +
                        "-- VHDL created from FP_LT_64_0002\n" +
                        "-- VHDL created on Sun Jun 21 03:54:41 2020\n" +
                        "\n" +
                        "\n" +
                        "library IEEE;\n" +
                        "use IEEE.std_logic_1164.all;\n" +
                        "use IEEE.NUMERIC_STD.all;\n" +
                        "use IEEE.MATH_REAL.all;\n" +
                        "use std.TextIO.all;\n" +
                        "use work.dspba_library_package.all;\n" +
                        "\n" +
                        "LIBRARY altera_mf;\n" +
                        "USE altera_mf.altera_mf_components.all;\n" +
                        "LIBRARY altera_lnsim;\n" +
                        "USE altera_lnsim.altera_lnsim_components.altera_syncram;\n" +
                        "LIBRARY lpm;\n" +
                        "USE lpm.lpm_components.all;\n" +
                        "\n" +
                        "entity FP_LT_64_0002 is\n" +
                        "    port (\n" +
                        "        a : in std_logic_vector(63 downto 0);  -- float64_m52\n" +
                        "        b : in std_logic_vector(63 downto 0);  -- float64_m52\n" +
                        "        q : out std_logic_vector(0 downto 0);  -- ufix1\n" +
                        "        clk : in std_logic;\n" +
                        "        areset : in std_logic\n" +
                        "    );\n" +
                        "end FP_LT_64_0002;\n" +
                        "\n" +
                        "architecture normal of FP_LT_64_0002 is\n" +
                        "\n" +
                        "    attribute altera_attribute : string;\n" +
                        "    attribute altera_attribute of normal : architecture is \"-name AUTO_SHIFT_REGISTER_RECOGNITION OFF; -name PHYSICAL_SYNTHESIS_REGISTER_DUPLICATION ON; -name MESSAGE_DISABLE 10036; -name MESSAGE_DISABLE 10037; -name MESSAGE_DISABLE 14130; -name MESSAGE_DISABLE 14320; -name MESSAGE_DISABLE 15400; -name MESSAGE_DISABLE 14130; -name MESSAGE_DISABLE 10036; -name MESSAGE_DISABLE 12020; -name MESSAGE_DISABLE 12030; -name MESSAGE_DISABLE 12010; -name MESSAGE_DISABLE 12110; -name MESSAGE_DISABLE 14320; -name MESSAGE_DISABLE 13410; -name MESSAGE_DISABLE 113007\";\n" +
                        "    \n" +
                        "    signal GND_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal VCC_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal cstAllOWE_uid6_fpCompareTest_q : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal cstZeroWF_uid7_fpCompareTest_q : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal cstAllZWE_uid8_fpCompareTest_q : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal exp_x_uid9_fpCompareTest_b : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal frac_x_uid10_fpCompareTest_b : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal excZ_x_uid11_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expXIsMax_uid12_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsZero_uid13_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsNotZero_uid14_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excN_x_uid16_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal exp_y_uid23_fpCompareTest_b : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal frac_y_uid24_fpCompareTest_b : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal excZ_y_uid25_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expXIsMax_uid26_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsZero_uid27_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsNotZero_uid28_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excN_y_uid30_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal oneIsNaN_uid34_fpCompareTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal oneIsNaN_uid34_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal xNotZero_uid39_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal yNotZero_uid40_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXPS_uid41_fpCompareTest_b : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal fracXPS_uid41_fpCompareTest_q : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal fracYPS_uid42_fpCompareTest_b : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal fracYPS_uid42_fpCompareTest_q : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal expFracX_uid43_fpCompareTest_q : STD_LOGIC_VECTOR (62 downto 0);\n" +
                        "    signal expFracY_uid45_fpCompareTest_q : STD_LOGIC_VECTOR (62 downto 0);\n" +
                        "    signal efxGTefy_uid47_fpCompareTest_a : STD_LOGIC_VECTOR (64 downto 0);\n" +
                        "    signal efxGTefy_uid47_fpCompareTest_b : STD_LOGIC_VECTOR (64 downto 0);\n" +
                        "    signal efxGTefy_uid47_fpCompareTest_o : STD_LOGIC_VECTOR (64 downto 0);\n" +
                        "    signal efxGTefy_uid47_fpCompareTest_c : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal efxLTefy_uid48_fpCompareTest_a : STD_LOGIC_VECTOR (64 downto 0);\n" +
                        "    signal efxLTefy_uid48_fpCompareTest_b : STD_LOGIC_VECTOR (64 downto 0);\n" +
                        "    signal efxLTefy_uid48_fpCompareTest_o : STD_LOGIC_VECTOR (64 downto 0);\n" +
                        "    signal efxLTefy_uid48_fpCompareTest_c : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal signX_uid52_fpCompareTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal signY_uid53_fpCompareTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal two_uid54_fpCompareTest_q : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal concSXSY_uid55_fpCompareTest_q : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal sxLTsy_uid56_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal xorSigns_uid57_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal sxEQsy_uid58_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expFracCompMux_uid59_fpCompareTest_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expFracCompMux_uid59_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal oneNonZero_uid62_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rc2_uid63_fpCompareTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rc2_uid63_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal sxEQsyExpFracCompMux_uid64_fpCompareTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal sxEQsyExpFracCompMux_uid64_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal r_uid65_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rPostExc_uid66_fpCompareTest_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rPostExc_uid66_fpCompareTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "\n" +
                        "    -- GND(CONSTANT,0)\n" +
                        "    GND_q <= \"0\";\n" +
                        "\n" +
                        "    -- cstAllZWE_uid8_fpCompareTest(CONSTANT,7)\n" +
                        "    cstAllZWE_uid8_fpCompareTest_q <= \"00000000000\";\n" +
                        "\n" +
                        "    -- exp_y_uid23_fpCompareTest(BITSELECT,22)@0\n" +
                        "    exp_y_uid23_fpCompareTest_b <= b(62 downto 52);\n" +
                        "\n" +
                        "    -- excZ_y_uid25_fpCompareTest(LOGICAL,24)@0\n" +
                        "    excZ_y_uid25_fpCompareTest_q <= \"1\" WHEN exp_y_uid23_fpCompareTest_b = cstAllZWE_uid8_fpCompareTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- yNotZero_uid40_fpCompareTest(LOGICAL,39)@0\n" +
                        "    yNotZero_uid40_fpCompareTest_q <= not (excZ_y_uid25_fpCompareTest_q);\n" +
                        "\n" +
                        "    -- exp_x_uid9_fpCompareTest(BITSELECT,8)@0\n" +
                        "    exp_x_uid9_fpCompareTest_b <= a(62 downto 52);\n" +
                        "\n" +
                        "    -- excZ_x_uid11_fpCompareTest(LOGICAL,10)@0\n" +
                        "    excZ_x_uid11_fpCompareTest_q <= \"1\" WHEN exp_x_uid9_fpCompareTest_b = cstAllZWE_uid8_fpCompareTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- xNotZero_uid39_fpCompareTest(LOGICAL,38)@0\n" +
                        "    xNotZero_uid39_fpCompareTest_q <= not (excZ_x_uid11_fpCompareTest_q);\n" +
                        "\n" +
                        "    -- oneNonZero_uid62_fpCompareTest(LOGICAL,61)@0\n" +
                        "    oneNonZero_uid62_fpCompareTest_q <= xNotZero_uid39_fpCompareTest_q or yNotZero_uid40_fpCompareTest_q;\n" +
                        "\n" +
                        "    -- two_uid54_fpCompareTest(CONSTANT,53)\n" +
                        "    two_uid54_fpCompareTest_q <= \"10\";\n" +
                        "\n" +
                        "    -- signX_uid52_fpCompareTest(BITSELECT,51)@0\n" +
                        "    signX_uid52_fpCompareTest_b <= STD_LOGIC_VECTOR(a(63 downto 63));\n" +
                        "\n" +
                        "    -- signY_uid53_fpCompareTest(BITSELECT,52)@0\n" +
                        "    signY_uid53_fpCompareTest_b <= STD_LOGIC_VECTOR(b(63 downto 63));\n" +
                        "\n" +
                        "    -- concSXSY_uid55_fpCompareTest(BITJOIN,54)@0\n" +
                        "    concSXSY_uid55_fpCompareTest_q <= signX_uid52_fpCompareTest_b & signY_uid53_fpCompareTest_b;\n" +
                        "\n" +
                        "    -- sxLTsy_uid56_fpCompareTest(LOGICAL,55)@0\n" +
                        "    sxLTsy_uid56_fpCompareTest_q <= \"1\" WHEN concSXSY_uid55_fpCompareTest_q = two_uid54_fpCompareTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- rc2_uid63_fpCompareTest(LOGICAL,62)@0 + 1\n" +
                        "    rc2_uid63_fpCompareTest_qi <= sxLTsy_uid56_fpCompareTest_q and oneNonZero_uid62_fpCompareTest_q;\n" +
                        "    rc2_uid63_fpCompareTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => rc2_uid63_fpCompareTest_qi, xout => rc2_uid63_fpCompareTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- frac_x_uid10_fpCompareTest(BITSELECT,9)@0\n" +
                        "    frac_x_uid10_fpCompareTest_b <= a(51 downto 0);\n" +
                        "\n" +
                        "    -- fracXPS_uid41_fpCompareTest(LOGICAL,40)@0\n" +
                        "    fracXPS_uid41_fpCompareTest_b <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR((51 downto 1 => xNotZero_uid39_fpCompareTest_q(0)) & xNotZero_uid39_fpCompareTest_q));\n" +
                        "    fracXPS_uid41_fpCompareTest_q <= frac_x_uid10_fpCompareTest_b and fracXPS_uid41_fpCompareTest_b;\n" +
                        "\n" +
                        "    -- expFracX_uid43_fpCompareTest(BITJOIN,42)@0\n" +
                        "    expFracX_uid43_fpCompareTest_q <= exp_x_uid9_fpCompareTest_b & fracXPS_uid41_fpCompareTest_q;\n" +
                        "\n" +
                        "    -- frac_y_uid24_fpCompareTest(BITSELECT,23)@0\n" +
                        "    frac_y_uid24_fpCompareTest_b <= b(51 downto 0);\n" +
                        "\n" +
                        "    -- fracYPS_uid42_fpCompareTest(LOGICAL,41)@0\n" +
                        "    fracYPS_uid42_fpCompareTest_b <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR((51 downto 1 => yNotZero_uid40_fpCompareTest_q(0)) & yNotZero_uid40_fpCompareTest_q));\n" +
                        "    fracYPS_uid42_fpCompareTest_q <= frac_y_uid24_fpCompareTest_b and fracYPS_uid42_fpCompareTest_b;\n" +
                        "\n" +
                        "    -- expFracY_uid45_fpCompareTest(BITJOIN,44)@0\n" +
                        "    expFracY_uid45_fpCompareTest_q <= exp_y_uid23_fpCompareTest_b & fracYPS_uid42_fpCompareTest_q;\n" +
                        "\n" +
                        "    -- efxGTefy_uid47_fpCompareTest(COMPARE,46)@0\n" +
                        "    efxGTefy_uid47_fpCompareTest_a <= STD_LOGIC_VECTOR(\"00\" & expFracY_uid45_fpCompareTest_q);\n" +
                        "    efxGTefy_uid47_fpCompareTest_b <= STD_LOGIC_VECTOR(\"00\" & expFracX_uid43_fpCompareTest_q);\n" +
                        "    efxGTefy_uid47_fpCompareTest_o <= STD_LOGIC_VECTOR(UNSIGNED(efxGTefy_uid47_fpCompareTest_a) - UNSIGNED(efxGTefy_uid47_fpCompareTest_b));\n" +
                        "    efxGTefy_uid47_fpCompareTest_c(0) <= efxGTefy_uid47_fpCompareTest_o(64);\n" +
                        "\n" +
                        "    -- efxLTefy_uid48_fpCompareTest(COMPARE,47)@0\n" +
                        "    efxLTefy_uid48_fpCompareTest_a <= STD_LOGIC_VECTOR(\"00\" & expFracX_uid43_fpCompareTest_q);\n" +
                        "    efxLTefy_uid48_fpCompareTest_b <= STD_LOGIC_VECTOR(\"00\" & expFracY_uid45_fpCompareTest_q);\n" +
                        "    efxLTefy_uid48_fpCompareTest_o <= STD_LOGIC_VECTOR(UNSIGNED(efxLTefy_uid48_fpCompareTest_a) - UNSIGNED(efxLTefy_uid48_fpCompareTest_b));\n" +
                        "    efxLTefy_uid48_fpCompareTest_c(0) <= efxLTefy_uid48_fpCompareTest_o(64);\n" +
                        "\n" +
                        "    -- expFracCompMux_uid59_fpCompareTest(MUX,58)@0\n" +
                        "    expFracCompMux_uid59_fpCompareTest_s <= signX_uid52_fpCompareTest_b;\n" +
                        "    expFracCompMux_uid59_fpCompareTest_combproc: PROCESS (expFracCompMux_uid59_fpCompareTest_s, efxLTefy_uid48_fpCompareTest_c, efxGTefy_uid47_fpCompareTest_c)\n" +
                        "    BEGIN\n" +
                        "        CASE (expFracCompMux_uid59_fpCompareTest_s) IS\n" +
                        "            WHEN \"0\" => expFracCompMux_uid59_fpCompareTest_q <= efxLTefy_uid48_fpCompareTest_c;\n" +
                        "            WHEN \"1\" => expFracCompMux_uid59_fpCompareTest_q <= efxGTefy_uid47_fpCompareTest_c;\n" +
                        "            WHEN OTHERS => expFracCompMux_uid59_fpCompareTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- xorSigns_uid57_fpCompareTest(LOGICAL,56)@0\n" +
                        "    xorSigns_uid57_fpCompareTest_q <= signX_uid52_fpCompareTest_b xor signY_uid53_fpCompareTest_b;\n" +
                        "\n" +
                        "    -- sxEQsy_uid58_fpCompareTest(LOGICAL,57)@0\n" +
                        "    sxEQsy_uid58_fpCompareTest_q <= not (xorSigns_uid57_fpCompareTest_q);\n" +
                        "\n" +
                        "    -- sxEQsyExpFracCompMux_uid64_fpCompareTest(LOGICAL,63)@0 + 1\n" +
                        "    sxEQsyExpFracCompMux_uid64_fpCompareTest_qi <= sxEQsy_uid58_fpCompareTest_q and expFracCompMux_uid59_fpCompareTest_q;\n" +
                        "    sxEQsyExpFracCompMux_uid64_fpCompareTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => sxEQsyExpFracCompMux_uid64_fpCompareTest_qi, xout => sxEQsyExpFracCompMux_uid64_fpCompareTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- r_uid65_fpCompareTest(LOGICAL,64)@1\n" +
                        "    r_uid65_fpCompareTest_q <= sxEQsyExpFracCompMux_uid64_fpCompareTest_q or rc2_uid63_fpCompareTest_q;\n" +
                        "\n" +
                        "    -- cstZeroWF_uid7_fpCompareTest(CONSTANT,6)\n" +
                        "    cstZeroWF_uid7_fpCompareTest_q <= \"0000000000000000000000000000000000000000000000000000\";\n" +
                        "\n" +
                        "    -- fracXIsZero_uid27_fpCompareTest(LOGICAL,26)@0\n" +
                        "    fracXIsZero_uid27_fpCompareTest_q <= \"1\" WHEN cstZeroWF_uid7_fpCompareTest_q = frac_y_uid24_fpCompareTest_b ELSE \"0\";\n" +
                        "\n" +
                        "    -- fracXIsNotZero_uid28_fpCompareTest(LOGICAL,27)@0\n" +
                        "    fracXIsNotZero_uid28_fpCompareTest_q <= not (fracXIsZero_uid27_fpCompareTest_q);\n" +
                        "\n" +
                        "    -- cstAllOWE_uid6_fpCompareTest(CONSTANT,5)\n" +
                        "    cstAllOWE_uid6_fpCompareTest_q <= \"11111111111\";\n" +
                        "\n" +
                        "    -- expXIsMax_uid26_fpCompareTest(LOGICAL,25)@0\n" +
                        "    expXIsMax_uid26_fpCompareTest_q <= \"1\" WHEN exp_y_uid23_fpCompareTest_b = cstAllOWE_uid6_fpCompareTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- excN_y_uid30_fpCompareTest(LOGICAL,29)@0\n" +
                        "    excN_y_uid30_fpCompareTest_q <= expXIsMax_uid26_fpCompareTest_q and fracXIsNotZero_uid28_fpCompareTest_q;\n" +
                        "\n" +
                        "    -- fracXIsZero_uid13_fpCompareTest(LOGICAL,12)@0\n" +
                        "    fracXIsZero_uid13_fpCompareTest_q <= \"1\" WHEN cstZeroWF_uid7_fpCompareTest_q = frac_x_uid10_fpCompareTest_b ELSE \"0\";\n" +
                        "\n" +
                        "    -- fracXIsNotZero_uid14_fpCompareTest(LOGICAL,13)@0\n" +
                        "    fracXIsNotZero_uid14_fpCompareTest_q <= not (fracXIsZero_uid13_fpCompareTest_q);\n" +
                        "\n" +
                        "    -- expXIsMax_uid12_fpCompareTest(LOGICAL,11)@0\n" +
                        "    expXIsMax_uid12_fpCompareTest_q <= \"1\" WHEN exp_x_uid9_fpCompareTest_b = cstAllOWE_uid6_fpCompareTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- excN_x_uid16_fpCompareTest(LOGICAL,15)@0\n" +
                        "    excN_x_uid16_fpCompareTest_q <= expXIsMax_uid12_fpCompareTest_q and fracXIsNotZero_uid14_fpCompareTest_q;\n" +
                        "\n" +
                        "    -- oneIsNaN_uid34_fpCompareTest(LOGICAL,33)@0 + 1\n" +
                        "    oneIsNaN_uid34_fpCompareTest_qi <= excN_x_uid16_fpCompareTest_q or excN_y_uid30_fpCompareTest_q;\n" +
                        "    oneIsNaN_uid34_fpCompareTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => oneIsNaN_uid34_fpCompareTest_qi, xout => oneIsNaN_uid34_fpCompareTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- VCC(CONSTANT,1)\n" +
                        "    VCC_q <= \"1\";\n" +
                        "\n" +
                        "    -- rPostExc_uid66_fpCompareTest(MUX,65)@1\n" +
                        "    rPostExc_uid66_fpCompareTest_s <= oneIsNaN_uid34_fpCompareTest_q;\n" +
                        "    rPostExc_uid66_fpCompareTest_combproc: PROCESS (rPostExc_uid66_fpCompareTest_s, r_uid65_fpCompareTest_q, GND_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (rPostExc_uid66_fpCompareTest_s) IS\n" +
                        "            WHEN \"0\" => rPostExc_uid66_fpCompareTest_q <= r_uid65_fpCompareTest_q;\n" +
                        "            WHEN \"1\" => rPostExc_uid66_fpCompareTest_q <= GND_q;\n" +
                        "            WHEN OTHERS => rPostExc_uid66_fpCompareTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- xOut(GPOUT,4)@1\n" +
                        "    q <= rPostExc_uid66_fpCompareTest_q;\n" +
                        "\n" +
                        "END normal;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_FP_MAX_64_qip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -entity \"FP_MAX_64\" -library \"FP_MAX_64\" -name IP_TOOL_NAME \"altera_fp_functions\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64\" -library \"FP_MAX_64\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64\" -library \"FP_MAX_64\" -name IP_TOOL_ENV \"mwpim\"\n" +
                        "set_global_assignment -library \"FP_MAX_64\" -name MISC_FILE [file join $::quartus(qip_path) \"FP_MAX_64.cmp\"]\n" +
                        "set_global_assignment -entity \"FP_MAX_64\" -library \"FP_MAX_64\" -name IP_TARGETED_DEVICE_FAMILY \"Cyclone V\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64\" -library \"FP_MAX_64\" -name IP_GENERATED_DEVICE_FAMILY \"{Cyclone V}\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64\" -library \"FP_MAX_64\" -name IP_QSYS_MODE \"UNKNOWN\"\n" +
                        "set_global_assignment -name SYNTHESIS_ONLY_QIP ON\n" +
                        "set_global_assignment -entity \"FP_MAX_64\" -library \"FP_MAX_64\" -name IP_COMPONENT_NAME \"RlBfTUFYXzY0\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64\" -library \"FP_MAX_64\" -name IP_COMPONENT_DISPLAY_NAME \"QUxURVJBX0ZQX0ZVTkNUSU9OUw==\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64\" -library \"FP_MAX_64\" -name IP_COMPONENT_REPORT_HIERARCHY \"Off\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64\" -library \"FP_MAX_64\" -name IP_COMPONENT_INTERNAL \"Off\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64\" -library \"FP_MAX_64\" -name IP_COMPONENT_AUTHOR \"QWx0ZXJhIENvcnBvcmF0aW9u\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64\" -library \"FP_MAX_64\" -name IP_COMPONENT_VERSION \"MTguMA==\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64\" -library \"FP_MAX_64\" -name IP_COMPONENT_DESCRIPTION \"QSBjb2xsZWN0aW9uIG9mIGZsb2F0aW5nIHBvaW50IGZ1bmN0aW9ucw==\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_NAME \"RlBfTUFYXzY0XzAwMDI=\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_DISPLAY_NAME \"QUxURVJBX0ZQX0ZVTkNUSU9OUw==\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_REPORT_HIERARCHY \"Off\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_INTERNAL \"Off\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_AUTHOR \"QWx0ZXJhIENvcnBvcmF0aW9u\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_VERSION \"MTguMA==\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_DESCRIPTION \"QSBjb2xsZWN0aW9uIG9mIGZsb2F0aW5nIHBvaW50IGZ1bmN0aW9ucw==\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"RlVOQ1RJT05fRkFNSUxZ::Q09NUEFSRQ==::RmFtaWx5\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"QVJJVEhfZnVuY3Rpb24=::QURE::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"Q09OVkVSVF9mdW5jdGlvbg==::RlhQX0ZQ::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"QUxMX2Z1bmN0aW9u::QURE::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"RVhQX0xPR19mdW5jdGlvbg==::RVhQRQ==::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"VFJJR19mdW5jdGlvbg==::U0lO::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"Q09NUEFSRV9mdW5jdGlvbg==::TUFY::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"Uk9PVFNfZnVuY3Rpb24=::U1FSVA==::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"ZGVyaXZlZGZ1bmN0aW9u::TUFY::ZGVyaXZlZGZ1bmN0aW9u\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"ZnBfZm9ybWF0::ZG91Ymxl::Rm9ybWF0\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"ZnBfZXhw::OA==::RXhwb25lbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"ZnBfZXhwX2Rlcml2ZWQ=::MTE=::ZnBfZXhwX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"ZnBfbWFu::MjM=::TWFudGlzc2E=\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"ZnBfbWFuX2Rlcml2ZWQ=::NTI=::ZnBfbWFuX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"ZXhwb25lbnRfd2lkdGg=::MjM=::RXhwb25lbnQgV2lkdGg=\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"ZnJlcXVlbmN5X3RhcmdldA==::NzU=::VGFyZ2V0\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"bGF0ZW5jeV90YXJnZXQ=::MA==::VGFyZ2V0\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"cGVyZm9ybWFuY2VfZ29hbA==::ZnJlcXVlbmN5::R29hbA==\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"cm91bmRpbmdfbW9kZQ==::bmVhcmVzdCB3aXRoIHRpZSBicmVha2luZyBhd2F5IGZyb20gemVybw==::TW9kZQ==\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"cm91bmRpbmdfbW9kZV9kZXJpdmVk::bmVhcmVzdCB3aXRoIHRpZSBicmVha2luZyB0byBldmVu::TW9kZQ==\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"dXNlX3JvdW5kaW5nX21vZGU=::ZmFsc2U=::dXNlX3JvdW5kaW5nX21vZGU=\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"ZmFpdGhmdWxfcm91bmRpbmc=::ZmFsc2U=::UmVsYXggcm91bmRpbmcgdG8gcm91bmQgdXAgb3IgZG93biB0byByZWR1Y2UgcmVzb3VyY2UgdXNhZ2U=\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"Z2VuX2VuYWJsZQ==::ZmFsc2U=::R2VuZXJhdGUgYW4gZW5hYmxlIHBvcnQ=\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"ZGl2aWRlX3R5cGU=::MA==::TWV0aG9k\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"c2VsZWN0X3NpZ25hbF9lbmFibGU=::ZmFsc2U=::VXNlIFNlbGVjdCBTaWduYWw=\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"c2NhbGVfYnlfcGk=::ZmFsc2U=::UmVwcmVzZW50IGFuZ2xlIGFzIG11bHRpcGxlIG9mIFBp\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"bnVtYmVyX29mX2lucHV0cw==::Mg==::SW5wdXQgVmVjdG9yIERpbWVuc2lvbg==\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"dHJpZ19ub19yYW5nZV9yZWR1Y3Rpb24=::ZmFsc2U=::SW5wdXRzIGFyZSB3aXRoaW4gcmFuZ2UgLTJwaSB0byArMnBp\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"cmVwb3J0X3Jlc291cmNlc190b194bWw=::ZmFsc2U=::cmVwb3J0X3Jlc291cmNlc190b194bWw=\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"ZnhwdF93aWR0aA==::MzI=::V2lkdGg=\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"ZnhwdF9mcmFjdGlvbg==::MA==::RnJhY3Rpb24=\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"ZnhwdF9zaWdu::MQ==::U2lnbg==\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"ZnJlcXVlbmN5X2ZlZWRiYWNr::ODI=::ZnJlcXVlbmN5X2ZlZWRiYWNr\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"bGF0ZW5jeV9mZWVkYmFjaw==::MA==::bGF0ZW5jeV9mZWVkYmFjaw==\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"Zm9yY2VfZWxhYm9yYXRl::MQ==::Zm9yY2VfZWxhYm9yYXRl\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X2Zvcm1hdA==::c2luZ2xl::T3V0cHV0IEZvcm1hdA==\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X2V4cA==::OA==::T3V0cHV0IEV4cG9uZW50\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X2V4cF9kZXJpdmVk::OA==::ZnBfb3V0X2V4cF9kZXJpdmVk\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X21hbg==::MjM=::T3V0cHV0IE1hbnRpc3Nh\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X21hbl9kZXJpdmVk::OA==::ZnBfb3V0X21hbl9kZXJpdmVk\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fZm9ybWF0::c2luZ2xl::SW5wdXQgRm9ybWF0\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fZXhw::OA==::SW5wdXQgRXhwb25lbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fZXhwX2Rlcml2ZWQ=::OA==::ZnBfaW5fZXhwX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fbWFu::MjM=::SW5wdXQgTWFudGlzc2E=\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fbWFuX2Rlcml2ZWQ=::OA==::ZnBfaW5fbWFuX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"ZW5hYmxlX2hhcmRfZnA=::dHJ1ZQ==::RW5hYmxlIEhhcmQgRmxvYXRpbmcgUG9pbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"bWFudWFsX2RzcF9wbGFubmluZw==::dHJ1ZQ==::RW5hYmxlIEhhcmQgRmxvYXRpbmcgUG9pbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"Zm9yY2VSZWdpc3RlcnM=::MTExMQ==::Zm9yY2VSZWdpc3RlcnM=\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"UkVTX0RTUF9wYXJhbQ==::MA==::TXVsdGlwbGllcw==\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"UkVTX0xVVF9wYXJhbQ==::MzA1::TFVUcw==\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"UkVTX01CSVRfcGFyYW0=::MA==::TWVtb3J5IEJpdHM=\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"UkVTX01CTE9DS19wYXJhbQ==::MA==::TWVtb3J5IEJsb2Nrcw==\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"c2VsZWN0ZWRfZGV2aWNlX2ZhbWlseQ==::Q3ljbG9uZSBW::c2VsZWN0ZWRfZGV2aWNlX2ZhbWlseQ==\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"c2VsZWN0ZWRfZGV2aWNlX3NwZWVkZ3JhZGU=::Nw==::c2VsZWN0ZWRfZGV2aWNlX3NwZWVkZ3JhZGU=\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_COMPONENT_PARAMETER \"dmFsaWRhdGlvbl9mYWlsZWQ=::ZmFsc2U=::dmFsaWRhdGlvbl9mYWlsZWQ=\"\n" +
                        "\n" +
                        "set_global_assignment -library \"FP_MAX_64\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_MAX_64.vhd\"]\n" +
                        "set_global_assignment -library \"FP_MAX_64\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_MAX_64/dspba_library_package.vhd\"]\n" +
                        "set_global_assignment -library \"FP_MAX_64\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_MAX_64/dspba_library.vhd\"]\n" +
                        "set_global_assignment -library \"FP_MAX_64\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_MAX_64/FP_MAX_64_0002.vhd\"]\n" +
                        "\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_TOOL_NAME \"altera_fp_functions\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64_0002\" -library \"FP_MAX_64\" -name IP_TOOL_ENV \"mwpim\"";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_FP_MAX_64_sip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -entity \"FP_MAX_64\" -library \"lib_FP_MAX_64\" -name IP_TOOL_NAME \"altera_fp_functions\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64\" -library \"lib_FP_MAX_64\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"FP_MAX_64\" -library \"lib_FP_MAX_64\" -name IP_TOOL_ENV \"mwpim\"\n" +
                        "set_global_assignment -library \"lib_FP_MAX_64\" -name SPD_FILE [file join $::quartus(sip_path) \"FP_MAX_64.spd\"]\n" +
                        "\n" +
                        "set_global_assignment -library \"lib_FP_MAX_64\" -name MISC_FILE [file join $::quartus(sip_path) \"FP_MAX_64_sim/dspba_library_package.vhd\"]\n" +
                        "set_global_assignment -library \"lib_FP_MAX_64\" -name MISC_FILE [file join $::quartus(sip_path) \"FP_MAX_64_sim/dspba_library.vhd\"]\n" +
                        "set_global_assignment -library \"lib_FP_MAX_64\" -name MISC_FILE [file join $::quartus(sip_path) \"FP_MAX_64_sim/FP_MAX_64.vhd\"]";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_FP_MAX_64_vhd_file(String Project_Folder_File) {
        String data =   "-- megafunction wizard: %ALTERA_FP_FUNCTIONS v18.0%\n" +
                        "-- GENERATION: XML\n" +
                        "-- FP_MAX_64.vhd\n" +
                        "\n" +
                        "-- Generated using ACDS version 18.0 614\n" +
                        "\n" +
                        "library IEEE;\n" +
                        "use IEEE.std_logic_1164.all;\n" +
                        "use IEEE.numeric_std.all;\n" +
                        "\n" +
                        "entity FP_MAX_64 is\n" +
                        "	port (\n" +
                        "		clk    : in  std_logic                     := '0';             --    clk.clk\n" +
                        "		areset : in  std_logic                     := '0';             -- areset.reset\n" +
                        "		a      : in  std_logic_vector(63 downto 0) := (others => '0'); --      a.a\n" +
                        "		b      : in  std_logic_vector(63 downto 0) := (others => '0'); --      b.b\n" +
                        "		q      : out std_logic_vector(63 downto 0)                     --      q.q\n" +
                        "	);\n" +
                        "end entity FP_MAX_64;\n" +
                        "\n" +
                        "architecture rtl of FP_MAX_64 is\n" +
                        "	component FP_MAX_64_0002 is\n" +
                        "		port (\n" +
                        "			clk    : in  std_logic                     := 'X';             -- clk\n" +
                        "			areset : in  std_logic                     := 'X';             -- reset\n" +
                        "			a      : in  std_logic_vector(63 downto 0) := (others => 'X'); -- a\n" +
                        "			b      : in  std_logic_vector(63 downto 0) := (others => 'X'); -- b\n" +
                        "			q      : out std_logic_vector(63 downto 0)                     -- q\n" +
                        "		);\n" +
                        "	end component FP_MAX_64_0002;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "	fp_max_64_inst : component FP_MAX_64_0002\n" +
                        "		port map (\n" +
                        "			clk    => clk,    --    clk.clk\n" +
                        "			areset => areset, -- areset.reset\n" +
                        "			a      => a,      --      a.a\n" +
                        "			b      => b,      --      b.b\n" +
                        "			q      => q       --      q.q\n" +
                        "		);\n" +
                        "\n" +
                        "end architecture rtl; -- of FP_MAX_64\n" +
                        "-- Retrieval info: <?xml version=\"1.0\"?>\n" +
                        "--<!--\n" +
                        "--	Generated by Altera MegaWizard Launcher Utility version 1.0\n" +
                        "--	************************************************************\n" +
                        "--	THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!\n" +
                        "--	************************************************************\n" +
                        "--	Copyright (C) 1991-2020 Altera Corporation\n" +
                        "--	Any megafunction design, and related net list (encrypted or decrypted),\n" +
                        "--	support information, device programming or simulation file, and any other\n" +
                        "--	associated documentation or information provided by Altera or a partner\n" +
                        "--	under Altera's Megafunction Partnership Program may be used only to\n" +
                        "--	program PLD devices (but not masked PLD devices) from Altera.  Any other\n" +
                        "--	use of such megafunction design, net list, support information, device\n" +
                        "--	programming or simulation file, or any other related documentation or\n" +
                        "--	information is prohibited for any other purpose, including, but not\n" +
                        "--	limited to modification, reverse engineering, de-compiling, or use with\n" +
                        "--	any other silicon devices, unless such use is explicitly licensed under\n" +
                        "--	a separate agreement with Altera or a megafunction partner.  Title to\n" +
                        "--	the intellectual property, including patents, copyrights, trademarks,\n" +
                        "--	trade secrets, or maskworks, embodied in any such megafunction design,\n" +
                        "--	net list, support information, device programming or simulation file, or\n" +
                        "--	any other related documentation or information provided by Altera or a\n" +
                        "--	megafunction partner, remains with Altera, the megafunction partner, or\n" +
                        "--	their respective licensors.  No other licenses, including any licenses\n" +
                        "--	needed under any third party's intellectual property, are provided herein.\n" +
                        "---->\n" +
                        "-- Retrieval info: <instance entity-name=\"altera_fp_functions\" version=\"18.0\" >\n" +
                        "-- Retrieval info: 	<generic name=\"FUNCTION_FAMILY\" value=\"COMPARE\" />\n" +
                        "-- Retrieval info: 	<generic name=\"ARITH_function\" value=\"ADD\" />\n" +
                        "-- Retrieval info: 	<generic name=\"CONVERT_function\" value=\"FXP_FP\" />\n" +
                        "-- Retrieval info: 	<generic name=\"ALL_function\" value=\"ADD\" />\n" +
                        "-- Retrieval info: 	<generic name=\"EXP_LOG_function\" value=\"EXPE\" />\n" +
                        "-- Retrieval info: 	<generic name=\"TRIG_function\" value=\"SIN\" />\n" +
                        "-- Retrieval info: 	<generic name=\"COMPARE_function\" value=\"MAX\" />\n" +
                        "-- Retrieval info: 	<generic name=\"ROOTS_function\" value=\"SQRT\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_format\" value=\"double\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_exp\" value=\"8\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_man\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"exponent_width\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"frequency_target\" value=\"75\" />\n" +
                        "-- Retrieval info: 	<generic name=\"latency_target\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"performance_goal\" value=\"frequency\" />\n" +
                        "-- Retrieval info: 	<generic name=\"rounding_mode\" value=\"nearest with tie breaking away from zero\" />\n" +
                        "-- Retrieval info: 	<generic name=\"faithful_rounding\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gen_enable\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"divide_type\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"select_signal_enable\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"scale_by_pi\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"number_of_inputs\" value=\"2\" />\n" +
                        "-- Retrieval info: 	<generic name=\"trig_no_range_reduction\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"report_resources_to_xml\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fxpt_width\" value=\"32\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fxpt_fraction\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fxpt_sign\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_out_format\" value=\"single\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_out_exp\" value=\"8\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_out_man\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_in_format\" value=\"single\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_in_exp\" value=\"8\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_in_man\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"enable_hard_fp\" value=\"true\" />\n" +
                        "-- Retrieval info: 	<generic name=\"manual_dsp_planning\" value=\"true\" />\n" +
                        "-- Retrieval info: 	<generic name=\"forceRegisters\" value=\"1111\" />\n" +
                        "-- Retrieval info: 	<generic name=\"selected_device_family\" value=\"Cyclone V\" />\n" +
                        "-- Retrieval info: 	<generic name=\"selected_device_speedgrade\" value=\"7\" />\n" +
                        "-- Retrieval info: </instance>\n" +
                        "-- IPFS_FILES : FP_MAX_64.vho\n" +
                        "-- RELATED_FILES: FP_MAX_64.vhd, dspba_library_package.vhd, dspba_library.vhd, FP_MAX_64_0002.vhd";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_FP_MAX_64_0002_vhd_file(String Project_Folder_File) {
        String data =   "-- ------------------------------------------------------------------------- \n" +
                        "-- High Level Design Compiler for Intel(R) FPGAs Version 18.0 (Release Build #614)\n" +
                        "-- Quartus Prime development tool and MATLAB/Simulink Interface\n" +
                        "-- \n" +
                        "-- Legal Notice: Copyright 2018 Intel Corporation.  All rights reserved.\n" +
                        "-- Your use of  Intel Corporation's design tools,  logic functions and other\n" +
                        "-- software and  tools, and its AMPP partner logic functions, and any output\n" +
                        "-- files any  of the foregoing (including  device programming  or simulation\n" +
                        "-- files), and  any associated  documentation  or information  are expressly\n" +
                        "-- subject  to the terms and  conditions of the  Intel FPGA Software License\n" +
                        "-- Agreement, Intel MegaCore Function License Agreement, or other applicable\n" +
                        "-- license agreement,  including,  without limitation,  that your use is for\n" +
                        "-- the  sole  purpose of  programming  logic devices  manufactured by  Intel\n" +
                        "-- and  sold by Intel  or its authorized  distributors. Please refer  to the\n" +
                        "-- applicable agreement for further details.\n" +
                        "-- ---------------------------------------------------------------------------\n" +
                        "\n" +
                        "-- VHDL created from FP_MAX_64_0002\n" +
                        "-- VHDL created on Sun Jun 21 03:58:58 2020\n" +
                        "\n" +
                        "\n" +
                        "library IEEE;\n" +
                        "use IEEE.std_logic_1164.all;\n" +
                        "use IEEE.NUMERIC_STD.all;\n" +
                        "use IEEE.MATH_REAL.all;\n" +
                        "use std.TextIO.all;\n" +
                        "use work.dspba_library_package.all;\n" +
                        "\n" +
                        "LIBRARY altera_mf;\n" +
                        "USE altera_mf.altera_mf_components.all;\n" +
                        "LIBRARY altera_lnsim;\n" +
                        "USE altera_lnsim.altera_lnsim_components.altera_syncram;\n" +
                        "LIBRARY lpm;\n" +
                        "USE lpm.lpm_components.all;\n" +
                        "\n" +
                        "entity FP_MAX_64_0002 is\n" +
                        "    port (\n" +
                        "        a : in std_logic_vector(63 downto 0);  -- float64_m52\n" +
                        "        b : in std_logic_vector(63 downto 0);  -- float64_m52\n" +
                        "        q : out std_logic_vector(63 downto 0);  -- float64_m52\n" +
                        "        clk : in std_logic;\n" +
                        "        areset : in std_logic\n" +
                        "    );\n" +
                        "end FP_MAX_64_0002;\n" +
                        "\n" +
                        "architecture normal of FP_MAX_64_0002 is\n" +
                        "\n" +
                        "    attribute altera_attribute : string;\n" +
                        "    attribute altera_attribute of normal : architecture is \"-name AUTO_SHIFT_REGISTER_RECOGNITION OFF; -name PHYSICAL_SYNTHESIS_REGISTER_DUPLICATION ON; -name MESSAGE_DISABLE 10036; -name MESSAGE_DISABLE 10037; -name MESSAGE_DISABLE 14130; -name MESSAGE_DISABLE 14320; -name MESSAGE_DISABLE 15400; -name MESSAGE_DISABLE 14130; -name MESSAGE_DISABLE 10036; -name MESSAGE_DISABLE 12020; -name MESSAGE_DISABLE 12030; -name MESSAGE_DISABLE 12010; -name MESSAGE_DISABLE 12110; -name MESSAGE_DISABLE 14320; -name MESSAGE_DISABLE 13410; -name MESSAGE_DISABLE 113007\";\n" +
                        "    \n" +
                        "    signal GND_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal VCC_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal cstAllOWE_uid6_fpMaxTest_q : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal cstZeroWF_uid7_fpMaxTest_q : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal exp_x_uid9_fpMaxTest_b : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal frac_x_uid10_fpMaxTest_b : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal expXIsMax_uid12_fpMaxTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsZero_uid13_fpMaxTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsNotZero_uid14_fpMaxTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excN_x_uid16_fpMaxTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal exp_y_uid23_fpMaxTest_b : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal frac_y_uid24_fpMaxTest_b : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal expXIsMax_uid26_fpMaxTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsZero_uid27_fpMaxTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsNotZero_uid28_fpMaxTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excN_y_uid30_fpMaxTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal nanOut_uid34_fpMaxTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal oneIsNaN_uid35_fpMaxTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal invExcYN_uid37_fpMaxTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal yNotNaN_uid39_fpMaxTest_a : STD_LOGIC_VECTOR (63 downto 0);\n" +
                        "    signal yNotNaN_uid39_fpMaxTest_q : STD_LOGIC_VECTOR (63 downto 0);\n" +
                        "    signal invExcXN_uid41_fpMaxTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal xNotNaN_uid43_fpMaxTest_a : STD_LOGIC_VECTOR (63 downto 0);\n" +
                        "    signal xNotNaN_uid43_fpMaxTest_q : STD_LOGIC_VECTOR (63 downto 0);\n" +
                        "    signal oneNaNOutput_uid44_fpMaxTest_q : STD_LOGIC_VECTOR (63 downto 0);\n" +
                        "    signal expFracX_uid47_fpMaxTest_q : STD_LOGIC_VECTOR (62 downto 0);\n" +
                        "    signal expFracY_uid51_fpMaxTest_q : STD_LOGIC_VECTOR (62 downto 0);\n" +
                        "    signal signX_uid53_fpMaxTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal signY_uid54_fpMaxTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal efxGTefy_uid55_fpMaxTest_a : STD_LOGIC_VECTOR (64 downto 0);\n" +
                        "    signal efxGTefy_uid55_fpMaxTest_b : STD_LOGIC_VECTOR (64 downto 0);\n" +
                        "    signal efxGTefy_uid55_fpMaxTest_o : STD_LOGIC_VECTOR (64 downto 0);\n" +
                        "    signal efxGTefy_uid55_fpMaxTest_c : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal invSX_uid56_fpMaxTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal invEfxGTefy_uid58_fpMaxTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal xNegyNegYGTX_uid59_fpMaxTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal xPosyPosXGtY_uid60_fpMaxTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal xPosYNeg_uid61_fpMaxTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal selX_uid62_fpMaxTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal r_uid63_fpMaxTest_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal r_uid63_fpMaxTest_q : STD_LOGIC_VECTOR (63 downto 0);\n" +
                        "    signal concOneIsNaNNaNOut_uid64_fpMaxTest_q : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal fracNaN_uid65_fpMaxTest_q : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal rPostNaNP_r3_uid67_fpMaxTest_q : STD_LOGIC_VECTOR (63 downto 0);\n" +
                        "    signal rPostNaN_uid72_fpMaxTest_s : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal rPostNaN_uid72_fpMaxTest_q : STD_LOGIC_VECTOR (63 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "\n" +
                        "    -- frac_y_uid24_fpMaxTest(BITSELECT,23)@0\n" +
                        "    frac_y_uid24_fpMaxTest_b <= b(51 downto 0);\n" +
                        "\n" +
                        "    -- cstZeroWF_uid7_fpMaxTest(CONSTANT,6)\n" +
                        "    cstZeroWF_uid7_fpMaxTest_q <= \"0000000000000000000000000000000000000000000000000000\";\n" +
                        "\n" +
                        "    -- fracXIsZero_uid27_fpMaxTest(LOGICAL,26)@0\n" +
                        "    fracXIsZero_uid27_fpMaxTest_q <= \"1\" WHEN cstZeroWF_uid7_fpMaxTest_q = frac_y_uid24_fpMaxTest_b ELSE \"0\";\n" +
                        "\n" +
                        "    -- fracXIsNotZero_uid28_fpMaxTest(LOGICAL,27)@0\n" +
                        "    fracXIsNotZero_uid28_fpMaxTest_q <= not (fracXIsZero_uid27_fpMaxTest_q);\n" +
                        "\n" +
                        "    -- cstAllOWE_uid6_fpMaxTest(CONSTANT,5)\n" +
                        "    cstAllOWE_uid6_fpMaxTest_q <= \"11111111111\";\n" +
                        "\n" +
                        "    -- exp_y_uid23_fpMaxTest(BITSELECT,22)@0\n" +
                        "    exp_y_uid23_fpMaxTest_b <= b(62 downto 52);\n" +
                        "\n" +
                        "    -- expXIsMax_uid26_fpMaxTest(LOGICAL,25)@0\n" +
                        "    expXIsMax_uid26_fpMaxTest_q <= \"1\" WHEN exp_y_uid23_fpMaxTest_b = cstAllOWE_uid6_fpMaxTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- excN_y_uid30_fpMaxTest(LOGICAL,29)@0\n" +
                        "    excN_y_uid30_fpMaxTest_q <= expXIsMax_uid26_fpMaxTest_q and fracXIsNotZero_uid28_fpMaxTest_q;\n" +
                        "\n" +
                        "    -- invExcYN_uid37_fpMaxTest(LOGICAL,36)@0\n" +
                        "    invExcYN_uid37_fpMaxTest_q <= not (excN_y_uid30_fpMaxTest_q);\n" +
                        "\n" +
                        "    -- yNotNaN_uid39_fpMaxTest(LOGICAL,38)@0\n" +
                        "    yNotNaN_uid39_fpMaxTest_a <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR((63 downto 1 => invExcYN_uid37_fpMaxTest_q(0)) & invExcYN_uid37_fpMaxTest_q));\n" +
                        "    yNotNaN_uid39_fpMaxTest_q <= yNotNaN_uid39_fpMaxTest_a and b;\n" +
                        "\n" +
                        "    -- frac_x_uid10_fpMaxTest(BITSELECT,9)@0\n" +
                        "    frac_x_uid10_fpMaxTest_b <= a(51 downto 0);\n" +
                        "\n" +
                        "    -- fracXIsZero_uid13_fpMaxTest(LOGICAL,12)@0\n" +
                        "    fracXIsZero_uid13_fpMaxTest_q <= \"1\" WHEN cstZeroWF_uid7_fpMaxTest_q = frac_x_uid10_fpMaxTest_b ELSE \"0\";\n" +
                        "\n" +
                        "    -- fracXIsNotZero_uid14_fpMaxTest(LOGICAL,13)@0\n" +
                        "    fracXIsNotZero_uid14_fpMaxTest_q <= not (fracXIsZero_uid13_fpMaxTest_q);\n" +
                        "\n" +
                        "    -- exp_x_uid9_fpMaxTest(BITSELECT,8)@0\n" +
                        "    exp_x_uid9_fpMaxTest_b <= a(62 downto 52);\n" +
                        "\n" +
                        "    -- expXIsMax_uid12_fpMaxTest(LOGICAL,11)@0\n" +
                        "    expXIsMax_uid12_fpMaxTest_q <= \"1\" WHEN exp_x_uid9_fpMaxTest_b = cstAllOWE_uid6_fpMaxTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- excN_x_uid16_fpMaxTest(LOGICAL,15)@0\n" +
                        "    excN_x_uid16_fpMaxTest_q <= expXIsMax_uid12_fpMaxTest_q and fracXIsNotZero_uid14_fpMaxTest_q;\n" +
                        "\n" +
                        "    -- invExcXN_uid41_fpMaxTest(LOGICAL,40)@0\n" +
                        "    invExcXN_uid41_fpMaxTest_q <= not (excN_x_uid16_fpMaxTest_q);\n" +
                        "\n" +
                        "    -- xNotNaN_uid43_fpMaxTest(LOGICAL,42)@0\n" +
                        "    xNotNaN_uid43_fpMaxTest_a <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR((63 downto 1 => invExcXN_uid41_fpMaxTest_q(0)) & invExcXN_uid41_fpMaxTest_q));\n" +
                        "    xNotNaN_uid43_fpMaxTest_q <= xNotNaN_uid43_fpMaxTest_a and a;\n" +
                        "\n" +
                        "    -- oneNaNOutput_uid44_fpMaxTest(LOGICAL,43)@0\n" +
                        "    oneNaNOutput_uid44_fpMaxTest_q <= xNotNaN_uid43_fpMaxTest_q or yNotNaN_uid39_fpMaxTest_q;\n" +
                        "\n" +
                        "    -- GND(CONSTANT,0)\n" +
                        "    GND_q <= \"0\";\n" +
                        "\n" +
                        "    -- fracNaN_uid65_fpMaxTest(CONSTANT,64)\n" +
                        "    fracNaN_uid65_fpMaxTest_q <= \"0000000000000000000000000000000000000000000000000001\";\n" +
                        "\n" +
                        "    -- rPostNaNP_r3_uid67_fpMaxTest(BITJOIN,66)@0\n" +
                        "    rPostNaNP_r3_uid67_fpMaxTest_q <= GND_q & cstAllOWE_uid6_fpMaxTest_q & fracNaN_uid65_fpMaxTest_q;\n" +
                        "\n" +
                        "    -- expFracX_uid47_fpMaxTest(BITJOIN,46)@0\n" +
                        "    expFracX_uid47_fpMaxTest_q <= exp_x_uid9_fpMaxTest_b & frac_x_uid10_fpMaxTest_b;\n" +
                        "\n" +
                        "    -- expFracY_uid51_fpMaxTest(BITJOIN,50)@0\n" +
                        "    expFracY_uid51_fpMaxTest_q <= exp_y_uid23_fpMaxTest_b & frac_y_uid24_fpMaxTest_b;\n" +
                        "\n" +
                        "    -- efxGTefy_uid55_fpMaxTest(COMPARE,54)@0\n" +
                        "    efxGTefy_uid55_fpMaxTest_a <= STD_LOGIC_VECTOR(\"00\" & expFracY_uid51_fpMaxTest_q);\n" +
                        "    efxGTefy_uid55_fpMaxTest_b <= STD_LOGIC_VECTOR(\"00\" & expFracX_uid47_fpMaxTest_q);\n" +
                        "    efxGTefy_uid55_fpMaxTest_o <= STD_LOGIC_VECTOR(UNSIGNED(efxGTefy_uid55_fpMaxTest_a) - UNSIGNED(efxGTefy_uid55_fpMaxTest_b));\n" +
                        "    efxGTefy_uid55_fpMaxTest_c(0) <= efxGTefy_uid55_fpMaxTest_o(64);\n" +
                        "\n" +
                        "    -- invEfxGTefy_uid58_fpMaxTest(LOGICAL,57)@0\n" +
                        "    invEfxGTefy_uid58_fpMaxTest_q <= not (efxGTefy_uid55_fpMaxTest_c);\n" +
                        "\n" +
                        "    -- signY_uid54_fpMaxTest(BITSELECT,53)@0\n" +
                        "    signY_uid54_fpMaxTest_b <= STD_LOGIC_VECTOR(b(63 downto 63));\n" +
                        "\n" +
                        "    -- signX_uid53_fpMaxTest(BITSELECT,52)@0\n" +
                        "    signX_uid53_fpMaxTest_b <= STD_LOGIC_VECTOR(a(63 downto 63));\n" +
                        "\n" +
                        "    -- xNegyNegYGTX_uid59_fpMaxTest(LOGICAL,58)@0\n" +
                        "    xNegyNegYGTX_uid59_fpMaxTest_q <= signX_uid53_fpMaxTest_b and signY_uid54_fpMaxTest_b and invEfxGTefy_uid58_fpMaxTest_q;\n" +
                        "\n" +
                        "    -- invSX_uid56_fpMaxTest(LOGICAL,55)@0\n" +
                        "    invSX_uid56_fpMaxTest_q <= not (signX_uid53_fpMaxTest_b);\n" +
                        "\n" +
                        "    -- xPosyPosXGtY_uid60_fpMaxTest(LOGICAL,59)@0\n" +
                        "    xPosyPosXGtY_uid60_fpMaxTest_q <= invSX_uid56_fpMaxTest_q and invSX_uid56_fpMaxTest_q and efxGTefy_uid55_fpMaxTest_c;\n" +
                        "\n" +
                        "    -- xPosYNeg_uid61_fpMaxTest(LOGICAL,60)@0\n" +
                        "    xPosYNeg_uid61_fpMaxTest_q <= invSX_uid56_fpMaxTest_q and signY_uid54_fpMaxTest_b;\n" +
                        "\n" +
                        "    -- selX_uid62_fpMaxTest(LOGICAL,61)@0\n" +
                        "    selX_uid62_fpMaxTest_q <= xPosYNeg_uid61_fpMaxTest_q or xPosyPosXGtY_uid60_fpMaxTest_q or xNegyNegYGTX_uid59_fpMaxTest_q;\n" +
                        "\n" +
                        "    -- r_uid63_fpMaxTest(MUX,62)@0\n" +
                        "    r_uid63_fpMaxTest_s <= selX_uid62_fpMaxTest_q;\n" +
                        "    r_uid63_fpMaxTest_combproc: PROCESS (r_uid63_fpMaxTest_s, b, a)\n" +
                        "    BEGIN\n" +
                        "        CASE (r_uid63_fpMaxTest_s) IS\n" +
                        "            WHEN \"0\" => r_uid63_fpMaxTest_q <= b;\n" +
                        "            WHEN \"1\" => r_uid63_fpMaxTest_q <= a;\n" +
                        "            WHEN OTHERS => r_uid63_fpMaxTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- oneIsNaN_uid35_fpMaxTest(LOGICAL,34)@0\n" +
                        "    oneIsNaN_uid35_fpMaxTest_q <= excN_x_uid16_fpMaxTest_q xor excN_y_uid30_fpMaxTest_q;\n" +
                        "\n" +
                        "    -- nanOut_uid34_fpMaxTest(LOGICAL,33)@0\n" +
                        "    nanOut_uid34_fpMaxTest_q <= excN_x_uid16_fpMaxTest_q and excN_y_uid30_fpMaxTest_q;\n" +
                        "\n" +
                        "    -- concOneIsNaNNaNOut_uid64_fpMaxTest(BITJOIN,63)@0\n" +
                        "    concOneIsNaNNaNOut_uid64_fpMaxTest_q <= oneIsNaN_uid35_fpMaxTest_q & nanOut_uid34_fpMaxTest_q;\n" +
                        "\n" +
                        "    -- VCC(CONSTANT,1)\n" +
                        "    VCC_q <= \"1\";\n" +
                        "\n" +
                        "    -- rPostNaN_uid72_fpMaxTest(MUX,71)@0\n" +
                        "    rPostNaN_uid72_fpMaxTest_s <= concOneIsNaNNaNOut_uid64_fpMaxTest_q;\n" +
                        "    rPostNaN_uid72_fpMaxTest_combproc: PROCESS (rPostNaN_uid72_fpMaxTest_s, r_uid63_fpMaxTest_q, rPostNaNP_r3_uid67_fpMaxTest_q, oneNaNOutput_uid44_fpMaxTest_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (rPostNaN_uid72_fpMaxTest_s) IS\n" +
                        "            WHEN \"00\" => rPostNaN_uid72_fpMaxTest_q <= r_uid63_fpMaxTest_q;\n" +
                        "            WHEN \"01\" => rPostNaN_uid72_fpMaxTest_q <= rPostNaNP_r3_uid67_fpMaxTest_q;\n" +
                        "            WHEN \"10\" => rPostNaN_uid72_fpMaxTest_q <= oneNaNOutput_uid44_fpMaxTest_q;\n" +
                        "            WHEN \"11\" => rPostNaN_uid72_fpMaxTest_q <= rPostNaNP_r3_uid67_fpMaxTest_q;\n" +
                        "            WHEN OTHERS => rPostNaN_uid72_fpMaxTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- xOut(GPOUT,4)@0\n" +
                        "    q <= rPostNaN_uid72_fpMaxTest_q;\n" +
                        "\n" +
                        "END normal;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_FP_MUL_64_qip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -entity \"FP_MUL_64\" -library \"FP_MUL_64\" -name IP_TOOL_NAME \"altera_fp_functions\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64\" -library \"FP_MUL_64\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64\" -library \"FP_MUL_64\" -name IP_TOOL_ENV \"mwpim\"\n" +
                        "set_global_assignment -library \"FP_MUL_64\" -name MISC_FILE [file join $::quartus(qip_path) \"FP_MUL_64.cmp\"]\n" +
                        "set_global_assignment -entity \"FP_MUL_64\" -library \"FP_MUL_64\" -name IP_TARGETED_DEVICE_FAMILY \"Cyclone V\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64\" -library \"FP_MUL_64\" -name IP_GENERATED_DEVICE_FAMILY \"{Cyclone V}\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64\" -library \"FP_MUL_64\" -name IP_QSYS_MODE \"UNKNOWN\"\n" +
                        "set_global_assignment -name SYNTHESIS_ONLY_QIP ON\n" +
                        "set_global_assignment -entity \"FP_MUL_64\" -library \"FP_MUL_64\" -name IP_COMPONENT_NAME \"RlBfTVVMXzY0\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64\" -library \"FP_MUL_64\" -name IP_COMPONENT_DISPLAY_NAME \"QUxURVJBX0ZQX0ZVTkNUSU9OUw==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64\" -library \"FP_MUL_64\" -name IP_COMPONENT_REPORT_HIERARCHY \"Off\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64\" -library \"FP_MUL_64\" -name IP_COMPONENT_INTERNAL \"Off\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64\" -library \"FP_MUL_64\" -name IP_COMPONENT_AUTHOR \"QWx0ZXJhIENvcnBvcmF0aW9u\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64\" -library \"FP_MUL_64\" -name IP_COMPONENT_VERSION \"MTguMA==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64\" -library \"FP_MUL_64\" -name IP_COMPONENT_DESCRIPTION \"QSBjb2xsZWN0aW9uIG9mIGZsb2F0aW5nIHBvaW50IGZ1bmN0aW9ucw==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_NAME \"RlBfTVVMXzY0XzAwMDI=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_DISPLAY_NAME \"QUxURVJBX0ZQX0ZVTkNUSU9OUw==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_REPORT_HIERARCHY \"Off\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_INTERNAL \"Off\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_AUTHOR \"QWx0ZXJhIENvcnBvcmF0aW9u\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_VERSION \"MTguMA==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_DESCRIPTION \"QSBjb2xsZWN0aW9uIG9mIGZsb2F0aW5nIHBvaW50IGZ1bmN0aW9ucw==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"RlVOQ1RJT05fRkFNSUxZ::QVJJVEg=::RmFtaWx5\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"QVJJVEhfZnVuY3Rpb24=::TVVM::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"Q09OVkVSVF9mdW5jdGlvbg==::RlhQX0ZQ::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"QUxMX2Z1bmN0aW9u::QURE::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"RVhQX0xPR19mdW5jdGlvbg==::RVhQRQ==::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"VFJJR19mdW5jdGlvbg==::U0lO::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"Q09NUEFSRV9mdW5jdGlvbg==::TUlO::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"Uk9PVFNfZnVuY3Rpb24=::U1FSVA==::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"ZGVyaXZlZGZ1bmN0aW9u::TVVM::ZGVyaXZlZGZ1bmN0aW9u\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"ZnBfZm9ybWF0::ZG91Ymxl::Rm9ybWF0\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"ZnBfZXhw::OA==::RXhwb25lbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"ZnBfZXhwX2Rlcml2ZWQ=::MTE=::ZnBfZXhwX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"ZnBfbWFu::MjM=::TWFudGlzc2E=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"ZnBfbWFuX2Rlcml2ZWQ=::NTI=::ZnBfbWFuX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"ZXhwb25lbnRfd2lkdGg=::MjM=::RXhwb25lbnQgV2lkdGg=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"ZnJlcXVlbmN5X3RhcmdldA==::MTAw::VGFyZ2V0\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"bGF0ZW5jeV90YXJnZXQ=::NQ==::VGFyZ2V0\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"cGVyZm9ybWFuY2VfZ29hbA==::ZnJlcXVlbmN5::R29hbA==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"cm91bmRpbmdfbW9kZQ==::bmVhcmVzdCB3aXRoIHRpZSBicmVha2luZyBhd2F5IGZyb20gemVybw==::TW9kZQ==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"cm91bmRpbmdfbW9kZV9kZXJpdmVk::bmVhcmVzdCB3aXRoIHRpZSBicmVha2luZyB0byBldmVu::TW9kZQ==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"dXNlX3JvdW5kaW5nX21vZGU=::dHJ1ZQ==::dXNlX3JvdW5kaW5nX21vZGU=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"ZmFpdGhmdWxfcm91bmRpbmc=::ZmFsc2U=::UmVsYXggcm91bmRpbmcgdG8gcm91bmQgdXAgb3IgZG93biB0byByZWR1Y2UgcmVzb3VyY2UgdXNhZ2U=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"Z2VuX2VuYWJsZQ==::ZmFsc2U=::R2VuZXJhdGUgYW4gZW5hYmxlIHBvcnQ=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"ZGl2aWRlX3R5cGU=::MA==::TWV0aG9k\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"c2VsZWN0X3NpZ25hbF9lbmFibGU=::ZmFsc2U=::VXNlIFNlbGVjdCBTaWduYWw=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"c2NhbGVfYnlfcGk=::ZmFsc2U=::UmVwcmVzZW50IGFuZ2xlIGFzIG11bHRpcGxlIG9mIFBp\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"bnVtYmVyX29mX2lucHV0cw==::Mg==::SW5wdXQgVmVjdG9yIERpbWVuc2lvbg==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"dHJpZ19ub19yYW5nZV9yZWR1Y3Rpb24=::ZmFsc2U=::SW5wdXRzIGFyZSB3aXRoaW4gcmFuZ2UgLTJwaSB0byArMnBp\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"cmVwb3J0X3Jlc291cmNlc190b194bWw=::ZmFsc2U=::cmVwb3J0X3Jlc291cmNlc190b194bWw=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"ZnhwdF93aWR0aA==::MzI=::V2lkdGg=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"ZnhwdF9mcmFjdGlvbg==::MA==::RnJhY3Rpb24=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"ZnhwdF9zaWdu::MQ==::U2lnbg==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"ZnJlcXVlbmN5X2ZlZWRiYWNr::MTE2::ZnJlcXVlbmN5X2ZlZWRiYWNr\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"bGF0ZW5jeV9mZWVkYmFjaw==::NQ==::bGF0ZW5jeV9mZWVkYmFjaw==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"Zm9yY2VfZWxhYm9yYXRl::MQ==::Zm9yY2VfZWxhYm9yYXRl\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X2Zvcm1hdA==::c2luZ2xl::T3V0cHV0IEZvcm1hdA==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X2V4cA==::OA==::T3V0cHV0IEV4cG9uZW50\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X2V4cF9kZXJpdmVk::OA==::ZnBfb3V0X2V4cF9kZXJpdmVk\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X21hbg==::MjM=::T3V0cHV0IE1hbnRpc3Nh\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X21hbl9kZXJpdmVk::OA==::ZnBfb3V0X21hbl9kZXJpdmVk\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fZm9ybWF0::c2luZ2xl::SW5wdXQgRm9ybWF0\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fZXhw::OA==::SW5wdXQgRXhwb25lbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fZXhwX2Rlcml2ZWQ=::OA==::ZnBfaW5fZXhwX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fbWFu::MjM=::SW5wdXQgTWFudGlzc2E=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fbWFuX2Rlcml2ZWQ=::OA==::ZnBfaW5fbWFuX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"ZW5hYmxlX2hhcmRfZnA=::dHJ1ZQ==::RW5hYmxlIEhhcmQgRmxvYXRpbmcgUG9pbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"bWFudWFsX2RzcF9wbGFubmluZw==::dHJ1ZQ==::RW5hYmxlIEhhcmQgRmxvYXRpbmcgUG9pbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"Zm9yY2VSZWdpc3RlcnM=::MTExMQ==::Zm9yY2VSZWdpc3RlcnM=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"UkVTX0RTUF9wYXJhbQ==::OA==::TXVsdGlwbGllcw==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"UkVTX0xVVF9wYXJhbQ==::NTAw::TFVUcw==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"UkVTX01CSVRfcGFyYW0=::MA==::TWVtb3J5IEJpdHM=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"UkVTX01CTE9DS19wYXJhbQ==::MA==::TWVtb3J5IEJsb2Nrcw==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"c2VsZWN0ZWRfZGV2aWNlX2ZhbWlseQ==::Q3ljbG9uZSBW::c2VsZWN0ZWRfZGV2aWNlX2ZhbWlseQ==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"c2VsZWN0ZWRfZGV2aWNlX3NwZWVkZ3JhZGU=::Nw==::c2VsZWN0ZWRfZGV2aWNlX3NwZWVkZ3JhZGU=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_COMPONENT_PARAMETER \"dmFsaWRhdGlvbl9mYWlsZWQ=::ZmFsc2U=::dmFsaWRhdGlvbl9mYWlsZWQ=\"\n" +
                        "\n" +
                        "set_global_assignment -library \"FP_MUL_64\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_MUL_64.vhd\"]\n" +
                        "set_global_assignment -library \"FP_MUL_64\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_MUL_64/dspba_library_package.vhd\"]\n" +
                        "set_global_assignment -library \"FP_MUL_64\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_MUL_64/dspba_library.vhd\"]\n" +
                        "set_global_assignment -library \"FP_MUL_64\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_MUL_64/FP_MUL_64_0002.vhd\"]\n" +
                        "\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_TOOL_NAME \"altera_fp_functions\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64_0002\" -library \"FP_MUL_64\" -name IP_TOOL_ENV \"mwpim\"";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_FP_MUL_64_sip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -entity \"FP_MUL_64\" -library \"lib_FP_MUL_64\" -name IP_TOOL_NAME \"altera_fp_functions\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64\" -library \"lib_FP_MUL_64\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"FP_MUL_64\" -library \"lib_FP_MUL_64\" -name IP_TOOL_ENV \"mwpim\"\n" +
                        "set_global_assignment -library \"lib_FP_MUL_64\" -name SPD_FILE [file join $::quartus(sip_path) \"FP_MUL_64.spd\"]\n" +
                        "\n" +
                        "set_global_assignment -library \"lib_FP_MUL_64\" -name MISC_FILE [file join $::quartus(sip_path) \"FP_MUL_64_sim/dspba_library_package.vhd\"]\n" +
                        "set_global_assignment -library \"lib_FP_MUL_64\" -name MISC_FILE [file join $::quartus(sip_path) \"FP_MUL_64_sim/dspba_library.vhd\"]\n" +
                        "set_global_assignment -library \"lib_FP_MUL_64\" -name MISC_FILE [file join $::quartus(sip_path) \"FP_MUL_64_sim/FP_MUL_64.vhd\"]";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_FP_MUL_64_vhd_file(String Project_Folder_File) {
        String data =   "-- megafunction wizard: %ALTERA_FP_FUNCTIONS v18.0%\n" +
                        "-- GENERATION: XML\n" +
                        "-- FP_MUL_64.vhd\n" +
                        "\n" +
                        "-- Generated using ACDS version 18.0 614\n" +
                        "\n" +
                        "library IEEE;\n" +
                        "use IEEE.std_logic_1164.all;\n" +
                        "use IEEE.numeric_std.all;\n" +
                        "\n" +
                        "entity FP_MUL_64 is\n" +
                        "	port (\n" +
                        "		clk    : in  std_logic                     := '0';             --    clk.clk\n" +
                        "		areset : in  std_logic                     := '0';             -- areset.reset\n" +
                        "		a      : in  std_logic_vector(63 downto 0) := (others => '0'); --      a.a\n" +
                        "		b      : in  std_logic_vector(63 downto 0) := (others => '0'); --      b.b\n" +
                        "		q      : out std_logic_vector(63 downto 0)                     --      q.q\n" +
                        "	);\n" +
                        "end entity FP_MUL_64;\n" +
                        "\n" +
                        "architecture rtl of FP_MUL_64 is\n" +
                        "	component FP_MUL_64_0002 is\n" +
                        "		port (\n" +
                        "			clk    : in  std_logic                     := 'X';             -- clk\n" +
                        "			areset : in  std_logic                     := 'X';             -- reset\n" +
                        "			a      : in  std_logic_vector(63 downto 0) := (others => 'X'); -- a\n" +
                        "			b      : in  std_logic_vector(63 downto 0) := (others => 'X'); -- b\n" +
                        "			q      : out std_logic_vector(63 downto 0)                     -- q\n" +
                        "		);\n" +
                        "	end component FP_MUL_64_0002;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "	fp_mul_64_inst : component FP_MUL_64_0002\n" +
                        "		port map (\n" +
                        "			clk    => clk,    --    clk.clk\n" +
                        "			areset => areset, -- areset.reset\n" +
                        "			a      => a,      --      a.a\n" +
                        "			b      => b,      --      b.b\n" +
                        "			q      => q       --      q.q\n" +
                        "		);\n" +
                        "\n" +
                        "end architecture rtl; -- of FP_MUL_64\n" +
                        "-- Retrieval info: <?xml version=\"1.0\"?>\n" +
                        "--<!--\n" +
                        "--	Generated by Altera MegaWizard Launcher Utility version 1.0\n" +
                        "--	************************************************************\n" +
                        "--	THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!\n" +
                        "--	************************************************************\n" +
                        "--	Copyright (C) 1991-2020 Altera Corporation\n" +
                        "--	Any megafunction design, and related net list (encrypted or decrypted),\n" +
                        "--	support information, device programming or simulation file, and any other\n" +
                        "--	associated documentation or information provided by Altera or a partner\n" +
                        "--	under Altera's Megafunction Partnership Program may be used only to\n" +
                        "--	program PLD devices (but not masked PLD devices) from Altera.  Any other\n" +
                        "--	use of such megafunction design, net list, support information, device\n" +
                        "--	programming or simulation file, or any other related documentation or\n" +
                        "--	information is prohibited for any other purpose, including, but not\n" +
                        "--	limited to modification, reverse engineering, de-compiling, or use with\n" +
                        "--	any other silicon devices, unless such use is explicitly licensed under\n" +
                        "--	a separate agreement with Altera or a megafunction partner.  Title to\n" +
                        "--	the intellectual property, including patents, copyrights, trademarks,\n" +
                        "--	trade secrets, or maskworks, embodied in any such megafunction design,\n" +
                        "--	net list, support information, device programming or simulation file, or\n" +
                        "--	any other related documentation or information provided by Altera or a\n" +
                        "--	megafunction partner, remains with Altera, the megafunction partner, or\n" +
                        "--	their respective licensors.  No other licenses, including any licenses\n" +
                        "--	needed under any third party's intellectual property, are provided herein.\n" +
                        "---->\n" +
                        "-- Retrieval info: <instance entity-name=\"altera_fp_functions\" version=\"18.0\" >\n" +
                        "-- Retrieval info: 	<generic name=\"FUNCTION_FAMILY\" value=\"ARITH\" />\n" +
                        "-- Retrieval info: 	<generic name=\"ARITH_function\" value=\"MUL\" />\n" +
                        "-- Retrieval info: 	<generic name=\"CONVERT_function\" value=\"FXP_FP\" />\n" +
                        "-- Retrieval info: 	<generic name=\"ALL_function\" value=\"ADD\" />\n" +
                        "-- Retrieval info: 	<generic name=\"EXP_LOG_function\" value=\"EXPE\" />\n" +
                        "-- Retrieval info: 	<generic name=\"TRIG_function\" value=\"SIN\" />\n" +
                        "-- Retrieval info: 	<generic name=\"COMPARE_function\" value=\"MIN\" />\n" +
                        "-- Retrieval info: 	<generic name=\"ROOTS_function\" value=\"SQRT\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_format\" value=\"double\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_exp\" value=\"8\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_man\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"exponent_width\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"frequency_target\" value=\"100\" />\n" +
                        "-- Retrieval info: 	<generic name=\"latency_target\" value=\"5\" />\n" +
                        "-- Retrieval info: 	<generic name=\"performance_goal\" value=\"frequency\" />\n" +
                        "-- Retrieval info: 	<generic name=\"rounding_mode\" value=\"nearest with tie breaking away from zero\" />\n" +
                        "-- Retrieval info: 	<generic name=\"faithful_rounding\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gen_enable\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"divide_type\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"select_signal_enable\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"scale_by_pi\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"number_of_inputs\" value=\"2\" />\n" +
                        "-- Retrieval info: 	<generic name=\"trig_no_range_reduction\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"report_resources_to_xml\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fxpt_width\" value=\"32\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fxpt_fraction\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fxpt_sign\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_out_format\" value=\"single\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_out_exp\" value=\"8\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_out_man\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_in_format\" value=\"single\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_in_exp\" value=\"8\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_in_man\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"enable_hard_fp\" value=\"true\" />\n" +
                        "-- Retrieval info: 	<generic name=\"manual_dsp_planning\" value=\"true\" />\n" +
                        "-- Retrieval info: 	<generic name=\"forceRegisters\" value=\"1111\" />\n" +
                        "-- Retrieval info: 	<generic name=\"selected_device_family\" value=\"Cyclone V\" />\n" +
                        "-- Retrieval info: 	<generic name=\"selected_device_speedgrade\" value=\"7\" />\n" +
                        "-- Retrieval info: </instance>\n" +
                        "-- IPFS_FILES : FP_MUL_64.vho\n" +
                        "-- RELATED_FILES: FP_MUL_64.vhd, dspba_library_package.vhd, dspba_library.vhd, FP_MUL_64_0002.vhd";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_FP_MUL_64_0002_vhd_file(String Project_Folder_File) {
        String data =   "-- ------------------------------------------------------------------------- \n" +
                        "-- High Level Design Compiler for Intel(R) FPGAs Version 18.0 (Release Build #614)\n" +
                        "-- Quartus Prime development tool and MATLAB/Simulink Interface\n" +
                        "-- \n" +
                        "-- Legal Notice: Copyright 2018 Intel Corporation.  All rights reserved.\n" +
                        "-- Your use of  Intel Corporation's design tools,  logic functions and other\n" +
                        "-- software and  tools, and its AMPP partner logic functions, and any output\n" +
                        "-- files any  of the foregoing (including  device programming  or simulation\n" +
                        "-- files), and  any associated  documentation  or information  are expressly\n" +
                        "-- subject  to the terms and  conditions of the  Intel FPGA Software License\n" +
                        "-- Agreement, Intel MegaCore Function License Agreement, or other applicable\n" +
                        "-- license agreement,  including,  without limitation,  that your use is for\n" +
                        "-- the  sole  purpose of  programming  logic devices  manufactured by  Intel\n" +
                        "-- and  sold by Intel  or its authorized  distributors. Please refer  to the\n" +
                        "-- applicable agreement for further details.\n" +
                        "-- ---------------------------------------------------------------------------\n" +
                        "\n" +
                        "-- VHDL created from FP_MUL_64_0002\n" +
                        "-- VHDL created on Thu Jun 25 13:10:29 2020\n" +
                        "\n" +
                        "\n" +
                        "library IEEE;\n" +
                        "use IEEE.std_logic_1164.all;\n" +
                        "use IEEE.NUMERIC_STD.all;\n" +
                        "use IEEE.MATH_REAL.all;\n" +
                        "use std.TextIO.all;\n" +
                        "use work.dspba_library_package.all;\n" +
                        "\n" +
                        "LIBRARY altera_mf;\n" +
                        "USE altera_mf.altera_mf_components.all;\n" +
                        "LIBRARY altera_lnsim;\n" +
                        "USE altera_lnsim.altera_lnsim_components.altera_syncram;\n" +
                        "LIBRARY lpm;\n" +
                        "USE lpm.lpm_components.all;\n" +
                        "\n" +
                        "entity FP_MUL_64_0002 is\n" +
                        "    port (\n" +
                        "        a : in std_logic_vector(63 downto 0);  -- float64_m52\n" +
                        "        b : in std_logic_vector(63 downto 0);  -- float64_m52\n" +
                        "        q : out std_logic_vector(63 downto 0);  -- float64_m52\n" +
                        "        clk : in std_logic;\n" +
                        "        areset : in std_logic\n" +
                        "    );\n" +
                        "end FP_MUL_64_0002;\n" +
                        "\n" +
                        "architecture normal of FP_MUL_64_0002 is\n" +
                        "\n" +
                        "    attribute altera_attribute : string;\n" +
                        "    attribute altera_attribute of normal : architecture is \"-name AUTO_SHIFT_REGISTER_RECOGNITION OFF; -name PHYSICAL_SYNTHESIS_REGISTER_DUPLICATION ON; -name MESSAGE_DISABLE 10036; -name MESSAGE_DISABLE 10037; -name MESSAGE_DISABLE 14130; -name MESSAGE_DISABLE 14320; -name MESSAGE_DISABLE 15400; -name MESSAGE_DISABLE 14130; -name MESSAGE_DISABLE 10036; -name MESSAGE_DISABLE 12020; -name MESSAGE_DISABLE 12030; -name MESSAGE_DISABLE 12010; -name MESSAGE_DISABLE 12110; -name MESSAGE_DISABLE 14320; -name MESSAGE_DISABLE 13410; -name MESSAGE_DISABLE 113007\";\n" +
                        "    \n" +
                        "    signal GND_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal VCC_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expX_uid6_fpMulTest_b : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal expY_uid7_fpMulTest_b : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal signX_uid8_fpMulTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal signY_uid9_fpMulTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal cstAllOWE_uid10_fpMulTest_q : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal cstZeroWF_uid11_fpMulTest_q : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal cstAllZWE_uid12_fpMulTest_q : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal frac_x_uid14_fpMulTest_b : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal excZ_x_uid15_fpMulTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excZ_x_uid15_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expXIsMax_uid16_fpMulTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expXIsMax_uid16_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsZero_uid17_fpMulTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsZero_uid17_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsNotZero_uid18_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excI_x_uid19_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excN_x_uid20_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal invExpXIsMax_uid21_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal InvExpXIsZero_uid22_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excR_x_uid23_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal frac_y_uid28_fpMulTest_b : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal excZ_y_uid29_fpMulTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excZ_y_uid29_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expXIsMax_uid30_fpMulTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expXIsMax_uid30_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsZero_uid31_fpMulTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsZero_uid31_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsNotZero_uid32_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excI_y_uid33_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excN_y_uid34_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal invExpXIsMax_uid35_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal InvExpXIsZero_uid36_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excR_y_uid37_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal ofracX_uid40_fpMulTest_q : STD_LOGIC_VECTOR (52 downto 0);\n" +
                        "    signal ofracY_uid43_fpMulTest_q : STD_LOGIC_VECTOR (52 downto 0);\n" +
                        "    signal expSum_uid44_fpMulTest_a : STD_LOGIC_VECTOR (11 downto 0);\n" +
                        "    signal expSum_uid44_fpMulTest_b : STD_LOGIC_VECTOR (11 downto 0);\n" +
                        "    signal expSum_uid44_fpMulTest_o : STD_LOGIC_VECTOR (11 downto 0);\n" +
                        "    signal expSum_uid44_fpMulTest_q : STD_LOGIC_VECTOR (11 downto 0);\n" +
                        "    signal biasInc_uid45_fpMulTest_q : STD_LOGIC_VECTOR (12 downto 0);\n" +
                        "    signal expSumMBias_uid46_fpMulTest_a : STD_LOGIC_VECTOR (14 downto 0);\n" +
                        "    signal expSumMBias_uid46_fpMulTest_b : STD_LOGIC_VECTOR (14 downto 0);\n" +
                        "    signal expSumMBias_uid46_fpMulTest_o : STD_LOGIC_VECTOR (14 downto 0);\n" +
                        "    signal expSumMBias_uid46_fpMulTest_q : STD_LOGIC_VECTOR (13 downto 0);\n" +
                        "    signal signR_uid48_fpMulTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal signR_uid48_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal normalizeBit_uid49_fpMulTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracRPostNormHigh_uid51_fpMulTest_in : STD_LOGIC_VECTOR (104 downto 0);\n" +
                        "    signal fracRPostNormHigh_uid51_fpMulTest_b : STD_LOGIC_VECTOR (52 downto 0);\n" +
                        "    signal fracRPostNormLow_uid52_fpMulTest_in : STD_LOGIC_VECTOR (103 downto 0);\n" +
                        "    signal fracRPostNormLow_uid52_fpMulTest_b : STD_LOGIC_VECTOR (52 downto 0);\n" +
                        "    signal fracRPostNorm_uid53_fpMulTest_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracRPostNorm_uid53_fpMulTest_q : STD_LOGIC_VECTOR (52 downto 0);\n" +
                        "    signal stickyRange_uid54_fpMulTest_in : STD_LOGIC_VECTOR (50 downto 0);\n" +
                        "    signal stickyRange_uid54_fpMulTest_b : STD_LOGIC_VECTOR (50 downto 0);\n" +
                        "    signal extraStickyBitOfProd_uid55_fpMulTest_in : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal extraStickyBitOfProd_uid55_fpMulTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal extraStickyBit_uid56_fpMulTest_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal extraStickyBit_uid56_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal stickyExtendedRange_uid57_fpMulTest_q : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal stickyRangeComparator_uid59_fpMulTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal stickyRangeComparator_uid59_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal sticky_uid60_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracRPostNorm1dto0_uid61_fpMulTest_in : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal fracRPostNorm1dto0_uid61_fpMulTest_b : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal lrs_uid62_fpMulTest_q : STD_LOGIC_VECTOR (2 downto 0);\n" +
                        "    signal roundBitDetectionConstant_uid63_fpMulTest_q : STD_LOGIC_VECTOR (2 downto 0);\n" +
                        "    signal roundBitDetectionPattern_uid64_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal roundBit_uid65_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expFracPreRound_uid66_fpMulTest_q : STD_LOGIC_VECTOR (66 downto 0);\n" +
                        "    signal roundBitAndNormalizationOp_uid68_fpMulTest_q : STD_LOGIC_VECTOR (54 downto 0);\n" +
                        "    signal expFracRPostRounding_uid69_fpMulTest_a : STD_LOGIC_VECTOR (68 downto 0);\n" +
                        "    signal expFracRPostRounding_uid69_fpMulTest_b : STD_LOGIC_VECTOR (68 downto 0);\n" +
                        "    signal expFracRPostRounding_uid69_fpMulTest_o : STD_LOGIC_VECTOR (68 downto 0);\n" +
                        "    signal expFracRPostRounding_uid69_fpMulTest_q : STD_LOGIC_VECTOR (67 downto 0);\n" +
                        "    signal fracRPreExc_uid70_fpMulTest_in : STD_LOGIC_VECTOR (52 downto 0);\n" +
                        "    signal fracRPreExc_uid70_fpMulTest_b : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal expRPreExcExt_uid71_fpMulTest_b : STD_LOGIC_VECTOR (14 downto 0);\n" +
                        "    signal expRPreExc_uid72_fpMulTest_in : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal expRPreExc_uid72_fpMulTest_b : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal expUdf_uid73_fpMulTest_a : STD_LOGIC_VECTOR (16 downto 0);\n" +
                        "    signal expUdf_uid73_fpMulTest_b : STD_LOGIC_VECTOR (16 downto 0);\n" +
                        "    signal expUdf_uid73_fpMulTest_o : STD_LOGIC_VECTOR (16 downto 0);\n" +
                        "    signal expUdf_uid73_fpMulTest_n : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expOvf_uid75_fpMulTest_a : STD_LOGIC_VECTOR (16 downto 0);\n" +
                        "    signal expOvf_uid75_fpMulTest_b : STD_LOGIC_VECTOR (16 downto 0);\n" +
                        "    signal expOvf_uid75_fpMulTest_o : STD_LOGIC_VECTOR (16 downto 0);\n" +
                        "    signal expOvf_uid75_fpMulTest_n : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excXZAndExcYZ_uid76_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excXZAndExcYR_uid77_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excYZAndExcXR_uid78_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excZC3_uid79_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excRZero_uid80_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excXIAndExcYI_uid81_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excXRAndExcYI_uid82_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excYRAndExcXI_uid83_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal ExcROvfAndInReg_uid84_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excRInf_uid85_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excYZAndExcXI_uid86_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excXZAndExcYI_uid87_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal ZeroTimesInf_uid88_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excRNaN_uid89_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal concExc_uid90_fpMulTest_q : STD_LOGIC_VECTOR (2 downto 0);\n" +
                        "    signal excREnc_uid91_fpMulTest_q : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal oneFracRPostExc2_uid92_fpMulTest_q : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal fracRPostExc_uid95_fpMulTest_s : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal fracRPostExc_uid95_fpMulTest_q : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal expRPostExc_uid100_fpMulTest_s : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal expRPostExc_uid100_fpMulTest_q : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal invExcRNaN_uid101_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal signRPostExc_uid102_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal R_uid103_fpMulTest_q : STD_LOGIC_VECTOR (63 downto 0);\n" +
                        "    signal aboveLeftY_mergedSignalTM_uid111_prod_uid47_fpMulTest_q : STD_LOGIC_VECTOR (26 downto 0);\n" +
                        "    signal rightBottomX_mergedSignalTM_uid115_prod_uid47_fpMulTest_q : STD_LOGIC_VECTOR (26 downto 0);\n" +
                        "    signal add0_uid129_prod_uid47_fpMulTest_q : STD_LOGIC_VECTOR (107 downto 0);\n" +
                        "    signal add1sumAHighB_uid132_prod_uid47_fpMulTest_a : STD_LOGIC_VECTOR (81 downto 0);\n" +
                        "    signal add1sumAHighB_uid132_prod_uid47_fpMulTest_b : STD_LOGIC_VECTOR (81 downto 0);\n" +
                        "    signal add1sumAHighB_uid132_prod_uid47_fpMulTest_o : STD_LOGIC_VECTOR (81 downto 0);\n" +
                        "    signal add1sumAHighB_uid132_prod_uid47_fpMulTest_q : STD_LOGIC_VECTOR (81 downto 0);\n" +
                        "    signal add1_uid133_prod_uid47_fpMulTest_q : STD_LOGIC_VECTOR (108 downto 0);\n" +
                        "    signal osig_uid134_prod_uid47_fpMulTest_in : STD_LOGIC_VECTOR (107 downto 0);\n" +
                        "    signal osig_uid134_prod_uid47_fpMulTest_b : STD_LOGIC_VECTOR (105 downto 0);\n" +
                        "    signal topProd_uid107_prod_uid47_fpMulTest_cma_reset : std_logic;\n" +
                        "    type topProd_uid107_prod_uid47_fpMulTest_cma_a0type is array(NATURAL range <>) of UNSIGNED(26 downto 0);\n" +
                        "    signal topProd_uid107_prod_uid47_fpMulTest_cma_a0 : topProd_uid107_prod_uid47_fpMulTest_cma_a0type(0 to 0);\n" +
                        "    attribute preserve : boolean;\n" +
                        "    attribute preserve of topProd_uid107_prod_uid47_fpMulTest_cma_a0 : signal is true;\n" +
                        "    signal topProd_uid107_prod_uid47_fpMulTest_cma_c0 : topProd_uid107_prod_uid47_fpMulTest_cma_a0type(0 to 0);\n" +
                        "    attribute preserve of topProd_uid107_prod_uid47_fpMulTest_cma_c0 : signal is true;\n" +
                        "    type topProd_uid107_prod_uid47_fpMulTest_cma_ptype is array(NATURAL range <>) of UNSIGNED(53 downto 0);\n" +
                        "    signal topProd_uid107_prod_uid47_fpMulTest_cma_p : topProd_uid107_prod_uid47_fpMulTest_cma_ptype(0 to 0);\n" +
                        "    signal topProd_uid107_prod_uid47_fpMulTest_cma_u : topProd_uid107_prod_uid47_fpMulTest_cma_ptype(0 to 0);\n" +
                        "    signal topProd_uid107_prod_uid47_fpMulTest_cma_w : topProd_uid107_prod_uid47_fpMulTest_cma_ptype(0 to 0);\n" +
                        "    signal topProd_uid107_prod_uid47_fpMulTest_cma_x : topProd_uid107_prod_uid47_fpMulTest_cma_ptype(0 to 0);\n" +
                        "    signal topProd_uid107_prod_uid47_fpMulTest_cma_y : topProd_uid107_prod_uid47_fpMulTest_cma_ptype(0 to 0);\n" +
                        "    signal topProd_uid107_prod_uid47_fpMulTest_cma_s : topProd_uid107_prod_uid47_fpMulTest_cma_ptype(0 to 0);\n" +
                        "    signal topProd_uid107_prod_uid47_fpMulTest_cma_qq : STD_LOGIC_VECTOR (53 downto 0);\n" +
                        "    signal topProd_uid107_prod_uid47_fpMulTest_cma_q : STD_LOGIC_VECTOR (53 downto 0);\n" +
                        "    signal topProd_uid107_prod_uid47_fpMulTest_cma_ena0 : std_logic;\n" +
                        "    signal topProd_uid107_prod_uid47_fpMulTest_cma_ena1 : std_logic;\n" +
                        "    signal sm0_uid128_prod_uid47_fpMulTest_cma_reset : std_logic;\n" +
                        "    signal sm0_uid128_prod_uid47_fpMulTest_cma_a0 : topProd_uid107_prod_uid47_fpMulTest_cma_a0type(0 to 0);\n" +
                        "    attribute preserve of sm0_uid128_prod_uid47_fpMulTest_cma_a0 : signal is true;\n" +
                        "    signal sm0_uid128_prod_uid47_fpMulTest_cma_c0 : topProd_uid107_prod_uid47_fpMulTest_cma_a0type(0 to 0);\n" +
                        "    attribute preserve of sm0_uid128_prod_uid47_fpMulTest_cma_c0 : signal is true;\n" +
                        "    signal sm0_uid128_prod_uid47_fpMulTest_cma_p : topProd_uid107_prod_uid47_fpMulTest_cma_ptype(0 to 0);\n" +
                        "    signal sm0_uid128_prod_uid47_fpMulTest_cma_u : topProd_uid107_prod_uid47_fpMulTest_cma_ptype(0 to 0);\n" +
                        "    signal sm0_uid128_prod_uid47_fpMulTest_cma_w : topProd_uid107_prod_uid47_fpMulTest_cma_ptype(0 to 0);\n" +
                        "    signal sm0_uid128_prod_uid47_fpMulTest_cma_x : topProd_uid107_prod_uid47_fpMulTest_cma_ptype(0 to 0);\n" +
                        "    signal sm0_uid128_prod_uid47_fpMulTest_cma_y : topProd_uid107_prod_uid47_fpMulTest_cma_ptype(0 to 0);\n" +
                        "    signal sm0_uid128_prod_uid47_fpMulTest_cma_s : topProd_uid107_prod_uid47_fpMulTest_cma_ptype(0 to 0);\n" +
                        "    signal sm0_uid128_prod_uid47_fpMulTest_cma_qq : STD_LOGIC_VECTOR (53 downto 0);\n" +
                        "    signal sm0_uid128_prod_uid47_fpMulTest_cma_q : STD_LOGIC_VECTOR (53 downto 0);\n" +
                        "    signal sm0_uid128_prod_uid47_fpMulTest_cma_ena0 : std_logic;\n" +
                        "    signal sm0_uid128_prod_uid47_fpMulTest_cma_ena1 : std_logic;\n" +
                        "    signal multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_reset : std_logic;\n" +
                        "    signal multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_a0 : topProd_uid107_prod_uid47_fpMulTest_cma_a0type(0 to 1);\n" +
                        "    attribute preserve of multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_a0 : signal is true;\n" +
                        "    signal multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_c0 : topProd_uid107_prod_uid47_fpMulTest_cma_a0type(0 to 1);\n" +
                        "    attribute preserve of multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_c0 : signal is true;\n" +
                        "    signal multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_p : topProd_uid107_prod_uid47_fpMulTest_cma_ptype(0 to 1);\n" +
                        "    type multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_utype is array(NATURAL range <>) of UNSIGNED(54 downto 0);\n" +
                        "    signal multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_u : multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_utype(0 to 1);\n" +
                        "    signal multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_w : multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_utype(0 to 0);\n" +
                        "    signal multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_x : multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_utype(0 to 0);\n" +
                        "    signal multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_y : multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_utype(0 to 0);\n" +
                        "    signal multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_s : multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_utype(0 to 0);\n" +
                        "    signal multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_qq : STD_LOGIC_VECTOR (54 downto 0);\n" +
                        "    signal multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_q : STD_LOGIC_VECTOR (54 downto 0);\n" +
                        "    signal multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_ena0 : std_logic;\n" +
                        "    signal multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_ena1 : std_logic;\n" +
                        "    signal topRangeX_uid105_prod_uid47_fpMulTest_merged_bit_select_b : STD_LOGIC_VECTOR (26 downto 0);\n" +
                        "    signal topRangeX_uid105_prod_uid47_fpMulTest_merged_bit_select_c : STD_LOGIC_VECTOR (25 downto 0);\n" +
                        "    signal topRangeY_uid106_prod_uid47_fpMulTest_merged_bit_select_b : STD_LOGIC_VECTOR (26 downto 0);\n" +
                        "    signal topRangeY_uid106_prod_uid47_fpMulTest_merged_bit_select_c : STD_LOGIC_VECTOR (25 downto 0);\n" +
                        "    signal lowRangeB_uid130_prod_uid47_fpMulTest_merged_bit_select_b : STD_LOGIC_VECTOR (26 downto 0);\n" +
                        "    signal lowRangeB_uid130_prod_uid47_fpMulTest_merged_bit_select_c : STD_LOGIC_VECTOR (80 downto 0);\n" +
                        "    signal redist0_osig_uid134_prod_uid47_fpMulTest_b_1_q : STD_LOGIC_VECTOR (105 downto 0);\n" +
                        "    signal redist1_expRPreExc_uid72_fpMulTest_b_1_q : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal redist2_fracRPreExc_uid70_fpMulTest_b_1_q : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal redist3_normalizeBit_uid49_fpMulTest_b_1_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist4_signR_uid48_fpMulTest_q_5_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist5_expSum_uid44_fpMulTest_q_3_q : STD_LOGIC_VECTOR (11 downto 0);\n" +
                        "    signal redist6_fracXIsZero_uid31_fpMulTest_q_5_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist7_expXIsMax_uid30_fpMulTest_q_5_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist8_excZ_y_uid29_fpMulTest_q_5_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist9_fracXIsZero_uid17_fpMulTest_q_5_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist10_expXIsMax_uid16_fpMulTest_q_5_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist11_excZ_x_uid15_fpMulTest_q_5_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "\n" +
                        "    -- frac_x_uid14_fpMulTest(BITSELECT,13)@0\n" +
                        "    frac_x_uid14_fpMulTest_b <= a(51 downto 0);\n" +
                        "\n" +
                        "    -- cstZeroWF_uid11_fpMulTest(CONSTANT,10)\n" +
                        "    cstZeroWF_uid11_fpMulTest_q <= \"0000000000000000000000000000000000000000000000000000\";\n" +
                        "\n" +
                        "    -- fracXIsZero_uid17_fpMulTest(LOGICAL,16)@0 + 1\n" +
                        "    fracXIsZero_uid17_fpMulTest_qi <= \"1\" WHEN cstZeroWF_uid11_fpMulTest_q = frac_x_uid14_fpMulTest_b ELSE \"0\";\n" +
                        "    fracXIsZero_uid17_fpMulTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => fracXIsZero_uid17_fpMulTest_qi, xout => fracXIsZero_uid17_fpMulTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist9_fracXIsZero_uid17_fpMulTest_q_5(DELAY,150)\n" +
                        "    redist9_fracXIsZero_uid17_fpMulTest_q_5 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 4, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => fracXIsZero_uid17_fpMulTest_q, xout => redist9_fracXIsZero_uid17_fpMulTest_q_5_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- cstAllOWE_uid10_fpMulTest(CONSTANT,9)\n" +
                        "    cstAllOWE_uid10_fpMulTest_q <= \"11111111111\";\n" +
                        "\n" +
                        "    -- expX_uid6_fpMulTest(BITSELECT,5)@0\n" +
                        "    expX_uid6_fpMulTest_b <= a(62 downto 52);\n" +
                        "\n" +
                        "    -- expXIsMax_uid16_fpMulTest(LOGICAL,15)@0 + 1\n" +
                        "    expXIsMax_uid16_fpMulTest_qi <= \"1\" WHEN expX_uid6_fpMulTest_b = cstAllOWE_uid10_fpMulTest_q ELSE \"0\";\n" +
                        "    expXIsMax_uid16_fpMulTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => expXIsMax_uid16_fpMulTest_qi, xout => expXIsMax_uid16_fpMulTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist10_expXIsMax_uid16_fpMulTest_q_5(DELAY,151)\n" +
                        "    redist10_expXIsMax_uid16_fpMulTest_q_5 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 4, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => expXIsMax_uid16_fpMulTest_q, xout => redist10_expXIsMax_uid16_fpMulTest_q_5_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- excI_x_uid19_fpMulTest(LOGICAL,18)@5\n" +
                        "    excI_x_uid19_fpMulTest_q <= redist10_expXIsMax_uid16_fpMulTest_q_5_q and redist9_fracXIsZero_uid17_fpMulTest_q_5_q;\n" +
                        "\n" +
                        "    -- cstAllZWE_uid12_fpMulTest(CONSTANT,11)\n" +
                        "    cstAllZWE_uid12_fpMulTest_q <= \"00000000000\";\n" +
                        "\n" +
                        "    -- expY_uid7_fpMulTest(BITSELECT,6)@0\n" +
                        "    expY_uid7_fpMulTest_b <= b(62 downto 52);\n" +
                        "\n" +
                        "    -- excZ_y_uid29_fpMulTest(LOGICAL,28)@0 + 1\n" +
                        "    excZ_y_uid29_fpMulTest_qi <= \"1\" WHEN expY_uid7_fpMulTest_b = cstAllZWE_uid12_fpMulTest_q ELSE \"0\";\n" +
                        "    excZ_y_uid29_fpMulTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => excZ_y_uid29_fpMulTest_qi, xout => excZ_y_uid29_fpMulTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist8_excZ_y_uid29_fpMulTest_q_5(DELAY,149)\n" +
                        "    redist8_excZ_y_uid29_fpMulTest_q_5 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 4, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => excZ_y_uid29_fpMulTest_q, xout => redist8_excZ_y_uid29_fpMulTest_q_5_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- excYZAndExcXI_uid86_fpMulTest(LOGICAL,85)@5\n" +
                        "    excYZAndExcXI_uid86_fpMulTest_q <= redist8_excZ_y_uid29_fpMulTest_q_5_q and excI_x_uid19_fpMulTest_q;\n" +
                        "\n" +
                        "    -- frac_y_uid28_fpMulTest(BITSELECT,27)@0\n" +
                        "    frac_y_uid28_fpMulTest_b <= b(51 downto 0);\n" +
                        "\n" +
                        "    -- fracXIsZero_uid31_fpMulTest(LOGICAL,30)@0 + 1\n" +
                        "    fracXIsZero_uid31_fpMulTest_qi <= \"1\" WHEN cstZeroWF_uid11_fpMulTest_q = frac_y_uid28_fpMulTest_b ELSE \"0\";\n" +
                        "    fracXIsZero_uid31_fpMulTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => fracXIsZero_uid31_fpMulTest_qi, xout => fracXIsZero_uid31_fpMulTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist6_fracXIsZero_uid31_fpMulTest_q_5(DELAY,147)\n" +
                        "    redist6_fracXIsZero_uid31_fpMulTest_q_5 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 4, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => fracXIsZero_uid31_fpMulTest_q, xout => redist6_fracXIsZero_uid31_fpMulTest_q_5_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- expXIsMax_uid30_fpMulTest(LOGICAL,29)@0 + 1\n" +
                        "    expXIsMax_uid30_fpMulTest_qi <= \"1\" WHEN expY_uid7_fpMulTest_b = cstAllOWE_uid10_fpMulTest_q ELSE \"0\";\n" +
                        "    expXIsMax_uid30_fpMulTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => expXIsMax_uid30_fpMulTest_qi, xout => expXIsMax_uid30_fpMulTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist7_expXIsMax_uid30_fpMulTest_q_5(DELAY,148)\n" +
                        "    redist7_expXIsMax_uid30_fpMulTest_q_5 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 4, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => expXIsMax_uid30_fpMulTest_q, xout => redist7_expXIsMax_uid30_fpMulTest_q_5_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- excI_y_uid33_fpMulTest(LOGICAL,32)@5\n" +
                        "    excI_y_uid33_fpMulTest_q <= redist7_expXIsMax_uid30_fpMulTest_q_5_q and redist6_fracXIsZero_uid31_fpMulTest_q_5_q;\n" +
                        "\n" +
                        "    -- excZ_x_uid15_fpMulTest(LOGICAL,14)@0 + 1\n" +
                        "    excZ_x_uid15_fpMulTest_qi <= \"1\" WHEN expX_uid6_fpMulTest_b = cstAllZWE_uid12_fpMulTest_q ELSE \"0\";\n" +
                        "    excZ_x_uid15_fpMulTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => excZ_x_uid15_fpMulTest_qi, xout => excZ_x_uid15_fpMulTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist11_excZ_x_uid15_fpMulTest_q_5(DELAY,152)\n" +
                        "    redist11_excZ_x_uid15_fpMulTest_q_5 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 4, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => excZ_x_uid15_fpMulTest_q, xout => redist11_excZ_x_uid15_fpMulTest_q_5_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- excXZAndExcYI_uid87_fpMulTest(LOGICAL,86)@5\n" +
                        "    excXZAndExcYI_uid87_fpMulTest_q <= redist11_excZ_x_uid15_fpMulTest_q_5_q and excI_y_uid33_fpMulTest_q;\n" +
                        "\n" +
                        "    -- ZeroTimesInf_uid88_fpMulTest(LOGICAL,87)@5\n" +
                        "    ZeroTimesInf_uid88_fpMulTest_q <= excXZAndExcYI_uid87_fpMulTest_q or excYZAndExcXI_uid86_fpMulTest_q;\n" +
                        "\n" +
                        "    -- fracXIsNotZero_uid32_fpMulTest(LOGICAL,31)@5\n" +
                        "    fracXIsNotZero_uid32_fpMulTest_q <= not (redist6_fracXIsZero_uid31_fpMulTest_q_5_q);\n" +
                        "\n" +
                        "    -- excN_y_uid34_fpMulTest(LOGICAL,33)@5\n" +
                        "    excN_y_uid34_fpMulTest_q <= redist7_expXIsMax_uid30_fpMulTest_q_5_q and fracXIsNotZero_uid32_fpMulTest_q;\n" +
                        "\n" +
                        "    -- fracXIsNotZero_uid18_fpMulTest(LOGICAL,17)@5\n" +
                        "    fracXIsNotZero_uid18_fpMulTest_q <= not (redist9_fracXIsZero_uid17_fpMulTest_q_5_q);\n" +
                        "\n" +
                        "    -- excN_x_uid20_fpMulTest(LOGICAL,19)@5\n" +
                        "    excN_x_uid20_fpMulTest_q <= redist10_expXIsMax_uid16_fpMulTest_q_5_q and fracXIsNotZero_uid18_fpMulTest_q;\n" +
                        "\n" +
                        "    -- excRNaN_uid89_fpMulTest(LOGICAL,88)@5\n" +
                        "    excRNaN_uid89_fpMulTest_q <= excN_x_uid20_fpMulTest_q or excN_y_uid34_fpMulTest_q or ZeroTimesInf_uid88_fpMulTest_q;\n" +
                        "\n" +
                        "    -- invExcRNaN_uid101_fpMulTest(LOGICAL,100)@5\n" +
                        "    invExcRNaN_uid101_fpMulTest_q <= not (excRNaN_uid89_fpMulTest_q);\n" +
                        "\n" +
                        "    -- signY_uid9_fpMulTest(BITSELECT,8)@0\n" +
                        "    signY_uid9_fpMulTest_b <= STD_LOGIC_VECTOR(b(63 downto 63));\n" +
                        "\n" +
                        "    -- signX_uid8_fpMulTest(BITSELECT,7)@0\n" +
                        "    signX_uid8_fpMulTest_b <= STD_LOGIC_VECTOR(a(63 downto 63));\n" +
                        "\n" +
                        "    -- signR_uid48_fpMulTest(LOGICAL,47)@0 + 1\n" +
                        "    signR_uid48_fpMulTest_qi <= signX_uid8_fpMulTest_b xor signY_uid9_fpMulTest_b;\n" +
                        "    signR_uid48_fpMulTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => signR_uid48_fpMulTest_qi, xout => signR_uid48_fpMulTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist4_signR_uid48_fpMulTest_q_5(DELAY,145)\n" +
                        "    redist4_signR_uid48_fpMulTest_q_5 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 4, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => signR_uid48_fpMulTest_q, xout => redist4_signR_uid48_fpMulTest_q_5_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- VCC(CONSTANT,1)\n" +
                        "    VCC_q <= \"1\";\n" +
                        "\n" +
                        "    -- signRPostExc_uid102_fpMulTest(LOGICAL,101)@5\n" +
                        "    signRPostExc_uid102_fpMulTest_q <= redist4_signR_uid48_fpMulTest_q_5_q and invExcRNaN_uid101_fpMulTest_q;\n" +
                        "\n" +
                        "    -- GND(CONSTANT,0)\n" +
                        "    GND_q <= \"0\";\n" +
                        "\n" +
                        "    -- ofracX_uid40_fpMulTest(BITJOIN,39)@0\n" +
                        "    ofracX_uid40_fpMulTest_q <= VCC_q & frac_x_uid14_fpMulTest_b;\n" +
                        "\n" +
                        "    -- topRangeX_uid105_prod_uid47_fpMulTest_merged_bit_select(BITSELECT,138)@0\n" +
                        "    topRangeX_uid105_prod_uid47_fpMulTest_merged_bit_select_b <= ofracX_uid40_fpMulTest_q(52 downto 26);\n" +
                        "    topRangeX_uid105_prod_uid47_fpMulTest_merged_bit_select_c <= ofracX_uid40_fpMulTest_q(25 downto 0);\n" +
                        "\n" +
                        "    -- aboveLeftY_mergedSignalTM_uid111_prod_uid47_fpMulTest(BITJOIN,110)@0\n" +
                        "    aboveLeftY_mergedSignalTM_uid111_prod_uid47_fpMulTest_q <= topRangeY_uid106_prod_uid47_fpMulTest_merged_bit_select_c & GND_q;\n" +
                        "\n" +
                        "    -- rightBottomX_mergedSignalTM_uid115_prod_uid47_fpMulTest(BITJOIN,114)@0\n" +
                        "    rightBottomX_mergedSignalTM_uid115_prod_uid47_fpMulTest_q <= topRangeX_uid105_prod_uid47_fpMulTest_merged_bit_select_c & GND_q;\n" +
                        "\n" +
                        "    -- ofracY_uid43_fpMulTest(BITJOIN,42)@0\n" +
                        "    ofracY_uid43_fpMulTest_q <= VCC_q & frac_y_uid28_fpMulTest_b;\n" +
                        "\n" +
                        "    -- topRangeY_uid106_prod_uid47_fpMulTest_merged_bit_select(BITSELECT,139)@0\n" +
                        "    topRangeY_uid106_prod_uid47_fpMulTest_merged_bit_select_b <= ofracY_uid43_fpMulTest_q(52 downto 26);\n" +
                        "    topRangeY_uid106_prod_uid47_fpMulTest_merged_bit_select_c <= ofracY_uid43_fpMulTest_q(25 downto 0);\n" +
                        "\n" +
                        "    -- multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma(CHAINMULTADD,137)@0 + 2\n" +
                        "    multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_reset <= areset;\n" +
                        "    multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_ena0 <= '1';\n" +
                        "    multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_ena1 <= multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_ena0;\n" +
                        "    multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_p(0) <= multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_a0(0) * multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_c0(0);\n" +
                        "    multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_p(1) <= multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_a0(1) * multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_c0(1);\n" +
                        "    multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_u(0) <= RESIZE(multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_p(0),55);\n" +
                        "    multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_u(1) <= RESIZE(multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_p(1),55);\n" +
                        "    multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_w(0) <= multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_u(0) + multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_u(1);\n" +
                        "    multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_x(0) <= multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_w(0);\n" +
                        "    multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_y(0) <= multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_x(0);\n" +
                        "    multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_chainmultadd_input: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_a0 <= (others => (others => '0'));\n" +
                        "            multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_c0 <= (others => (others => '0'));\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            IF (multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_ena0 = '1') THEN\n" +
                        "                multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_a0(0) <= RESIZE(UNSIGNED(topRangeY_uid106_prod_uid47_fpMulTest_merged_bit_select_b),27);\n" +
                        "                multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_a0(1) <= RESIZE(UNSIGNED(aboveLeftY_mergedSignalTM_uid111_prod_uid47_fpMulTest_q),27);\n" +
                        "                multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_c0(0) <= RESIZE(UNSIGNED(rightBottomX_mergedSignalTM_uid115_prod_uid47_fpMulTest_q),27);\n" +
                        "                multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_c0(1) <= RESIZE(UNSIGNED(topRangeX_uid105_prod_uid47_fpMulTest_merged_bit_select_b),27);\n" +
                        "            END IF;\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "    multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_chainmultadd_output: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_s <= (others => (others => '0'));\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            IF (multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_ena1 = '1') THEN\n" +
                        "                multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_s(0) <= multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_y(0);\n" +
                        "            END IF;\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "    multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 55, depth => 0, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => STD_LOGIC_VECTOR(multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_s(0)(54 downto 0)), xout => multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_qq, clk => clk, aclr => areset );\n" +
                        "    multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_q <= STD_LOGIC_VECTOR(multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_qq(54 downto 0));\n" +
                        "\n" +
                        "    -- add1sumAHighB_uid132_prod_uid47_fpMulTest(ADD,131)@2\n" +
                        "    add1sumAHighB_uid132_prod_uid47_fpMulTest_a <= STD_LOGIC_VECTOR(\"000000000000000000000000000\" & multSumOfTwoTS_uid118_prod_uid47_fpMulTest_cma_q);\n" +
                        "    add1sumAHighB_uid132_prod_uid47_fpMulTest_b <= STD_LOGIC_VECTOR(\"0\" & lowRangeB_uid130_prod_uid47_fpMulTest_merged_bit_select_c);\n" +
                        "    add1sumAHighB_uid132_prod_uid47_fpMulTest_o <= STD_LOGIC_VECTOR(UNSIGNED(add1sumAHighB_uid132_prod_uid47_fpMulTest_a) + UNSIGNED(add1sumAHighB_uid132_prod_uid47_fpMulTest_b));\n" +
                        "    add1sumAHighB_uid132_prod_uid47_fpMulTest_q <= add1sumAHighB_uid132_prod_uid47_fpMulTest_o(81 downto 0);\n" +
                        "\n" +
                        "    -- topProd_uid107_prod_uid47_fpMulTest_cma(CHAINMULTADD,135)@0 + 2\n" +
                        "    topProd_uid107_prod_uid47_fpMulTest_cma_reset <= areset;\n" +
                        "    topProd_uid107_prod_uid47_fpMulTest_cma_ena0 <= '1';\n" +
                        "    topProd_uid107_prod_uid47_fpMulTest_cma_ena1 <= topProd_uid107_prod_uid47_fpMulTest_cma_ena0;\n" +
                        "    topProd_uid107_prod_uid47_fpMulTest_cma_p(0) <= topProd_uid107_prod_uid47_fpMulTest_cma_a0(0) * topProd_uid107_prod_uid47_fpMulTest_cma_c0(0);\n" +
                        "    topProd_uid107_prod_uid47_fpMulTest_cma_u(0) <= RESIZE(topProd_uid107_prod_uid47_fpMulTest_cma_p(0),54);\n" +
                        "    topProd_uid107_prod_uid47_fpMulTest_cma_w(0) <= topProd_uid107_prod_uid47_fpMulTest_cma_u(0);\n" +
                        "    topProd_uid107_prod_uid47_fpMulTest_cma_x(0) <= topProd_uid107_prod_uid47_fpMulTest_cma_w(0);\n" +
                        "    topProd_uid107_prod_uid47_fpMulTest_cma_y(0) <= topProd_uid107_prod_uid47_fpMulTest_cma_x(0);\n" +
                        "    topProd_uid107_prod_uid47_fpMulTest_cma_chainmultadd_input: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            topProd_uid107_prod_uid47_fpMulTest_cma_a0 <= (others => (others => '0'));\n" +
                        "            topProd_uid107_prod_uid47_fpMulTest_cma_c0 <= (others => (others => '0'));\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            IF (topProd_uid107_prod_uid47_fpMulTest_cma_ena0 = '1') THEN\n" +
                        "                topProd_uid107_prod_uid47_fpMulTest_cma_a0(0) <= RESIZE(UNSIGNED(topRangeX_uid105_prod_uid47_fpMulTest_merged_bit_select_b),27);\n" +
                        "                topProd_uid107_prod_uid47_fpMulTest_cma_c0(0) <= RESIZE(UNSIGNED(topRangeY_uid106_prod_uid47_fpMulTest_merged_bit_select_b),27);\n" +
                        "            END IF;\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "    topProd_uid107_prod_uid47_fpMulTest_cma_chainmultadd_output: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            topProd_uid107_prod_uid47_fpMulTest_cma_s <= (others => (others => '0'));\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            IF (topProd_uid107_prod_uid47_fpMulTest_cma_ena1 = '1') THEN\n" +
                        "                topProd_uid107_prod_uid47_fpMulTest_cma_s(0) <= topProd_uid107_prod_uid47_fpMulTest_cma_y(0);\n" +
                        "            END IF;\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "    topProd_uid107_prod_uid47_fpMulTest_cma_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 54, depth => 0, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => STD_LOGIC_VECTOR(topProd_uid107_prod_uid47_fpMulTest_cma_s(0)(53 downto 0)), xout => topProd_uid107_prod_uid47_fpMulTest_cma_qq, clk => clk, aclr => areset );\n" +
                        "    topProd_uid107_prod_uid47_fpMulTest_cma_q <= STD_LOGIC_VECTOR(topProd_uid107_prod_uid47_fpMulTest_cma_qq(53 downto 0));\n" +
                        "\n" +
                        "    -- sm0_uid128_prod_uid47_fpMulTest_cma(CHAINMULTADD,136)@0 + 2\n" +
                        "    sm0_uid128_prod_uid47_fpMulTest_cma_reset <= areset;\n" +
                        "    sm0_uid128_prod_uid47_fpMulTest_cma_ena0 <= '1';\n" +
                        "    sm0_uid128_prod_uid47_fpMulTest_cma_ena1 <= sm0_uid128_prod_uid47_fpMulTest_cma_ena0;\n" +
                        "    sm0_uid128_prod_uid47_fpMulTest_cma_p(0) <= sm0_uid128_prod_uid47_fpMulTest_cma_a0(0) * sm0_uid128_prod_uid47_fpMulTest_cma_c0(0);\n" +
                        "    sm0_uid128_prod_uid47_fpMulTest_cma_u(0) <= RESIZE(sm0_uid128_prod_uid47_fpMulTest_cma_p(0),54);\n" +
                        "    sm0_uid128_prod_uid47_fpMulTest_cma_w(0) <= sm0_uid128_prod_uid47_fpMulTest_cma_u(0);\n" +
                        "    sm0_uid128_prod_uid47_fpMulTest_cma_x(0) <= sm0_uid128_prod_uid47_fpMulTest_cma_w(0);\n" +
                        "    sm0_uid128_prod_uid47_fpMulTest_cma_y(0) <= sm0_uid128_prod_uid47_fpMulTest_cma_x(0);\n" +
                        "    sm0_uid128_prod_uid47_fpMulTest_cma_chainmultadd_input: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            sm0_uid128_prod_uid47_fpMulTest_cma_a0 <= (others => (others => '0'));\n" +
                        "            sm0_uid128_prod_uid47_fpMulTest_cma_c0 <= (others => (others => '0'));\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            IF (sm0_uid128_prod_uid47_fpMulTest_cma_ena0 = '1') THEN\n" +
                        "                sm0_uid128_prod_uid47_fpMulTest_cma_a0(0) <= RESIZE(UNSIGNED(rightBottomX_mergedSignalTM_uid115_prod_uid47_fpMulTest_q),27);\n" +
                        "                sm0_uid128_prod_uid47_fpMulTest_cma_c0(0) <= RESIZE(UNSIGNED(aboveLeftY_mergedSignalTM_uid111_prod_uid47_fpMulTest_q),27);\n" +
                        "            END IF;\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "    sm0_uid128_prod_uid47_fpMulTest_cma_chainmultadd_output: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            sm0_uid128_prod_uid47_fpMulTest_cma_s <= (others => (others => '0'));\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            IF (sm0_uid128_prod_uid47_fpMulTest_cma_ena1 = '1') THEN\n" +
                        "                sm0_uid128_prod_uid47_fpMulTest_cma_s(0) <= sm0_uid128_prod_uid47_fpMulTest_cma_y(0);\n" +
                        "            END IF;\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "    sm0_uid128_prod_uid47_fpMulTest_cma_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 54, depth => 0, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => STD_LOGIC_VECTOR(sm0_uid128_prod_uid47_fpMulTest_cma_s(0)(53 downto 0)), xout => sm0_uid128_prod_uid47_fpMulTest_cma_qq, clk => clk, aclr => areset );\n" +
                        "    sm0_uid128_prod_uid47_fpMulTest_cma_q <= STD_LOGIC_VECTOR(sm0_uid128_prod_uid47_fpMulTest_cma_qq(53 downto 0));\n" +
                        "\n" +
                        "    -- add0_uid129_prod_uid47_fpMulTest(BITJOIN,128)@2\n" +
                        "    add0_uid129_prod_uid47_fpMulTest_q <= topProd_uid107_prod_uid47_fpMulTest_cma_q & sm0_uid128_prod_uid47_fpMulTest_cma_q;\n" +
                        "\n" +
                        "    -- lowRangeB_uid130_prod_uid47_fpMulTest_merged_bit_select(BITSELECT,140)@2\n" +
                        "    lowRangeB_uid130_prod_uid47_fpMulTest_merged_bit_select_b <= add0_uid129_prod_uid47_fpMulTest_q(26 downto 0);\n" +
                        "    lowRangeB_uid130_prod_uid47_fpMulTest_merged_bit_select_c <= add0_uid129_prod_uid47_fpMulTest_q(107 downto 27);\n" +
                        "\n" +
                        "    -- add1_uid133_prod_uid47_fpMulTest(BITJOIN,132)@2\n" +
                        "    add1_uid133_prod_uid47_fpMulTest_q <= add1sumAHighB_uid132_prod_uid47_fpMulTest_q & lowRangeB_uid130_prod_uid47_fpMulTest_merged_bit_select_b;\n" +
                        "\n" +
                        "    -- osig_uid134_prod_uid47_fpMulTest(BITSELECT,133)@2\n" +
                        "    osig_uid134_prod_uid47_fpMulTest_in <= add1_uid133_prod_uid47_fpMulTest_q(107 downto 0);\n" +
                        "    osig_uid134_prod_uid47_fpMulTest_b <= osig_uid134_prod_uid47_fpMulTest_in(107 downto 2);\n" +
                        "\n" +
                        "    -- redist0_osig_uid134_prod_uid47_fpMulTest_b_1(DELAY,141)\n" +
                        "    redist0_osig_uid134_prod_uid47_fpMulTest_b_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 106, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => osig_uid134_prod_uid47_fpMulTest_b, xout => redist0_osig_uid134_prod_uid47_fpMulTest_b_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- normalizeBit_uid49_fpMulTest(BITSELECT,48)@3\n" +
                        "    normalizeBit_uid49_fpMulTest_b <= STD_LOGIC_VECTOR(redist0_osig_uid134_prod_uid47_fpMulTest_b_1_q(105 downto 105));\n" +
                        "\n" +
                        "    -- redist3_normalizeBit_uid49_fpMulTest_b_1(DELAY,144)\n" +
                        "    redist3_normalizeBit_uid49_fpMulTest_b_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => normalizeBit_uid49_fpMulTest_b, xout => redist3_normalizeBit_uid49_fpMulTest_b_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- roundBitDetectionConstant_uid63_fpMulTest(CONSTANT,62)\n" +
                        "    roundBitDetectionConstant_uid63_fpMulTest_q <= \"010\";\n" +
                        "\n" +
                        "    -- fracRPostNormHigh_uid51_fpMulTest(BITSELECT,50)@3\n" +
                        "    fracRPostNormHigh_uid51_fpMulTest_in <= redist0_osig_uid134_prod_uid47_fpMulTest_b_1_q(104 downto 0);\n" +
                        "    fracRPostNormHigh_uid51_fpMulTest_b <= fracRPostNormHigh_uid51_fpMulTest_in(104 downto 52);\n" +
                        "\n" +
                        "    -- fracRPostNormLow_uid52_fpMulTest(BITSELECT,51)@3\n" +
                        "    fracRPostNormLow_uid52_fpMulTest_in <= redist0_osig_uid134_prod_uid47_fpMulTest_b_1_q(103 downto 0);\n" +
                        "    fracRPostNormLow_uid52_fpMulTest_b <= fracRPostNormLow_uid52_fpMulTest_in(103 downto 51);\n" +
                        "\n" +
                        "    -- fracRPostNorm_uid53_fpMulTest(MUX,52)@3 + 1\n" +
                        "    fracRPostNorm_uid53_fpMulTest_s <= normalizeBit_uid49_fpMulTest_b;\n" +
                        "    fracRPostNorm_uid53_fpMulTest_clkproc: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            fracRPostNorm_uid53_fpMulTest_q <= (others => '0');\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            CASE (fracRPostNorm_uid53_fpMulTest_s) IS\n" +
                        "                WHEN \"0\" => fracRPostNorm_uid53_fpMulTest_q <= fracRPostNormLow_uid52_fpMulTest_b;\n" +
                        "                WHEN \"1\" => fracRPostNorm_uid53_fpMulTest_q <= fracRPostNormHigh_uid51_fpMulTest_b;\n" +
                        "                WHEN OTHERS => fracRPostNorm_uid53_fpMulTest_q <= (others => '0');\n" +
                        "            END CASE;\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- fracRPostNorm1dto0_uid61_fpMulTest(BITSELECT,60)@4\n" +
                        "    fracRPostNorm1dto0_uid61_fpMulTest_in <= fracRPostNorm_uid53_fpMulTest_q(1 downto 0);\n" +
                        "    fracRPostNorm1dto0_uid61_fpMulTest_b <= fracRPostNorm1dto0_uid61_fpMulTest_in(1 downto 0);\n" +
                        "\n" +
                        "    -- extraStickyBitOfProd_uid55_fpMulTest(BITSELECT,54)@3\n" +
                        "    extraStickyBitOfProd_uid55_fpMulTest_in <= STD_LOGIC_VECTOR(redist0_osig_uid134_prod_uid47_fpMulTest_b_1_q(51 downto 0));\n" +
                        "    extraStickyBitOfProd_uid55_fpMulTest_b <= STD_LOGIC_VECTOR(extraStickyBitOfProd_uid55_fpMulTest_in(51 downto 51));\n" +
                        "\n" +
                        "    -- extraStickyBit_uid56_fpMulTest(MUX,55)@3\n" +
                        "    extraStickyBit_uid56_fpMulTest_s <= normalizeBit_uid49_fpMulTest_b;\n" +
                        "    extraStickyBit_uid56_fpMulTest_combproc: PROCESS (extraStickyBit_uid56_fpMulTest_s, GND_q, extraStickyBitOfProd_uid55_fpMulTest_b)\n" +
                        "    BEGIN\n" +
                        "        CASE (extraStickyBit_uid56_fpMulTest_s) IS\n" +
                        "            WHEN \"0\" => extraStickyBit_uid56_fpMulTest_q <= GND_q;\n" +
                        "            WHEN \"1\" => extraStickyBit_uid56_fpMulTest_q <= extraStickyBitOfProd_uid55_fpMulTest_b;\n" +
                        "            WHEN OTHERS => extraStickyBit_uid56_fpMulTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- stickyRange_uid54_fpMulTest(BITSELECT,53)@3\n" +
                        "    stickyRange_uid54_fpMulTest_in <= redist0_osig_uid134_prod_uid47_fpMulTest_b_1_q(50 downto 0);\n" +
                        "    stickyRange_uid54_fpMulTest_b <= stickyRange_uid54_fpMulTest_in(50 downto 0);\n" +
                        "\n" +
                        "    -- stickyExtendedRange_uid57_fpMulTest(BITJOIN,56)@3\n" +
                        "    stickyExtendedRange_uid57_fpMulTest_q <= extraStickyBit_uid56_fpMulTest_q & stickyRange_uid54_fpMulTest_b;\n" +
                        "\n" +
                        "    -- stickyRangeComparator_uid59_fpMulTest(LOGICAL,58)@3 + 1\n" +
                        "    stickyRangeComparator_uid59_fpMulTest_qi <= \"1\" WHEN stickyExtendedRange_uid57_fpMulTest_q = cstZeroWF_uid11_fpMulTest_q ELSE \"0\";\n" +
                        "    stickyRangeComparator_uid59_fpMulTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => stickyRangeComparator_uid59_fpMulTest_qi, xout => stickyRangeComparator_uid59_fpMulTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- sticky_uid60_fpMulTest(LOGICAL,59)@4\n" +
                        "    sticky_uid60_fpMulTest_q <= not (stickyRangeComparator_uid59_fpMulTest_q);\n" +
                        "\n" +
                        "    -- lrs_uid62_fpMulTest(BITJOIN,61)@4\n" +
                        "    lrs_uid62_fpMulTest_q <= fracRPostNorm1dto0_uid61_fpMulTest_b & sticky_uid60_fpMulTest_q;\n" +
                        "\n" +
                        "    -- roundBitDetectionPattern_uid64_fpMulTest(LOGICAL,63)@4\n" +
                        "    roundBitDetectionPattern_uid64_fpMulTest_q <= \"1\" WHEN lrs_uid62_fpMulTest_q = roundBitDetectionConstant_uid63_fpMulTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- roundBit_uid65_fpMulTest(LOGICAL,64)@4\n" +
                        "    roundBit_uid65_fpMulTest_q <= not (roundBitDetectionPattern_uid64_fpMulTest_q);\n" +
                        "\n" +
                        "    -- roundBitAndNormalizationOp_uid68_fpMulTest(BITJOIN,67)@4\n" +
                        "    roundBitAndNormalizationOp_uid68_fpMulTest_q <= GND_q & redist3_normalizeBit_uid49_fpMulTest_b_1_q & cstZeroWF_uid11_fpMulTest_q & roundBit_uid65_fpMulTest_q;\n" +
                        "\n" +
                        "    -- biasInc_uid45_fpMulTest(CONSTANT,44)\n" +
                        "    biasInc_uid45_fpMulTest_q <= \"0001111111111\";\n" +
                        "\n" +
                        "    -- expSum_uid44_fpMulTest(ADD,43)@0 + 1\n" +
                        "    expSum_uid44_fpMulTest_a <= STD_LOGIC_VECTOR(\"0\" & expX_uid6_fpMulTest_b);\n" +
                        "    expSum_uid44_fpMulTest_b <= STD_LOGIC_VECTOR(\"0\" & expY_uid7_fpMulTest_b);\n" +
                        "    expSum_uid44_fpMulTest_clkproc: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            expSum_uid44_fpMulTest_o <= (others => '0');\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            expSum_uid44_fpMulTest_o <= STD_LOGIC_VECTOR(UNSIGNED(expSum_uid44_fpMulTest_a) + UNSIGNED(expSum_uid44_fpMulTest_b));\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "    expSum_uid44_fpMulTest_q <= expSum_uid44_fpMulTest_o(11 downto 0);\n" +
                        "\n" +
                        "    -- redist5_expSum_uid44_fpMulTest_q_3(DELAY,146)\n" +
                        "    redist5_expSum_uid44_fpMulTest_q_3 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 12, depth => 2, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => expSum_uid44_fpMulTest_q, xout => redist5_expSum_uid44_fpMulTest_q_3_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- expSumMBias_uid46_fpMulTest(SUB,45)@3 + 1\n" +
                        "    expSumMBias_uid46_fpMulTest_a <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR(\"000\" & redist5_expSum_uid44_fpMulTest_q_3_q));\n" +
                        "    expSumMBias_uid46_fpMulTest_b <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR((14 downto 13 => biasInc_uid45_fpMulTest_q(12)) & biasInc_uid45_fpMulTest_q));\n" +
                        "    expSumMBias_uid46_fpMulTest_clkproc: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            expSumMBias_uid46_fpMulTest_o <= (others => '0');\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            expSumMBias_uid46_fpMulTest_o <= STD_LOGIC_VECTOR(SIGNED(expSumMBias_uid46_fpMulTest_a) - SIGNED(expSumMBias_uid46_fpMulTest_b));\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "    expSumMBias_uid46_fpMulTest_q <= expSumMBias_uid46_fpMulTest_o(13 downto 0);\n" +
                        "\n" +
                        "    -- expFracPreRound_uid66_fpMulTest(BITJOIN,65)@4\n" +
                        "    expFracPreRound_uid66_fpMulTest_q <= expSumMBias_uid46_fpMulTest_q & fracRPostNorm_uid53_fpMulTest_q;\n" +
                        "\n" +
                        "    -- expFracRPostRounding_uid69_fpMulTest(ADD,68)@4\n" +
                        "    expFracRPostRounding_uid69_fpMulTest_a <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR((68 downto 67 => expFracPreRound_uid66_fpMulTest_q(66)) & expFracPreRound_uid66_fpMulTest_q));\n" +
                        "    expFracRPostRounding_uid69_fpMulTest_b <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR(\"00000000000000\" & roundBitAndNormalizationOp_uid68_fpMulTest_q));\n" +
                        "    expFracRPostRounding_uid69_fpMulTest_o <= STD_LOGIC_VECTOR(SIGNED(expFracRPostRounding_uid69_fpMulTest_a) + SIGNED(expFracRPostRounding_uid69_fpMulTest_b));\n" +
                        "    expFracRPostRounding_uid69_fpMulTest_q <= expFracRPostRounding_uid69_fpMulTest_o(67 downto 0);\n" +
                        "\n" +
                        "    -- expRPreExcExt_uid71_fpMulTest(BITSELECT,70)@4\n" +
                        "    expRPreExcExt_uid71_fpMulTest_b <= STD_LOGIC_VECTOR(expFracRPostRounding_uid69_fpMulTest_q(67 downto 53));\n" +
                        "\n" +
                        "    -- expRPreExc_uid72_fpMulTest(BITSELECT,71)@4\n" +
                        "    expRPreExc_uid72_fpMulTest_in <= expRPreExcExt_uid71_fpMulTest_b(10 downto 0);\n" +
                        "    expRPreExc_uid72_fpMulTest_b <= expRPreExc_uid72_fpMulTest_in(10 downto 0);\n" +
                        "\n" +
                        "    -- redist1_expRPreExc_uid72_fpMulTest_b_1(DELAY,142)\n" +
                        "    redist1_expRPreExc_uid72_fpMulTest_b_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 11, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => expRPreExc_uid72_fpMulTest_b, xout => redist1_expRPreExc_uid72_fpMulTest_b_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- expOvf_uid75_fpMulTest(COMPARE,74)@4 + 1\n" +
                        "    expOvf_uid75_fpMulTest_a <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR((16 downto 15 => expRPreExcExt_uid71_fpMulTest_b(14)) & expRPreExcExt_uid71_fpMulTest_b));\n" +
                        "    expOvf_uid75_fpMulTest_b <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR(\"000000\" & cstAllOWE_uid10_fpMulTest_q));\n" +
                        "    expOvf_uid75_fpMulTest_clkproc: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            expOvf_uid75_fpMulTest_o <= (others => '0');\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            expOvf_uid75_fpMulTest_o <= STD_LOGIC_VECTOR(SIGNED(expOvf_uid75_fpMulTest_a) - SIGNED(expOvf_uid75_fpMulTest_b));\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "    expOvf_uid75_fpMulTest_n(0) <= not (expOvf_uid75_fpMulTest_o(16));\n" +
                        "\n" +
                        "    -- invExpXIsMax_uid35_fpMulTest(LOGICAL,34)@5\n" +
                        "    invExpXIsMax_uid35_fpMulTest_q <= not (redist7_expXIsMax_uid30_fpMulTest_q_5_q);\n" +
                        "\n" +
                        "    -- InvExpXIsZero_uid36_fpMulTest(LOGICAL,35)@5\n" +
                        "    InvExpXIsZero_uid36_fpMulTest_q <= not (redist8_excZ_y_uid29_fpMulTest_q_5_q);\n" +
                        "\n" +
                        "    -- excR_y_uid37_fpMulTest(LOGICAL,36)@5\n" +
                        "    excR_y_uid37_fpMulTest_q <= InvExpXIsZero_uid36_fpMulTest_q and invExpXIsMax_uid35_fpMulTest_q;\n" +
                        "\n" +
                        "    -- invExpXIsMax_uid21_fpMulTest(LOGICAL,20)@5\n" +
                        "    invExpXIsMax_uid21_fpMulTest_q <= not (redist10_expXIsMax_uid16_fpMulTest_q_5_q);\n" +
                        "\n" +
                        "    -- InvExpXIsZero_uid22_fpMulTest(LOGICAL,21)@5\n" +
                        "    InvExpXIsZero_uid22_fpMulTest_q <= not (redist11_excZ_x_uid15_fpMulTest_q_5_q);\n" +
                        "\n" +
                        "    -- excR_x_uid23_fpMulTest(LOGICAL,22)@5\n" +
                        "    excR_x_uid23_fpMulTest_q <= InvExpXIsZero_uid22_fpMulTest_q and invExpXIsMax_uid21_fpMulTest_q;\n" +
                        "\n" +
                        "    -- ExcROvfAndInReg_uid84_fpMulTest(LOGICAL,83)@5\n" +
                        "    ExcROvfAndInReg_uid84_fpMulTest_q <= excR_x_uid23_fpMulTest_q and excR_y_uid37_fpMulTest_q and expOvf_uid75_fpMulTest_n;\n" +
                        "\n" +
                        "    -- excYRAndExcXI_uid83_fpMulTest(LOGICAL,82)@5\n" +
                        "    excYRAndExcXI_uid83_fpMulTest_q <= excR_y_uid37_fpMulTest_q and excI_x_uid19_fpMulTest_q;\n" +
                        "\n" +
                        "    -- excXRAndExcYI_uid82_fpMulTest(LOGICAL,81)@5\n" +
                        "    excXRAndExcYI_uid82_fpMulTest_q <= excR_x_uid23_fpMulTest_q and excI_y_uid33_fpMulTest_q;\n" +
                        "\n" +
                        "    -- excXIAndExcYI_uid81_fpMulTest(LOGICAL,80)@5\n" +
                        "    excXIAndExcYI_uid81_fpMulTest_q <= excI_x_uid19_fpMulTest_q and excI_y_uid33_fpMulTest_q;\n" +
                        "\n" +
                        "    -- excRInf_uid85_fpMulTest(LOGICAL,84)@5\n" +
                        "    excRInf_uid85_fpMulTest_q <= excXIAndExcYI_uid81_fpMulTest_q or excXRAndExcYI_uid82_fpMulTest_q or excYRAndExcXI_uid83_fpMulTest_q or ExcROvfAndInReg_uid84_fpMulTest_q;\n" +
                        "\n" +
                        "    -- expUdf_uid73_fpMulTest(COMPARE,72)@4 + 1\n" +
                        "    expUdf_uid73_fpMulTest_a <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR(\"0000000000000000\" & GND_q));\n" +
                        "    expUdf_uid73_fpMulTest_b <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR((16 downto 15 => expRPreExcExt_uid71_fpMulTest_b(14)) & expRPreExcExt_uid71_fpMulTest_b));\n" +
                        "    expUdf_uid73_fpMulTest_clkproc: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            expUdf_uid73_fpMulTest_o <= (others => '0');\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            expUdf_uid73_fpMulTest_o <= STD_LOGIC_VECTOR(SIGNED(expUdf_uid73_fpMulTest_a) - SIGNED(expUdf_uid73_fpMulTest_b));\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "    expUdf_uid73_fpMulTest_n(0) <= not (expUdf_uid73_fpMulTest_o(16));\n" +
                        "\n" +
                        "    -- excZC3_uid79_fpMulTest(LOGICAL,78)@5\n" +
                        "    excZC3_uid79_fpMulTest_q <= excR_x_uid23_fpMulTest_q and excR_y_uid37_fpMulTest_q and expUdf_uid73_fpMulTest_n;\n" +
                        "\n" +
                        "    -- excYZAndExcXR_uid78_fpMulTest(LOGICAL,77)@5\n" +
                        "    excYZAndExcXR_uid78_fpMulTest_q <= redist8_excZ_y_uid29_fpMulTest_q_5_q and excR_x_uid23_fpMulTest_q;\n" +
                        "\n" +
                        "    -- excXZAndExcYR_uid77_fpMulTest(LOGICAL,76)@5\n" +
                        "    excXZAndExcYR_uid77_fpMulTest_q <= redist11_excZ_x_uid15_fpMulTest_q_5_q and excR_y_uid37_fpMulTest_q;\n" +
                        "\n" +
                        "    -- excXZAndExcYZ_uid76_fpMulTest(LOGICAL,75)@5\n" +
                        "    excXZAndExcYZ_uid76_fpMulTest_q <= redist11_excZ_x_uid15_fpMulTest_q_5_q and redist8_excZ_y_uid29_fpMulTest_q_5_q;\n" +
                        "\n" +
                        "    -- excRZero_uid80_fpMulTest(LOGICAL,79)@5\n" +
                        "    excRZero_uid80_fpMulTest_q <= excXZAndExcYZ_uid76_fpMulTest_q or excXZAndExcYR_uid77_fpMulTest_q or excYZAndExcXR_uid78_fpMulTest_q or excZC3_uid79_fpMulTest_q;\n" +
                        "\n" +
                        "    -- concExc_uid90_fpMulTest(BITJOIN,89)@5\n" +
                        "    concExc_uid90_fpMulTest_q <= excRNaN_uid89_fpMulTest_q & excRInf_uid85_fpMulTest_q & excRZero_uid80_fpMulTest_q;\n" +
                        "\n" +
                        "    -- excREnc_uid91_fpMulTest(LOOKUP,90)@5\n" +
                        "    excREnc_uid91_fpMulTest_combproc: PROCESS (concExc_uid90_fpMulTest_q)\n" +
                        "    BEGIN\n" +
                        "        -- Begin reserved scope level\n" +
                        "        CASE (concExc_uid90_fpMulTest_q) IS\n" +
                        "            WHEN \"000\" => excREnc_uid91_fpMulTest_q <= \"01\";\n" +
                        "            WHEN \"001\" => excREnc_uid91_fpMulTest_q <= \"00\";\n" +
                        "            WHEN \"010\" => excREnc_uid91_fpMulTest_q <= \"10\";\n" +
                        "            WHEN \"011\" => excREnc_uid91_fpMulTest_q <= \"00\";\n" +
                        "            WHEN \"100\" => excREnc_uid91_fpMulTest_q <= \"11\";\n" +
                        "            WHEN \"101\" => excREnc_uid91_fpMulTest_q <= \"00\";\n" +
                        "            WHEN \"110\" => excREnc_uid91_fpMulTest_q <= \"00\";\n" +
                        "            WHEN \"111\" => excREnc_uid91_fpMulTest_q <= \"00\";\n" +
                        "            WHEN OTHERS => -- unreachable\n" +
                        "                           excREnc_uid91_fpMulTest_q <= (others => '-');\n" +
                        "        END CASE;\n" +
                        "        -- End reserved scope level\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- expRPostExc_uid100_fpMulTest(MUX,99)@5\n" +
                        "    expRPostExc_uid100_fpMulTest_s <= excREnc_uid91_fpMulTest_q;\n" +
                        "    expRPostExc_uid100_fpMulTest_combproc: PROCESS (expRPostExc_uid100_fpMulTest_s, cstAllZWE_uid12_fpMulTest_q, redist1_expRPreExc_uid72_fpMulTest_b_1_q, cstAllOWE_uid10_fpMulTest_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (expRPostExc_uid100_fpMulTest_s) IS\n" +
                        "            WHEN \"00\" => expRPostExc_uid100_fpMulTest_q <= cstAllZWE_uid12_fpMulTest_q;\n" +
                        "            WHEN \"01\" => expRPostExc_uid100_fpMulTest_q <= redist1_expRPreExc_uid72_fpMulTest_b_1_q;\n" +
                        "            WHEN \"10\" => expRPostExc_uid100_fpMulTest_q <= cstAllOWE_uid10_fpMulTest_q;\n" +
                        "            WHEN \"11\" => expRPostExc_uid100_fpMulTest_q <= cstAllOWE_uid10_fpMulTest_q;\n" +
                        "            WHEN OTHERS => expRPostExc_uid100_fpMulTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- oneFracRPostExc2_uid92_fpMulTest(CONSTANT,91)\n" +
                        "    oneFracRPostExc2_uid92_fpMulTest_q <= \"0000000000000000000000000000000000000000000000000001\";\n" +
                        "\n" +
                        "    -- fracRPreExc_uid70_fpMulTest(BITSELECT,69)@4\n" +
                        "    fracRPreExc_uid70_fpMulTest_in <= expFracRPostRounding_uid69_fpMulTest_q(52 downto 0);\n" +
                        "    fracRPreExc_uid70_fpMulTest_b <= fracRPreExc_uid70_fpMulTest_in(52 downto 1);\n" +
                        "\n" +
                        "    -- redist2_fracRPreExc_uid70_fpMulTest_b_1(DELAY,143)\n" +
                        "    redist2_fracRPreExc_uid70_fpMulTest_b_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 52, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => fracRPreExc_uid70_fpMulTest_b, xout => redist2_fracRPreExc_uid70_fpMulTest_b_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- fracRPostExc_uid95_fpMulTest(MUX,94)@5\n" +
                        "    fracRPostExc_uid95_fpMulTest_s <= excREnc_uid91_fpMulTest_q;\n" +
                        "    fracRPostExc_uid95_fpMulTest_combproc: PROCESS (fracRPostExc_uid95_fpMulTest_s, cstZeroWF_uid11_fpMulTest_q, redist2_fracRPreExc_uid70_fpMulTest_b_1_q, oneFracRPostExc2_uid92_fpMulTest_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (fracRPostExc_uid95_fpMulTest_s) IS\n" +
                        "            WHEN \"00\" => fracRPostExc_uid95_fpMulTest_q <= cstZeroWF_uid11_fpMulTest_q;\n" +
                        "            WHEN \"01\" => fracRPostExc_uid95_fpMulTest_q <= redist2_fracRPreExc_uid70_fpMulTest_b_1_q;\n" +
                        "            WHEN \"10\" => fracRPostExc_uid95_fpMulTest_q <= cstZeroWF_uid11_fpMulTest_q;\n" +
                        "            WHEN \"11\" => fracRPostExc_uid95_fpMulTest_q <= oneFracRPostExc2_uid92_fpMulTest_q;\n" +
                        "            WHEN OTHERS => fracRPostExc_uid95_fpMulTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- R_uid103_fpMulTest(BITJOIN,102)@5\n" +
                        "    R_uid103_fpMulTest_q <= signRPostExc_uid102_fpMulTest_q & expRPostExc_uid100_fpMulTest_q & fracRPostExc_uid95_fpMulTest_q;\n" +
                        "\n" +
                        "    -- xOut(GPOUT,4)@5\n" +
                        "    q <= R_uid103_fpMulTest_q;\n" +
                        "\n" +
                        "END normal;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_FP_ADD_32_qip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -entity \"FP_ADD_32\" -library \"FP_ADD_32\" -name IP_TOOL_NAME \"altera_fp_functions\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32\" -library \"FP_ADD_32\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32\" -library \"FP_ADD_32\" -name IP_TOOL_ENV \"mwpim\"\n" +
                        "set_global_assignment -library \"FP_ADD_32\" -name MISC_FILE [file join $::quartus(qip_path) \"FP_ADD_32.cmp\"]\n" +
                        "set_global_assignment -entity \"FP_ADD_32\" -library \"FP_ADD_32\" -name IP_TARGETED_DEVICE_FAMILY \"Cyclone V\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32\" -library \"FP_ADD_32\" -name IP_GENERATED_DEVICE_FAMILY \"{Cyclone V}\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32\" -library \"FP_ADD_32\" -name IP_QSYS_MODE \"UNKNOWN\"\n" +
                        "set_global_assignment -name SYNTHESIS_ONLY_QIP ON\n" +
                        "set_global_assignment -entity \"FP_ADD_32\" -library \"FP_ADD_32\" -name IP_COMPONENT_NAME \"RlBfQUREXzMy\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32\" -library \"FP_ADD_32\" -name IP_COMPONENT_DISPLAY_NAME \"QUxURVJBX0ZQX0ZVTkNUSU9OUw==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32\" -library \"FP_ADD_32\" -name IP_COMPONENT_REPORT_HIERARCHY \"Off\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32\" -library \"FP_ADD_32\" -name IP_COMPONENT_INTERNAL \"Off\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32\" -library \"FP_ADD_32\" -name IP_COMPONENT_AUTHOR \"QWx0ZXJhIENvcnBvcmF0aW9u\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32\" -library \"FP_ADD_32\" -name IP_COMPONENT_VERSION \"MTguMA==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32\" -library \"FP_ADD_32\" -name IP_COMPONENT_DESCRIPTION \"QSBjb2xsZWN0aW9uIG9mIGZsb2F0aW5nIHBvaW50IGZ1bmN0aW9ucw==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_NAME \"RlBfQUREXzMyXzAwMDI=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_DISPLAY_NAME \"QUxURVJBX0ZQX0ZVTkNUSU9OUw==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_REPORT_HIERARCHY \"Off\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_INTERNAL \"Off\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_AUTHOR \"QWx0ZXJhIENvcnBvcmF0aW9u\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_VERSION \"MTguMA==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_DESCRIPTION \"QSBjb2xsZWN0aW9uIG9mIGZsb2F0aW5nIHBvaW50IGZ1bmN0aW9ucw==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"RlVOQ1RJT05fRkFNSUxZ::QVJJVEg=::RmFtaWx5\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"QVJJVEhfZnVuY3Rpb24=::QURE::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"Q09OVkVSVF9mdW5jdGlvbg==::RlhQX0ZQ::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"QUxMX2Z1bmN0aW9u::QURE::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"RVhQX0xPR19mdW5jdGlvbg==::RVhQRQ==::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"VFJJR19mdW5jdGlvbg==::U0lO::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"Q09NUEFSRV9mdW5jdGlvbg==::TUlO::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"Uk9PVFNfZnVuY3Rpb24=::U1FSVA==::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"ZGVyaXZlZGZ1bmN0aW9u::QURE::ZGVyaXZlZGZ1bmN0aW9u\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"ZnBfZm9ybWF0::c2luZ2xl::Rm9ybWF0\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"ZnBfZXhw::OA==::RXhwb25lbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"ZnBfZXhwX2Rlcml2ZWQ=::OA==::ZnBfZXhwX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"ZnBfbWFu::MjM=::TWFudGlzc2E=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"ZnBfbWFuX2Rlcml2ZWQ=::MjM=::ZnBfbWFuX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"ZXhwb25lbnRfd2lkdGg=::MjM=::RXhwb25lbnQgV2lkdGg=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"ZnJlcXVlbmN5X3RhcmdldA==::MTAw::VGFyZ2V0\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"bGF0ZW5jeV90YXJnZXQ=::Mg==::VGFyZ2V0\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"cGVyZm9ybWFuY2VfZ29hbA==::ZnJlcXVlbmN5::R29hbA==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"cm91bmRpbmdfbW9kZQ==::bmVhcmVzdCB3aXRoIHRpZSBicmVha2luZyBhd2F5IGZyb20gemVybw==::TW9kZQ==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"cm91bmRpbmdfbW9kZV9kZXJpdmVk::bmVhcmVzdCB3aXRoIHRpZSBicmVha2luZyB0byBldmVu::TW9kZQ==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"dXNlX3JvdW5kaW5nX21vZGU=::dHJ1ZQ==::dXNlX3JvdW5kaW5nX21vZGU=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"ZmFpdGhmdWxfcm91bmRpbmc=::ZmFsc2U=::UmVsYXggcm91bmRpbmcgdG8gcm91bmQgdXAgb3IgZG93biB0byByZWR1Y2UgcmVzb3VyY2UgdXNhZ2U=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"Z2VuX2VuYWJsZQ==::ZmFsc2U=::R2VuZXJhdGUgYW4gZW5hYmxlIHBvcnQ=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"ZGl2aWRlX3R5cGU=::MA==::TWV0aG9k\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"c2VsZWN0X3NpZ25hbF9lbmFibGU=::ZmFsc2U=::VXNlIFNlbGVjdCBTaWduYWw=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"c2NhbGVfYnlfcGk=::ZmFsc2U=::UmVwcmVzZW50IGFuZ2xlIGFzIG11bHRpcGxlIG9mIFBp\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"bnVtYmVyX29mX2lucHV0cw==::Mg==::SW5wdXQgVmVjdG9yIERpbWVuc2lvbg==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"dHJpZ19ub19yYW5nZV9yZWR1Y3Rpb24=::ZmFsc2U=::SW5wdXRzIGFyZSB3aXRoaW4gcmFuZ2UgLTJwaSB0byArMnBp\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"cmVwb3J0X3Jlc291cmNlc190b194bWw=::ZmFsc2U=::cmVwb3J0X3Jlc291cmNlc190b194bWw=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"ZnhwdF93aWR0aA==::MzI=::V2lkdGg=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"ZnhwdF9mcmFjdGlvbg==::MA==::RnJhY3Rpb24=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"ZnhwdF9zaWdu::MQ==::U2lnbg==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"ZnJlcXVlbmN5X2ZlZWRiYWNr::MA==::ZnJlcXVlbmN5X2ZlZWRiYWNr\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"bGF0ZW5jeV9mZWVkYmFjaw==::NQ==::bGF0ZW5jeV9mZWVkYmFjaw==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"Zm9yY2VfZWxhYm9yYXRl::MA==::Zm9yY2VfZWxhYm9yYXRl\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X2Zvcm1hdA==::c2luZ2xl::T3V0cHV0IEZvcm1hdA==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X2V4cA==::OA==::T3V0cHV0IEV4cG9uZW50\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X2V4cF9kZXJpdmVk::OA==::ZnBfb3V0X2V4cF9kZXJpdmVk\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X21hbg==::MjM=::T3V0cHV0IE1hbnRpc3Nh\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X21hbl9kZXJpdmVk::OA==::ZnBfb3V0X21hbl9kZXJpdmVk\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fZm9ybWF0::c2luZ2xl::SW5wdXQgRm9ybWF0\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fZXhw::OA==::SW5wdXQgRXhwb25lbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fZXhwX2Rlcml2ZWQ=::OA==::ZnBfaW5fZXhwX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fbWFu::MjM=::SW5wdXQgTWFudGlzc2E=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fbWFuX2Rlcml2ZWQ=::OA==::ZnBfaW5fbWFuX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"ZW5hYmxlX2hhcmRfZnA=::dHJ1ZQ==::RW5hYmxlIEhhcmQgRmxvYXRpbmcgUG9pbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"bWFudWFsX2RzcF9wbGFubmluZw==::dHJ1ZQ==::RW5hYmxlIEhhcmQgRmxvYXRpbmcgUG9pbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"Zm9yY2VSZWdpc3RlcnM=::MTExMQ==::Zm9yY2VSZWdpc3RlcnM=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"UkVTX0RTUF9wYXJhbQ==::MA==::TXVsdGlwbGllcw==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"UkVTX0xVVF9wYXJhbQ==::ODAz::TFVUcw==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"UkVTX01CSVRfcGFyYW0=::MA==::TWVtb3J5IEJpdHM=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"UkVTX01CTE9DS19wYXJhbQ==::MA==::TWVtb3J5IEJsb2Nrcw==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"c2VsZWN0ZWRfZGV2aWNlX2ZhbWlseQ==::Q3ljbG9uZSBW::c2VsZWN0ZWRfZGV2aWNlX2ZhbWlseQ==\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"c2VsZWN0ZWRfZGV2aWNlX3NwZWVkZ3JhZGU=::Nw==::c2VsZWN0ZWRfZGV2aWNlX3NwZWVkZ3JhZGU=\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_COMPONENT_PARAMETER \"dmFsaWRhdGlvbl9mYWlsZWQ=::ZmFsc2U=::dmFsaWRhdGlvbl9mYWlsZWQ=\"\n" +
                        "\n" +
                        "set_global_assignment -library \"FP_ADD_32\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_ADD_32.vhd\"]\n" +
                        "set_global_assignment -library \"FP_ADD_32\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_ADD_32/dspba_library_package.vhd\"]\n" +
                        "set_global_assignment -library \"FP_ADD_32\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_ADD_32/dspba_library.vhd\"]\n" +
                        "set_global_assignment -library \"FP_ADD_32\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_ADD_32/FP_ADD_32_0002.vhd\"]\n" +
                        "\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_TOOL_NAME \"altera_fp_functions\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32_0002\" -library \"FP_ADD_32\" -name IP_TOOL_ENV \"mwpim\"";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_FP_ADD_32_sip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -entity \"FP_ADD_32\" -library \"lib_FP_ADD_32\" -name IP_TOOL_NAME \"altera_fp_functions\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32\" -library \"lib_FP_ADD_32\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"FP_ADD_32\" -library \"lib_FP_ADD_32\" -name IP_TOOL_ENV \"mwpim\"\n" +
                        "set_global_assignment -library \"lib_FP_ADD_32\" -name SPD_FILE [file join $::quartus(sip_path) \"FP_ADD_32.spd\"]\n" +
                        "\n" +
                        "set_global_assignment -library \"lib_FP_ADD_32\" -name MISC_FILE [file join $::quartus(sip_path) \"FP_ADD_32_sim/dspba_library_package.vhd\"]\n" +
                        "set_global_assignment -library \"lib_FP_ADD_32\" -name MISC_FILE [file join $::quartus(sip_path) \"FP_ADD_32_sim/dspba_library.vhd\"]\n" +
                        "set_global_assignment -library \"lib_FP_ADD_32\" -name MISC_FILE [file join $::quartus(sip_path) \"FP_ADD_32_sim/FP_ADD_32.vhd\"]";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_FP_ADD_32_vhd_file(String Project_Folder_File) {
        String data =   "-- megafunction wizard: %ALTERA_FP_FUNCTIONS v18.0%\n" +
                        "-- GENERATION: XML\n" +
                        "-- FP_ADD_32.vhd\n" +
                        "\n" +
                        "-- Generated using ACDS version 18.0 614\n" +
                        "\n" +
                        "library IEEE;\n" +
                        "use IEEE.std_logic_1164.all;\n" +
                        "use IEEE.numeric_std.all;\n" +
                        "\n" +
                        "entity FP_ADD_32 is\n" +
                        "	port (\n" +
                        "		clk    : in  std_logic                     := '0';             --    clk.clk\n" +
                        "		areset : in  std_logic                     := '0';             -- areset.reset\n" +
                        "		a      : in  std_logic_vector(31 downto 0) := (others => '0'); --      a.a\n" +
                        "		b      : in  std_logic_vector(31 downto 0) := (others => '0'); --      b.b\n" +
                        "		q      : out std_logic_vector(31 downto 0)                     --      q.q\n" +
                        "	);\n" +
                        "end entity FP_ADD_32;\n" +
                        "\n" +
                        "architecture rtl of FP_ADD_32 is\n" +
                        "	component FP_ADD_32_0002 is\n" +
                        "		port (\n" +
                        "			clk    : in  std_logic                     := 'X';             -- clk\n" +
                        "			areset : in  std_logic                     := 'X';             -- reset\n" +
                        "			a      : in  std_logic_vector(31 downto 0) := (others => 'X'); -- a\n" +
                        "			b      : in  std_logic_vector(31 downto 0) := (others => 'X'); -- b\n" +
                        "			q      : out std_logic_vector(31 downto 0)                     -- q\n" +
                        "		);\n" +
                        "	end component FP_ADD_32_0002;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "	fp_add_32_inst : component FP_ADD_32_0002\n" +
                        "		port map (\n" +
                        "			clk    => clk,    --    clk.clk\n" +
                        "			areset => areset, -- areset.reset\n" +
                        "			a      => a,      --      a.a\n" +
                        "			b      => b,      --      b.b\n" +
                        "			q      => q       --      q.q\n" +
                        "		);\n" +
                        "\n" +
                        "end architecture rtl; -- of FP_ADD_32\n" +
                        "-- Retrieval info: <?xml version=\"1.0\"?>\n" +
                        "--<!--\n" +
                        "--	Generated by Altera MegaWizard Launcher Utility version 1.0\n" +
                        "--	************************************************************\n" +
                        "--	THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!\n" +
                        "--	************************************************************\n" +
                        "--	Copyright (C) 1991-2020 Altera Corporation\n" +
                        "--	Any megafunction design, and related net list (encrypted or decrypted),\n" +
                        "--	support information, device programming or simulation file, and any other\n" +
                        "--	associated documentation or information provided by Altera or a partner\n" +
                        "--	under Altera's Megafunction Partnership Program may be used only to\n" +
                        "--	program PLD devices (but not masked PLD devices) from Altera.  Any other\n" +
                        "--	use of such megafunction design, net list, support information, device\n" +
                        "--	programming or simulation file, or any other related documentation or\n" +
                        "--	information is prohibited for any other purpose, including, but not\n" +
                        "--	limited to modification, reverse engineering, de-compiling, or use with\n" +
                        "--	any other silicon devices, unless such use is explicitly licensed under\n" +
                        "--	a separate agreement with Altera or a megafunction partner.  Title to\n" +
                        "--	the intellectual property, including patents, copyrights, trademarks,\n" +
                        "--	trade secrets, or maskworks, embodied in any such megafunction design,\n" +
                        "--	net list, support information, device programming or simulation file, or\n" +
                        "--	any other related documentation or information provided by Altera or a\n" +
                        "--	megafunction partner, remains with Altera, the megafunction partner, or\n" +
                        "--	their respective licensors.  No other licenses, including any licenses\n" +
                        "--	needed under any third party's intellectual property, are provided herein.\n" +
                        "---->\n" +
                        "-- Retrieval info: <instance entity-name=\"altera_fp_functions\" version=\"18.0\" >\n" +
                        "-- Retrieval info: 	<generic name=\"FUNCTION_FAMILY\" value=\"ARITH\" />\n" +
                        "-- Retrieval info: 	<generic name=\"ARITH_function\" value=\"ADD\" />\n" +
                        "-- Retrieval info: 	<generic name=\"CONVERT_function\" value=\"FXP_FP\" />\n" +
                        "-- Retrieval info: 	<generic name=\"ALL_function\" value=\"ADD\" />\n" +
                        "-- Retrieval info: 	<generic name=\"EXP_LOG_function\" value=\"EXPE\" />\n" +
                        "-- Retrieval info: 	<generic name=\"TRIG_function\" value=\"SIN\" />\n" +
                        "-- Retrieval info: 	<generic name=\"COMPARE_function\" value=\"MIN\" />\n" +
                        "-- Retrieval info: 	<generic name=\"ROOTS_function\" value=\"SQRT\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_format\" value=\"single\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_exp\" value=\"8\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_man\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"exponent_width\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"frequency_target\" value=\"100\" />\n" +
                        "-- Retrieval info: 	<generic name=\"latency_target\" value=\"2\" />\n" +
                        "-- Retrieval info: 	<generic name=\"performance_goal\" value=\"frequency\" />\n" +
                        "-- Retrieval info: 	<generic name=\"rounding_mode\" value=\"nearest with tie breaking away from zero\" />\n" +
                        "-- Retrieval info: 	<generic name=\"faithful_rounding\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gen_enable\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"divide_type\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"select_signal_enable\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"scale_by_pi\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"number_of_inputs\" value=\"2\" />\n" +
                        "-- Retrieval info: 	<generic name=\"trig_no_range_reduction\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"report_resources_to_xml\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fxpt_width\" value=\"32\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fxpt_fraction\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fxpt_sign\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_out_format\" value=\"single\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_out_exp\" value=\"8\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_out_man\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_in_format\" value=\"single\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_in_exp\" value=\"8\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_in_man\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"enable_hard_fp\" value=\"true\" />\n" +
                        "-- Retrieval info: 	<generic name=\"manual_dsp_planning\" value=\"true\" />\n" +
                        "-- Retrieval info: 	<generic name=\"forceRegisters\" value=\"1111\" />\n" +
                        "-- Retrieval info: 	<generic name=\"selected_device_family\" value=\"Cyclone V\" />\n" +
                        "-- Retrieval info: 	<generic name=\"selected_device_speedgrade\" value=\"7\" />\n" +
                        "-- Retrieval info: </instance>\n" +
                        "-- IPFS_FILES : FP_ADD_32.vho\n" +
                        "-- RELATED_FILES: FP_ADD_32.vhd, dspba_library_package.vhd, dspba_library.vhd, FP_ADD_32_0002.vhd";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_FP_ADD_32_0002_vhd_file(String Project_Folder_File) {
        String data1 =  "-- ------------------------------------------------------------------------- \n" +
                        "-- High Level Design Compiler for Intel(R) FPGAs Version 18.0 (Release Build #614)\n" +
                        "-- Quartus Prime development tool and MATLAB/Simulink Interface\n" +
                        "-- \n" +
                        "-- Legal Notice: Copyright 2018 Intel Corporation.  All rights reserved.\n" +
                        "-- Your use of  Intel Corporation's design tools,  logic functions and other\n" +
                        "-- software and  tools, and its AMPP partner logic functions, and any output\n" +
                        "-- files any  of the foregoing (including  device programming  or simulation\n" +
                        "-- files), and  any associated  documentation  or information  are expressly\n" +
                        "-- subject  to the terms and  conditions of the  Intel FPGA Software License\n" +
                        "-- Agreement, Intel MegaCore Function License Agreement, or other applicable\n" +
                        "-- license agreement,  including,  without limitation,  that your use is for\n" +
                        "-- the  sole  purpose of  programming  logic devices  manufactured by  Intel\n" +
                        "-- and  sold by Intel  or its authorized  distributors. Please refer  to the\n" +
                        "-- applicable agreement for further details.\n" +
                        "-- ---------------------------------------------------------------------------\n" +
                        "\n" +
                        "-- VHDL created from FP_ADD_32_0002\n" +
                        "-- VHDL created on Fri Jul 24 01:37:02 2020\n" +
                        "\n" +
                        "\n" +
                        "library IEEE;\n" +
                        "use IEEE.std_logic_1164.all;\n" +
                        "use IEEE.NUMERIC_STD.all;\n" +
                        "use IEEE.MATH_REAL.all;\n" +
                        "use std.TextIO.all;\n" +
                        "use work.dspba_library_package.all;\n" +
                        "\n" +
                        "LIBRARY altera_mf;\n" +
                        "USE altera_mf.altera_mf_components.all;\n" +
                        "LIBRARY altera_lnsim;\n" +
                        "USE altera_lnsim.altera_lnsim_components.altera_syncram;\n" +
                        "LIBRARY lpm;\n" +
                        "USE lpm.lpm_components.all;\n" +
                        "\n" +
                        "entity FP_ADD_32_0002 is\n" +
                        "    port (\n" +
                        "        a : in std_logic_vector(31 downto 0);  -- float32_m23\n" +
                        "        b : in std_logic_vector(31 downto 0);  -- float32_m23\n" +
                        "        q : out std_logic_vector(31 downto 0);  -- float32_m23\n" +
                        "        clk : in std_logic;\n" +
                        "        areset : in std_logic\n" +
                        "    );\n" +
                        "end FP_ADD_32_0002;\n" +
                        "\n" +
                        "architecture normal of FP_ADD_32_0002 is\n" +
                        "\n" +
                        "    attribute altera_attribute : string;\n" +
                        "    attribute altera_attribute of normal : architecture is \"-name AUTO_SHIFT_REGISTER_RECOGNITION OFF; -name PHYSICAL_SYNTHESIS_REGISTER_DUPLICATION ON; -name MESSAGE_DISABLE 10036; -name MESSAGE_DISABLE 10037; -name MESSAGE_DISABLE 14130; -name MESSAGE_DISABLE 14320; -name MESSAGE_DISABLE 15400; -name MESSAGE_DISABLE 14130; -name MESSAGE_DISABLE 10036; -name MESSAGE_DISABLE 12020; -name MESSAGE_DISABLE 12030; -name MESSAGE_DISABLE 12010; -name MESSAGE_DISABLE 12110; -name MESSAGE_DISABLE 14320; -name MESSAGE_DISABLE 13410; -name MESSAGE_DISABLE 113007\";\n" +
                        "    \n" +
                        "    signal GND_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal VCC_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expFracX_uid6_fpAddTest_b : STD_LOGIC_VECTOR (30 downto 0);\n" +
                        "    signal expFracY_uid7_fpAddTest_b : STD_LOGIC_VECTOR (30 downto 0);\n" +
                        "    signal xGTEy_uid8_fpAddTest_a : STD_LOGIC_VECTOR (32 downto 0);\n" +
                        "    signal xGTEy_uid8_fpAddTest_b : STD_LOGIC_VECTOR (32 downto 0);\n" +
                        "    signal xGTEy_uid8_fpAddTest_o : STD_LOGIC_VECTOR (32 downto 0);\n" +
                        "    signal xGTEy_uid8_fpAddTest_n : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracY_uid9_fpAddTest_b : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal expY_uid10_fpAddTest_b : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal sigY_uid11_fpAddTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal ypn_uid12_fpAddTest_q : STD_LOGIC_VECTOR (31 downto 0);\n" +
                        "    signal aSig_uid16_fpAddTest_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal aSig_uid16_fpAddTest_q : STD_LOGIC_VECTOR (31 downto 0);\n" +
                        "    signal bSig_uid17_fpAddTest_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal bSig_uid17_fpAddTest_q : STD_LOGIC_VECTOR (31 downto 0);\n" +
                        "    signal cstAllOWE_uid18_fpAddTest_q : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal cstZeroWF_uid19_fpAddTest_q : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal cstAllZWE_uid20_fpAddTest_q : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal exp_aSig_uid21_fpAddTest_in : STD_LOGIC_VECTOR (30 downto 0);\n" +
                        "    signal exp_aSig_uid21_fpAddTest_b : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal frac_aSig_uid22_fpAddTest_in : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal frac_aSig_uid22_fpAddTest_b : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal excZ_aSig_uid16_uid23_fpAddTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excZ_aSig_uid16_uid23_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expXIsMax_uid24_fpAddTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expXIsMax_uid24_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsZero_uid25_fpAddTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsZero_uid25_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsNotZero_uid26_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excI_aSig_uid27_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excN_aSig_uid28_fpAddTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excN_aSig_uid28_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal invExpXIsMax_uid29_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal InvExpXIsZero_uid30_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excR_aSig_uid31_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal exp_bSig_uid35_fpAddTest_in : STD_LOGIC_VECTOR (30 downto 0);\n" +
                        "    signal exp_bSig_uid35_fpAddTest_b : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal frac_bSig_uid36_fpAddTest_in : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal frac_bSig_uid36_fpAddTest_b : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal excZ_bSig_uid17_uid37_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expXIsMax_uid38_fpAddTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expXIsMax_uid38_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsZero_uid39_fpAddTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsZero_uid39_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsNotZero_uid40_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excI_bSig_uid41_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excN_bSig_uid42_fpAddTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excN_bSig_uid42_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal invExpXIsMax_uid43_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal InvExpXIsZero_uid44_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excR_bSig_uid45_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal sigA_uid50_fpAddTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal sigB_uid51_fpAddTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal effSub_uid52_fpAddTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal effSub_uid52_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracBz_uid56_fpAddTest_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracBz_uid56_fpAddTest_q : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal oFracB_uid59_fpAddTest_q : STD_LOGIC_VECTOR (23 downto 0);\n" +
                        "    signal expAmExpB_uid60_fpAddTest_a : STD_LOGIC_VECTOR (8 downto 0);\n" +
                        "    signal expAmExpB_uid60_fpAddTest_b : STD_LOGIC_VECTOR (8 downto 0);\n" +
                        "    signal expAmExpB_uid60_fpAddTest_o : STD_LOGIC_VECTOR (8 downto 0);\n" +
                        "    signal expAmExpB_uid60_fpAddTest_q : STD_LOGIC_VECTOR (8 downto 0);\n" +
                        "    signal cWFP2_uid61_fpAddTest_q : STD_LOGIC_VECTOR (4 downto 0);\n" +
                        "    signal shiftedOut_uid63_fpAddTest_a : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal shiftedOut_uid63_fpAddTest_b : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal shiftedOut_uid63_fpAddTest_o : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal shiftedOut_uid63_fpAddTest_c : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal padConst_uid64_fpAddTest_q : STD_LOGIC_VECTOR (24 downto 0);\n" +
                        "    signal rightPaddedIn_uid65_fpAddTest_q : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal iShiftedOut_uid67_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal alignFracBPostShiftOut_uid68_fpAddTest_b : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal alignFracBPostShiftOut_uid68_fpAddTest_q : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal cmpEQ_stickyBits_cZwF_uid71_fpAddTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal cmpEQ_stickyBits_cZwF_uid71_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal invCmpEQ_stickyBits_cZwF_uid72_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal effSubInvSticky_uid74_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal zocst_uid76_fpAddTest_q : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal fracAAddOp_uid77_fpAddTest_q : STD_LOGIC_VECTOR (26 downto 0);\n" +
                        "    signal fracBAddOp_uid80_fpAddTest_q : STD_LOGIC_VECTOR (26 downto 0);\n" +
                        "    signal fracBAddOpPostXor_uid81_fpAddTest_b : STD_LOGIC_VECTOR (26 downto 0);\n" +
                        "    signal fracBAddOpPostXor_uid81_fpAddTest_q : STD_LOGIC_VECTOR (26 downto 0);\n" +
                        "    signal fracAddResult_uid82_fpAddTest_a : STD_LOGIC_VECTOR (27 downto 0);\n" +
                        "    signal fracAddResult_uid82_fpAddTest_b : STD_LOGIC_VECTOR (27 downto 0);\n" +
                        "    signal fracAddResult_uid82_fpAddTest_o : STD_LOGIC_VECTOR (27 downto 0);\n" +
                        "    signal fracAddResult_uid82_fpAddTest_q : STD_LOGIC_VECTOR (27 downto 0);\n" +
                        "    signal rangeFracAddResultMwfp3Dto0_uid83_fpAddTest_in : STD_LOGIC_VECTOR (26 downto 0);\n" +
                        "    signal rangeFracAddResultMwfp3Dto0_uid83_fpAddTest_b : STD_LOGIC_VECTOR (26 downto 0);\n" +
                        "    signal fracGRS_uid84_fpAddTest_q : STD_LOGIC_VECTOR (27 downto 0);\n" +
                        "    signal cAmA_uid86_fpAddTest_q : STD_LOGIC_VECTOR (4 downto 0);\n" +
                        "    signal aMinusA_uid87_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracPostNorm_uid89_fpAddTest_b : STD_LOGIC_VECTOR (26 downto 0);\n" +
                        "    signal oneCST_uid90_fpAddTest_q : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal expInc_uid91_fpAddTest_a : STD_LOGIC_VECTOR (8 downto 0);\n" +
                        "    signal expInc_uid91_fpAddTest_b : STD_LOGIC_VECTOR (8 downto 0);\n" +
                        "    signal expInc_uid91_fpAddTest_o : STD_LOGIC_VECTOR (8 downto 0);\n" +
                        "    signal expInc_uid91_fpAddTest_q : STD_LOGIC_VECTOR (8 downto 0);\n" +
                        "    signal expPostNorm_uid92_fpAddTest_a : STD_LOGIC_VECTOR (9 downto 0);\n" +
                        "    signal expPostNorm_uid92_fpAddTest_b : STD_LOGIC_VECTOR (9 downto 0);\n" +
                        "    signal expPostNorm_uid92_fpAddTest_o : STD_LOGIC_VECTOR (9 downto 0);\n" +
                        "    signal expPostNorm_uid92_fpAddTest_q : STD_LOGIC_VECTOR (9 downto 0);\n" +
                        "    signal Sticky0_uid93_fpAddTest_in : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal Sticky0_uid93_fpAddTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal Sticky1_uid94_fpAddTest_in : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal Sticky1_uid94_fpAddTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal Round_uid95_fpAddTest_in : STD_LOGIC_VECTOR (2 downto 0);\n" +
                        "    signal Round_uid95_fpAddTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal Guard_uid96_fpAddTest_in : STD_LOGIC_VECTOR (3 downto 0);\n" +
                        "    signal Guard_uid96_fpAddTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal LSB_uid97_fpAddTest_in : STD_LOGIC_VECTOR (4 downto 0);\n" +
                        "    signal LSB_uid97_fpAddTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rndBitCond_uid98_fpAddTest_q : STD_LOGIC_VECTOR (4 downto 0);\n" +
                        "    signal cRBit_uid99_fpAddTest_q : STD_LOGIC_VECTOR (4 downto 0);\n" +
                        "    signal rBi_uid100_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal roundBit_uid101_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracPostNormRndRange_uid102_fpAddTest_in : STD_LOGIC_VECTOR (25 downto 0);\n" +
                        "    signal fracPostNormRndRange_uid102_fpAddTest_b : STD_LOGIC_VECTOR (23 downto 0);\n" +
                        "    signal expFracR_uid103_fpAddTest_q : STD_LOGIC_VECTOR (33 downto 0);\n" +
                        "    signal rndExpFrac_uid104_fpAddTest_a : STD_LOGIC_VECTOR (34 downto 0);\n" +
                        "    signal rndExpFrac_uid104_fpAddTest_b : STD_LOGIC_VECTOR (34 downto 0);\n" +
                        "    signal rndExpFrac_uid104_fpAddTest_o : STD_LOGIC_VECTOR (34 downto 0);\n" +
                        "    signal rndExpFrac_uid104_fpAddTest_q : STD_LOGIC_VECTOR (34 downto 0);\n" +
                        "    signal wEP2AllOwE_uid105_fpAddTest_q : STD_LOGIC_VECTOR (9 downto 0);\n" +
                        "    signal rndExp_uid106_fpAddTest_in : STD_LOGIC_VECTOR (33 downto 0);\n" +
                        "    signal rndExp_uid106_fpAddTest_b : STD_LOGIC_VECTOR (9 downto 0);\n" +
                        "    signal rOvfEQMax_uid107_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rndExpFracOvfBits_uid109_fpAddTest_in : STD_LOGIC_VECTOR (33 downto 0);\n" +
                        "    signal rndExpFracOvfBits_uid109_fpAddTest_b : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal rOvfExtraBits_uid110_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rOvf_uid111_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal wEP2AllZ_uid112_fpAddTest_q : STD_LOGIC_VECTOR (9 downto 0);\n" +
                        "    signal rUdfEQMin_uid113_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rUdfExtraBit_uid114_fpAddTest_in : STD_LOGIC_VECTOR (33 downto 0);\n" +
                        "    signal rUdfExtraBit_uid114_fpAddTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rUdf_uid115_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracRPreExc_uid116_fpAddTest_in : STD_LOGIC_VECTOR (23 downto 0);\n" +
                        "    signal fracRPreExc_uid116_fpAddTest_b : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal expRPreExc_uid117_fpAddTest_in : STD_LOGIC_VECTOR (31 downto 0);\n" +
                        "    signal expRPreExc_uid117_fpAddTest_b : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal regInputs_uid118_fpAddTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal regInputs_uid118_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excRZeroVInC_uid119_fpAddTest_q : STD_LOGIC_VECTOR (4 downto 0);\n" +
                        "    signal excRZero_uid120_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rInfOvf_uid121_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excRInfVInC_uid122_fpAddTest_q : STD_LOGIC_VECTOR (5 downto 0);\n" +
                        "    signal excRInf_uid123_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excRNaN2_uid124_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excAIBISub_uid125_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excRNaN_uid126_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal concExc_uid127_fpAddTest_q : STD_LOGIC_VECTOR (2 downto 0);\n" +
                        "    signal excREnc_uid128_fpAddTest_q : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal invAMinusA_uid129_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal signRReg_uid130_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal sigBBInf_uid131_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal sigAAInf_uid132_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal signRInf_uid133_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excAZBZSigASigB_uid134_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excBZARSigA_uid135_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal signRZero_uid136_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal signRInfRZRReg_uid137_fpAddTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal signRInfRZRReg_uid137_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal invExcRNaN_uid138_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal signRPostExc_uid139_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal oneFracRPostExc2_uid140_fpAddTest_q : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal fracRPostExc_uid143_fpAddTest_s : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal fracRPostExc_uid143_fpAddTest_q : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal expRPostExc_uid147_fpAddTest_s : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal expRPostExc_uid147_fpAddTest_q : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal R_uid148_fpAddTest_q : STD_LOGIC_VECTOR (31 downto 0);\n" +
                        "    signal zs_uid150_lzCountVal_uid85_fpAddTest_q : STD_LOGIC_VECTOR (15 downto 0);\n" +
                        "    signal rVStage_uid151_lzCountVal_uid85_fpAddTest_b : STD_LOGIC_VECTOR (15 downto 0);\n" +
                        "    signal vCount_uid152_lzCountVal_uid85_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal mO_uid153_lzCountVal_uid85_fpAddTest_q : STD_LOGIC_VECTOR (3 downto 0);\n" +
                        "    signal vStage_uid154_lzCountVal_uid85_fpAddTest_in : STD_LOGIC_VECTOR (11 downto 0);\n" +
                        "    signal vStage_uid154_lzCountVal_uid85_fpAddTest_b : STD_LOGIC_VECTOR (11 downto 0);\n" +
                        "    signal cStage_uid155_lzCountVal_uid85_fpAddTest_q : STD_LOGIC_VECTOR (15 downto 0);\n" +
                        "    signal vStagei_uid157_lzCountVal_uid85_fpAddTest_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal vStagei_uid157_lzCountVal_uid85_fpAddTest_q : STD_LOGIC_VECTOR (15 downto 0);\n" +
                        "    signal vCount_uid160_lzCountVal_uid85_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal vStagei_uid163_lzCountVal_uid85_fpAddTest_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal vStagei_uid163_lzCountVal_uid85_fpAddTest_q : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal zs_uid164_lzCountVal_uid85_fpAddTest_q : STD_LOGIC_VECTOR (3 downto 0);\n" +
                        "    signal vCount_uid166_lzCountVal_uid85_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal vStagei_uid169_lzCountVal_uid85_fpAddTest_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal vStagei_uid169_lzCountVal_uid85_fpAddTest_q : STD_LOGIC_VECTOR (3 downto 0);\n" +
                        "    signal zs_uid170_lzCountVal_uid85_fpAddTest_q : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal vCount_uid172_lzCountVal_uid85_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal vStagei_uid175_lzCountVal_uid85_fpAddTest_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal vStagei_uid175_lzCountVal_uid85_fpAddTest_q : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal rVStage_uid177_lzCountVal_uid85_fpAddTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal vCount_uid178_lzCountVal_uid85_fpAddTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal r_uid179_lzCountVal_uid85_fpAddTest_q : STD_LOGIC_VECTOR (4 downto 0);\n" +
                        "    signal wIntCst_uid183_alignmentShifter_uid64_fpAddTest_q : STD_LOGIC_VECTOR (5 downto 0);\n" +
                        "    signal shiftedOut_uid184_alignmentShifter_uid64_fpAddTest_a : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal shiftedOut_uid184_alignmentShifter_uid64_fpAddTest_b : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal shiftedOut_uid184_alignmentShifter_uid64_fpAddTest_o : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal shiftedOut_uid184_alignmentShifter_uid64_fpAddTest_n : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rightShiftStage0Idx1Rng16_uid185_alignmentShifter_uid64_fpAddTest_b : STD_LOGIC_VECTOR (32 downto 0);\n" +
                        "    signal rightShiftStage0Idx1_uid187_alignmentShifter_uid64_fpAddTest_q : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal rightShiftStage0Idx2Rng32_uid188_alignmentShifter_uid64_fpAddTest_b : STD_LOGIC_VECTOR (16 downto 0);\n" +
                        "    signal rightShiftStage0Idx2Pad32_uid189_alignmentShifter_uid64_fpAddTest_q : STD_LOGIC_VECTOR (31 downto 0);\n" +
                        "    signal rightShiftStage0Idx2_uid190_alignmentShifter_uid64_fpAddTest_q : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal rightShiftStage0Idx3Rng48_uid191_alignmentShifter_uid64_fpAddTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rightShiftStage0Idx3Pad48_uid192_alignmentShifter_uid64_fpAddTest_q : STD_LOGIC_VECTOR (47 downto 0);\n" +
                        "    signal rightShiftStage0Idx3_uid193_alignmentShifter_uid64_fpAddTest_q : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal rightShiftStage0_uid195_alignmentShifter_uid64_fpAddTest_s : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal rightShiftStage0_uid195_alignmentShifter_uid64_fpAddTest_q : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal rightShiftStage1Idx1Rng4_uid196_alignmentShifter_uid64_fpAddTest_b : STD_LOGIC_VECTOR (44 downto 0);\n" +
                        "    signal rightShiftStage1Idx1_uid198_alignmentShifter_uid64_fpAddTest_q : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal rightShiftStage1Idx2Rng8_uid199_alignmentShifter_uid64_fpAddTest_b : STD_LOGIC_VECTOR (40 downto 0);\n" +
                        "    signal rightShiftStage1Idx2_uid201_alignmentShifter_uid64_fpAddTest_q : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal rightShiftStage1Idx3Rng12_uid202_alignmentShifter_uid64_fpAddTest_b : STD_LOGIC_VECTOR (36 downto 0);\n" +
                        "    signal rightShiftStage1Idx3Pad12_uid203_alignmentShifter_uid64_fpAddTest_q : STD_LOGIC_VECTOR (11 downto 0);\n" +
                        "    signal rightShiftStage1Idx3_uid204_alignmentShifter_uid64_fpAddTest_q : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal rightShiftStage1_uid206_alignmentShifter_uid64_fpAddTest_s : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal rightShiftStage1_uid206_alignmentShifter_uid64_fpAddTest_q : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal rightShiftStage2Idx1Rng1_uid207_alignmentShifter_uid64_fpAddTest_b : STD_LOGIC_VECTOR (47 downto 0);\n" +
                        "    signal rightShiftStage2Idx1_uid209_alignmentShifter_uid64_fpAddTest_q : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal rightShiftStage2Idx2Rng2_uid210_alignmentShifter_uid64_fpAddTest_b : STD_LOGIC_VECTOR (46 downto 0);\n" +
                        "    signal rightShiftStage2Idx2_uid212_alignmentShifter_uid64_fpAddTest_q : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal rightShiftStage2Idx3Rng3_uid213_alignmentShifter_uid64_fpAddTest_b : STD_LOGIC_VECTOR (45 downto 0);\n" +
                        "    signal rightShiftStage2Idx3Pad3_uid214_alignmentShifter_uid64_fpAddTest_q : STD_LOGIC_VECTOR (2 downto 0);\n" +
                        "    signal rightShiftStage2Idx3_uid215_alignmentShifter_uid64_fpAddTest_q : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal rightShiftStage2_uid217_alignmentShifter_uid64_fpAddTest_s : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal rightShiftStage2_uid217_alignmentShifter_uid64_fpAddTest_q : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal zeroOutCst_uid218_alignmentShifter_uid64_fpAddTest_q : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal r_uid219_alignmentShifter_uid64_fpAddTest_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal r_uid219_alignmentShifter_uid64_fpAddTest_q : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal leftShiftStage0Idx1Rng8_uid224_fracPostNormExt_uid88_fpAddTest_in : STD_LOGIC_VECTOR (19 downto 0);\n" +
                        "    signal leftShiftStage0Idx1Rng8_uid224_fracPostNormExt_uid88_fpAddTest_b : STD_LOGIC_VECTOR (19 downto 0);\n" +
                        "    signal leftShiftStage0Idx1_uid225_fracPostNormExt_uid88_fpAddTest_q : STD_LOGIC_VECTOR (27 downto 0);\n" +
                        "    signal leftShiftStage0Idx2_uid228_fracPostNormExt_uid88_fpAddTest_q : STD_LOGIC_VECTOR (27 downto 0);\n" +
                        "    signal leftShiftStage0Idx3Pad24_uid229_fracPostNormExt_uid88_fpAddTest_q : STD_LOGIC_VECTOR (23 downto 0);\n" +
                        "    signal leftShiftStage0Idx3Rng24_uid230_fracPostNormExt_uid88_fpAddTest_in : STD_LOGIC_VECTOR (3 downto 0);\n" +
                        "    signal leftShiftStage0Idx3Rng24_uid230_fracPostNormExt_uid88_fpAddTest_b : STD_LOGIC_VECTOR (3 downto 0);\n" +
                        "    signal leftShiftStage0Idx3_uid231_fracPostNormExt_uid88_fpAddTest_q : STD_LOGIC_VECTOR (27 downto 0);\n" +
                        "    signal leftShiftStage0_uid233_fracPostNormExt_uid88_fpAddTest_s : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal leftShiftStage0_uid233_fracPostNormExt_uid88_fpAddTest_q : STD_LOGIC_VECTOR (27 downto 0);\n" +
                        "    signal leftShiftStage1Idx1Rng2_uid235_fracPostNormExt_uid88_fpAddTest_in : STD_LOGIC_VECTOR (25 downto 0);\n";
        String data2 =  "    signal leftShiftStage1Idx1Rng2_uid235_fracPostNormExt_uid88_fpAddTest_b : STD_LOGIC_VECTOR (25 downto 0);\n" +
                        "    signal leftShiftStage1Idx1_uid236_fracPostNormExt_uid88_fpAddTest_q : STD_LOGIC_VECTOR (27 downto 0);\n" +
                        "    signal leftShiftStage1Idx2Rng4_uid238_fracPostNormExt_uid88_fpAddTest_in : STD_LOGIC_VECTOR (23 downto 0);\n" +
                        "    signal leftShiftStage1Idx2Rng4_uid238_fracPostNormExt_uid88_fpAddTest_b : STD_LOGIC_VECTOR (23 downto 0);\n" +
                        "    signal leftShiftStage1Idx2_uid239_fracPostNormExt_uid88_fpAddTest_q : STD_LOGIC_VECTOR (27 downto 0);\n" +
                        "    signal leftShiftStage1Idx3Pad6_uid240_fracPostNormExt_uid88_fpAddTest_q : STD_LOGIC_VECTOR (5 downto 0);\n" +
                        "    signal leftShiftStage1Idx3Rng6_uid241_fracPostNormExt_uid88_fpAddTest_in : STD_LOGIC_VECTOR (21 downto 0);\n" +
                        "    signal leftShiftStage1Idx3Rng6_uid241_fracPostNormExt_uid88_fpAddTest_b : STD_LOGIC_VECTOR (21 downto 0);\n" +
                        "    signal leftShiftStage1Idx3_uid242_fracPostNormExt_uid88_fpAddTest_q : STD_LOGIC_VECTOR (27 downto 0);\n" +
                        "    signal leftShiftStage1_uid244_fracPostNormExt_uid88_fpAddTest_s : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal leftShiftStage1_uid244_fracPostNormExt_uid88_fpAddTest_q : STD_LOGIC_VECTOR (27 downto 0);\n" +
                        "    signal leftShiftStage2Idx1Rng1_uid246_fracPostNormExt_uid88_fpAddTest_in : STD_LOGIC_VECTOR (26 downto 0);\n" +
                        "    signal leftShiftStage2Idx1Rng1_uid246_fracPostNormExt_uid88_fpAddTest_b : STD_LOGIC_VECTOR (26 downto 0);\n" +
                        "    signal leftShiftStage2Idx1_uid247_fracPostNormExt_uid88_fpAddTest_q : STD_LOGIC_VECTOR (27 downto 0);\n" +
                        "    signal leftShiftStage2_uid249_fracPostNormExt_uid88_fpAddTest_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal leftShiftStage2_uid249_fracPostNormExt_uid88_fpAddTest_q : STD_LOGIC_VECTOR (27 downto 0);\n" +
                        "    signal rightShiftStageSel5Dto4_uid194_alignmentShifter_uid64_fpAddTest_merged_bit_select_in : STD_LOGIC_VECTOR (5 downto 0);\n" +
                        "    signal rightShiftStageSel5Dto4_uid194_alignmentShifter_uid64_fpAddTest_merged_bit_select_b : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal rightShiftStageSel5Dto4_uid194_alignmentShifter_uid64_fpAddTest_merged_bit_select_c : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal rightShiftStageSel5Dto4_uid194_alignmentShifter_uid64_fpAddTest_merged_bit_select_d : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal stickyBits_uid69_fpAddTest_merged_bit_select_b : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal stickyBits_uid69_fpAddTest_merged_bit_select_c : STD_LOGIC_VECTOR (25 downto 0);\n" +
                        "    signal rVStage_uid159_lzCountVal_uid85_fpAddTest_merged_bit_select_b : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal rVStage_uid159_lzCountVal_uid85_fpAddTest_merged_bit_select_c : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal rVStage_uid165_lzCountVal_uid85_fpAddTest_merged_bit_select_b : STD_LOGIC_VECTOR (3 downto 0);\n" +
                        "    signal rVStage_uid165_lzCountVal_uid85_fpAddTest_merged_bit_select_c : STD_LOGIC_VECTOR (3 downto 0);\n" +
                        "    signal rVStage_uid171_lzCountVal_uid85_fpAddTest_merged_bit_select_b : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal rVStage_uid171_lzCountVal_uid85_fpAddTest_merged_bit_select_c : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal leftShiftStageSel4Dto3_uid232_fracPostNormExt_uid88_fpAddTest_merged_bit_select_b : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal leftShiftStageSel4Dto3_uid232_fracPostNormExt_uid88_fpAddTest_merged_bit_select_c : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal leftShiftStageSel4Dto3_uid232_fracPostNormExt_uid88_fpAddTest_merged_bit_select_d : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist0_stickyBits_uid69_fpAddTest_merged_bit_select_c_1_q : STD_LOGIC_VECTOR (25 downto 0);\n" +
                        "    signal redist1_r_uid179_lzCountVal_uid85_fpAddTest_q_1_q : STD_LOGIC_VECTOR (4 downto 0);\n" +
                        "    signal redist2_vStage_uid154_lzCountVal_uid85_fpAddTest_b_2_q : STD_LOGIC_VECTOR (11 downto 0);\n" +
                        "    signal redist3_vCount_uid152_lzCountVal_uid85_fpAddTest_q_1_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist4_aMinusA_uid87_fpAddTest_q_1_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist5_fracGRS_uid84_fpAddTest_q_2_q : STD_LOGIC_VECTOR (27 downto 0);\n" +
                        "    signal redist6_effSub_uid52_fpAddTest_q_4_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist7_sigB_uid51_fpAddTest_b_1_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist8_sigB_uid51_fpAddTest_b_4_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist9_sigA_uid50_fpAddTest_b_1_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist10_sigA_uid50_fpAddTest_b_4_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist11_InvExpXIsZero_uid44_fpAddTest_q_3_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist12_excI_bSig_uid41_fpAddTest_q_1_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist13_fracXIsZero_uid39_fpAddTest_q_4_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist14_expXIsMax_uid38_fpAddTest_q_4_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist15_excZ_bSig_uid17_uid37_fpAddTest_q_1_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist16_excZ_bSig_uid17_uid37_fpAddTest_q_4_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist17_excZ_bSig_uid17_uid37_fpAddTest_q_5_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist18_excI_aSig_uid27_fpAddTest_q_1_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist19_fracXIsZero_uid25_fpAddTest_q_2_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist20_excZ_aSig_uid16_uid23_fpAddTest_q_2_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist21_frac_aSig_uid22_fpAddTest_b_2_q : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal redist22_exp_aSig_uid21_fpAddTest_b_3_q : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "\n" +
                        "    -- cAmA_uid86_fpAddTest(CONSTANT,85)\n" +
                        "    cAmA_uid86_fpAddTest_q <= \"11100\";\n" +
                        "\n" +
                        "    -- zs_uid150_lzCountVal_uid85_fpAddTest(CONSTANT,149)\n" +
                        "    zs_uid150_lzCountVal_uid85_fpAddTest_q <= \"0000000000000000\";\n" +
                        "\n" +
                        "    -- sigY_uid11_fpAddTest(BITSELECT,10)@0\n" +
                        "    sigY_uid11_fpAddTest_b <= STD_LOGIC_VECTOR(b(31 downto 31));\n" +
                        "\n" +
                        "    -- expY_uid10_fpAddTest(BITSELECT,9)@0\n" +
                        "    expY_uid10_fpAddTest_b <= b(30 downto 23);\n" +
                        "\n" +
                        "    -- fracY_uid9_fpAddTest(BITSELECT,8)@0\n" +
                        "    fracY_uid9_fpAddTest_b <= b(22 downto 0);\n" +
                        "\n" +
                        "    -- ypn_uid12_fpAddTest(BITJOIN,11)@0\n" +
                        "    ypn_uid12_fpAddTest_q <= sigY_uid11_fpAddTest_b & expY_uid10_fpAddTest_b & fracY_uid9_fpAddTest_b;\n" +
                        "\n" +
                        "    -- GND(CONSTANT,0)\n" +
                        "    GND_q <= \"0\";\n" +
                        "\n" +
                        "    -- expFracY_uid7_fpAddTest(BITSELECT,6)@0\n" +
                        "    expFracY_uid7_fpAddTest_b <= b(30 downto 0);\n" +
                        "\n" +
                        "    -- expFracX_uid6_fpAddTest(BITSELECT,5)@0\n" +
                        "    expFracX_uid6_fpAddTest_b <= a(30 downto 0);\n" +
                        "\n" +
                        "    -- xGTEy_uid8_fpAddTest(COMPARE,7)@0\n" +
                        "    xGTEy_uid8_fpAddTest_a <= STD_LOGIC_VECTOR(\"00\" & expFracX_uid6_fpAddTest_b);\n" +
                        "    xGTEy_uid8_fpAddTest_b <= STD_LOGIC_VECTOR(\"00\" & expFracY_uid7_fpAddTest_b);\n" +
                        "    xGTEy_uid8_fpAddTest_o <= STD_LOGIC_VECTOR(UNSIGNED(xGTEy_uid8_fpAddTest_a) - UNSIGNED(xGTEy_uid8_fpAddTest_b));\n" +
                        "    xGTEy_uid8_fpAddTest_n(0) <= not (xGTEy_uid8_fpAddTest_o(32));\n" +
                        "\n" +
                        "    -- bSig_uid17_fpAddTest(MUX,16)@0\n" +
                        "    bSig_uid17_fpAddTest_s <= xGTEy_uid8_fpAddTest_n;\n" +
                        "    bSig_uid17_fpAddTest_combproc: PROCESS (bSig_uid17_fpAddTest_s, a, ypn_uid12_fpAddTest_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (bSig_uid17_fpAddTest_s) IS\n" +
                        "            WHEN \"0\" => bSig_uid17_fpAddTest_q <= a;\n" +
                        "            WHEN \"1\" => bSig_uid17_fpAddTest_q <= ypn_uid12_fpAddTest_q;\n" +
                        "            WHEN OTHERS => bSig_uid17_fpAddTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- sigB_uid51_fpAddTest(BITSELECT,50)@0\n" +
                        "    sigB_uid51_fpAddTest_b <= STD_LOGIC_VECTOR(bSig_uid17_fpAddTest_q(31 downto 31));\n" +
                        "\n" +
                        "    -- redist7_sigB_uid51_fpAddTest_b_1(DELAY,263)\n" +
                        "    redist7_sigB_uid51_fpAddTest_b_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => sigB_uid51_fpAddTest_b, xout => redist7_sigB_uid51_fpAddTest_b_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- aSig_uid16_fpAddTest(MUX,15)@0\n" +
                        "    aSig_uid16_fpAddTest_s <= xGTEy_uid8_fpAddTest_n;\n" +
                        "    aSig_uid16_fpAddTest_combproc: PROCESS (aSig_uid16_fpAddTest_s, ypn_uid12_fpAddTest_q, a)\n" +
                        "    BEGIN\n" +
                        "        CASE (aSig_uid16_fpAddTest_s) IS\n" +
                        "            WHEN \"0\" => aSig_uid16_fpAddTest_q <= ypn_uid12_fpAddTest_q;\n" +
                        "            WHEN \"1\" => aSig_uid16_fpAddTest_q <= a;\n" +
                        "            WHEN OTHERS => aSig_uid16_fpAddTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- sigA_uid50_fpAddTest(BITSELECT,49)@0\n" +
                        "    sigA_uid50_fpAddTest_b <= STD_LOGIC_VECTOR(aSig_uid16_fpAddTest_q(31 downto 31));\n" +
                        "\n" +
                        "    -- redist9_sigA_uid50_fpAddTest_b_1(DELAY,265)\n" +
                        "    redist9_sigA_uid50_fpAddTest_b_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => sigA_uid50_fpAddTest_b, xout => redist9_sigA_uid50_fpAddTest_b_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- effSub_uid52_fpAddTest(LOGICAL,51)@1 + 1\n" +
                        "    effSub_uid52_fpAddTest_qi <= redist9_sigA_uid50_fpAddTest_b_1_q xor redist7_sigB_uid51_fpAddTest_b_1_q;\n" +
                        "    effSub_uid52_fpAddTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => effSub_uid52_fpAddTest_qi, xout => effSub_uid52_fpAddTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- exp_bSig_uid35_fpAddTest(BITSELECT,34)@0\n" +
                        "    exp_bSig_uid35_fpAddTest_in <= bSig_uid17_fpAddTest_q(30 downto 0);\n" +
                        "    exp_bSig_uid35_fpAddTest_b <= exp_bSig_uid35_fpAddTest_in(30 downto 23);\n" +
                        "\n" +
                        "    -- exp_aSig_uid21_fpAddTest(BITSELECT,20)@0\n" +
                        "    exp_aSig_uid21_fpAddTest_in <= aSig_uid16_fpAddTest_q(30 downto 0);\n" +
                        "    exp_aSig_uid21_fpAddTest_b <= exp_aSig_uid21_fpAddTest_in(30 downto 23);\n" +
                        "\n" +
                        "    -- expAmExpB_uid60_fpAddTest(SUB,59)@0 + 1\n" +
                        "    expAmExpB_uid60_fpAddTest_a <= STD_LOGIC_VECTOR(\"0\" & exp_aSig_uid21_fpAddTest_b);\n" +
                        "    expAmExpB_uid60_fpAddTest_b <= STD_LOGIC_VECTOR(\"0\" & exp_bSig_uid35_fpAddTest_b);\n" +
                        "    expAmExpB_uid60_fpAddTest_clkproc: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            expAmExpB_uid60_fpAddTest_o <= (others => '0');\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            expAmExpB_uid60_fpAddTest_o <= STD_LOGIC_VECTOR(UNSIGNED(expAmExpB_uid60_fpAddTest_a) - UNSIGNED(expAmExpB_uid60_fpAddTest_b));\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "    expAmExpB_uid60_fpAddTest_q <= expAmExpB_uid60_fpAddTest_o(8 downto 0);\n" +
                        "\n" +
                        "    -- cWFP2_uid61_fpAddTest(CONSTANT,60)\n" +
                        "    cWFP2_uid61_fpAddTest_q <= \"11001\";\n" +
                        "\n" +
                        "    -- shiftedOut_uid63_fpAddTest(COMPARE,62)@1\n" +
                        "    shiftedOut_uid63_fpAddTest_a <= STD_LOGIC_VECTOR(\"000000\" & cWFP2_uid61_fpAddTest_q);\n" +
                        "    shiftedOut_uid63_fpAddTest_b <= STD_LOGIC_VECTOR(\"00\" & expAmExpB_uid60_fpAddTest_q);\n" +
                        "    shiftedOut_uid63_fpAddTest_o <= STD_LOGIC_VECTOR(UNSIGNED(shiftedOut_uid63_fpAddTest_a) - UNSIGNED(shiftedOut_uid63_fpAddTest_b));\n" +
                        "    shiftedOut_uid63_fpAddTest_c(0) <= shiftedOut_uid63_fpAddTest_o(10);\n" +
                        "\n" +
                        "    -- iShiftedOut_uid67_fpAddTest(LOGICAL,66)@1\n" +
                        "    iShiftedOut_uid67_fpAddTest_q <= not (shiftedOut_uid63_fpAddTest_c);\n" +
                        "\n" +
                        "    -- zeroOutCst_uid218_alignmentShifter_uid64_fpAddTest(CONSTANT,217)\n" +
                        "    zeroOutCst_uid218_alignmentShifter_uid64_fpAddTest_q <= \"0000000000000000000000000000000000000000000000000\";\n" +
                        "\n" +
                        "    -- rightShiftStage2Idx3Pad3_uid214_alignmentShifter_uid64_fpAddTest(CONSTANT,213)\n" +
                        "    rightShiftStage2Idx3Pad3_uid214_alignmentShifter_uid64_fpAddTest_q <= \"000\";\n" +
                        "\n" +
                        "    -- rightShiftStage2Idx3Rng3_uid213_alignmentShifter_uid64_fpAddTest(BITSELECT,212)@1\n" +
                        "    rightShiftStage2Idx3Rng3_uid213_alignmentShifter_uid64_fpAddTest_b <= rightShiftStage1_uid206_alignmentShifter_uid64_fpAddTest_q(48 downto 3);\n" +
                        "\n" +
                        "    -- rightShiftStage2Idx3_uid215_alignmentShifter_uid64_fpAddTest(BITJOIN,214)@1\n" +
                        "    rightShiftStage2Idx3_uid215_alignmentShifter_uid64_fpAddTest_q <= rightShiftStage2Idx3Pad3_uid214_alignmentShifter_uid64_fpAddTest_q & rightShiftStage2Idx3Rng3_uid213_alignmentShifter_uid64_fpAddTest_b;\n" +
                        "\n" +
                        "    -- zs_uid170_lzCountVal_uid85_fpAddTest(CONSTANT,169)\n" +
                        "    zs_uid170_lzCountVal_uid85_fpAddTest_q <= \"00\";\n" +
                        "\n" +
                        "    -- rightShiftStage2Idx2Rng2_uid210_alignmentShifter_uid64_fpAddTest(BITSELECT,209)@1\n" +
                        "    rightShiftStage2Idx2Rng2_uid210_alignmentShifter_uid64_fpAddTest_b <= rightShiftStage1_uid206_alignmentShifter_uid64_fpAddTest_q(48 downto 2);\n" +
                        "\n" +
                        "    -- rightShiftStage2Idx2_uid212_alignmentShifter_uid64_fpAddTest(BITJOIN,211)@1\n" +
                        "    rightShiftStage2Idx2_uid212_alignmentShifter_uid64_fpAddTest_q <= zs_uid170_lzCountVal_uid85_fpAddTest_q & rightShiftStage2Idx2Rng2_uid210_alignmentShifter_uid64_fpAddTest_b;\n" +
                        "\n" +
                        "    -- rightShiftStage2Idx1Rng1_uid207_alignmentShifter_uid64_fpAddTest(BITSELECT,206)@1\n" +
                        "    rightShiftStage2Idx1Rng1_uid207_alignmentShifter_uid64_fpAddTest_b <= rightShiftStage1_uid206_alignmentShifter_uid64_fpAddTest_q(48 downto 1);\n" +
                        "\n" +
                        "    -- rightShiftStage2Idx1_uid209_alignmentShifter_uid64_fpAddTest(BITJOIN,208)@1\n" +
                        "    rightShiftStage2Idx1_uid209_alignmentShifter_uid64_fpAddTest_q <= GND_q & rightShiftStage2Idx1Rng1_uid207_alignmentShifter_uid64_fpAddTest_b;\n" +
                        "\n" +
                        "    -- rightShiftStage1Idx3Pad12_uid203_alignmentShifter_uid64_fpAddTest(CONSTANT,202)\n" +
                        "    rightShiftStage1Idx3Pad12_uid203_alignmentShifter_uid64_fpAddTest_q <= \"000000000000\";\n" +
                        "\n" +
                        "    -- rightShiftStage1Idx3Rng12_uid202_alignmentShifter_uid64_fpAddTest(BITSELECT,201)@1\n" +
                        "    rightShiftStage1Idx3Rng12_uid202_alignmentShifter_uid64_fpAddTest_b <= rightShiftStage0_uid195_alignmentShifter_uid64_fpAddTest_q(48 downto 12);\n" +
                        "\n" +
                        "    -- rightShiftStage1Idx3_uid204_alignmentShifter_uid64_fpAddTest(BITJOIN,203)@1\n" +
                        "    rightShiftStage1Idx3_uid204_alignmentShifter_uid64_fpAddTest_q <= rightShiftStage1Idx3Pad12_uid203_alignmentShifter_uid64_fpAddTest_q & rightShiftStage1Idx3Rng12_uid202_alignmentShifter_uid64_fpAddTest_b;\n" +
                        "\n" +
                        "    -- cstAllZWE_uid20_fpAddTest(CONSTANT,19)\n" +
                        "    cstAllZWE_uid20_fpAddTest_q <= \"00000000\";\n" +
                        "\n" +
                        "    -- rightShiftStage1Idx2Rng8_uid199_alignmentShifter_uid64_fpAddTest(BITSELECT,198)@1\n" +
                        "    rightShiftStage1Idx2Rng8_uid199_alignmentShifter_uid64_fpAddTest_b <= rightShiftStage0_uid195_alignmentShifter_uid64_fpAddTest_q(48 downto 8);\n" +
                        "\n" +
                        "    -- rightShiftStage1Idx2_uid201_alignmentShifter_uid64_fpAddTest(BITJOIN,200)@1\n" +
                        "    rightShiftStage1Idx2_uid201_alignmentShifter_uid64_fpAddTest_q <= cstAllZWE_uid20_fpAddTest_q & rightShiftStage1Idx2Rng8_uid199_alignmentShifter_uid64_fpAddTest_b;\n" +
                        "\n" +
                        "    -- zs_uid164_lzCountVal_uid85_fpAddTest(CONSTANT,163)\n" +
                        "    zs_uid164_lzCountVal_uid85_fpAddTest_q <= \"0000\";\n" +
                        "\n" +
                        "    -- rightShiftStage1Idx1Rng4_uid196_alignmentShifter_uid64_fpAddTest(BITSELECT,195)@1\n" +
                        "    rightShiftStage1Idx1Rng4_uid196_alignmentShifter_uid64_fpAddTest_b <= rightShiftStage0_uid195_alignmentShifter_uid64_fpAddTest_q(48 downto 4);\n" +
                        "\n" +
                        "    -- rightShiftStage1Idx1_uid198_alignmentShifter_uid64_fpAddTest(BITJOIN,197)@1\n" +
                        "    rightShiftStage1Idx1_uid198_alignmentShifter_uid64_fpAddTest_q <= zs_uid164_lzCountVal_uid85_fpAddTest_q & rightShiftStage1Idx1Rng4_uid196_alignmentShifter_uid64_fpAddTest_b;\n" +
                        "\n" +
                        "    -- rightShiftStage0Idx3Pad48_uid192_alignmentShifter_uid64_fpAddTest(CONSTANT,191)\n" +
                        "    rightShiftStage0Idx3Pad48_uid192_alignmentShifter_uid64_fpAddTest_q <= \"000000000000000000000000000000000000000000000000\";\n" +
                        "\n" +
                        "    -- rightShiftStage0Idx3Rng48_uid191_alignmentShifter_uid64_fpAddTest(BITSELECT,190)@1\n" +
                        "    rightShiftStage0Idx3Rng48_uid191_alignmentShifter_uid64_fpAddTest_b <= rightPaddedIn_uid65_fpAddTest_q(48 downto 48);\n" +
                        "\n" +
                        "    -- rightShiftStage0Idx3_uid193_alignmentShifter_uid64_fpAddTest(BITJOIN,192)@1\n" +
                        "    rightShiftStage0Idx3_uid193_alignmentShifter_uid64_fpAddTest_q <= rightShiftStage0Idx3Pad48_uid192_alignmentShifter_uid64_fpAddTest_q & rightShiftStage0Idx3Rng48_uid191_alignmentShifter_uid64_fpAddTest_b;\n" +
                        "\n" +
                        "    -- rightShiftStage0Idx2Pad32_uid189_alignmentShifter_uid64_fpAddTest(CONSTANT,188)\n" +
                        "    rightShiftStage0Idx2Pad32_uid189_alignmentShifter_uid64_fpAddTest_q <= \"00000000000000000000000000000000\";\n" +
                        "\n" +
                        "    -- rightShiftStage0Idx2Rng32_uid188_alignmentShifter_uid64_fpAddTest(BITSELECT,187)@1\n" +
                        "    rightShiftStage0Idx2Rng32_uid188_alignmentShifter_uid64_fpAddTest_b <= rightPaddedIn_uid65_fpAddTest_q(48 downto 32);\n" +
                        "\n" +
                        "    -- rightShiftStage0Idx2_uid190_alignmentShifter_uid64_fpAddTest(BITJOIN,189)@1\n" +
                        "    rightShiftStage0Idx2_uid190_alignmentShifter_uid64_fpAddTest_q <= rightShiftStage0Idx2Pad32_uid189_alignmentShifter_uid64_fpAddTest_q & rightShiftStage0Idx2Rng32_uid188_alignmentShifter_uid64_fpAddTest_b;\n" +
                        "\n" +
                        "    -- rightShiftStage0Idx1Rng16_uid185_alignmentShifter_uid64_fpAddTest(BITSELECT,184)@1\n" +
                        "    rightShiftStage0Idx1Rng16_uid185_alignmentShifter_uid64_fpAddTest_b <= rightPaddedIn_uid65_fpAddTest_q(48 downto 16);\n" +
                        "\n" +
                        "    -- rightShiftStage0Idx1_uid187_alignmentShifter_uid64_fpAddTest(BITJOIN,186)@1\n" +
                        "    rightShiftStage0Idx1_uid187_alignmentShifter_uid64_fpAddTest_q <= zs_uid150_lzCountVal_uid85_fpAddTest_q & rightShiftStage0Idx1Rng16_uid185_alignmentShifter_uid64_fpAddTest_b;\n" +
                        "\n" +
                        "    -- excZ_bSig_uid17_uid37_fpAddTest(LOGICAL,36)@0\n" +
                        "    excZ_bSig_uid17_uid37_fpAddTest_q <= \"1\" WHEN exp_bSig_uid35_fpAddTest_b = cstAllZWE_uid20_fpAddTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- redist15_excZ_bSig_uid17_uid37_fpAddTest_q_1(DELAY,271)\n" +
                        "    redist15_excZ_bSig_uid17_uid37_fpAddTest_q_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => excZ_bSig_uid17_uid37_fpAddTest_q, xout => redist15_excZ_bSig_uid17_uid37_fpAddTest_q_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- InvExpXIsZero_uid44_fpAddTest(LOGICAL,43)@1\n" +
                        "    InvExpXIsZero_uid44_fpAddTest_q <= not (redist15_excZ_bSig_uid17_uid37_fpAddTest_q_1_q);\n" +
                        "\n" +
                        "    -- cstZeroWF_uid19_fpAddTest(CONSTANT,18)\n" +
                        "    cstZeroWF_uid19_fpAddTest_q <= \"00000000000000000000000\";\n" +
                        "\n" +
                        "    -- frac_bSig_uid36_fpAddTest(BITSELECT,35)@0\n" +
                        "    frac_bSig_uid36_fpAddTest_in <= bSig_uid17_fpAddTest_q(22 downto 0);\n" +
                        "    frac_bSig_uid36_fpAddTest_b <= frac_bSig_uid36_fpAddTest_in(22 downto 0);\n" +
                        "\n" +
                        "    -- fracBz_uid56_fpAddTest(MUX,55)@0 + 1\n" +
                        "    fracBz_uid56_fpAddTest_s <= excZ_bSig_uid17_uid37_fpAddTest_q;\n" +
                        "    fracBz_uid56_fpAddTest_clkproc: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            fracBz_uid56_fpAddTest_q <= (others => '0');\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            CASE (fracBz_uid56_fpAddTest_s) IS\n" +
                        "                WHEN \"0\" => fracBz_uid56_fpAddTest_q <= frac_bSig_uid36_fpAddTest_b;\n" +
                        "                WHEN \"1\" => fracBz_uid56_fpAddTest_q <= cstZeroWF_uid19_fpAddTest_q;\n" +
                        "                WHEN OTHERS => fracBz_uid56_fpAddTest_q <= (others => '0');\n" +
                        "            END CASE;\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- oFracB_uid59_fpAddTest(BITJOIN,58)@1\n" +
                        "    oFracB_uid59_fpAddTest_q <= InvExpXIsZero_uid44_fpAddTest_q & fracBz_uid56_fpAddTest_q;\n" +
                        "\n" +
                        "    -- padConst_uid64_fpAddTest(CONSTANT,63)\n" +
                        "    padConst_uid64_fpAddTest_q <= \"0000000000000000000000000\";\n" +
                        "\n" +
                        "    -- rightPaddedIn_uid65_fpAddTest(BITJOIN,64)@1\n" +
                        "    rightPaddedIn_uid65_fpAddTest_q <= oFracB_uid59_fpAddTest_q & padConst_uid64_fpAddTest_q;\n" +
                        "\n" +
                        "    -- rightShiftStage0_uid195_alignmentShifter_uid64_fpAddTest(MUX,194)@1\n" +
                        "    rightShiftStage0_uid195_alignmentShifter_uid64_fpAddTest_s <= rightShiftStageSel5Dto4_uid194_alignmentShifter_uid64_fpAddTest_merged_bit_select_b;\n" +
                        "    rightShiftStage0_uid195_alignmentShifter_uid64_fpAddTest_combproc: PROCESS (rightShiftStage0_uid195_alignmentShifter_uid64_fpAddTest_s, rightPaddedIn_uid65_fpAddTest_q, rightShiftStage0Idx1_uid187_alignmentShifter_uid64_fpAddTest_q, rightShiftStage0Idx2_uid190_alignmentShifter_uid64_fpAddTest_q, rightShiftStage0Idx3_uid193_alignmentShifter_uid64_fpAddTest_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (rightShiftStage0_uid195_alignmentShifter_uid64_fpAddTest_s) IS\n" +
                        "            WHEN \"00\" => rightShiftStage0_uid195_alignmentShifter_uid64_fpAddTest_q <= rightPaddedIn_uid65_fpAddTest_q;\n" +
                        "            WHEN \"01\" => rightShiftStage0_uid195_alignmentShifter_uid64_fpAddTest_q <= rightShiftStage0Idx1_uid187_alignmentShifter_uid64_fpAddTest_q;\n" +
                        "            WHEN \"10\" => rightShiftStage0_uid195_alignmentShifter_uid64_fpAddTest_q <= rightShiftStage0Idx2_uid190_alignmentShifter_uid64_fpAddTest_q;\n" +
                        "            WHEN \"11\" => rightShiftStage0_uid195_alignmentShifter_uid64_fpAddTest_q <= rightShiftStage0Idx3_uid193_alignmentShifter_uid64_fpAddTest_q;\n" +
                        "            WHEN OTHERS => rightShiftStage0_uid195_alignmentShifter_uid64_fpAddTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- rightShiftStage1_uid206_alignmentShifter_uid64_fpAddTest(MUX,205)@1\n" +
                        "    rightShiftStage1_uid206_alignmentShifter_uid64_fpAddTest_s <= rightShiftStageSel5Dto4_uid194_alignmentShifter_uid64_fpAddTest_merged_bit_select_c;\n" +
                        "    rightShiftStage1_uid206_alignmentShifter_uid64_fpAddTest_combproc: PROCESS (rightShiftStage1_uid206_alignmentShifter_uid64_fpAddTest_s, rightShiftStage0_uid195_alignmentShifter_uid64_fpAddTest_q, rightShiftStage1Idx1_uid198_alignmentShifter_uid64_fpAddTest_q, rightShiftStage1Idx2_uid201_alignmentShifter_uid64_fpAddTest_q, rightShiftStage1Idx3_uid204_alignmentShifter_uid64_fpAddTest_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (rightShiftStage1_uid206_alignmentShifter_uid64_fpAddTest_s) IS\n" +
                        "            WHEN \"00\" => rightShiftStage1_uid206_alignmentShifter_uid64_fpAddTest_q <= rightShiftStage0_uid195_alignmentShifter_uid64_fpAddTest_q;\n" +
                        "            WHEN \"01\" => rightShiftStage1_uid206_alignmentShifter_uid64_fpAddTest_q <= rightShiftStage1Idx1_uid198_alignmentShifter_uid64_fpAddTest_q;\n" +
                        "            WHEN \"10\" => rightShiftStage1_uid206_alignmentShifter_uid64_fpAddTest_q <= rightShiftStage1Idx2_uid201_alignmentShifter_uid64_fpAddTest_q;\n" +
                        "            WHEN \"11\" => rightShiftStage1_uid206_alignmentShifter_uid64_fpAddTest_q <= rightShiftStage1Idx3_uid204_alignmentShifter_uid64_fpAddTest_q;\n" +
                        "            WHEN OTHERS => rightShiftStage1_uid206_alignmentShifter_uid64_fpAddTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- rightShiftStageSel5Dto4_uid194_alignmentShifter_uid64_fpAddTest_merged_bit_select(BITSELECT,250)@1\n" +
                        "    rightShiftStageSel5Dto4_uid194_alignmentShifter_uid64_fpAddTest_merged_bit_select_in <= expAmExpB_uid60_fpAddTest_q(5 downto 0);\n" +
                        "    rightShiftStageSel5Dto4_uid194_alignmentShifter_uid64_fpAddTest_merged_bit_select_b <= rightShiftStageSel5Dto4_uid194_alignmentShifter_uid64_fpAddTest_merged_bit_select_in(5 downto 4);\n" +
                        "    rightShiftStageSel5Dto4_uid194_alignmentShifter_uid64_fpAddTest_merged_bit_select_c <= rightShiftStageSel5Dto4_uid194_alignmentShifter_uid64_fpAddTest_merged_bit_select_in(3 downto 2);\n" +
                        "    rightShiftStageSel5Dto4_uid194_alignmentShifter_uid64_fpAddTest_merged_bit_select_d <= rightShiftStageSel5Dto4_uid194_alignmentShifter_uid64_fpAddTest_merged_bit_select_in(1 downto 0);\n" +
                        "\n" +
                        "    -- rightShiftStage2_uid217_alignmentShifter_uid64_fpAddTest(MUX,216)@1\n" +
                        "    rightShiftStage2_uid217_alignmentShifter_uid64_fpAddTest_s <= rightShiftStageSel5Dto4_uid194_alignmentShifter_uid64_fpAddTest_merged_bit_select_d;\n" +
                        "    rightShiftStage2_uid217_alignmentShifter_uid64_fpAddTest_combproc: PROCESS (rightShiftStage2_uid217_alignmentShifter_uid64_fpAddTest_s, rightShiftStage1_uid206_alignmentShifter_uid64_fpAddTest_q, rightShiftStage2Idx1_uid209_alignmentShifter_uid64_fpAddTest_q, rightShiftStage2Idx2_uid212_alignmentShifter_uid64_fpAddTest_q, rightShiftStage2Idx3_uid215_alignmentShifter_uid64_fpAddTest_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (rightShiftStage2_uid217_alignmentShifter_uid64_fpAddTest_s) IS\n" +
                        "            WHEN \"00\" => rightShiftStage2_uid217_alignmentShifter_uid64_fpAddTest_q <= rightShiftStage1_uid206_alignmentShifter_uid64_fpAddTest_q;\n" +
                        "            WHEN \"01\" => rightShiftStage2_uid217_alignmentShifter_uid64_fpAddTest_q <= rightShiftStage2Idx1_uid209_alignmentShifter_uid64_fpAddTest_q;\n" +
                        "            WHEN \"10\" => rightShiftStage2_uid217_alignmentShifter_uid64_fpAddTest_q <= rightShiftStage2Idx2_uid212_alignmentShifter_uid64_fpAddTest_q;\n" +
                        "            WHEN \"11\" => rightShiftStage2_uid217_alignmentShifter_uid64_fpAddTest_q <= rightShiftStage2Idx3_uid215_alignmentShifter_uid64_fpAddTest_q;\n" +
                        "            WHEN OTHERS => rightShiftStage2_uid217_alignmentShifter_uid64_fpAddTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- wIntCst_uid183_alignmentShifter_uid64_fpAddTest(CONSTANT,182)\n" +
                        "    wIntCst_uid183_alignmentShifter_uid64_fpAddTest_q <= \"110001\";\n" +
                        "\n" +
                        "    -- shiftedOut_uid184_alignmentShifter_uid64_fpAddTest(COMPARE,183)@1\n" +
                        "    shiftedOut_uid184_alignmentShifter_uid64_fpAddTest_a <= STD_LOGIC_VECTOR(\"00\" & expAmExpB_uid60_fpAddTest_q);\n" +
                        "    shiftedOut_uid184_alignmentShifter_uid64_fpAddTest_b <= STD_LOGIC_VECTOR(\"00000\" & wIntCst_uid183_alignmentShifter_uid64_fpAddTest_q);\n" +
                        "    shiftedOut_uid184_alignmentShifter_uid64_fpAddTest_o <= STD_LOGIC_VECTOR(UNSIGNED(shiftedOut_uid184_alignmentShifter_uid64_fpAddTest_a) - UNSIGNED(shiftedOut_uid184_alignmentShifter_uid64_fpAddTest_b));\n" +
                        "    shiftedOut_uid184_alignmentShifter_uid64_fpAddTest_n(0) <= not (shiftedOut_uid184_alignmentShifter_uid64_fpAddTest_o(10));\n" +
                        "\n" +
                        "    -- r_uid219_alignmentShifter_uid64_fpAddTest(MUX,218)@1\n" +
                        "    r_uid219_alignmentShifter_uid64_fpAddTest_s <= shiftedOut_uid184_alignmentShifter_uid64_fpAddTest_n;\n" +
                        "    r_uid219_alignmentShifter_uid64_fpAddTest_combproc: PROCESS (r_uid219_alignmentShifter_uid64_fpAddTest_s, rightShiftStage2_uid217_alignmentShifter_uid64_fpAddTest_q, zeroOutCst_uid218_alignmentShifter_uid64_fpAddTest_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (r_uid219_alignmentShifter_uid64_fpAddTest_s) IS\n" +
                        "            WHEN \"0\" => r_uid219_alignmentShifter_uid64_fpAddTest_q <= rightShiftStage2_uid217_alignmentShifter_uid64_fpAddTest_q;\n" +
                        "            WHEN \"1\" => r_uid219_alignmentShifter_uid64_fpAddTest_q <= zeroOutCst_uid218_alignmentShifter_uid64_fpAddTest_q;\n" +
                        "            WHEN OTHERS => r_uid219_alignmentShifter_uid64_fpAddTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- alignFracBPostShiftOut_uid68_fpAddTest(LOGICAL,67)@1\n" +
                        "    alignFracBPostShiftOut_uid68_fpAddTest_b <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR((48 downto 1 => iShiftedOut_uid67_fpAddTest_q(0)) & iShiftedOut_uid67_fpAddTest_q));\n" +
                        "    alignFracBPostShiftOut_uid68_fpAddTest_q <= r_uid219_alignmentShifter_uid64_fpAddTest_q and alignFracBPostShiftOut_uid68_fpAddTest_b;\n" +
                        "\n" +
                        "    -- stickyBits_uid69_fpAddTest_merged_bit_select(BITSELECT,251)@1\n" +
                        "    stickyBits_uid69_fpAddTest_merged_bit_select_b <= alignFracBPostShiftOut_uid68_fpAddTest_q(22 downto 0);\n" +
                        "    stickyBits_uid69_fpAddTest_merged_bit_select_c <= alignFracBPostShiftOut_uid68_fpAddTest_q(48 downto 23);\n" +
                        "\n" +
                        "    -- redist0_stickyBits_uid69_fpAddTest_merged_bit_select_c_1(DELAY,256)\n" +
                        "    redist0_stickyBits_uid69_fpAddTest_merged_bit_select_c_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 26, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => stickyBits_uid69_fpAddTest_merged_bit_select_c, xout => redist0_stickyBits_uid69_fpAddTest_merged_bit_select_c_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- fracBAddOp_uid80_fpAddTest(BITJOIN,79)@2\n" +
                        "    fracBAddOp_uid80_fpAddTest_q <= GND_q & redist0_stickyBits_uid69_fpAddTest_merged_bit_select_c_1_q;\n" +
                        "\n" +
                        "    -- fracBAddOpPostXor_uid81_fpAddTest(LOGICAL,80)@2\n" +
                        "    fracBAddOpPostXor_uid81_fpAddTest_b <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR((26 downto 1 => effSub_uid52_fpAddTest_q(0)) & effSub_uid52_fpAddTest_q));\n" +
                        "    fracBAddOpPostXor_uid81_fpAddTest_q <= fracBAddOp_uid80_fpAddTest_q xor fracBAddOpPostXor_uid81_fpAddTest_b;\n" +
                        "\n" +
                        "    -- zocst_uid76_fpAddTest(CONSTANT,75)\n" +
                        "    zocst_uid76_fpAddTest_q <= \"01\";\n" +
                        "\n" +
                        "    -- frac_aSig_uid22_fpAddTest(BITSELECT,21)@0\n" +
                        "    frac_aSig_uid22_fpAddTest_in <= aSig_uid16_fpAddTest_q(22 downto 0);\n" +
                        "    frac_aSig_uid22_fpAddTest_b <= frac_aSig_uid22_fpAddTest_in(22 downto 0);\n" +
                        "\n" +
                        "    -- redist21_frac_aSig_uid22_fpAddTest_b_2(DELAY,277)\n" +
                        "    redist21_frac_aSig_uid22_fpAddTest_b_2 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 23, depth => 2, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => frac_aSig_uid22_fpAddTest_b, xout => redist21_frac_aSig_uid22_fpAddTest_b_2_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- cmpEQ_stickyBits_cZwF_uid71_fpAddTest(LOGICAL,70)@1 + 1\n" +
                        "    cmpEQ_stickyBits_cZwF_uid71_fpAddTest_qi <= \"1\" WHEN stickyBits_uid69_fpAddTest_merged_bit_select_b = cstZeroWF_uid19_fpAddTest_q ELSE \"0\";\n" +
                        "    cmpEQ_stickyBits_cZwF_uid71_fpAddTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => cmpEQ_stickyBits_cZwF_uid71_fpAddTest_qi, xout => cmpEQ_stickyBits_cZwF_uid71_fpAddTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- effSubInvSticky_uid74_fpAddTest(LOGICAL,73)@2\n" +
                        "    effSubInvSticky_uid74_fpAddTest_q <= effSub_uid52_fpAddTest_q and cmpEQ_stickyBits_cZwF_uid71_fpAddTest_q;\n" +
                        "\n" +
                        "    -- fracAAddOp_uid77_fpAddTest(BITJOIN,76)@2\n" +
                        "    fracAAddOp_uid77_fpAddTest_q <= zocst_uid76_fpAddTest_q & redist21_frac_aSig_uid22_fpAddTest_b_2_q & GND_q & effSubInvSticky_uid74_fpAddTest_q;\n" +
                        "\n" +
                        "    -- fracAddResult_uid82_fpAddTest(ADD,81)@2\n" +
                        "    fracAddResult_uid82_fpAddTest_a <= STD_LOGIC_VECTOR(\"0\" & fracAAddOp_uid77_fpAddTest_q);\n" +
                        "    fracAddResult_uid82_fpAddTest_b <= STD_LOGIC_VECTOR(\"0\" & fracBAddOpPostXor_uid81_fpAddTest_q);\n" +
                        "    fracAddResult_uid82_fpAddTest_o <= STD_LOGIC_VECTOR(UNSIGNED(fracAddResult_uid82_fpAddTest_a) + UNSIGNED(fracAddResult_uid82_fpAddTest_b));\n" +
                        "    fracAddResult_uid82_fpAddTest_q <= fracAddResult_uid82_fpAddTest_o(27 downto 0);\n" +
                        "\n" +
                        "    -- rangeFracAddResultMwfp3Dto0_uid83_fpAddTest(BITSELECT,82)@2\n" +
                        "    rangeFracAddResultMwfp3Dto0_uid83_fpAddTest_in <= fracAddResult_uid82_fpAddTest_q(26 downto 0);\n" +
                        "    rangeFracAddResultMwfp3Dto0_uid83_fpAddTest_b <= rangeFracAddResultMwfp3Dto0_uid83_fpAddTest_in(26 downto 0);\n" +
                        "\n" +
                        "    -- invCmpEQ_stickyBits_cZwF_uid72_fpAddTest(LOGICAL,71)@2\n" +
                        "    invCmpEQ_stickyBits_cZwF_uid72_fpAddTest_q <= not (cmpEQ_stickyBits_cZwF_uid71_fpAddTest_q);\n" +
                        "\n" +
                        "    -- fracGRS_uid84_fpAddTest(BITJOIN,83)@2\n" +
                        "    fracGRS_uid84_fpAddTest_q <= rangeFracAddResultMwfp3Dto0_uid83_fpAddTest_b & invCmpEQ_stickyBits_cZwF_uid72_fpAddTest_q;\n" +
                        "\n" +
                        "    -- rVStage_uid151_lzCountVal_uid85_fpAddTest(BITSELECT,150)@2\n" +
                        "    rVStage_uid151_lzCountVal_uid85_fpAddTest_b <= fracGRS_uid84_fpAddTest_q(27 downto 12);\n" +
                        "\n" +
                        "    -- vCount_uid152_lzCountVal_uid85_fpAddTest(LOGICAL,151)@2\n" +
                        "    vCount_uid152_lzCountVal_uid85_fpAddTest_q <= \"1\" WHEN rVStage_uid151_lzCountVal_uid85_fpAddTest_b = zs_uid150_lzCountVal_uid85_fpAddTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- redist3_vCount_uid152_lzCountVal_uid85_fpAddTest_q_1(DELAY,259)\n" +
                        "    redist3_vCount_uid152_lzCountVal_uid85_fpAddTest_q_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => vCount_uid152_lzCountVal_uid85_fpAddTest_q, xout => redist3_vCount_uid152_lzCountVal_uid85_fpAddTest_q_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- vStage_uid154_lzCountVal_uid85_fpAddTest(BITSELECT,153)@2\n" +
                        "    vStage_uid154_lzCountVal_uid85_fpAddTest_in <= fracGRS_uid84_fpAddTest_q(11 downto 0);\n" +
                        "    vStage_uid154_lzCountVal_uid85_fpAddTest_b <= vStage_uid154_lzCountVal_uid85_fpAddTest_in(11 downto 0);\n" +
                        "\n" +
                        "    -- mO_uid153_lzCountVal_uid85_fpAddTest(CONSTANT,152)\n" +
                        "    mO_uid153_lzCountVal_uid85_fpAddTest_q <= \"1111\";\n" +
                        "\n" +
                        "    -- cStage_uid155_lzCountVal_uid85_fpAddTest(BITJOIN,154)@2\n" +
                        "    cStage_uid155_lzCountVal_uid85_fpAddTest_q <= vStage_uid154_lzCountVal_uid85_fpAddTest_b & mO_uid153_lzCountVal_uid85_fpAddTest_q;\n" +
                        "\n" +
                        "    -- vStagei_uid157_lzCountVal_uid85_fpAddTest(MUX,156)@2 + 1\n" +
                        "    vStagei_uid157_lzCountVal_uid85_fpAddTest_s <= vCount_uid152_lzCountVal_uid85_fpAddTest_q;\n" +
                        "    vStagei_uid157_lzCountVal_uid85_fpAddTest_clkproc: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            vStagei_uid157_lzCountVal_uid85_fpAddTest_q <= (others => '0');\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            CASE (vStagei_uid157_lzCountVal_uid85_fpAddTest_s) IS\n" +
                        "                WHEN \"0\" => vStagei_uid157_lzCountVal_uid85_fpAddTest_q <= rVStage_uid151_lzCountVal_uid85_fpAddTest_b;\n" +
                        "                WHEN \"1\" => vStagei_uid157_lzCountVal_uid85_fpAddTest_q <= cStage_uid155_lzCountVal_uid85_fpAddTest_q;\n" +
                        "                WHEN OTHERS => vStagei_uid157_lzCountVal_uid85_fpAddTest_q <= (others => '0');\n" +
                        "            END CASE;\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- rVStage_uid159_lzCountVal_uid85_fpAddTest_merged_bit_select(BITSELECT,252)@3\n" +
                        "    rVStage_uid159_lzCountVal_uid85_fpAddTest_merged_bit_select_b <= vStagei_uid157_lzCountVal_uid85_fpAddTest_q(15 downto 8);\n" +
                        "    rVStage_uid159_lzCountVal_uid85_fpAddTest_merged_bit_select_c <= vStagei_uid157_lzCountVal_uid85_fpAddTest_q(7 downto 0);\n" +
                        "\n" +
                        "    -- vCount_uid160_lzCountVal_uid85_fpAddTest(LOGICAL,159)@3\n" +
                        "    vCount_uid160_lzCountVal_uid85_fpAddTest_q <= \"1\" WHEN rVStage_uid159_lzCountVal_uid85_fpAddTest_merged_bit_select_b = cstAllZWE_uid20_fpAddTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- vStagei_uid163_lzCountVal_uid85_fpAddTest(MUX,162)@3\n" +
                        "    vStagei_uid163_lzCountVal_uid85_fpAddTest_s <= vCount_uid160_lzCountVal_uid85_fpAddTest_q;\n" +
                        "    vStagei_uid163_lzCountVal_uid85_fpAddTest_combproc: PROCESS (vStagei_uid163_lzCountVal_uid85_fpAddTest_s, rVStage_uid159_lzCountVal_uid85_fpAddTest_merged_bit_select_b, rVStage_uid159_lzCountVal_uid85_fpAddTest_merged_bit_select_c)\n" +
                        "    BEGIN\n" +
                        "        CASE (vStagei_uid163_lzCountVal_uid85_fpAddTest_s) IS\n" +
                        "            WHEN \"0\" => vStagei_uid163_lzCountVal_uid85_fpAddTest_q <= rVStage_uid159_lzCountVal_uid85_fpAddTest_merged_bit_select_b;\n" +
                        "            WHEN \"1\" => vStagei_uid163_lzCountVal_uid85_fpAddTest_q <= rVStage_uid159_lzCountVal_uid85_fpAddTest_merged_bit_select_c;\n" +
                        "            WHEN OTHERS => vStagei_uid163_lzCountVal_uid85_fpAddTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- rVStage_uid165_lzCountVal_uid85_fpAddTest_merged_bit_select(BITSELECT,253)@3\n" +
                        "    rVStage_uid165_lzCountVal_uid85_fpAddTest_merged_bit_select_b <= vStagei_uid163_lzCountVal_uid85_fpAddTest_q(7 downto 4);\n" +
                        "    rVStage_uid165_lzCountVal_uid85_fpAddTest_merged_bit_select_c <= vStagei_uid163_lzCountVal_uid85_fpAddTest_q(3 downto 0);\n" +
                        "\n" +
                        "    -- vCount_uid166_lzCountVal_uid85_fpAddTest(LOGICAL,165)@3\n" +
                        "    vCount_uid166_lzCountVal_uid85_fpAddTest_q <= \"1\" WHEN rVStage_uid165_lzCountVal_uid85_fpAddTest_merged_bit_select_b = zs_uid164_lzCountVal_uid85_fpAddTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- vStagei_uid169_lzCountVal_uid85_fpAddTest(MUX,168)@3\n" +
                        "    vStagei_uid169_lzCountVal_uid85_fpAddTest_s <= vCount_uid166_lzCountVal_uid85_fpAddTest_q;\n" +
                        "    vStagei_uid169_lzCountVal_uid85_fpAddTest_combproc: PROCESS (vStagei_uid169_lzCountVal_uid85_fpAddTest_s, rVStage_uid165_lzCountVal_uid85_fpAddTest_merged_bit_select_b, rVStage_uid165_lzCountVal_uid85_fpAddTest_merged_bit_select_c)\n" +
                        "    BEGIN\n" +
                        "        CASE (vStagei_uid169_lzCountVal_uid85_fpAddTest_s) IS\n" +
                        "            WHEN \"0\" => vStagei_uid169_lzCountVal_uid85_fpAddTest_q <= rVStage_uid165_lzCountVal_uid85_fpAddTest_merged_bit_select_b;\n" +
                        "            WHEN \"1\" => vStagei_uid169_lzCountVal_uid85_fpAddTest_q <= rVStage_uid165_lzCountVal_uid85_fpAddTest_merged_bit_select_c;\n" +
                        "            WHEN OTHERS => vStagei_uid169_lzCountVal_uid85_fpAddTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- rVStage_uid171_lzCountVal_uid85_fpAddTest_merged_bit_select(BITSELECT,254)@3\n" +
                        "    rVStage_uid171_lzCountVal_uid85_fpAddTest_merged_bit_select_b <= vStagei_uid169_lzCountVal_uid85_fpAddTest_q(3 downto 2);\n" +
                        "    rVStage_uid171_lzCountVal_uid85_fpAddTest_merged_bit_select_c <= vStagei_uid169_lzCountVal_uid85_fpAddTest_q(1 downto 0);\n" +
                        "\n" +
                        "    -- vCount_uid172_lzCountVal_uid85_fpAddTest(LOGICAL,171)@3\n" +
                        "    vCount_uid172_lzCountVal_uid85_fpAddTest_q <= \"1\" WHEN rVStage_uid171_lzCountVal_uid85_fpAddTest_merged_bit_select_b = zs_uid170_lzCountVal_uid85_fpAddTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- vStagei_uid175_lzCountVal_uid85_fpAddTest(MUX,174)@3\n" +
                        "    vStagei_uid175_lzCountVal_uid85_fpAddTest_s <= vCount_uid172_lzCountVal_uid85_fpAddTest_q;\n" +
                        "    vStagei_uid175_lzCountVal_uid85_fpAddTest_combproc: PROCESS (vStagei_uid175_lzCountVal_uid85_fpAddTest_s, rVStage_uid171_lzCountVal_uid85_fpAddTest_merged_bit_select_b, rVStage_uid171_lzCountVal_uid85_fpAddTest_merged_bit_select_c)\n" +
                        "    BEGIN\n" +
                        "        CASE (vStagei_uid175_lzCountVal_uid85_fpAddTest_s) IS\n" +
                        "            WHEN \"0\" => vStagei_uid175_lzCountVal_uid85_fpAddTest_q <= rVStage_uid171_lzCountVal_uid85_fpAddTest_merged_bit_select_b;\n" +
                        "            WHEN \"1\" => vStagei_uid175_lzCountVal_uid85_fpAddTest_q <= rVStage_uid171_lzCountVal_uid85_fpAddTest_merged_bit_select_c;\n" +
                        "            WHEN OTHERS => vStagei_uid175_lzCountVal_uid85_fpAddTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- rVStage_uid177_lzCountVal_uid85_fpAddTest(BITSELECT,176)@3\n" +
                        "    rVStage_uid177_lzCountVal_uid85_fpAddTest_b <= vStagei_uid175_lzCountVal_uid85_fpAddTest_q(1 downto 1);\n" +
                        "\n" +
                        "    -- vCount_uid178_lzCountVal_uid85_fpAddTest(LOGICAL,177)@3\n" +
                        "    vCount_uid178_lzCountVal_uid85_fpAddTest_q <= \"1\" WHEN rVStage_uid177_lzCountVal_uid85_fpAddTest_b = GND_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- r_uid179_lzCountVal_uid85_fpAddTest(BITJOIN,178)@3\n" +
                        "    r_uid179_lzCountVal_uid85_fpAddTest_q <= redist3_vCount_uid152_lzCountVal_uid85_fpAddTest_q_1_q & vCount_uid160_lzCountVal_uid85_fpAddTest_q & vCount_uid166_lzCountVal_uid85_fpAddTest_q & vCount_uid172_lzCountVal_uid85_fpAddTest_q & vCount_uid178_lzCountVal_uid85_fpAddTest_q;\n" +
                        "\n" +
                        "    -- redist1_r_uid179_lzCountVal_uid85_fpAddTest_q_1(DELAY,257)\n" +
                        "    redist1_r_uid179_lzCountVal_uid85_fpAddTest_q_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 5, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => r_uid179_lzCountVal_uid85_fpAddTest_q, xout => redist1_r_uid179_lzCountVal_uid85_fpAddTest_q_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- aMinusA_uid87_fpAddTest(LOGICAL,86)@4\n" +
                        "    aMinusA_uid87_fpAddTest_q <= \"1\" WHEN redist1_r_uid179_lzCountVal_uid85_fpAddTest_q_1_q = cAmA_uid86_fpAddTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- invAMinusA_uid129_fpAddTest(LOGICAL,128)@4\n" +
                        "    invAMinusA_uid129_fpAddTest_q <= not (aMinusA_uid87_fpAddTest_q);\n" +
                        "\n" +
                        "    -- redist10_sigA_uid50_fpAddTest_b_4(DELAY,266)\n" +
                        "    redist10_sigA_uid50_fpAddTest_b_4 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 3, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => redist9_sigA_uid50_fpAddTest_b_1_q, xout => redist10_sigA_uid50_fpAddTest_b_4_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- cstAllOWE_uid18_fpAddTest(CONSTANT,17)\n";
        String data3 =  "    cstAllOWE_uid18_fpAddTest_q <= \"11111111\";\n" +
                        "\n" +
                        "    -- expXIsMax_uid38_fpAddTest(LOGICAL,37)@0 + 1\n" +
                        "    expXIsMax_uid38_fpAddTest_qi <= \"1\" WHEN exp_bSig_uid35_fpAddTest_b = cstAllOWE_uid18_fpAddTest_q ELSE \"0\";\n" +
                        "    expXIsMax_uid38_fpAddTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => expXIsMax_uid38_fpAddTest_qi, xout => expXIsMax_uid38_fpAddTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist14_expXIsMax_uid38_fpAddTest_q_4(DELAY,270)\n" +
                        "    redist14_expXIsMax_uid38_fpAddTest_q_4 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 3, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => expXIsMax_uid38_fpAddTest_q, xout => redist14_expXIsMax_uid38_fpAddTest_q_4_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- invExpXIsMax_uid43_fpAddTest(LOGICAL,42)@4\n" +
                        "    invExpXIsMax_uid43_fpAddTest_q <= not (redist14_expXIsMax_uid38_fpAddTest_q_4_q);\n" +
                        "\n" +
                        "    -- redist11_InvExpXIsZero_uid44_fpAddTest_q_3(DELAY,267)\n" +
                        "    redist11_InvExpXIsZero_uid44_fpAddTest_q_3 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 3, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => InvExpXIsZero_uid44_fpAddTest_q, xout => redist11_InvExpXIsZero_uid44_fpAddTest_q_3_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- excR_bSig_uid45_fpAddTest(LOGICAL,44)@4\n" +
                        "    excR_bSig_uid45_fpAddTest_q <= redist11_InvExpXIsZero_uid44_fpAddTest_q_3_q and invExpXIsMax_uid43_fpAddTest_q;\n" +
                        "\n" +
                        "    -- redist22_exp_aSig_uid21_fpAddTest_b_3(DELAY,278)\n" +
                        "    redist22_exp_aSig_uid21_fpAddTest_b_3 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 8, depth => 3, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => exp_aSig_uid21_fpAddTest_b, xout => redist22_exp_aSig_uid21_fpAddTest_b_3_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- expXIsMax_uid24_fpAddTest(LOGICAL,23)@3 + 1\n" +
                        "    expXIsMax_uid24_fpAddTest_qi <= \"1\" WHEN redist22_exp_aSig_uid21_fpAddTest_b_3_q = cstAllOWE_uid18_fpAddTest_q ELSE \"0\";\n" +
                        "    expXIsMax_uid24_fpAddTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => expXIsMax_uid24_fpAddTest_qi, xout => expXIsMax_uid24_fpAddTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- invExpXIsMax_uid29_fpAddTest(LOGICAL,28)@4\n" +
                        "    invExpXIsMax_uid29_fpAddTest_q <= not (expXIsMax_uid24_fpAddTest_q);\n" +
                        "\n" +
                        "    -- excZ_aSig_uid16_uid23_fpAddTest(LOGICAL,22)@3 + 1\n" +
                        "    excZ_aSig_uid16_uid23_fpAddTest_qi <= \"1\" WHEN redist22_exp_aSig_uid21_fpAddTest_b_3_q = cstAllZWE_uid20_fpAddTest_q ELSE \"0\";\n" +
                        "    excZ_aSig_uid16_uid23_fpAddTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => excZ_aSig_uid16_uid23_fpAddTest_qi, xout => excZ_aSig_uid16_uid23_fpAddTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- InvExpXIsZero_uid30_fpAddTest(LOGICAL,29)@4\n" +
                        "    InvExpXIsZero_uid30_fpAddTest_q <= not (excZ_aSig_uid16_uid23_fpAddTest_q);\n" +
                        "\n" +
                        "    -- excR_aSig_uid31_fpAddTest(LOGICAL,30)@4\n" +
                        "    excR_aSig_uid31_fpAddTest_q <= InvExpXIsZero_uid30_fpAddTest_q and invExpXIsMax_uid29_fpAddTest_q;\n" +
                        "\n" +
                        "    -- signRReg_uid130_fpAddTest(LOGICAL,129)@4\n" +
                        "    signRReg_uid130_fpAddTest_q <= excR_aSig_uid31_fpAddTest_q and excR_bSig_uid45_fpAddTest_q and redist10_sigA_uid50_fpAddTest_b_4_q and invAMinusA_uid129_fpAddTest_q;\n" +
                        "\n" +
                        "    -- redist8_sigB_uid51_fpAddTest_b_4(DELAY,264)\n" +
                        "    redist8_sigB_uid51_fpAddTest_b_4 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 3, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => redist7_sigB_uid51_fpAddTest_b_1_q, xout => redist8_sigB_uid51_fpAddTest_b_4_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist16_excZ_bSig_uid17_uid37_fpAddTest_q_4(DELAY,272)\n" +
                        "    redist16_excZ_bSig_uid17_uid37_fpAddTest_q_4 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 3, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => redist15_excZ_bSig_uid17_uid37_fpAddTest_q_1_q, xout => redist16_excZ_bSig_uid17_uid37_fpAddTest_q_4_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- excAZBZSigASigB_uid134_fpAddTest(LOGICAL,133)@4\n" +
                        "    excAZBZSigASigB_uid134_fpAddTest_q <= excZ_aSig_uid16_uid23_fpAddTest_q and redist16_excZ_bSig_uid17_uid37_fpAddTest_q_4_q and redist10_sigA_uid50_fpAddTest_b_4_q and redist8_sigB_uid51_fpAddTest_b_4_q;\n" +
                        "\n" +
                        "    -- excBZARSigA_uid135_fpAddTest(LOGICAL,134)@4\n" +
                        "    excBZARSigA_uid135_fpAddTest_q <= redist16_excZ_bSig_uid17_uid37_fpAddTest_q_4_q and excR_aSig_uid31_fpAddTest_q and redist10_sigA_uid50_fpAddTest_b_4_q;\n" +
                        "\n" +
                        "    -- signRZero_uid136_fpAddTest(LOGICAL,135)@4\n" +
                        "    signRZero_uid136_fpAddTest_q <= excBZARSigA_uid135_fpAddTest_q or excAZBZSigASigB_uid134_fpAddTest_q;\n" +
                        "\n" +
                        "    -- fracXIsZero_uid39_fpAddTest(LOGICAL,38)@0 + 1\n" +
                        "    fracXIsZero_uid39_fpAddTest_qi <= \"1\" WHEN cstZeroWF_uid19_fpAddTest_q = frac_bSig_uid36_fpAddTest_b ELSE \"0\";\n" +
                        "    fracXIsZero_uid39_fpAddTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => fracXIsZero_uid39_fpAddTest_qi, xout => fracXIsZero_uid39_fpAddTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist13_fracXIsZero_uid39_fpAddTest_q_4(DELAY,269)\n" +
                        "    redist13_fracXIsZero_uid39_fpAddTest_q_4 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 3, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => fracXIsZero_uid39_fpAddTest_q, xout => redist13_fracXIsZero_uid39_fpAddTest_q_4_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- excI_bSig_uid41_fpAddTest(LOGICAL,40)@4\n" +
                        "    excI_bSig_uid41_fpAddTest_q <= redist14_expXIsMax_uid38_fpAddTest_q_4_q and redist13_fracXIsZero_uid39_fpAddTest_q_4_q;\n" +
                        "\n" +
                        "    -- sigBBInf_uid131_fpAddTest(LOGICAL,130)@4\n" +
                        "    sigBBInf_uid131_fpAddTest_q <= redist8_sigB_uid51_fpAddTest_b_4_q and excI_bSig_uid41_fpAddTest_q;\n" +
                        "\n" +
                        "    -- fracXIsZero_uid25_fpAddTest(LOGICAL,24)@2 + 1\n" +
                        "    fracXIsZero_uid25_fpAddTest_qi <= \"1\" WHEN cstZeroWF_uid19_fpAddTest_q = redist21_frac_aSig_uid22_fpAddTest_b_2_q ELSE \"0\";\n" +
                        "    fracXIsZero_uid25_fpAddTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => fracXIsZero_uid25_fpAddTest_qi, xout => fracXIsZero_uid25_fpAddTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist19_fracXIsZero_uid25_fpAddTest_q_2(DELAY,275)\n" +
                        "    redist19_fracXIsZero_uid25_fpAddTest_q_2 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => fracXIsZero_uid25_fpAddTest_q, xout => redist19_fracXIsZero_uid25_fpAddTest_q_2_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- excI_aSig_uid27_fpAddTest(LOGICAL,26)@4\n" +
                        "    excI_aSig_uid27_fpAddTest_q <= expXIsMax_uid24_fpAddTest_q and redist19_fracXIsZero_uid25_fpAddTest_q_2_q;\n" +
                        "\n" +
                        "    -- sigAAInf_uid132_fpAddTest(LOGICAL,131)@4\n" +
                        "    sigAAInf_uid132_fpAddTest_q <= redist10_sigA_uid50_fpAddTest_b_4_q and excI_aSig_uid27_fpAddTest_q;\n" +
                        "\n" +
                        "    -- signRInf_uid133_fpAddTest(LOGICAL,132)@4\n" +
                        "    signRInf_uid133_fpAddTest_q <= sigAAInf_uid132_fpAddTest_q or sigBBInf_uid131_fpAddTest_q;\n" +
                        "\n" +
                        "    -- signRInfRZRReg_uid137_fpAddTest(LOGICAL,136)@4 + 1\n" +
                        "    signRInfRZRReg_uid137_fpAddTest_qi <= signRInf_uid133_fpAddTest_q or signRZero_uid136_fpAddTest_q or signRReg_uid130_fpAddTest_q;\n" +
                        "    signRInfRZRReg_uid137_fpAddTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => signRInfRZRReg_uid137_fpAddTest_qi, xout => signRInfRZRReg_uid137_fpAddTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- fracXIsNotZero_uid40_fpAddTest(LOGICAL,39)@4\n" +
                        "    fracXIsNotZero_uid40_fpAddTest_q <= not (redist13_fracXIsZero_uid39_fpAddTest_q_4_q);\n" +
                        "\n" +
                        "    -- excN_bSig_uid42_fpAddTest(LOGICAL,41)@4 + 1\n" +
                        "    excN_bSig_uid42_fpAddTest_qi <= redist14_expXIsMax_uid38_fpAddTest_q_4_q and fracXIsNotZero_uid40_fpAddTest_q;\n" +
                        "    excN_bSig_uid42_fpAddTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => excN_bSig_uid42_fpAddTest_qi, xout => excN_bSig_uid42_fpAddTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- fracXIsNotZero_uid26_fpAddTest(LOGICAL,25)@4\n" +
                        "    fracXIsNotZero_uid26_fpAddTest_q <= not (redist19_fracXIsZero_uid25_fpAddTest_q_2_q);\n" +
                        "\n" +
                        "    -- excN_aSig_uid28_fpAddTest(LOGICAL,27)@4 + 1\n" +
                        "    excN_aSig_uid28_fpAddTest_qi <= expXIsMax_uid24_fpAddTest_q and fracXIsNotZero_uid26_fpAddTest_q;\n" +
                        "    excN_aSig_uid28_fpAddTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => excN_aSig_uid28_fpAddTest_qi, xout => excN_aSig_uid28_fpAddTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- excRNaN2_uid124_fpAddTest(LOGICAL,123)@5\n" +
                        "    excRNaN2_uid124_fpAddTest_q <= excN_aSig_uid28_fpAddTest_q or excN_bSig_uid42_fpAddTest_q;\n" +
                        "\n" +
                        "    -- redist6_effSub_uid52_fpAddTest_q_4(DELAY,262)\n" +
                        "    redist6_effSub_uid52_fpAddTest_q_4 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 3, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => effSub_uid52_fpAddTest_q, xout => redist6_effSub_uid52_fpAddTest_q_4_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist12_excI_bSig_uid41_fpAddTest_q_1(DELAY,268)\n" +
                        "    redist12_excI_bSig_uid41_fpAddTest_q_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => excI_bSig_uid41_fpAddTest_q, xout => redist12_excI_bSig_uid41_fpAddTest_q_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist18_excI_aSig_uid27_fpAddTest_q_1(DELAY,274)\n" +
                        "    redist18_excI_aSig_uid27_fpAddTest_q_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => excI_aSig_uid27_fpAddTest_q, xout => redist18_excI_aSig_uid27_fpAddTest_q_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- excAIBISub_uid125_fpAddTest(LOGICAL,124)@5\n" +
                        "    excAIBISub_uid125_fpAddTest_q <= redist18_excI_aSig_uid27_fpAddTest_q_1_q and redist12_excI_bSig_uid41_fpAddTest_q_1_q and redist6_effSub_uid52_fpAddTest_q_4_q;\n" +
                        "\n" +
                        "    -- excRNaN_uid126_fpAddTest(LOGICAL,125)@5\n" +
                        "    excRNaN_uid126_fpAddTest_q <= excAIBISub_uid125_fpAddTest_q or excRNaN2_uid124_fpAddTest_q;\n" +
                        "\n" +
                        "    -- invExcRNaN_uid138_fpAddTest(LOGICAL,137)@5\n" +
                        "    invExcRNaN_uid138_fpAddTest_q <= not (excRNaN_uid126_fpAddTest_q);\n" +
                        "\n" +
                        "    -- VCC(CONSTANT,1)\n" +
                        "    VCC_q <= \"1\";\n" +
                        "\n" +
                        "    -- signRPostExc_uid139_fpAddTest(LOGICAL,138)@5\n" +
                        "    signRPostExc_uid139_fpAddTest_q <= invExcRNaN_uid138_fpAddTest_q and signRInfRZRReg_uid137_fpAddTest_q;\n" +
                        "\n" +
                        "    -- cRBit_uid99_fpAddTest(CONSTANT,98)\n" +
                        "    cRBit_uid99_fpAddTest_q <= \"01000\";\n" +
                        "\n" +
                        "    -- leftShiftStage2Idx1Rng1_uid246_fracPostNormExt_uid88_fpAddTest(BITSELECT,245)@4\n" +
                        "    leftShiftStage2Idx1Rng1_uid246_fracPostNormExt_uid88_fpAddTest_in <= leftShiftStage1_uid244_fracPostNormExt_uid88_fpAddTest_q(26 downto 0);\n" +
                        "    leftShiftStage2Idx1Rng1_uid246_fracPostNormExt_uid88_fpAddTest_b <= leftShiftStage2Idx1Rng1_uid246_fracPostNormExt_uid88_fpAddTest_in(26 downto 0);\n" +
                        "\n" +
                        "    -- leftShiftStage2Idx1_uid247_fracPostNormExt_uid88_fpAddTest(BITJOIN,246)@4\n" +
                        "    leftShiftStage2Idx1_uid247_fracPostNormExt_uid88_fpAddTest_q <= leftShiftStage2Idx1Rng1_uid246_fracPostNormExt_uid88_fpAddTest_b & GND_q;\n" +
                        "\n" +
                        "    -- leftShiftStage1Idx3Rng6_uid241_fracPostNormExt_uid88_fpAddTest(BITSELECT,240)@4\n" +
                        "    leftShiftStage1Idx3Rng6_uid241_fracPostNormExt_uid88_fpAddTest_in <= leftShiftStage0_uid233_fracPostNormExt_uid88_fpAddTest_q(21 downto 0);\n" +
                        "    leftShiftStage1Idx3Rng6_uid241_fracPostNormExt_uid88_fpAddTest_b <= leftShiftStage1Idx3Rng6_uid241_fracPostNormExt_uid88_fpAddTest_in(21 downto 0);\n" +
                        "\n" +
                        "    -- leftShiftStage1Idx3Pad6_uid240_fracPostNormExt_uid88_fpAddTest(CONSTANT,239)\n" +
                        "    leftShiftStage1Idx3Pad6_uid240_fracPostNormExt_uid88_fpAddTest_q <= \"000000\";\n" +
                        "\n" +
                        "    -- leftShiftStage1Idx3_uid242_fracPostNormExt_uid88_fpAddTest(BITJOIN,241)@4\n" +
                        "    leftShiftStage1Idx3_uid242_fracPostNormExt_uid88_fpAddTest_q <= leftShiftStage1Idx3Rng6_uid241_fracPostNormExt_uid88_fpAddTest_b & leftShiftStage1Idx3Pad6_uid240_fracPostNormExt_uid88_fpAddTest_q;\n" +
                        "\n" +
                        "    -- leftShiftStage1Idx2Rng4_uid238_fracPostNormExt_uid88_fpAddTest(BITSELECT,237)@4\n" +
                        "    leftShiftStage1Idx2Rng4_uid238_fracPostNormExt_uid88_fpAddTest_in <= leftShiftStage0_uid233_fracPostNormExt_uid88_fpAddTest_q(23 downto 0);\n" +
                        "    leftShiftStage1Idx2Rng4_uid238_fracPostNormExt_uid88_fpAddTest_b <= leftShiftStage1Idx2Rng4_uid238_fracPostNormExt_uid88_fpAddTest_in(23 downto 0);\n" +
                        "\n" +
                        "    -- leftShiftStage1Idx2_uid239_fracPostNormExt_uid88_fpAddTest(BITJOIN,238)@4\n" +
                        "    leftShiftStage1Idx2_uid239_fracPostNormExt_uid88_fpAddTest_q <= leftShiftStage1Idx2Rng4_uid238_fracPostNormExt_uid88_fpAddTest_b & zs_uid164_lzCountVal_uid85_fpAddTest_q;\n" +
                        "\n" +
                        "    -- leftShiftStage1Idx1Rng2_uid235_fracPostNormExt_uid88_fpAddTest(BITSELECT,234)@4\n" +
                        "    leftShiftStage1Idx1Rng2_uid235_fracPostNormExt_uid88_fpAddTest_in <= leftShiftStage0_uid233_fracPostNormExt_uid88_fpAddTest_q(25 downto 0);\n" +
                        "    leftShiftStage1Idx1Rng2_uid235_fracPostNormExt_uid88_fpAddTest_b <= leftShiftStage1Idx1Rng2_uid235_fracPostNormExt_uid88_fpAddTest_in(25 downto 0);\n" +
                        "\n" +
                        "    -- leftShiftStage1Idx1_uid236_fracPostNormExt_uid88_fpAddTest(BITJOIN,235)@4\n" +
                        "    leftShiftStage1Idx1_uid236_fracPostNormExt_uid88_fpAddTest_q <= leftShiftStage1Idx1Rng2_uid235_fracPostNormExt_uid88_fpAddTest_b & zs_uid170_lzCountVal_uid85_fpAddTest_q;\n" +
                        "\n" +
                        "    -- leftShiftStage0Idx3Rng24_uid230_fracPostNormExt_uid88_fpAddTest(BITSELECT,229)@4\n" +
                        "    leftShiftStage0Idx3Rng24_uid230_fracPostNormExt_uid88_fpAddTest_in <= redist5_fracGRS_uid84_fpAddTest_q_2_q(3 downto 0);\n" +
                        "    leftShiftStage0Idx3Rng24_uid230_fracPostNormExt_uid88_fpAddTest_b <= leftShiftStage0Idx3Rng24_uid230_fracPostNormExt_uid88_fpAddTest_in(3 downto 0);\n" +
                        "\n" +
                        "    -- leftShiftStage0Idx3Pad24_uid229_fracPostNormExt_uid88_fpAddTest(CONSTANT,228)\n" +
                        "    leftShiftStage0Idx3Pad24_uid229_fracPostNormExt_uid88_fpAddTest_q <= \"000000000000000000000000\";\n" +
                        "\n" +
                        "    -- leftShiftStage0Idx3_uid231_fracPostNormExt_uid88_fpAddTest(BITJOIN,230)@4\n" +
                        "    leftShiftStage0Idx3_uid231_fracPostNormExt_uid88_fpAddTest_q <= leftShiftStage0Idx3Rng24_uid230_fracPostNormExt_uid88_fpAddTest_b & leftShiftStage0Idx3Pad24_uid229_fracPostNormExt_uid88_fpAddTest_q;\n" +
                        "\n" +
                        "    -- redist2_vStage_uid154_lzCountVal_uid85_fpAddTest_b_2(DELAY,258)\n" +
                        "    redist2_vStage_uid154_lzCountVal_uid85_fpAddTest_b_2 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 12, depth => 2, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => vStage_uid154_lzCountVal_uid85_fpAddTest_b, xout => redist2_vStage_uid154_lzCountVal_uid85_fpAddTest_b_2_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- leftShiftStage0Idx2_uid228_fracPostNormExt_uid88_fpAddTest(BITJOIN,227)@4\n" +
                        "    leftShiftStage0Idx2_uid228_fracPostNormExt_uid88_fpAddTest_q <= redist2_vStage_uid154_lzCountVal_uid85_fpAddTest_b_2_q & zs_uid150_lzCountVal_uid85_fpAddTest_q;\n" +
                        "\n" +
                        "    -- leftShiftStage0Idx1Rng8_uid224_fracPostNormExt_uid88_fpAddTest(BITSELECT,223)@4\n" +
                        "    leftShiftStage0Idx1Rng8_uid224_fracPostNormExt_uid88_fpAddTest_in <= redist5_fracGRS_uid84_fpAddTest_q_2_q(19 downto 0);\n" +
                        "    leftShiftStage0Idx1Rng8_uid224_fracPostNormExt_uid88_fpAddTest_b <= leftShiftStage0Idx1Rng8_uid224_fracPostNormExt_uid88_fpAddTest_in(19 downto 0);\n" +
                        "\n" +
                        "    -- leftShiftStage0Idx1_uid225_fracPostNormExt_uid88_fpAddTest(BITJOIN,224)@4\n" +
                        "    leftShiftStage0Idx1_uid225_fracPostNormExt_uid88_fpAddTest_q <= leftShiftStage0Idx1Rng8_uid224_fracPostNormExt_uid88_fpAddTest_b & cstAllZWE_uid20_fpAddTest_q;\n" +
                        "\n" +
                        "    -- redist5_fracGRS_uid84_fpAddTest_q_2(DELAY,261)\n" +
                        "    redist5_fracGRS_uid84_fpAddTest_q_2 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 28, depth => 2, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => fracGRS_uid84_fpAddTest_q, xout => redist5_fracGRS_uid84_fpAddTest_q_2_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- leftShiftStage0_uid233_fracPostNormExt_uid88_fpAddTest(MUX,232)@4\n" +
                        "    leftShiftStage0_uid233_fracPostNormExt_uid88_fpAddTest_s <= leftShiftStageSel4Dto3_uid232_fracPostNormExt_uid88_fpAddTest_merged_bit_select_b;\n" +
                        "    leftShiftStage0_uid233_fracPostNormExt_uid88_fpAddTest_combproc: PROCESS (leftShiftStage0_uid233_fracPostNormExt_uid88_fpAddTest_s, redist5_fracGRS_uid84_fpAddTest_q_2_q, leftShiftStage0Idx1_uid225_fracPostNormExt_uid88_fpAddTest_q, leftShiftStage0Idx2_uid228_fracPostNormExt_uid88_fpAddTest_q, leftShiftStage0Idx3_uid231_fracPostNormExt_uid88_fpAddTest_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (leftShiftStage0_uid233_fracPostNormExt_uid88_fpAddTest_s) IS\n" +
                        "            WHEN \"00\" => leftShiftStage0_uid233_fracPostNormExt_uid88_fpAddTest_q <= redist5_fracGRS_uid84_fpAddTest_q_2_q;\n" +
                        "            WHEN \"01\" => leftShiftStage0_uid233_fracPostNormExt_uid88_fpAddTest_q <= leftShiftStage0Idx1_uid225_fracPostNormExt_uid88_fpAddTest_q;\n" +
                        "            WHEN \"10\" => leftShiftStage0_uid233_fracPostNormExt_uid88_fpAddTest_q <= leftShiftStage0Idx2_uid228_fracPostNormExt_uid88_fpAddTest_q;\n" +
                        "            WHEN \"11\" => leftShiftStage0_uid233_fracPostNormExt_uid88_fpAddTest_q <= leftShiftStage0Idx3_uid231_fracPostNormExt_uid88_fpAddTest_q;\n" +
                        "            WHEN OTHERS => leftShiftStage0_uid233_fracPostNormExt_uid88_fpAddTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- leftShiftStage1_uid244_fracPostNormExt_uid88_fpAddTest(MUX,243)@4\n" +
                        "    leftShiftStage1_uid244_fracPostNormExt_uid88_fpAddTest_s <= leftShiftStageSel4Dto3_uid232_fracPostNormExt_uid88_fpAddTest_merged_bit_select_c;\n" +
                        "    leftShiftStage1_uid244_fracPostNormExt_uid88_fpAddTest_combproc: PROCESS (leftShiftStage1_uid244_fracPostNormExt_uid88_fpAddTest_s, leftShiftStage0_uid233_fracPostNormExt_uid88_fpAddTest_q, leftShiftStage1Idx1_uid236_fracPostNormExt_uid88_fpAddTest_q, leftShiftStage1Idx2_uid239_fracPostNormExt_uid88_fpAddTest_q, leftShiftStage1Idx3_uid242_fracPostNormExt_uid88_fpAddTest_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (leftShiftStage1_uid244_fracPostNormExt_uid88_fpAddTest_s) IS\n" +
                        "            WHEN \"00\" => leftShiftStage1_uid244_fracPostNormExt_uid88_fpAddTest_q <= leftShiftStage0_uid233_fracPostNormExt_uid88_fpAddTest_q;\n" +
                        "            WHEN \"01\" => leftShiftStage1_uid244_fracPostNormExt_uid88_fpAddTest_q <= leftShiftStage1Idx1_uid236_fracPostNormExt_uid88_fpAddTest_q;\n" +
                        "            WHEN \"10\" => leftShiftStage1_uid244_fracPostNormExt_uid88_fpAddTest_q <= leftShiftStage1Idx2_uid239_fracPostNormExt_uid88_fpAddTest_q;\n" +
                        "            WHEN \"11\" => leftShiftStage1_uid244_fracPostNormExt_uid88_fpAddTest_q <= leftShiftStage1Idx3_uid242_fracPostNormExt_uid88_fpAddTest_q;\n" +
                        "            WHEN OTHERS => leftShiftStage1_uid244_fracPostNormExt_uid88_fpAddTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- leftShiftStageSel4Dto3_uid232_fracPostNormExt_uid88_fpAddTest_merged_bit_select(BITSELECT,255)@4\n" +
                        "    leftShiftStageSel4Dto3_uid232_fracPostNormExt_uid88_fpAddTest_merged_bit_select_b <= redist1_r_uid179_lzCountVal_uid85_fpAddTest_q_1_q(4 downto 3);\n" +
                        "    leftShiftStageSel4Dto3_uid232_fracPostNormExt_uid88_fpAddTest_merged_bit_select_c <= redist1_r_uid179_lzCountVal_uid85_fpAddTest_q_1_q(2 downto 1);\n" +
                        "    leftShiftStageSel4Dto3_uid232_fracPostNormExt_uid88_fpAddTest_merged_bit_select_d <= redist1_r_uid179_lzCountVal_uid85_fpAddTest_q_1_q(0 downto 0);\n" +
                        "\n" +
                        "    -- leftShiftStage2_uid249_fracPostNormExt_uid88_fpAddTest(MUX,248)@4\n" +
                        "    leftShiftStage2_uid249_fracPostNormExt_uid88_fpAddTest_s <= leftShiftStageSel4Dto3_uid232_fracPostNormExt_uid88_fpAddTest_merged_bit_select_d;\n" +
                        "    leftShiftStage2_uid249_fracPostNormExt_uid88_fpAddTest_combproc: PROCESS (leftShiftStage2_uid249_fracPostNormExt_uid88_fpAddTest_s, leftShiftStage1_uid244_fracPostNormExt_uid88_fpAddTest_q, leftShiftStage2Idx1_uid247_fracPostNormExt_uid88_fpAddTest_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (leftShiftStage2_uid249_fracPostNormExt_uid88_fpAddTest_s) IS\n" +
                        "            WHEN \"0\" => leftShiftStage2_uid249_fracPostNormExt_uid88_fpAddTest_q <= leftShiftStage1_uid244_fracPostNormExt_uid88_fpAddTest_q;\n" +
                        "            WHEN \"1\" => leftShiftStage2_uid249_fracPostNormExt_uid88_fpAddTest_q <= leftShiftStage2Idx1_uid247_fracPostNormExt_uid88_fpAddTest_q;\n" +
                        "            WHEN OTHERS => leftShiftStage2_uid249_fracPostNormExt_uid88_fpAddTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- LSB_uid97_fpAddTest(BITSELECT,96)@4\n" +
                        "    LSB_uid97_fpAddTest_in <= STD_LOGIC_VECTOR(leftShiftStage2_uid249_fracPostNormExt_uid88_fpAddTest_q(4 downto 0));\n" +
                        "    LSB_uid97_fpAddTest_b <= STD_LOGIC_VECTOR(LSB_uid97_fpAddTest_in(4 downto 4));\n" +
                        "\n" +
                        "    -- Guard_uid96_fpAddTest(BITSELECT,95)@4\n" +
                        "    Guard_uid96_fpAddTest_in <= STD_LOGIC_VECTOR(leftShiftStage2_uid249_fracPostNormExt_uid88_fpAddTest_q(3 downto 0));\n" +
                        "    Guard_uid96_fpAddTest_b <= STD_LOGIC_VECTOR(Guard_uid96_fpAddTest_in(3 downto 3));\n" +
                        "\n" +
                        "    -- Round_uid95_fpAddTest(BITSELECT,94)@4\n" +
                        "    Round_uid95_fpAddTest_in <= STD_LOGIC_VECTOR(leftShiftStage2_uid249_fracPostNormExt_uid88_fpAddTest_q(2 downto 0));\n" +
                        "    Round_uid95_fpAddTest_b <= STD_LOGIC_VECTOR(Round_uid95_fpAddTest_in(2 downto 2));\n" +
                        "\n" +
                        "    -- Sticky1_uid94_fpAddTest(BITSELECT,93)@4\n" +
                        "    Sticky1_uid94_fpAddTest_in <= STD_LOGIC_VECTOR(leftShiftStage2_uid249_fracPostNormExt_uid88_fpAddTest_q(1 downto 0));\n" +
                        "    Sticky1_uid94_fpAddTest_b <= STD_LOGIC_VECTOR(Sticky1_uid94_fpAddTest_in(1 downto 1));\n" +
                        "\n" +
                        "    -- Sticky0_uid93_fpAddTest(BITSELECT,92)@4\n" +
                        "    Sticky0_uid93_fpAddTest_in <= STD_LOGIC_VECTOR(leftShiftStage2_uid249_fracPostNormExt_uid88_fpAddTest_q(0 downto 0));\n" +
                        "    Sticky0_uid93_fpAddTest_b <= STD_LOGIC_VECTOR(Sticky0_uid93_fpAddTest_in(0 downto 0));\n" +
                        "\n" +
                        "    -- rndBitCond_uid98_fpAddTest(BITJOIN,97)@4\n" +
                        "    rndBitCond_uid98_fpAddTest_q <= LSB_uid97_fpAddTest_b & Guard_uid96_fpAddTest_b & Round_uid95_fpAddTest_b & Sticky1_uid94_fpAddTest_b & Sticky0_uid93_fpAddTest_b;\n" +
                        "\n" +
                        "    -- rBi_uid100_fpAddTest(LOGICAL,99)@4\n" +
                        "    rBi_uid100_fpAddTest_q <= \"1\" WHEN rndBitCond_uid98_fpAddTest_q = cRBit_uid99_fpAddTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- roundBit_uid101_fpAddTest(LOGICAL,100)@4\n" +
                        "    roundBit_uid101_fpAddTest_q <= not (rBi_uid100_fpAddTest_q);\n" +
                        "\n" +
                        "    -- oneCST_uid90_fpAddTest(CONSTANT,89)\n" +
                        "    oneCST_uid90_fpAddTest_q <= \"00000001\";\n" +
                        "\n" +
                        "    -- expInc_uid91_fpAddTest(ADD,90)@3 + 1\n" +
                        "    expInc_uid91_fpAddTest_a <= STD_LOGIC_VECTOR(\"0\" & redist22_exp_aSig_uid21_fpAddTest_b_3_q);\n" +
                        "    expInc_uid91_fpAddTest_b <= STD_LOGIC_VECTOR(\"0\" & oneCST_uid90_fpAddTest_q);\n" +
                        "    expInc_uid91_fpAddTest_clkproc: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            expInc_uid91_fpAddTest_o <= (others => '0');\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            expInc_uid91_fpAddTest_o <= STD_LOGIC_VECTOR(UNSIGNED(expInc_uid91_fpAddTest_a) + UNSIGNED(expInc_uid91_fpAddTest_b));\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "    expInc_uid91_fpAddTest_q <= expInc_uid91_fpAddTest_o(8 downto 0);\n" +
                        "\n" +
                        "    -- expPostNorm_uid92_fpAddTest(SUB,91)@4\n" +
                        "    expPostNorm_uid92_fpAddTest_a <= STD_LOGIC_VECTOR(\"0\" & expInc_uid91_fpAddTest_q);\n" +
                        "    expPostNorm_uid92_fpAddTest_b <= STD_LOGIC_VECTOR(\"00000\" & redist1_r_uid179_lzCountVal_uid85_fpAddTest_q_1_q);\n" +
                        "    expPostNorm_uid92_fpAddTest_o <= STD_LOGIC_VECTOR(UNSIGNED(expPostNorm_uid92_fpAddTest_a) - UNSIGNED(expPostNorm_uid92_fpAddTest_b));\n" +
                        "    expPostNorm_uid92_fpAddTest_q <= expPostNorm_uid92_fpAddTest_o(9 downto 0);\n" +
                        "\n" +
                        "    -- fracPostNorm_uid89_fpAddTest(BITSELECT,88)@4\n" +
                        "    fracPostNorm_uid89_fpAddTest_b <= leftShiftStage2_uid249_fracPostNormExt_uid88_fpAddTest_q(27 downto 1);\n" +
                        "\n" +
                        "    -- fracPostNormRndRange_uid102_fpAddTest(BITSELECT,101)@4\n" +
                        "    fracPostNormRndRange_uid102_fpAddTest_in <= fracPostNorm_uid89_fpAddTest_b(25 downto 0);\n" +
                        "    fracPostNormRndRange_uid102_fpAddTest_b <= fracPostNormRndRange_uid102_fpAddTest_in(25 downto 2);\n" +
                        "\n" +
                        "    -- expFracR_uid103_fpAddTest(BITJOIN,102)@4\n" +
                        "    expFracR_uid103_fpAddTest_q <= expPostNorm_uid92_fpAddTest_q & fracPostNormRndRange_uid102_fpAddTest_b;\n" +
                        "\n" +
                        "    -- rndExpFrac_uid104_fpAddTest(ADD,103)@4 + 1\n" +
                        "    rndExpFrac_uid104_fpAddTest_a <= STD_LOGIC_VECTOR(\"0\" & expFracR_uid103_fpAddTest_q);\n" +
                        "    rndExpFrac_uid104_fpAddTest_b <= STD_LOGIC_VECTOR(\"0000000000000000000000000000000000\" & roundBit_uid101_fpAddTest_q);\n" +
                        "    rndExpFrac_uid104_fpAddTest_clkproc: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            rndExpFrac_uid104_fpAddTest_o <= (others => '0');\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            rndExpFrac_uid104_fpAddTest_o <= STD_LOGIC_VECTOR(UNSIGNED(rndExpFrac_uid104_fpAddTest_a) + UNSIGNED(rndExpFrac_uid104_fpAddTest_b));\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "    rndExpFrac_uid104_fpAddTest_q <= rndExpFrac_uid104_fpAddTest_o(34 downto 0);\n" +
                        "\n" +
                        "    -- expRPreExc_uid117_fpAddTest(BITSELECT,116)@5\n" +
                        "    expRPreExc_uid117_fpAddTest_in <= rndExpFrac_uid104_fpAddTest_q(31 downto 0);\n" +
                        "    expRPreExc_uid117_fpAddTest_b <= expRPreExc_uid117_fpAddTest_in(31 downto 24);\n" +
                        "\n" +
                        "    -- rndExpFracOvfBits_uid109_fpAddTest(BITSELECT,108)@5\n" +
                        "    rndExpFracOvfBits_uid109_fpAddTest_in <= rndExpFrac_uid104_fpAddTest_q(33 downto 0);\n" +
                        "    rndExpFracOvfBits_uid109_fpAddTest_b <= rndExpFracOvfBits_uid109_fpAddTest_in(33 downto 32);\n" +
                        "\n" +
                        "    -- rOvfExtraBits_uid110_fpAddTest(LOGICAL,109)@5\n" +
                        "    rOvfExtraBits_uid110_fpAddTest_q <= \"1\" WHEN rndExpFracOvfBits_uid109_fpAddTest_b = zocst_uid76_fpAddTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- wEP2AllOwE_uid105_fpAddTest(CONSTANT,104)\n" +
                        "    wEP2AllOwE_uid105_fpAddTest_q <= \"0011111111\";\n" +
                        "\n" +
                        "    -- rndExp_uid106_fpAddTest(BITSELECT,105)@5\n" +
                        "    rndExp_uid106_fpAddTest_in <= rndExpFrac_uid104_fpAddTest_q(33 downto 0);\n" +
                        "    rndExp_uid106_fpAddTest_b <= rndExp_uid106_fpAddTest_in(33 downto 24);\n" +
                        "\n" +
                        "    -- rOvfEQMax_uid107_fpAddTest(LOGICAL,106)@5\n" +
                        "    rOvfEQMax_uid107_fpAddTest_q <= \"1\" WHEN rndExp_uid106_fpAddTest_b = wEP2AllOwE_uid105_fpAddTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- rOvf_uid111_fpAddTest(LOGICAL,110)@5\n" +
                        "    rOvf_uid111_fpAddTest_q <= rOvfEQMax_uid107_fpAddTest_q or rOvfExtraBits_uid110_fpAddTest_q;\n" +
                        "\n" +
                        "    -- regInputs_uid118_fpAddTest(LOGICAL,117)@4 + 1\n" +
                        "    regInputs_uid118_fpAddTest_qi <= excR_aSig_uid31_fpAddTest_q and excR_bSig_uid45_fpAddTest_q;\n" +
                        "    regInputs_uid118_fpAddTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => regInputs_uid118_fpAddTest_qi, xout => regInputs_uid118_fpAddTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- rInfOvf_uid121_fpAddTest(LOGICAL,120)@5\n" +
                        "    rInfOvf_uid121_fpAddTest_q <= regInputs_uid118_fpAddTest_q and rOvf_uid111_fpAddTest_q;\n" +
                        "\n" +
                        "    -- excRInfVInC_uid122_fpAddTest(BITJOIN,121)@5\n" +
                        "    excRInfVInC_uid122_fpAddTest_q <= rInfOvf_uid121_fpAddTest_q & excN_bSig_uid42_fpAddTest_q & excN_aSig_uid28_fpAddTest_q & redist12_excI_bSig_uid41_fpAddTest_q_1_q & redist18_excI_aSig_uid27_fpAddTest_q_1_q & redist6_effSub_uid52_fpAddTest_q_4_q;\n" +
                        "\n" +
                        "    -- excRInf_uid123_fpAddTest(LOOKUP,122)@5\n" +
                        "    excRInf_uid123_fpAddTest_combproc: PROCESS (excRInfVInC_uid122_fpAddTest_q)\n" +
                        "    BEGIN\n" +
                        "        -- Begin reserved scope level\n" +
                        "        CASE (excRInfVInC_uid122_fpAddTest_q) IS\n" +
                        "            WHEN \"000000\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"000001\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"000010\" => excRInf_uid123_fpAddTest_q <= \"1\";\n" +
                        "            WHEN \"000011\" => excRInf_uid123_fpAddTest_q <= \"1\";\n" +
                        "            WHEN \"000100\" => excRInf_uid123_fpAddTest_q <= \"1\";\n" +
                        "            WHEN \"000101\" => excRInf_uid123_fpAddTest_q <= \"1\";\n" +
                        "            WHEN \"000110\" => excRInf_uid123_fpAddTest_q <= \"1\";\n" +
                        "            WHEN \"000111\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"001000\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"001001\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"001010\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"001011\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"001100\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"001101\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"001110\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"001111\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"010000\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"010001\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"010010\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"010011\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"010100\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"010101\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"010110\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"010111\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"011000\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"011001\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"011010\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"011011\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"011100\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"011101\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"011110\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"011111\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"100000\" => excRInf_uid123_fpAddTest_q <= \"1\";\n" +
                        "            WHEN \"100001\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"100010\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"100011\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"100100\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"100101\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"100110\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"100111\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"101000\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"101001\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"101010\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"101011\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"101100\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"101101\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"101110\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"101111\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"110000\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"110001\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"110010\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"110011\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"110100\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"110101\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"110110\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"110111\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"111000\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"111001\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"111010\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"111011\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"111100\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"111101\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"111110\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"111111\" => excRInf_uid123_fpAddTest_q <= \"0\";\n" +
                        "            WHEN OTHERS => -- unreachable\n" +
                        "                           excRInf_uid123_fpAddTest_q <= (others => '-');\n" +
                        "        END CASE;\n" +
                        "        -- End reserved scope level\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- redist4_aMinusA_uid87_fpAddTest_q_1(DELAY,260)\n" +
                        "    redist4_aMinusA_uid87_fpAddTest_q_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => aMinusA_uid87_fpAddTest_q, xout => redist4_aMinusA_uid87_fpAddTest_q_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- rUdfExtraBit_uid114_fpAddTest(BITSELECT,113)@5\n" +
                        "    rUdfExtraBit_uid114_fpAddTest_in <= STD_LOGIC_VECTOR(rndExpFrac_uid104_fpAddTest_q(33 downto 0));\n" +
                        "    rUdfExtraBit_uid114_fpAddTest_b <= STD_LOGIC_VECTOR(rUdfExtraBit_uid114_fpAddTest_in(33 downto 33));\n" +
                        "\n" +
                        "    -- wEP2AllZ_uid112_fpAddTest(CONSTANT,111)\n" +
                        "    wEP2AllZ_uid112_fpAddTest_q <= \"0000000000\";\n" +
                        "\n" +
                        "    -- rUdfEQMin_uid113_fpAddTest(LOGICAL,112)@5\n" +
                        "    rUdfEQMin_uid113_fpAddTest_q <= \"1\" WHEN rndExp_uid106_fpAddTest_b = wEP2AllZ_uid112_fpAddTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- rUdf_uid115_fpAddTest(LOGICAL,114)@5\n" +
                        "    rUdf_uid115_fpAddTest_q <= rUdfEQMin_uid113_fpAddTest_q or rUdfExtraBit_uid114_fpAddTest_b;\n" +
                        "\n" +
                        "    -- redist17_excZ_bSig_uid17_uid37_fpAddTest_q_5(DELAY,273)\n" +
                        "    redist17_excZ_bSig_uid17_uid37_fpAddTest_q_5 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => redist16_excZ_bSig_uid17_uid37_fpAddTest_q_4_q, xout => redist17_excZ_bSig_uid17_uid37_fpAddTest_q_5_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist20_excZ_aSig_uid16_uid23_fpAddTest_q_2(DELAY,276)\n" +
                        "    redist20_excZ_aSig_uid16_uid23_fpAddTest_q_2 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => excZ_aSig_uid16_uid23_fpAddTest_q, xout => redist20_excZ_aSig_uid16_uid23_fpAddTest_q_2_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- excRZeroVInC_uid119_fpAddTest(BITJOIN,118)@5\n" +
                        "    excRZeroVInC_uid119_fpAddTest_q <= redist4_aMinusA_uid87_fpAddTest_q_1_q & rUdf_uid115_fpAddTest_q & regInputs_uid118_fpAddTest_q & redist17_excZ_bSig_uid17_uid37_fpAddTest_q_5_q & redist20_excZ_aSig_uid16_uid23_fpAddTest_q_2_q;\n" +
                        "\n" +
                        "    -- excRZero_uid120_fpAddTest(LOOKUP,119)@5\n" +
                        "    excRZero_uid120_fpAddTest_combproc: PROCESS (excRZeroVInC_uid119_fpAddTest_q)\n" +
                        "    BEGIN\n" +
                        "        -- Begin reserved scope level\n" +
                        "        CASE (excRZeroVInC_uid119_fpAddTest_q) IS\n" +
                        "            WHEN \"00000\" => excRZero_uid120_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"00001\" => excRZero_uid120_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"00010\" => excRZero_uid120_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"00011\" => excRZero_uid120_fpAddTest_q <= \"1\";\n" +
                        "            WHEN \"00100\" => excRZero_uid120_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"00101\" => excRZero_uid120_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"00110\" => excRZero_uid120_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"00111\" => excRZero_uid120_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"01000\" => excRZero_uid120_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"01001\" => excRZero_uid120_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"01010\" => excRZero_uid120_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"01011\" => excRZero_uid120_fpAddTest_q <= \"1\";\n" +
                        "            WHEN \"01100\" => excRZero_uid120_fpAddTest_q <= \"1\";\n" +
                        "            WHEN \"01101\" => excRZero_uid120_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"01110\" => excRZero_uid120_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"01111\" => excRZero_uid120_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"10000\" => excRZero_uid120_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"10001\" => excRZero_uid120_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"10010\" => excRZero_uid120_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"10011\" => excRZero_uid120_fpAddTest_q <= \"1\";\n" +
                        "            WHEN \"10100\" => excRZero_uid120_fpAddTest_q <= \"1\";\n" +
                        "            WHEN \"10101\" => excRZero_uid120_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"10110\" => excRZero_uid120_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"10111\" => excRZero_uid120_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"11000\" => excRZero_uid120_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"11001\" => excRZero_uid120_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"11010\" => excRZero_uid120_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"11011\" => excRZero_uid120_fpAddTest_q <= \"1\";\n" +
                        "            WHEN \"11100\" => excRZero_uid120_fpAddTest_q <= \"1\";\n" +
                        "            WHEN \"11101\" => excRZero_uid120_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"11110\" => excRZero_uid120_fpAddTest_q <= \"0\";\n" +
                        "            WHEN \"11111\" => excRZero_uid120_fpAddTest_q <= \"0\";\n" +
                        "            WHEN OTHERS => -- unreachable\n" +
                        "                           excRZero_uid120_fpAddTest_q <= (others => '-');\n" +
                        "        END CASE;\n" +
                        "        -- End reserved scope level\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- concExc_uid127_fpAddTest(BITJOIN,126)@5\n" +
                        "    concExc_uid127_fpAddTest_q <= excRNaN_uid126_fpAddTest_q & excRInf_uid123_fpAddTest_q & excRZero_uid120_fpAddTest_q;\n" +
                        "\n" +
                        "    -- excREnc_uid128_fpAddTest(LOOKUP,127)@5\n" +
                        "    excREnc_uid128_fpAddTest_combproc: PROCESS (concExc_uid127_fpAddTest_q)\n" +
                        "    BEGIN\n" +
                        "        -- Begin reserved scope level\n" +
                        "        CASE (concExc_uid127_fpAddTest_q) IS\n" +
                        "            WHEN \"000\" => excREnc_uid128_fpAddTest_q <= \"01\";\n" +
                        "            WHEN \"001\" => excREnc_uid128_fpAddTest_q <= \"00\";\n" +
                        "            WHEN \"010\" => excREnc_uid128_fpAddTest_q <= \"10\";\n" +
                        "            WHEN \"011\" => excREnc_uid128_fpAddTest_q <= \"10\";\n" +
                        "            WHEN \"100\" => excREnc_uid128_fpAddTest_q <= \"11\";\n" +
                        "            WHEN \"101\" => excREnc_uid128_fpAddTest_q <= \"11\";\n" +
                        "            WHEN \"110\" => excREnc_uid128_fpAddTest_q <= \"11\";\n" +
                        "            WHEN \"111\" => excREnc_uid128_fpAddTest_q <= \"11\";\n" +
                        "            WHEN OTHERS => -- unreachable\n" +
                        "                           excREnc_uid128_fpAddTest_q <= (others => '-');\n" +
                        "        END CASE;\n" +
                        "        -- End reserved scope level\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- expRPostExc_uid147_fpAddTest(MUX,146)@5\n" +
                        "    expRPostExc_uid147_fpAddTest_s <= excREnc_uid128_fpAddTest_q;\n" +
                        "    expRPostExc_uid147_fpAddTest_combproc: PROCESS (expRPostExc_uid147_fpAddTest_s, cstAllZWE_uid20_fpAddTest_q, expRPreExc_uid117_fpAddTest_b, cstAllOWE_uid18_fpAddTest_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (expRPostExc_uid147_fpAddTest_s) IS\n" +
                        "            WHEN \"00\" => expRPostExc_uid147_fpAddTest_q <= cstAllZWE_uid20_fpAddTest_q;\n" +
                        "            WHEN \"01\" => expRPostExc_uid147_fpAddTest_q <= expRPreExc_uid117_fpAddTest_b;\n" +
                        "            WHEN \"10\" => expRPostExc_uid147_fpAddTest_q <= cstAllOWE_uid18_fpAddTest_q;\n" +
                        "            WHEN \"11\" => expRPostExc_uid147_fpAddTest_q <= cstAllOWE_uid18_fpAddTest_q;\n" +
                        "            WHEN OTHERS => expRPostExc_uid147_fpAddTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- oneFracRPostExc2_uid140_fpAddTest(CONSTANT,139)\n" +
                        "    oneFracRPostExc2_uid140_fpAddTest_q <= \"00000000000000000000001\";\n" +
                        "\n" +
                        "    -- fracRPreExc_uid116_fpAddTest(BITSELECT,115)@5\n" +
                        "    fracRPreExc_uid116_fpAddTest_in <= rndExpFrac_uid104_fpAddTest_q(23 downto 0);\n" +
                        "    fracRPreExc_uid116_fpAddTest_b <= fracRPreExc_uid116_fpAddTest_in(23 downto 1);\n" +
                        "\n" +
                        "    -- fracRPostExc_uid143_fpAddTest(MUX,142)@5\n" +
                        "    fracRPostExc_uid143_fpAddTest_s <= excREnc_uid128_fpAddTest_q;\n" +
                        "    fracRPostExc_uid143_fpAddTest_combproc: PROCESS (fracRPostExc_uid143_fpAddTest_s, cstZeroWF_uid19_fpAddTest_q, fracRPreExc_uid116_fpAddTest_b, oneFracRPostExc2_uid140_fpAddTest_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (fracRPostExc_uid143_fpAddTest_s) IS\n" +
                        "            WHEN \"00\" => fracRPostExc_uid143_fpAddTest_q <= cstZeroWF_uid19_fpAddTest_q;\n" +
                        "            WHEN \"01\" => fracRPostExc_uid143_fpAddTest_q <= fracRPreExc_uid116_fpAddTest_b;\n" +
                        "            WHEN \"10\" => fracRPostExc_uid143_fpAddTest_q <= cstZeroWF_uid19_fpAddTest_q;\n" +
                        "            WHEN \"11\" => fracRPostExc_uid143_fpAddTest_q <= oneFracRPostExc2_uid140_fpAddTest_q;\n" +
                        "            WHEN OTHERS => fracRPostExc_uid143_fpAddTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- R_uid148_fpAddTest(BITJOIN,147)@5\n" +
                        "    R_uid148_fpAddTest_q <= signRPostExc_uid139_fpAddTest_q & expRPostExc_uid147_fpAddTest_q & fracRPostExc_uid143_fpAddTest_q;\n" +
                        "\n" +
                        "    -- xOut(GPOUT,4)@5\n" +
                        "    q <= R_uid148_fpAddTest_q;\n" +
                        "\n" +
                        "END normal;";
        new GeneralFunctions().write_file(Project_Folder_File, data1, data2, data3);
    }
    
    private void generate_FP_SUB_32_qip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -entity \"FP_SUB_32\" -library \"FP_SUB_32\" -name IP_TOOL_NAME \"altera_fp_functions\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32\" -library \"FP_SUB_32\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32\" -library \"FP_SUB_32\" -name IP_TOOL_ENV \"mwpim\"\n" +
                        "set_global_assignment -library \"FP_SUB_32\" -name MISC_FILE [file join $::quartus(qip_path) \"FP_SUB_32.cmp\"]\n" +
                        "set_global_assignment -entity \"FP_SUB_32\" -library \"FP_SUB_32\" -name IP_TARGETED_DEVICE_FAMILY \"Cyclone V\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32\" -library \"FP_SUB_32\" -name IP_GENERATED_DEVICE_FAMILY \"{Cyclone V}\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32\" -library \"FP_SUB_32\" -name IP_QSYS_MODE \"UNKNOWN\"\n" +
                        "set_global_assignment -name SYNTHESIS_ONLY_QIP ON\n" +
                        "set_global_assignment -entity \"FP_SUB_32\" -library \"FP_SUB_32\" -name IP_COMPONENT_NAME \"RlBfU1VCXzMy\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32\" -library \"FP_SUB_32\" -name IP_COMPONENT_DISPLAY_NAME \"QUxURVJBX0ZQX0ZVTkNUSU9OUw==\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32\" -library \"FP_SUB_32\" -name IP_COMPONENT_REPORT_HIERARCHY \"Off\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32\" -library \"FP_SUB_32\" -name IP_COMPONENT_INTERNAL \"Off\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32\" -library \"FP_SUB_32\" -name IP_COMPONENT_AUTHOR \"QWx0ZXJhIENvcnBvcmF0aW9u\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32\" -library \"FP_SUB_32\" -name IP_COMPONENT_VERSION \"MTguMA==\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32\" -library \"FP_SUB_32\" -name IP_COMPONENT_DESCRIPTION \"QSBjb2xsZWN0aW9uIG9mIGZsb2F0aW5nIHBvaW50IGZ1bmN0aW9ucw==\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_NAME \"RlBfU1VCXzMyXzAwMDI=\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_DISPLAY_NAME \"QUxURVJBX0ZQX0ZVTkNUSU9OUw==\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_REPORT_HIERARCHY \"Off\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_INTERNAL \"Off\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_AUTHOR \"QWx0ZXJhIENvcnBvcmF0aW9u\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_VERSION \"MTguMA==\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_DESCRIPTION \"QSBjb2xsZWN0aW9uIG9mIGZsb2F0aW5nIHBvaW50IGZ1bmN0aW9ucw==\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"RlVOQ1RJT05fRkFNSUxZ::QVJJVEg=::RmFtaWx5\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"QVJJVEhfZnVuY3Rpb24=::U1VC::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"Q09OVkVSVF9mdW5jdGlvbg==::RlhQX0ZQ::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"QUxMX2Z1bmN0aW9u::QURE::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"RVhQX0xPR19mdW5jdGlvbg==::RVhQRQ==::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"VFJJR19mdW5jdGlvbg==::U0lO::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"Q09NUEFSRV9mdW5jdGlvbg==::TUlO::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"Uk9PVFNfZnVuY3Rpb24=::U1FSVA==::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"ZGVyaXZlZGZ1bmN0aW9u::U1VC::ZGVyaXZlZGZ1bmN0aW9u\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"ZnBfZm9ybWF0::c2luZ2xl::Rm9ybWF0\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"ZnBfZXhw::OA==::RXhwb25lbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"ZnBfZXhwX2Rlcml2ZWQ=::OA==::ZnBfZXhwX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"ZnBfbWFu::MjM=::TWFudGlzc2E=\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"ZnBfbWFuX2Rlcml2ZWQ=::MjM=::ZnBfbWFuX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"ZXhwb25lbnRfd2lkdGg=::MjM=::RXhwb25lbnQgV2lkdGg=\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"ZnJlcXVlbmN5X3RhcmdldA==::MTAw::VGFyZ2V0\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"bGF0ZW5jeV90YXJnZXQ=::Mg==::VGFyZ2V0\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"cGVyZm9ybWFuY2VfZ29hbA==::ZnJlcXVlbmN5::R29hbA==\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"cm91bmRpbmdfbW9kZQ==::bmVhcmVzdCB3aXRoIHRpZSBicmVha2luZyBhd2F5IGZyb20gemVybw==::TW9kZQ==\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"cm91bmRpbmdfbW9kZV9kZXJpdmVk::bmVhcmVzdCB3aXRoIHRpZSBicmVha2luZyB0byBldmVu::TW9kZQ==\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"dXNlX3JvdW5kaW5nX21vZGU=::dHJ1ZQ==::dXNlX3JvdW5kaW5nX21vZGU=\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"ZmFpdGhmdWxfcm91bmRpbmc=::ZmFsc2U=::UmVsYXggcm91bmRpbmcgdG8gcm91bmQgdXAgb3IgZG93biB0byByZWR1Y2UgcmVzb3VyY2UgdXNhZ2U=\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"Z2VuX2VuYWJsZQ==::ZmFsc2U=::R2VuZXJhdGUgYW4gZW5hYmxlIHBvcnQ=\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"ZGl2aWRlX3R5cGU=::MA==::TWV0aG9k\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"c2VsZWN0X3NpZ25hbF9lbmFibGU=::ZmFsc2U=::VXNlIFNlbGVjdCBTaWduYWw=\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"c2NhbGVfYnlfcGk=::ZmFsc2U=::UmVwcmVzZW50IGFuZ2xlIGFzIG11bHRpcGxlIG9mIFBp\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"bnVtYmVyX29mX2lucHV0cw==::Mg==::SW5wdXQgVmVjdG9yIERpbWVuc2lvbg==\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"dHJpZ19ub19yYW5nZV9yZWR1Y3Rpb24=::ZmFsc2U=::SW5wdXRzIGFyZSB3aXRoaW4gcmFuZ2UgLTJwaSB0byArMnBp\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"cmVwb3J0X3Jlc291cmNlc190b194bWw=::ZmFsc2U=::cmVwb3J0X3Jlc291cmNlc190b194bWw=\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"ZnhwdF93aWR0aA==::MzI=::V2lkdGg=\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"ZnhwdF9mcmFjdGlvbg==::MA==::RnJhY3Rpb24=\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"ZnhwdF9zaWdu::MQ==::U2lnbg==\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"ZnJlcXVlbmN5X2ZlZWRiYWNr::MA==::ZnJlcXVlbmN5X2ZlZWRiYWNr\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"bGF0ZW5jeV9mZWVkYmFjaw==::NQ==::bGF0ZW5jeV9mZWVkYmFjaw==\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"Zm9yY2VfZWxhYm9yYXRl::MA==::Zm9yY2VfZWxhYm9yYXRl\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X2Zvcm1hdA==::c2luZ2xl::T3V0cHV0IEZvcm1hdA==\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X2V4cA==::OA==::T3V0cHV0IEV4cG9uZW50\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X2V4cF9kZXJpdmVk::OA==::ZnBfb3V0X2V4cF9kZXJpdmVk\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X21hbg==::MjM=::T3V0cHV0IE1hbnRpc3Nh\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X21hbl9kZXJpdmVk::OA==::ZnBfb3V0X21hbl9kZXJpdmVk\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fZm9ybWF0::c2luZ2xl::SW5wdXQgRm9ybWF0\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fZXhw::OA==::SW5wdXQgRXhwb25lbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fZXhwX2Rlcml2ZWQ=::OA==::ZnBfaW5fZXhwX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fbWFu::MjM=::SW5wdXQgTWFudGlzc2E=\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fbWFuX2Rlcml2ZWQ=::OA==::ZnBfaW5fbWFuX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"ZW5hYmxlX2hhcmRfZnA=::dHJ1ZQ==::RW5hYmxlIEhhcmQgRmxvYXRpbmcgUG9pbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"bWFudWFsX2RzcF9wbGFubmluZw==::dHJ1ZQ==::RW5hYmxlIEhhcmQgRmxvYXRpbmcgUG9pbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"Zm9yY2VSZWdpc3RlcnM=::MTExMQ==::Zm9yY2VSZWdpc3RlcnM=\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"UkVTX0RTUF9wYXJhbQ==::MA==::TXVsdGlwbGllcw==\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"UkVTX0xVVF9wYXJhbQ==::ODAz::TFVUcw==\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"UkVTX01CSVRfcGFyYW0=::MA==::TWVtb3J5IEJpdHM=\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"UkVTX01CTE9DS19wYXJhbQ==::MA==::TWVtb3J5IEJsb2Nrcw==\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"c2VsZWN0ZWRfZGV2aWNlX2ZhbWlseQ==::Q3ljbG9uZSBW::c2VsZWN0ZWRfZGV2aWNlX2ZhbWlseQ==\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"c2VsZWN0ZWRfZGV2aWNlX3NwZWVkZ3JhZGU=::Nw==::c2VsZWN0ZWRfZGV2aWNlX3NwZWVkZ3JhZGU=\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_COMPONENT_PARAMETER \"dmFsaWRhdGlvbl9mYWlsZWQ=::ZmFsc2U=::dmFsaWRhdGlvbl9mYWlsZWQ=\"\n" +
                        "\n" +
                        "set_global_assignment -library \"FP_SUB_32\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_SUB_32.vhd\"]\n" +
                        "set_global_assignment -library \"FP_SUB_32\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_SUB_32/dspba_library_package.vhd\"]\n" +
                        "set_global_assignment -library \"FP_SUB_32\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_SUB_32/dspba_library.vhd\"]\n" +
                        "set_global_assignment -library \"FP_SUB_32\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_SUB_32/FP_SUB_32_0002.vhd\"]\n" +
                        "\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_TOOL_NAME \"altera_fp_functions\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32_0002\" -library \"FP_SUB_32\" -name IP_TOOL_ENV \"mwpim\"";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_FP_SUB_32_sip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -entity \"FP_SUB_32\" -library \"lib_FP_SUB_32\" -name IP_TOOL_NAME \"altera_fp_functions\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32\" -library \"lib_FP_SUB_32\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"FP_SUB_32\" -library \"lib_FP_SUB_32\" -name IP_TOOL_ENV \"mwpim\"\n" +
                        "set_global_assignment -library \"lib_FP_SUB_32\" -name SPD_FILE [file join $::quartus(sip_path) \"FP_SUB_32.spd\"]\n" +
                        "\n" +
                        "set_global_assignment -library \"lib_FP_SUB_32\" -name MISC_FILE [file join $::quartus(sip_path) \"FP_SUB_32_sim/dspba_library_package.vhd\"]\n" +
                        "set_global_assignment -library \"lib_FP_SUB_32\" -name MISC_FILE [file join $::quartus(sip_path) \"FP_SUB_32_sim/dspba_library.vhd\"]\n" +
                        "set_global_assignment -library \"lib_FP_SUB_32\" -name MISC_FILE [file join $::quartus(sip_path) \"FP_SUB_32_sim/FP_SUB_32.vhd\"]";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_FP_SUB_32_vhd_file(String Project_Folder_File) {
        String data =   "-- megafunction wizard: %ALTERA_FP_FUNCTIONS v18.0%\n" +
                        "-- GENERATION: XML\n" +
                        "-- FP_SUB_32.vhd\n" +
                        "\n" +
                        "-- Generated using ACDS version 18.0 614\n" +
                        "\n" +
                        "library IEEE;\n" +
                        "use IEEE.std_logic_1164.all;\n" +
                        "use IEEE.numeric_std.all;\n" +
                        "\n" +
                        "entity FP_SUB_32 is\n" +
                        "	port (\n" +
                        "		clk    : in  std_logic                     := '0';             --    clk.clk\n" +
                        "		areset : in  std_logic                     := '0';             -- areset.reset\n" +
                        "		a      : in  std_logic_vector(31 downto 0) := (others => '0'); --      a.a\n" +
                        "		b      : in  std_logic_vector(31 downto 0) := (others => '0'); --      b.b\n" +
                        "		q      : out std_logic_vector(31 downto 0)                     --      q.q\n" +
                        "	);\n" +
                        "end entity FP_SUB_32;\n" +
                        "\n" +
                        "architecture rtl of FP_SUB_32 is\n" +
                        "	component FP_SUB_32_0002 is\n" +
                        "		port (\n" +
                        "			clk    : in  std_logic                     := 'X';             -- clk\n" +
                        "			areset : in  std_logic                     := 'X';             -- reset\n" +
                        "			a      : in  std_logic_vector(31 downto 0) := (others => 'X'); -- a\n" +
                        "			b      : in  std_logic_vector(31 downto 0) := (others => 'X'); -- b\n" +
                        "			q      : out std_logic_vector(31 downto 0)                     -- q\n" +
                        "		);\n" +
                        "	end component FP_SUB_32_0002;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "	fp_sub_32_inst : component FP_SUB_32_0002\n" +
                        "		port map (\n" +
                        "			clk    => clk,    --    clk.clk\n" +
                        "			areset => areset, -- areset.reset\n" +
                        "			a      => a,      --      a.a\n" +
                        "			b      => b,      --      b.b\n" +
                        "			q      => q       --      q.q\n" +
                        "		);\n" +
                        "\n" +
                        "end architecture rtl; -- of FP_SUB_32\n" +
                        "-- Retrieval info: <?xml version=\"1.0\"?>\n" +
                        "--<!--\n" +
                        "--	Generated by Altera MegaWizard Launcher Utility version 1.0\n" +
                        "--	************************************************************\n" +
                        "--	THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!\n" +
                        "--	************************************************************\n" +
                        "--	Copyright (C) 1991-2020 Altera Corporation\n" +
                        "--	Any megafunction design, and related net list (encrypted or decrypted),\n" +
                        "--	support information, device programming or simulation file, and any other\n" +
                        "--	associated documentation or information provided by Altera or a partner\n" +
                        "--	under Altera's Megafunction Partnership Program may be used only to\n" +
                        "--	program PLD devices (but not masked PLD devices) from Altera.  Any other\n" +
                        "--	use of such megafunction design, net list, support information, device\n" +
                        "--	programming or simulation file, or any other related documentation or\n" +
                        "--	information is prohibited for any other purpose, including, but not\n" +
                        "--	limited to modification, reverse engineering, de-compiling, or use with\n" +
                        "--	any other silicon devices, unless such use is explicitly licensed under\n" +
                        "--	a separate agreement with Altera or a megafunction partner.  Title to\n" +
                        "--	the intellectual property, including patents, copyrights, trademarks,\n" +
                        "--	trade secrets, or maskworks, embodied in any such megafunction design,\n" +
                        "--	net list, support information, device programming or simulation file, or\n" +
                        "--	any other related documentation or information provided by Altera or a\n" +
                        "--	megafunction partner, remains with Altera, the megafunction partner, or\n" +
                        "--	their respective licensors.  No other licenses, including any licenses\n" +
                        "--	needed under any third party's intellectual property, are provided herein.\n" +
                        "---->\n" +
                        "-- Retrieval info: <instance entity-name=\"altera_fp_functions\" version=\"18.0\" >\n" +
                        "-- Retrieval info: 	<generic name=\"FUNCTION_FAMILY\" value=\"ARITH\" />\n" +
                        "-- Retrieval info: 	<generic name=\"ARITH_function\" value=\"SUB\" />\n" +
                        "-- Retrieval info: 	<generic name=\"CONVERT_function\" value=\"FXP_FP\" />\n" +
                        "-- Retrieval info: 	<generic name=\"ALL_function\" value=\"ADD\" />\n" +
                        "-- Retrieval info: 	<generic name=\"EXP_LOG_function\" value=\"EXPE\" />\n" +
                        "-- Retrieval info: 	<generic name=\"TRIG_function\" value=\"SIN\" />\n" +
                        "-- Retrieval info: 	<generic name=\"COMPARE_function\" value=\"MIN\" />\n" +
                        "-- Retrieval info: 	<generic name=\"ROOTS_function\" value=\"SQRT\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_format\" value=\"single\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_exp\" value=\"8\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_man\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"exponent_width\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"frequency_target\" value=\"100\" />\n" +
                        "-- Retrieval info: 	<generic name=\"latency_target\" value=\"2\" />\n" +
                        "-- Retrieval info: 	<generic name=\"performance_goal\" value=\"frequency\" />\n" +
                        "-- Retrieval info: 	<generic name=\"rounding_mode\" value=\"nearest with tie breaking away from zero\" />\n" +
                        "-- Retrieval info: 	<generic name=\"faithful_rounding\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gen_enable\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"divide_type\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"select_signal_enable\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"scale_by_pi\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"number_of_inputs\" value=\"2\" />\n" +
                        "-- Retrieval info: 	<generic name=\"trig_no_range_reduction\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"report_resources_to_xml\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fxpt_width\" value=\"32\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fxpt_fraction\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fxpt_sign\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_out_format\" value=\"single\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_out_exp\" value=\"8\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_out_man\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_in_format\" value=\"single\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_in_exp\" value=\"8\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_in_man\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"enable_hard_fp\" value=\"true\" />\n" +
                        "-- Retrieval info: 	<generic name=\"manual_dsp_planning\" value=\"true\" />\n" +
                        "-- Retrieval info: 	<generic name=\"forceRegisters\" value=\"1111\" />\n" +
                        "-- Retrieval info: 	<generic name=\"selected_device_family\" value=\"Cyclone V\" />\n" +
                        "-- Retrieval info: 	<generic name=\"selected_device_speedgrade\" value=\"7\" />\n" +
                        "-- Retrieval info: </instance>\n" +
                        "-- IPFS_FILES : FP_SUB_32.vho\n" +
                        "-- RELATED_FILES: FP_SUB_32.vhd, dspba_library_package.vhd, dspba_library.vhd, FP_SUB_32_0002.vhd";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }
    
    private void generate_FP_SUB_32_0002_vhd_file(String Project_Folder_File) {
        String data1 =  "-- ------------------------------------------------------------------------- \n" +
                        "-- High Level Design Compiler for Intel(R) FPGAs Version 18.0 (Release Build #614)\n" +
                        "-- Quartus Prime development tool and MATLAB/Simulink Interface\n" +
                        "-- \n" +
                        "-- Legal Notice: Copyright 2018 Intel Corporation.  All rights reserved.\n" +
                        "-- Your use of  Intel Corporation's design tools,  logic functions and other\n" +
                        "-- software and  tools, and its AMPP partner logic functions, and any output\n" +
                        "-- files any  of the foregoing (including  device programming  or simulation\n" +
                        "-- files), and  any associated  documentation  or information  are expressly\n" +
                        "-- subject  to the terms and  conditions of the  Intel FPGA Software License\n" +
                        "-- Agreement, Intel MegaCore Function License Agreement, or other applicable\n" +
                        "-- license agreement,  including,  without limitation,  that your use is for\n" +
                        "-- the  sole  purpose of  programming  logic devices  manufactured by  Intel\n" +
                        "-- and  sold by Intel  or its authorized  distributors. Please refer  to the\n" +
                        "-- applicable agreement for further details.\n" +
                        "-- ---------------------------------------------------------------------------\n" +
                        "\n" +
                        "-- VHDL created from FP_SUB_32_0002\n" +
                        "-- VHDL created on Fri Jul 24 01:59:42 2020\n" +
                        "\n" +
                        "\n" +
                        "library IEEE;\n" +
                        "use IEEE.std_logic_1164.all;\n" +
                        "use IEEE.NUMERIC_STD.all;\n" +
                        "use IEEE.MATH_REAL.all;\n" +
                        "use std.TextIO.all;\n" +
                        "use work.dspba_library_package.all;\n" +
                        "\n" +
                        "LIBRARY altera_mf;\n" +
                        "USE altera_mf.altera_mf_components.all;\n" +
                        "LIBRARY altera_lnsim;\n" +
                        "USE altera_lnsim.altera_lnsim_components.altera_syncram;\n" +
                        "LIBRARY lpm;\n" +
                        "USE lpm.lpm_components.all;\n" +
                        "\n" +
                        "entity FP_SUB_32_0002 is\n" +
                        "    port (\n" +
                        "        a : in std_logic_vector(31 downto 0);  -- float32_m23\n" +
                        "        b : in std_logic_vector(31 downto 0);  -- float32_m23\n" +
                        "        q : out std_logic_vector(31 downto 0);  -- float32_m23\n" +
                        "        clk : in std_logic;\n" +
                        "        areset : in std_logic\n" +
                        "    );\n" +
                        "end FP_SUB_32_0002;\n" +
                        "\n" +
                        "architecture normal of FP_SUB_32_0002 is\n" +
                        "\n" +
                        "    attribute altera_attribute : string;\n" +
                        "    attribute altera_attribute of normal : architecture is \"-name AUTO_SHIFT_REGISTER_RECOGNITION OFF; -name PHYSICAL_SYNTHESIS_REGISTER_DUPLICATION ON; -name MESSAGE_DISABLE 10036; -name MESSAGE_DISABLE 10037; -name MESSAGE_DISABLE 14130; -name MESSAGE_DISABLE 14320; -name MESSAGE_DISABLE 15400; -name MESSAGE_DISABLE 14130; -name MESSAGE_DISABLE 10036; -name MESSAGE_DISABLE 12020; -name MESSAGE_DISABLE 12030; -name MESSAGE_DISABLE 12010; -name MESSAGE_DISABLE 12110; -name MESSAGE_DISABLE 14320; -name MESSAGE_DISABLE 13410; -name MESSAGE_DISABLE 113007\";\n" +
                        "    \n" +
                        "    signal GND_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal VCC_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expFracX_uid6_fpSubTest_b : STD_LOGIC_VECTOR (30 downto 0);\n" +
                        "    signal expFracY_uid7_fpSubTest_b : STD_LOGIC_VECTOR (30 downto 0);\n" +
                        "    signal xGTEy_uid8_fpSubTest_a : STD_LOGIC_VECTOR (32 downto 0);\n" +
                        "    signal xGTEy_uid8_fpSubTest_b : STD_LOGIC_VECTOR (32 downto 0);\n" +
                        "    signal xGTEy_uid8_fpSubTest_o : STD_LOGIC_VECTOR (32 downto 0);\n" +
                        "    signal xGTEy_uid8_fpSubTest_n : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracY_uid9_fpSubTest_b : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal expY_uid10_fpSubTest_b : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal sigY_uid11_fpSubTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal invSigY_uid12_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal ypn_uid13_fpSubTest_q : STD_LOGIC_VECTOR (31 downto 0);\n" +
                        "    signal aSig_uid17_fpSubTest_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal aSig_uid17_fpSubTest_q : STD_LOGIC_VECTOR (31 downto 0);\n" +
                        "    signal bSig_uid18_fpSubTest_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal bSig_uid18_fpSubTest_q : STD_LOGIC_VECTOR (31 downto 0);\n" +
                        "    signal cstAllOWE_uid19_fpSubTest_q : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal cstZeroWF_uid20_fpSubTest_q : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal cstAllZWE_uid21_fpSubTest_q : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal exp_aSig_uid22_fpSubTest_in : STD_LOGIC_VECTOR (30 downto 0);\n" +
                        "    signal exp_aSig_uid22_fpSubTest_b : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal frac_aSig_uid23_fpSubTest_in : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal frac_aSig_uid23_fpSubTest_b : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal excZ_aSig_uid17_uid24_fpSubTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excZ_aSig_uid17_uid24_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expXIsMax_uid25_fpSubTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expXIsMax_uid25_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsZero_uid26_fpSubTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsZero_uid26_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsNotZero_uid27_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excI_aSig_uid28_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excN_aSig_uid29_fpSubTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excN_aSig_uid29_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal invExpXIsMax_uid30_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal InvExpXIsZero_uid31_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excR_aSig_uid32_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal exp_bSig_uid36_fpSubTest_in : STD_LOGIC_VECTOR (30 downto 0);\n" +
                        "    signal exp_bSig_uid36_fpSubTest_b : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal frac_bSig_uid37_fpSubTest_in : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal frac_bSig_uid37_fpSubTest_b : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal excZ_bSig_uid18_uid38_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expXIsMax_uid39_fpSubTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expXIsMax_uid39_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsZero_uid40_fpSubTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsZero_uid40_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsNotZero_uid41_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excI_bSig_uid42_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excN_bSig_uid43_fpSubTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excN_bSig_uid43_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal invExpXIsMax_uid44_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal InvExpXIsZero_uid45_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excR_bSig_uid46_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal sigA_uid51_fpSubTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal sigB_uid52_fpSubTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal effSub_uid53_fpSubTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal effSub_uid53_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracBz_uid57_fpSubTest_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracBz_uid57_fpSubTest_q : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal oFracB_uid60_fpSubTest_q : STD_LOGIC_VECTOR (23 downto 0);\n" +
                        "    signal expAmExpB_uid61_fpSubTest_a : STD_LOGIC_VECTOR (8 downto 0);\n" +
                        "    signal expAmExpB_uid61_fpSubTest_b : STD_LOGIC_VECTOR (8 downto 0);\n" +
                        "    signal expAmExpB_uid61_fpSubTest_o : STD_LOGIC_VECTOR (8 downto 0);\n" +
                        "    signal expAmExpB_uid61_fpSubTest_q : STD_LOGIC_VECTOR (8 downto 0);\n" +
                        "    signal cWFP2_uid62_fpSubTest_q : STD_LOGIC_VECTOR (4 downto 0);\n" +
                        "    signal shiftedOut_uid64_fpSubTest_a : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal shiftedOut_uid64_fpSubTest_b : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal shiftedOut_uid64_fpSubTest_o : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal shiftedOut_uid64_fpSubTest_c : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal padConst_uid65_fpSubTest_q : STD_LOGIC_VECTOR (24 downto 0);\n" +
                        "    signal rightPaddedIn_uid66_fpSubTest_q : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal iShiftedOut_uid68_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal alignFracBPostShiftOut_uid69_fpSubTest_b : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal alignFracBPostShiftOut_uid69_fpSubTest_q : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal cmpEQ_stickyBits_cZwF_uid72_fpSubTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal cmpEQ_stickyBits_cZwF_uid72_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal invCmpEQ_stickyBits_cZwF_uid73_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal effSubInvSticky_uid75_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal zocst_uid77_fpSubTest_q : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal fracAAddOp_uid78_fpSubTest_q : STD_LOGIC_VECTOR (26 downto 0);\n" +
                        "    signal fracBAddOp_uid81_fpSubTest_q : STD_LOGIC_VECTOR (26 downto 0);\n" +
                        "    signal fracBAddOpPostXor_uid82_fpSubTest_b : STD_LOGIC_VECTOR (26 downto 0);\n" +
                        "    signal fracBAddOpPostXor_uid82_fpSubTest_q : STD_LOGIC_VECTOR (26 downto 0);\n" +
                        "    signal fracAddResult_uid83_fpSubTest_a : STD_LOGIC_VECTOR (27 downto 0);\n" +
                        "    signal fracAddResult_uid83_fpSubTest_b : STD_LOGIC_VECTOR (27 downto 0);\n" +
                        "    signal fracAddResult_uid83_fpSubTest_o : STD_LOGIC_VECTOR (27 downto 0);\n" +
                        "    signal fracAddResult_uid83_fpSubTest_q : STD_LOGIC_VECTOR (27 downto 0);\n" +
                        "    signal rangeFracAddResultMwfp3Dto0_uid84_fpSubTest_in : STD_LOGIC_VECTOR (26 downto 0);\n" +
                        "    signal rangeFracAddResultMwfp3Dto0_uid84_fpSubTest_b : STD_LOGIC_VECTOR (26 downto 0);\n" +
                        "    signal fracGRS_uid85_fpSubTest_q : STD_LOGIC_VECTOR (27 downto 0);\n" +
                        "    signal cAmA_uid87_fpSubTest_q : STD_LOGIC_VECTOR (4 downto 0);\n" +
                        "    signal aMinusA_uid88_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracPostNorm_uid90_fpSubTest_b : STD_LOGIC_VECTOR (26 downto 0);\n" +
                        "    signal oneCST_uid91_fpSubTest_q : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal expInc_uid92_fpSubTest_a : STD_LOGIC_VECTOR (8 downto 0);\n" +
                        "    signal expInc_uid92_fpSubTest_b : STD_LOGIC_VECTOR (8 downto 0);\n" +
                        "    signal expInc_uid92_fpSubTest_o : STD_LOGIC_VECTOR (8 downto 0);\n" +
                        "    signal expInc_uid92_fpSubTest_q : STD_LOGIC_VECTOR (8 downto 0);\n" +
                        "    signal expPostNorm_uid93_fpSubTest_a : STD_LOGIC_VECTOR (9 downto 0);\n" +
                        "    signal expPostNorm_uid93_fpSubTest_b : STD_LOGIC_VECTOR (9 downto 0);\n" +
                        "    signal expPostNorm_uid93_fpSubTest_o : STD_LOGIC_VECTOR (9 downto 0);\n" +
                        "    signal expPostNorm_uid93_fpSubTest_q : STD_LOGIC_VECTOR (9 downto 0);\n" +
                        "    signal Sticky0_uid94_fpSubTest_in : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal Sticky0_uid94_fpSubTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal Sticky1_uid95_fpSubTest_in : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal Sticky1_uid95_fpSubTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal Round_uid96_fpSubTest_in : STD_LOGIC_VECTOR (2 downto 0);\n" +
                        "    signal Round_uid96_fpSubTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal Guard_uid97_fpSubTest_in : STD_LOGIC_VECTOR (3 downto 0);\n" +
                        "    signal Guard_uid97_fpSubTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal LSB_uid98_fpSubTest_in : STD_LOGIC_VECTOR (4 downto 0);\n" +
                        "    signal LSB_uid98_fpSubTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rndBitCond_uid99_fpSubTest_q : STD_LOGIC_VECTOR (4 downto 0);\n" +
                        "    signal cRBit_uid100_fpSubTest_q : STD_LOGIC_VECTOR (4 downto 0);\n" +
                        "    signal rBi_uid101_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal roundBit_uid102_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracPostNormRndRange_uid103_fpSubTest_in : STD_LOGIC_VECTOR (25 downto 0);\n" +
                        "    signal fracPostNormRndRange_uid103_fpSubTest_b : STD_LOGIC_VECTOR (23 downto 0);\n" +
                        "    signal expFracR_uid104_fpSubTest_q : STD_LOGIC_VECTOR (33 downto 0);\n" +
                        "    signal rndExpFrac_uid105_fpSubTest_a : STD_LOGIC_VECTOR (34 downto 0);\n" +
                        "    signal rndExpFrac_uid105_fpSubTest_b : STD_LOGIC_VECTOR (34 downto 0);\n" +
                        "    signal rndExpFrac_uid105_fpSubTest_o : STD_LOGIC_VECTOR (34 downto 0);\n" +
                        "    signal rndExpFrac_uid105_fpSubTest_q : STD_LOGIC_VECTOR (34 downto 0);\n" +
                        "    signal wEP2AllOwE_uid106_fpSubTest_q : STD_LOGIC_VECTOR (9 downto 0);\n" +
                        "    signal rndExp_uid107_fpSubTest_in : STD_LOGIC_VECTOR (33 downto 0);\n" +
                        "    signal rndExp_uid107_fpSubTest_b : STD_LOGIC_VECTOR (9 downto 0);\n" +
                        "    signal rOvfEQMax_uid108_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rndExpFracOvfBits_uid110_fpSubTest_in : STD_LOGIC_VECTOR (33 downto 0);\n" +
                        "    signal rndExpFracOvfBits_uid110_fpSubTest_b : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal rOvfExtraBits_uid111_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rOvf_uid112_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal wEP2AllZ_uid113_fpSubTest_q : STD_LOGIC_VECTOR (9 downto 0);\n" +
                        "    signal rUdfEQMin_uid114_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rUdfExtraBit_uid115_fpSubTest_in : STD_LOGIC_VECTOR (33 downto 0);\n" +
                        "    signal rUdfExtraBit_uid115_fpSubTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rUdf_uid116_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracRPreExc_uid117_fpSubTest_in : STD_LOGIC_VECTOR (23 downto 0);\n" +
                        "    signal fracRPreExc_uid117_fpSubTest_b : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal expRPreExc_uid118_fpSubTest_in : STD_LOGIC_VECTOR (31 downto 0);\n" +
                        "    signal expRPreExc_uid118_fpSubTest_b : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal regInputs_uid119_fpSubTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal regInputs_uid119_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excRZeroVInC_uid120_fpSubTest_q : STD_LOGIC_VECTOR (4 downto 0);\n" +
                        "    signal excRZero_uid121_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rInfOvf_uid122_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excRInfVInC_uid123_fpSubTest_q : STD_LOGIC_VECTOR (5 downto 0);\n" +
                        "    signal excRInf_uid124_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excRNaN2_uid125_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excAIBISub_uid126_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excRNaN_uid127_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal concExc_uid128_fpSubTest_q : STD_LOGIC_VECTOR (2 downto 0);\n" +
                        "    signal excREnc_uid129_fpSubTest_q : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal invAMinusA_uid130_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal signRReg_uid131_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal sigBBInf_uid132_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal sigAAInf_uid133_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal signRInf_uid134_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excAZBZSigASigB_uid135_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excBZARSigA_uid136_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal signRZero_uid137_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal signRInfRZRReg_uid138_fpSubTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal signRInfRZRReg_uid138_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal invExcRNaN_uid139_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal signRPostExc_uid140_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal oneFracRPostExc2_uid141_fpSubTest_q : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal fracRPostExc_uid144_fpSubTest_s : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal fracRPostExc_uid144_fpSubTest_q : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal expRPostExc_uid148_fpSubTest_s : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal expRPostExc_uid148_fpSubTest_q : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal R_uid149_fpSubTest_q : STD_LOGIC_VECTOR (31 downto 0);\n" +
                        "    signal zs_uid151_lzCountVal_uid86_fpSubTest_q : STD_LOGIC_VECTOR (15 downto 0);\n" +
                        "    signal rVStage_uid152_lzCountVal_uid86_fpSubTest_b : STD_LOGIC_VECTOR (15 downto 0);\n" +
                        "    signal vCount_uid153_lzCountVal_uid86_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal mO_uid154_lzCountVal_uid86_fpSubTest_q : STD_LOGIC_VECTOR (3 downto 0);\n" +
                        "    signal vStage_uid155_lzCountVal_uid86_fpSubTest_in : STD_LOGIC_VECTOR (11 downto 0);\n" +
                        "    signal vStage_uid155_lzCountVal_uid86_fpSubTest_b : STD_LOGIC_VECTOR (11 downto 0);\n" +
                        "    signal cStage_uid156_lzCountVal_uid86_fpSubTest_q : STD_LOGIC_VECTOR (15 downto 0);\n" +
                        "    signal vStagei_uid158_lzCountVal_uid86_fpSubTest_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal vStagei_uid158_lzCountVal_uid86_fpSubTest_q : STD_LOGIC_VECTOR (15 downto 0);\n" +
                        "    signal vCount_uid161_lzCountVal_uid86_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal vStagei_uid164_lzCountVal_uid86_fpSubTest_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal vStagei_uid164_lzCountVal_uid86_fpSubTest_q : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal zs_uid165_lzCountVal_uid86_fpSubTest_q : STD_LOGIC_VECTOR (3 downto 0);\n" +
                        "    signal vCount_uid167_lzCountVal_uid86_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal vStagei_uid170_lzCountVal_uid86_fpSubTest_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal vStagei_uid170_lzCountVal_uid86_fpSubTest_q : STD_LOGIC_VECTOR (3 downto 0);\n" +
                        "    signal zs_uid171_lzCountVal_uid86_fpSubTest_q : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal vCount_uid173_lzCountVal_uid86_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal vStagei_uid176_lzCountVal_uid86_fpSubTest_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal vStagei_uid176_lzCountVal_uid86_fpSubTest_q : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal rVStage_uid178_lzCountVal_uid86_fpSubTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal vCount_uid179_lzCountVal_uid86_fpSubTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal r_uid180_lzCountVal_uid86_fpSubTest_q : STD_LOGIC_VECTOR (4 downto 0);\n" +
                        "    signal wIntCst_uid184_alignmentShifter_uid65_fpSubTest_q : STD_LOGIC_VECTOR (5 downto 0);\n" +
                        "    signal shiftedOut_uid185_alignmentShifter_uid65_fpSubTest_a : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal shiftedOut_uid185_alignmentShifter_uid65_fpSubTest_b : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal shiftedOut_uid185_alignmentShifter_uid65_fpSubTest_o : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal shiftedOut_uid185_alignmentShifter_uid65_fpSubTest_n : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rightShiftStage0Idx1Rng16_uid186_alignmentShifter_uid65_fpSubTest_b : STD_LOGIC_VECTOR (32 downto 0);\n" +
                        "    signal rightShiftStage0Idx1_uid188_alignmentShifter_uid65_fpSubTest_q : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal rightShiftStage0Idx2Rng32_uid189_alignmentShifter_uid65_fpSubTest_b : STD_LOGIC_VECTOR (16 downto 0);\n" +
                        "    signal rightShiftStage0Idx2Pad32_uid190_alignmentShifter_uid65_fpSubTest_q : STD_LOGIC_VECTOR (31 downto 0);\n" +
                        "    signal rightShiftStage0Idx2_uid191_alignmentShifter_uid65_fpSubTest_q : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal rightShiftStage0Idx3Rng48_uid192_alignmentShifter_uid65_fpSubTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal rightShiftStage0Idx3Pad48_uid193_alignmentShifter_uid65_fpSubTest_q : STD_LOGIC_VECTOR (47 downto 0);\n" +
                        "    signal rightShiftStage0Idx3_uid194_alignmentShifter_uid65_fpSubTest_q : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal rightShiftStage0_uid196_alignmentShifter_uid65_fpSubTest_s : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal rightShiftStage0_uid196_alignmentShifter_uid65_fpSubTest_q : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal rightShiftStage1Idx1Rng4_uid197_alignmentShifter_uid65_fpSubTest_b : STD_LOGIC_VECTOR (44 downto 0);\n" +
                        "    signal rightShiftStage1Idx1_uid199_alignmentShifter_uid65_fpSubTest_q : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal rightShiftStage1Idx2Rng8_uid200_alignmentShifter_uid65_fpSubTest_b : STD_LOGIC_VECTOR (40 downto 0);\n" +
                        "    signal rightShiftStage1Idx2_uid202_alignmentShifter_uid65_fpSubTest_q : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal rightShiftStage1Idx3Rng12_uid203_alignmentShifter_uid65_fpSubTest_b : STD_LOGIC_VECTOR (36 downto 0);\n" +
                        "    signal rightShiftStage1Idx3Pad12_uid204_alignmentShifter_uid65_fpSubTest_q : STD_LOGIC_VECTOR (11 downto 0);\n" +
                        "    signal rightShiftStage1Idx3_uid205_alignmentShifter_uid65_fpSubTest_q : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal rightShiftStage1_uid207_alignmentShifter_uid65_fpSubTest_s : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal rightShiftStage1_uid207_alignmentShifter_uid65_fpSubTest_q : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal rightShiftStage2Idx1Rng1_uid208_alignmentShifter_uid65_fpSubTest_b : STD_LOGIC_VECTOR (47 downto 0);\n" +
                        "    signal rightShiftStage2Idx1_uid210_alignmentShifter_uid65_fpSubTest_q : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal rightShiftStage2Idx2Rng2_uid211_alignmentShifter_uid65_fpSubTest_b : STD_LOGIC_VECTOR (46 downto 0);\n" +
                        "    signal rightShiftStage2Idx2_uid213_alignmentShifter_uid65_fpSubTest_q : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal rightShiftStage2Idx3Rng3_uid214_alignmentShifter_uid65_fpSubTest_b : STD_LOGIC_VECTOR (45 downto 0);\n" +
                        "    signal rightShiftStage2Idx3Pad3_uid215_alignmentShifter_uid65_fpSubTest_q : STD_LOGIC_VECTOR (2 downto 0);\n" +
                        "    signal rightShiftStage2Idx3_uid216_alignmentShifter_uid65_fpSubTest_q : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal rightShiftStage2_uid218_alignmentShifter_uid65_fpSubTest_s : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal rightShiftStage2_uid218_alignmentShifter_uid65_fpSubTest_q : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal zeroOutCst_uid219_alignmentShifter_uid65_fpSubTest_q : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal r_uid220_alignmentShifter_uid65_fpSubTest_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal r_uid220_alignmentShifter_uid65_fpSubTest_q : STD_LOGIC_VECTOR (48 downto 0);\n" +
                        "    signal leftShiftStage0Idx1Rng8_uid225_fracPostNormExt_uid89_fpSubTest_in : STD_LOGIC_VECTOR (19 downto 0);\n" +
                        "    signal leftShiftStage0Idx1Rng8_uid225_fracPostNormExt_uid89_fpSubTest_b : STD_LOGIC_VECTOR (19 downto 0);\n" +
                        "    signal leftShiftStage0Idx1_uid226_fracPostNormExt_uid89_fpSubTest_q : STD_LOGIC_VECTOR (27 downto 0);\n" +
                        "    signal leftShiftStage0Idx2_uid229_fracPostNormExt_uid89_fpSubTest_q : STD_LOGIC_VECTOR (27 downto 0);\n" +
                        "    signal leftShiftStage0Idx3Pad24_uid230_fracPostNormExt_uid89_fpSubTest_q : STD_LOGIC_VECTOR (23 downto 0);\n" +
                        "    signal leftShiftStage0Idx3Rng24_uid231_fracPostNormExt_uid89_fpSubTest_in : STD_LOGIC_VECTOR (3 downto 0);\n" +
                        "    signal leftShiftStage0Idx3Rng24_uid231_fracPostNormExt_uid89_fpSubTest_b : STD_LOGIC_VECTOR (3 downto 0);\n" +
                        "    signal leftShiftStage0Idx3_uid232_fracPostNormExt_uid89_fpSubTest_q : STD_LOGIC_VECTOR (27 downto 0);\n" +
                        "    signal leftShiftStage0_uid234_fracPostNormExt_uid89_fpSubTest_s : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal leftShiftStage0_uid234_fracPostNormExt_uid89_fpSubTest_q : STD_LOGIC_VECTOR (27 downto 0);\n" +
                        "    signal leftShiftStage1Idx1Rng2_uid236_fracPostNormExt_uid89_fpSubTest_in : STD_LOGIC_VECTOR (25 downto 0);\n" +
                        "    signal leftShiftStage1Idx1Rng2_uid236_fracPostNormExt_uid89_fpSubTest_b : STD_LOGIC_VECTOR (25 downto 0);\n" +
                        "    signal leftShiftStage1Idx1_uid237_fracPostNormExt_uid89_fpSubTest_q : STD_LOGIC_VECTOR (27 downto 0);\n" +
                        "    signal leftShiftStage1Idx2Rng4_uid239_fracPostNormExt_uid89_fpSubTest_in : STD_LOGIC_VECTOR (23 downto 0);\n" +
                        "    signal leftShiftStage1Idx2Rng4_uid239_fracPostNormExt_uid89_fpSubTest_b : STD_LOGIC_VECTOR (23 downto 0);\n" +
                        "    signal leftShiftStage1Idx2_uid240_fracPostNormExt_uid89_fpSubTest_q : STD_LOGIC_VECTOR (27 downto 0);\n" +
                        "    signal leftShiftStage1Idx3Pad6_uid241_fracPostNormExt_uid89_fpSubTest_q : STD_LOGIC_VECTOR (5 downto 0);\n" +
                        "    signal leftShiftStage1Idx3Rng6_uid242_fracPostNormExt_uid89_fpSubTest_in : STD_LOGIC_VECTOR (21 downto 0);\n" +
                        "    signal leftShiftStage1Idx3Rng6_uid242_fracPostNormExt_uid89_fpSubTest_b : STD_LOGIC_VECTOR (21 downto 0);\n" +
                        "    signal leftShiftStage1Idx3_uid243_fracPostNormExt_uid89_fpSubTest_q : STD_LOGIC_VECTOR (27 downto 0);\n" +
                        "    signal leftShiftStage1_uid245_fracPostNormExt_uid89_fpSubTest_s : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal leftShiftStage1_uid245_fracPostNormExt_uid89_fpSubTest_q : STD_LOGIC_VECTOR (27 downto 0);\n" +
                        "    signal leftShiftStage2Idx1Rng1_uid247_fracPostNormExt_uid89_fpSubTest_in : STD_LOGIC_VECTOR (26 downto 0);\n" +
                        "    signal leftShiftStage2Idx1Rng1_uid247_fracPostNormExt_uid89_fpSubTest_b : STD_LOGIC_VECTOR (26 downto 0);\n" +
                        "    signal leftShiftStage2Idx1_uid248_fracPostNormExt_uid89_fpSubTest_q : STD_LOGIC_VECTOR (27 downto 0);\n" +
                        "    signal leftShiftStage2_uid250_fracPostNormExt_uid89_fpSubTest_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal leftShiftStage2_uid250_fracPostNormExt_uid89_fpSubTest_q : STD_LOGIC_VECTOR (27 downto 0);\n" +
                        "    signal rightShiftStageSel5Dto4_uid195_alignmentShifter_uid65_fpSubTest_merged_bit_select_in : STD_LOGIC_VECTOR (5 downto 0);\n" +
                        "    signal rightShiftStageSel5Dto4_uid195_alignmentShifter_uid65_fpSubTest_merged_bit_select_b : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal rightShiftStageSel5Dto4_uid195_alignmentShifter_uid65_fpSubTest_merged_bit_select_c : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal rightShiftStageSel5Dto4_uid195_alignmentShifter_uid65_fpSubTest_merged_bit_select_d : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal stickyBits_uid70_fpSubTest_merged_bit_select_b : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal stickyBits_uid70_fpSubTest_merged_bit_select_c : STD_LOGIC_VECTOR (25 downto 0);\n" +
                        "    signal rVStage_uid160_lzCountVal_uid86_fpSubTest_merged_bit_select_b : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal rVStage_uid160_lzCountVal_uid86_fpSubTest_merged_bit_select_c : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal rVStage_uid166_lzCountVal_uid86_fpSubTest_merged_bit_select_b : STD_LOGIC_VECTOR (3 downto 0);\n" +
                        "    signal rVStage_uid166_lzCountVal_uid86_fpSubTest_merged_bit_select_c : STD_LOGIC_VECTOR (3 downto 0);\n" +
                        "    signal rVStage_uid172_lzCountVal_uid86_fpSubTest_merged_bit_select_b : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal rVStage_uid172_lzCountVal_uid86_fpSubTest_merged_bit_select_c : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal leftShiftStageSel4Dto3_uid233_fracPostNormExt_uid89_fpSubTest_merged_bit_select_b : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal leftShiftStageSel4Dto3_uid233_fracPostNormExt_uid89_fpSubTest_merged_bit_select_c : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal leftShiftStageSel4Dto3_uid233_fracPostNormExt_uid89_fpSubTest_merged_bit_select_d : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist0_stickyBits_uid70_fpSubTest_merged_bit_select_c_1_q : STD_LOGIC_VECTOR (25 downto 0);\n" +
                        "    signal redist1_r_uid180_lzCountVal_uid86_fpSubTest_q_1_q : STD_LOGIC_VECTOR (4 downto 0);\n" +
                        "    signal redist2_vStage_uid155_lzCountVal_uid86_fpSubTest_b_2_q : STD_LOGIC_VECTOR (11 downto 0);\n" +
                        "    signal redist3_vCount_uid153_lzCountVal_uid86_fpSubTest_q_1_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist4_aMinusA_uid88_fpSubTest_q_1_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist5_fracGRS_uid85_fpSubTest_q_2_q : STD_LOGIC_VECTOR (27 downto 0);\n" +
                        "    signal redist6_effSub_uid53_fpSubTest_q_4_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist7_sigB_uid52_fpSubTest_b_1_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist8_sigB_uid52_fpSubTest_b_4_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist9_sigA_uid51_fpSubTest_b_1_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist10_sigA_uid51_fpSubTest_b_4_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist11_InvExpXIsZero_uid45_fpSubTest_q_3_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist12_excI_bSig_uid42_fpSubTest_q_1_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist13_fracXIsZero_uid40_fpSubTest_q_4_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist14_expXIsMax_uid39_fpSubTest_q_4_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist15_excZ_bSig_uid18_uid38_fpSubTest_q_1_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist16_excZ_bSig_uid18_uid38_fpSubTest_q_4_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist17_excZ_bSig_uid18_uid38_fpSubTest_q_5_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist18_excI_aSig_uid28_fpSubTest_q_1_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist19_fracXIsZero_uid26_fpSubTest_q_2_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist20_excZ_aSig_uid17_uid24_fpSubTest_q_2_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist21_frac_aSig_uid23_fpSubTest_b_2_q : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal redist22_exp_aSig_uid22_fpSubTest_b_3_q : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "\n" +
                        "    -- cAmA_uid87_fpSubTest(CONSTANT,86)\n" +
                        "    cAmA_uid87_fpSubTest_q <= \"11100\";\n" +
                        "\n" +
                        "    -- zs_uid151_lzCountVal_uid86_fpSubTest(CONSTANT,150)\n" +
                        "    zs_uid151_lzCountVal_uid86_fpSubTest_q <= \"0000000000000000\";\n" +
                        "\n" +
                        "    -- sigY_uid11_fpSubTest(BITSELECT,10)@0\n" +
                        "    sigY_uid11_fpSubTest_b <= STD_LOGIC_VECTOR(b(31 downto 31));\n" +
                        "\n" +
                        "    -- invSigY_uid12_fpSubTest(LOGICAL,11)@0\n" +
                        "    invSigY_uid12_fpSubTest_q <= not (sigY_uid11_fpSubTest_b);\n" +
                        "\n" +
                        "    -- expY_uid10_fpSubTest(BITSELECT,9)@0\n" +
                        "    expY_uid10_fpSubTest_b <= b(30 downto 23);\n" +
                        "\n" +
                        "    -- fracY_uid9_fpSubTest(BITSELECT,8)@0\n" +
                        "    fracY_uid9_fpSubTest_b <= b(22 downto 0);\n" +
                        "\n" +
                        "    -- ypn_uid13_fpSubTest(BITJOIN,12)@0\n" +
                        "    ypn_uid13_fpSubTest_q <= invSigY_uid12_fpSubTest_q & expY_uid10_fpSubTest_b & fracY_uid9_fpSubTest_b;\n" +
                        "\n" +
                        "    -- GND(CONSTANT,0)\n" +
                        "    GND_q <= \"0\";\n" +
                        "\n" +
                        "    -- expFracY_uid7_fpSubTest(BITSELECT,6)@0\n" +
                        "    expFracY_uid7_fpSubTest_b <= b(30 downto 0);\n" +
                        "\n" +
                        "    -- expFracX_uid6_fpSubTest(BITSELECT,5)@0\n" +
                        "    expFracX_uid6_fpSubTest_b <= a(30 downto 0);\n" +
                        "\n" +
                        "    -- xGTEy_uid8_fpSubTest(COMPARE,7)@0\n" +
                        "    xGTEy_uid8_fpSubTest_a <= STD_LOGIC_VECTOR(\"00\" & expFracX_uid6_fpSubTest_b);\n" +
                        "    xGTEy_uid8_fpSubTest_b <= STD_LOGIC_VECTOR(\"00\" & expFracY_uid7_fpSubTest_b);\n" +
                        "    xGTEy_uid8_fpSubTest_o <= STD_LOGIC_VECTOR(UNSIGNED(xGTEy_uid8_fpSubTest_a) - UNSIGNED(xGTEy_uid8_fpSubTest_b));\n" +
                        "    xGTEy_uid8_fpSubTest_n(0) <= not (xGTEy_uid8_fpSubTest_o(32));\n" +
                        "\n" +
                        "    -- bSig_uid18_fpSubTest(MUX,17)@0\n" +
                        "    bSig_uid18_fpSubTest_s <= xGTEy_uid8_fpSubTest_n;\n" +
                        "    bSig_uid18_fpSubTest_combproc: PROCESS (bSig_uid18_fpSubTest_s, a, ypn_uid13_fpSubTest_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (bSig_uid18_fpSubTest_s) IS\n" +
                        "            WHEN \"0\" => bSig_uid18_fpSubTest_q <= a;\n" +
                        "            WHEN \"1\" => bSig_uid18_fpSubTest_q <= ypn_uid13_fpSubTest_q;\n" +
                        "            WHEN OTHERS => bSig_uid18_fpSubTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- sigB_uid52_fpSubTest(BITSELECT,51)@0\n" +
                        "    sigB_uid52_fpSubTest_b <= STD_LOGIC_VECTOR(bSig_uid18_fpSubTest_q(31 downto 31));\n" +
                        "\n" +
                        "    -- redist7_sigB_uid52_fpSubTest_b_1(DELAY,264)\n" +
                        "    redist7_sigB_uid52_fpSubTest_b_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => sigB_uid52_fpSubTest_b, xout => redist7_sigB_uid52_fpSubTest_b_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- aSig_uid17_fpSubTest(MUX,16)@0\n" +
                        "    aSig_uid17_fpSubTest_s <= xGTEy_uid8_fpSubTest_n;\n" +
                        "    aSig_uid17_fpSubTest_combproc: PROCESS (aSig_uid17_fpSubTest_s, ypn_uid13_fpSubTest_q, a)\n" +
                        "    BEGIN\n" +
                        "        CASE (aSig_uid17_fpSubTest_s) IS\n" +
                        "            WHEN \"0\" => aSig_uid17_fpSubTest_q <= ypn_uid13_fpSubTest_q;\n" +
                        "            WHEN \"1\" => aSig_uid17_fpSubTest_q <= a;\n" +
                        "            WHEN OTHERS => aSig_uid17_fpSubTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- sigA_uid51_fpSubTest(BITSELECT,50)@0\n" +
                        "    sigA_uid51_fpSubTest_b <= STD_LOGIC_VECTOR(aSig_uid17_fpSubTest_q(31 downto 31));\n" +
                        "\n" +
                        "    -- redist9_sigA_uid51_fpSubTest_b_1(DELAY,266)\n" +
                        "    redist9_sigA_uid51_fpSubTest_b_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => sigA_uid51_fpSubTest_b, xout => redist9_sigA_uid51_fpSubTest_b_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- effSub_uid53_fpSubTest(LOGICAL,52)@1 + 1\n" +
                        "    effSub_uid53_fpSubTest_qi <= redist9_sigA_uid51_fpSubTest_b_1_q xor redist7_sigB_uid52_fpSubTest_b_1_q;\n" +
                        "    effSub_uid53_fpSubTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => effSub_uid53_fpSubTest_qi, xout => effSub_uid53_fpSubTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- exp_bSig_uid36_fpSubTest(BITSELECT,35)@0\n" +
                        "    exp_bSig_uid36_fpSubTest_in <= bSig_uid18_fpSubTest_q(30 downto 0);\n" +
                        "    exp_bSig_uid36_fpSubTest_b <= exp_bSig_uid36_fpSubTest_in(30 downto 23);\n" +
                        "\n" +
                        "    -- exp_aSig_uid22_fpSubTest(BITSELECT,21)@0\n" +
                        "    exp_aSig_uid22_fpSubTest_in <= aSig_uid17_fpSubTest_q(30 downto 0);\n" +
                        "    exp_aSig_uid22_fpSubTest_b <= exp_aSig_uid22_fpSubTest_in(30 downto 23);\n" +
                        "\n" +
                        "    -- expAmExpB_uid61_fpSubTest(SUB,60)@0 + 1\n" +
                        "    expAmExpB_uid61_fpSubTest_a <= STD_LOGIC_VECTOR(\"0\" & exp_aSig_uid22_fpSubTest_b);\n" +
                        "    expAmExpB_uid61_fpSubTest_b <= STD_LOGIC_VECTOR(\"0\" & exp_bSig_uid36_fpSubTest_b);\n" +
                        "    expAmExpB_uid61_fpSubTest_clkproc: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            expAmExpB_uid61_fpSubTest_o <= (others => '0');\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            expAmExpB_uid61_fpSubTest_o <= STD_LOGIC_VECTOR(UNSIGNED(expAmExpB_uid61_fpSubTest_a) - UNSIGNED(expAmExpB_uid61_fpSubTest_b));\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "    expAmExpB_uid61_fpSubTest_q <= expAmExpB_uid61_fpSubTest_o(8 downto 0);\n" +
                        "\n" +
                        "    -- cWFP2_uid62_fpSubTest(CONSTANT,61)\n" +
                        "    cWFP2_uid62_fpSubTest_q <= \"11001\";\n" +
                        "\n" +
                        "    -- shiftedOut_uid64_fpSubTest(COMPARE,63)@1\n" +
                        "    shiftedOut_uid64_fpSubTest_a <= STD_LOGIC_VECTOR(\"000000\" & cWFP2_uid62_fpSubTest_q);\n" +
                        "    shiftedOut_uid64_fpSubTest_b <= STD_LOGIC_VECTOR(\"00\" & expAmExpB_uid61_fpSubTest_q);\n" +
                        "    shiftedOut_uid64_fpSubTest_o <= STD_LOGIC_VECTOR(UNSIGNED(shiftedOut_uid64_fpSubTest_a) - UNSIGNED(shiftedOut_uid64_fpSubTest_b));\n" +
                        "    shiftedOut_uid64_fpSubTest_c(0) <= shiftedOut_uid64_fpSubTest_o(10);\n" +
                        "\n" +
                        "    -- iShiftedOut_uid68_fpSubTest(LOGICAL,67)@1\n" +
                        "    iShiftedOut_uid68_fpSubTest_q <= not (shiftedOut_uid64_fpSubTest_c);\n" +
                        "\n" +
                        "    -- zeroOutCst_uid219_alignmentShifter_uid65_fpSubTest(CONSTANT,218)\n" +
                        "    zeroOutCst_uid219_alignmentShifter_uid65_fpSubTest_q <= \"0000000000000000000000000000000000000000000000000\";\n" +
                        "\n" +
                        "    -- rightShiftStage2Idx3Pad3_uid215_alignmentShifter_uid65_fpSubTest(CONSTANT,214)\n" +
                        "    rightShiftStage2Idx3Pad3_uid215_alignmentShifter_uid65_fpSubTest_q <= \"000\";\n" +
                        "\n" +
                        "    -- rightShiftStage2Idx3Rng3_uid214_alignmentShifter_uid65_fpSubTest(BITSELECT,213)@1\n" +
                        "    rightShiftStage2Idx3Rng3_uid214_alignmentShifter_uid65_fpSubTest_b <= rightShiftStage1_uid207_alignmentShifter_uid65_fpSubTest_q(48 downto 3);\n" +
                        "\n" +
                        "    -- rightShiftStage2Idx3_uid216_alignmentShifter_uid65_fpSubTest(BITJOIN,215)@1\n" +
                        "    rightShiftStage2Idx3_uid216_alignmentShifter_uid65_fpSubTest_q <= rightShiftStage2Idx3Pad3_uid215_alignmentShifter_uid65_fpSubTest_q & rightShiftStage2Idx3Rng3_uid214_alignmentShifter_uid65_fpSubTest_b;\n" +
                        "\n" +
                        "    -- zs_uid171_lzCountVal_uid86_fpSubTest(CONSTANT,170)\n" +
                        "    zs_uid171_lzCountVal_uid86_fpSubTest_q <= \"00\";\n" +
                        "\n" +
                        "    -- rightShiftStage2Idx2Rng2_uid211_alignmentShifter_uid65_fpSubTest(BITSELECT,210)@1\n" +
                        "    rightShiftStage2Idx2Rng2_uid211_alignmentShifter_uid65_fpSubTest_b <= rightShiftStage1_uid207_alignmentShifter_uid65_fpSubTest_q(48 downto 2);\n" +
                        "\n" +
                        "    -- rightShiftStage2Idx2_uid213_alignmentShifter_uid65_fpSubTest(BITJOIN,212)@1\n" +
                        "    rightShiftStage2Idx2_uid213_alignmentShifter_uid65_fpSubTest_q <= zs_uid171_lzCountVal_uid86_fpSubTest_q & rightShiftStage2Idx2Rng2_uid211_alignmentShifter_uid65_fpSubTest_b;\n" +
                        "\n" +
                        "    -- rightShiftStage2Idx1Rng1_uid208_alignmentShifter_uid65_fpSubTest(BITSELECT,207)@1\n" +
                        "    rightShiftStage2Idx1Rng1_uid208_alignmentShifter_uid65_fpSubTest_b <= rightShiftStage1_uid207_alignmentShifter_uid65_fpSubTest_q(48 downto 1);\n" +
                        "\n" +
                        "    -- rightShiftStage2Idx1_uid210_alignmentShifter_uid65_fpSubTest(BITJOIN,209)@1\n" +
                        "    rightShiftStage2Idx1_uid210_alignmentShifter_uid65_fpSubTest_q <= GND_q & rightShiftStage2Idx1Rng1_uid208_alignmentShifter_uid65_fpSubTest_b;\n" +
                        "\n" +
                        "    -- rightShiftStage1Idx3Pad12_uid204_alignmentShifter_uid65_fpSubTest(CONSTANT,203)\n" +
                        "    rightShiftStage1Idx3Pad12_uid204_alignmentShifter_uid65_fpSubTest_q <= \"000000000000\";\n" +
                        "\n" +
                        "    -- rightShiftStage1Idx3Rng12_uid203_alignmentShifter_uid65_fpSubTest(BITSELECT,202)@1\n" +
                        "    rightShiftStage1Idx3Rng12_uid203_alignmentShifter_uid65_fpSubTest_b <= rightShiftStage0_uid196_alignmentShifter_uid65_fpSubTest_q(48 downto 12);\n" +
                        "\n" +
                        "    -- rightShiftStage1Idx3_uid205_alignmentShifter_uid65_fpSubTest(BITJOIN,204)@1\n" +
                        "    rightShiftStage1Idx3_uid205_alignmentShifter_uid65_fpSubTest_q <= rightShiftStage1Idx3Pad12_uid204_alignmentShifter_uid65_fpSubTest_q & rightShiftStage1Idx3Rng12_uid203_alignmentShifter_uid65_fpSubTest_b;\n" +
                        "\n" +
                        "    -- cstAllZWE_uid21_fpSubTest(CONSTANT,20)\n" +
                        "    cstAllZWE_uid21_fpSubTest_q <= \"00000000\";\n" +
                        "\n" +
                        "    -- rightShiftStage1Idx2Rng8_uid200_alignmentShifter_uid65_fpSubTest(BITSELECT,199)@1\n" +
                        "    rightShiftStage1Idx2Rng8_uid200_alignmentShifter_uid65_fpSubTest_b <= rightShiftStage0_uid196_alignmentShifter_uid65_fpSubTest_q(48 downto 8);\n" +
                        "\n" +
                        "    -- rightShiftStage1Idx2_uid202_alignmentShifter_uid65_fpSubTest(BITJOIN,201)@1\n" +
                        "    rightShiftStage1Idx2_uid202_alignmentShifter_uid65_fpSubTest_q <= cstAllZWE_uid21_fpSubTest_q & rightShiftStage1Idx2Rng8_uid200_alignmentShifter_uid65_fpSubTest_b;\n" +
                        "\n" +
                        "    -- zs_uid165_lzCountVal_uid86_fpSubTest(CONSTANT,164)\n" +
                        "    zs_uid165_lzCountVal_uid86_fpSubTest_q <= \"0000\";\n" +
                        "\n" +
                        "    -- rightShiftStage1Idx1Rng4_uid197_alignmentShifter_uid65_fpSubTest(BITSELECT,196)@1\n" +
                        "    rightShiftStage1Idx1Rng4_uid197_alignmentShifter_uid65_fpSubTest_b <= rightShiftStage0_uid196_alignmentShifter_uid65_fpSubTest_q(48 downto 4);\n" +
                        "\n" +
                        "    -- rightShiftStage1Idx1_uid199_alignmentShifter_uid65_fpSubTest(BITJOIN,198)@1\n" +
                        "    rightShiftStage1Idx1_uid199_alignmentShifter_uid65_fpSubTest_q <= zs_uid165_lzCountVal_uid86_fpSubTest_q & rightShiftStage1Idx1Rng4_uid197_alignmentShifter_uid65_fpSubTest_b;\n" +
                        "\n" +
                        "    -- rightShiftStage0Idx3Pad48_uid193_alignmentShifter_uid65_fpSubTest(CONSTANT,192)\n" +
                        "    rightShiftStage0Idx3Pad48_uid193_alignmentShifter_uid65_fpSubTest_q <= \"000000000000000000000000000000000000000000000000\";\n" +
                        "\n" +
                        "    -- rightShiftStage0Idx3Rng48_uid192_alignmentShifter_uid65_fpSubTest(BITSELECT,191)@1\n" +
                        "    rightShiftStage0Idx3Rng48_uid192_alignmentShifter_uid65_fpSubTest_b <= rightPaddedIn_uid66_fpSubTest_q(48 downto 48);\n" +
                        "\n" +
                        "    -- rightShiftStage0Idx3_uid194_alignmentShifter_uid65_fpSubTest(BITJOIN,193)@1\n" +
                        "    rightShiftStage0Idx3_uid194_alignmentShifter_uid65_fpSubTest_q <= rightShiftStage0Idx3Pad48_uid193_alignmentShifter_uid65_fpSubTest_q & rightShiftStage0Idx3Rng48_uid192_alignmentShifter_uid65_fpSubTest_b;\n" +
                        "\n" +
                        "    -- rightShiftStage0Idx2Pad32_uid190_alignmentShifter_uid65_fpSubTest(CONSTANT,189)\n" +
                        "    rightShiftStage0Idx2Pad32_uid190_alignmentShifter_uid65_fpSubTest_q <= \"00000000000000000000000000000000\";\n" +
                        "\n" +
                        "    -- rightShiftStage0Idx2Rng32_uid189_alignmentShifter_uid65_fpSubTest(BITSELECT,188)@1\n" +
                        "    rightShiftStage0Idx2Rng32_uid189_alignmentShifter_uid65_fpSubTest_b <= rightPaddedIn_uid66_fpSubTest_q(48 downto 32);\n" +
                        "\n" +
                        "    -- rightShiftStage0Idx2_uid191_alignmentShifter_uid65_fpSubTest(BITJOIN,190)@1\n" +
                        "    rightShiftStage0Idx2_uid191_alignmentShifter_uid65_fpSubTest_q <= rightShiftStage0Idx2Pad32_uid190_alignmentShifter_uid65_fpSubTest_q & rightShiftStage0Idx2Rng32_uid189_alignmentShifter_uid65_fpSubTest_b;\n" +
                        "\n" +
                        "    -- rightShiftStage0Idx1Rng16_uid186_alignmentShifter_uid65_fpSubTest(BITSELECT,185)@1\n" +
                        "    rightShiftStage0Idx1Rng16_uid186_alignmentShifter_uid65_fpSubTest_b <= rightPaddedIn_uid66_fpSubTest_q(48 downto 16);\n" +
                        "\n" +
                        "    -- rightShiftStage0Idx1_uid188_alignmentShifter_uid65_fpSubTest(BITJOIN,187)@1\n" +
                        "    rightShiftStage0Idx1_uid188_alignmentShifter_uid65_fpSubTest_q <= zs_uid151_lzCountVal_uid86_fpSubTest_q & rightShiftStage0Idx1Rng16_uid186_alignmentShifter_uid65_fpSubTest_b;\n" +
                        "\n" +
                        "    -- excZ_bSig_uid18_uid38_fpSubTest(LOGICAL,37)@0\n" +
                        "    excZ_bSig_uid18_uid38_fpSubTest_q <= \"1\" WHEN exp_bSig_uid36_fpSubTest_b = cstAllZWE_uid21_fpSubTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- redist15_excZ_bSig_uid18_uid38_fpSubTest_q_1(DELAY,272)\n" +
                        "    redist15_excZ_bSig_uid18_uid38_fpSubTest_q_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => excZ_bSig_uid18_uid38_fpSubTest_q, xout => redist15_excZ_bSig_uid18_uid38_fpSubTest_q_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- InvExpXIsZero_uid45_fpSubTest(LOGICAL,44)@1\n" +
                        "    InvExpXIsZero_uid45_fpSubTest_q <= not (redist15_excZ_bSig_uid18_uid38_fpSubTest_q_1_q);\n" +
                        "\n" +
                        "    -- cstZeroWF_uid20_fpSubTest(CONSTANT,19)\n" +
                        "    cstZeroWF_uid20_fpSubTest_q <= \"00000000000000000000000\";\n" +
                        "\n" +
                        "    -- frac_bSig_uid37_fpSubTest(BITSELECT,36)@0\n" +
                        "    frac_bSig_uid37_fpSubTest_in <= bSig_uid18_fpSubTest_q(22 downto 0);\n" +
                        "    frac_bSig_uid37_fpSubTest_b <= frac_bSig_uid37_fpSubTest_in(22 downto 0);\n" +
                        "\n" +
                        "    -- fracBz_uid57_fpSubTest(MUX,56)@0 + 1\n" +
                        "    fracBz_uid57_fpSubTest_s <= excZ_bSig_uid18_uid38_fpSubTest_q;\n" +
                        "    fracBz_uid57_fpSubTest_clkproc: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            fracBz_uid57_fpSubTest_q <= (others => '0');\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            CASE (fracBz_uid57_fpSubTest_s) IS\n" +
                        "                WHEN \"0\" => fracBz_uid57_fpSubTest_q <= frac_bSig_uid37_fpSubTest_b;\n" +
                        "                WHEN \"1\" => fracBz_uid57_fpSubTest_q <= cstZeroWF_uid20_fpSubTest_q;\n" +
                        "                WHEN OTHERS => fracBz_uid57_fpSubTest_q <= (others => '0');\n" +
                        "            END CASE;\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- oFracB_uid60_fpSubTest(BITJOIN,59)@1\n" +
                        "    oFracB_uid60_fpSubTest_q <= InvExpXIsZero_uid45_fpSubTest_q & fracBz_uid57_fpSubTest_q;\n" +
                        "\n" +
                        "    -- padConst_uid65_fpSubTest(CONSTANT,64)\n" +
                        "    padConst_uid65_fpSubTest_q <= \"0000000000000000000000000\";\n" +
                        "\n" +
                        "    -- rightPaddedIn_uid66_fpSubTest(BITJOIN,65)@1\n" +
                        "    rightPaddedIn_uid66_fpSubTest_q <= oFracB_uid60_fpSubTest_q & padConst_uid65_fpSubTest_q;\n" +
                        "\n" +
                        "    -- rightShiftStage0_uid196_alignmentShifter_uid65_fpSubTest(MUX,195)@1\n" +
                        "    rightShiftStage0_uid196_alignmentShifter_uid65_fpSubTest_s <= rightShiftStageSel5Dto4_uid195_alignmentShifter_uid65_fpSubTest_merged_bit_select_b;\n" +
                        "    rightShiftStage0_uid196_alignmentShifter_uid65_fpSubTest_combproc: PROCESS (rightShiftStage0_uid196_alignmentShifter_uid65_fpSubTest_s, rightPaddedIn_uid66_fpSubTest_q, rightShiftStage0Idx1_uid188_alignmentShifter_uid65_fpSubTest_q, rightShiftStage0Idx2_uid191_alignmentShifter_uid65_fpSubTest_q, rightShiftStage0Idx3_uid194_alignmentShifter_uid65_fpSubTest_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (rightShiftStage0_uid196_alignmentShifter_uid65_fpSubTest_s) IS\n" +
                        "            WHEN \"00\" => rightShiftStage0_uid196_alignmentShifter_uid65_fpSubTest_q <= rightPaddedIn_uid66_fpSubTest_q;\n" +
                        "            WHEN \"01\" => rightShiftStage0_uid196_alignmentShifter_uid65_fpSubTest_q <= rightShiftStage0Idx1_uid188_alignmentShifter_uid65_fpSubTest_q;\n" +
                        "            WHEN \"10\" => rightShiftStage0_uid196_alignmentShifter_uid65_fpSubTest_q <= rightShiftStage0Idx2_uid191_alignmentShifter_uid65_fpSubTest_q;\n" +
                        "            WHEN \"11\" => rightShiftStage0_uid196_alignmentShifter_uid65_fpSubTest_q <= rightShiftStage0Idx3_uid194_alignmentShifter_uid65_fpSubTest_q;\n" +
                        "            WHEN OTHERS => rightShiftStage0_uid196_alignmentShifter_uid65_fpSubTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- rightShiftStage1_uid207_alignmentShifter_uid65_fpSubTest(MUX,206)@1\n" +
                        "    rightShiftStage1_uid207_alignmentShifter_uid65_fpSubTest_s <= rightShiftStageSel5Dto4_uid195_alignmentShifter_uid65_fpSubTest_merged_bit_select_c;\n" +
                        "    rightShiftStage1_uid207_alignmentShifter_uid65_fpSubTest_combproc: PROCESS (rightShiftStage1_uid207_alignmentShifter_uid65_fpSubTest_s, rightShiftStage0_uid196_alignmentShifter_uid65_fpSubTest_q, rightShiftStage1Idx1_uid199_alignmentShifter_uid65_fpSubTest_q, rightShiftStage1Idx2_uid202_alignmentShifter_uid65_fpSubTest_q, rightShiftStage1Idx3_uid205_alignmentShifter_uid65_fpSubTest_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (rightShiftStage1_uid207_alignmentShifter_uid65_fpSubTest_s) IS\n" +
                        "            WHEN \"00\" => rightShiftStage1_uid207_alignmentShifter_uid65_fpSubTest_q <= rightShiftStage0_uid196_alignmentShifter_uid65_fpSubTest_q;\n" +
                        "            WHEN \"01\" => rightShiftStage1_uid207_alignmentShifter_uid65_fpSubTest_q <= rightShiftStage1Idx1_uid199_alignmentShifter_uid65_fpSubTest_q;\n" +
                        "            WHEN \"10\" => rightShiftStage1_uid207_alignmentShifter_uid65_fpSubTest_q <= rightShiftStage1Idx2_uid202_alignmentShifter_uid65_fpSubTest_q;\n" +
                        "            WHEN \"11\" => rightShiftStage1_uid207_alignmentShifter_uid65_fpSubTest_q <= rightShiftStage1Idx3_uid205_alignmentShifter_uid65_fpSubTest_q;\n" +
                        "            WHEN OTHERS => rightShiftStage1_uid207_alignmentShifter_uid65_fpSubTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- rightShiftStageSel5Dto4_uid195_alignmentShifter_uid65_fpSubTest_merged_bit_select(BITSELECT,251)@1\n" +
                        "    rightShiftStageSel5Dto4_uid195_alignmentShifter_uid65_fpSubTest_merged_bit_select_in <= expAmExpB_uid61_fpSubTest_q(5 downto 0);\n" +
                        "    rightShiftStageSel5Dto4_uid195_alignmentShifter_uid65_fpSubTest_merged_bit_select_b <= rightShiftStageSel5Dto4_uid195_alignmentShifter_uid65_fpSubTest_merged_bit_select_in(5 downto 4);\n" +
                        "    rightShiftStageSel5Dto4_uid195_alignmentShifter_uid65_fpSubTest_merged_bit_select_c <= rightShiftStageSel5Dto4_uid195_alignmentShifter_uid65_fpSubTest_merged_bit_select_in(3 downto 2);\n" +
                        "    rightShiftStageSel5Dto4_uid195_alignmentShifter_uid65_fpSubTest_merged_bit_select_d <= rightShiftStageSel5Dto4_uid195_alignmentShifter_uid65_fpSubTest_merged_bit_select_in(1 downto 0);\n" +
                        "\n" +
                        "    -- rightShiftStage2_uid218_alignmentShifter_uid65_fpSubTest(MUX,217)@1\n" +
                        "    rightShiftStage2_uid218_alignmentShifter_uid65_fpSubTest_s <= rightShiftStageSel5Dto4_uid195_alignmentShifter_uid65_fpSubTest_merged_bit_select_d;\n" +
                        "    rightShiftStage2_uid218_alignmentShifter_uid65_fpSubTest_combproc: PROCESS (rightShiftStage2_uid218_alignmentShifter_uid65_fpSubTest_s, rightShiftStage1_uid207_alignmentShifter_uid65_fpSubTest_q, rightShiftStage2Idx1_uid210_alignmentShifter_uid65_fpSubTest_q, rightShiftStage2Idx2_uid213_alignmentShifter_uid65_fpSubTest_q, rightShiftStage2Idx3_uid216_alignmentShifter_uid65_fpSubTest_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (rightShiftStage2_uid218_alignmentShifter_uid65_fpSubTest_s) IS\n" +
                        "            WHEN \"00\" => rightShiftStage2_uid218_alignmentShifter_uid65_fpSubTest_q <= rightShiftStage1_uid207_alignmentShifter_uid65_fpSubTest_q;\n" +
                        "            WHEN \"01\" => rightShiftStage2_uid218_alignmentShifter_uid65_fpSubTest_q <= rightShiftStage2Idx1_uid210_alignmentShifter_uid65_fpSubTest_q;\n" +
                        "            WHEN \"10\" => rightShiftStage2_uid218_alignmentShifter_uid65_fpSubTest_q <= rightShiftStage2Idx2_uid213_alignmentShifter_uid65_fpSubTest_q;\n" +
                        "            WHEN \"11\" => rightShiftStage2_uid218_alignmentShifter_uid65_fpSubTest_q <= rightShiftStage2Idx3_uid216_alignmentShifter_uid65_fpSubTest_q;\n" +
                        "            WHEN OTHERS => rightShiftStage2_uid218_alignmentShifter_uid65_fpSubTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- wIntCst_uid184_alignmentShifter_uid65_fpSubTest(CONSTANT,183)\n" +
                        "    wIntCst_uid184_alignmentShifter_uid65_fpSubTest_q <= \"110001\";\n" +
                        "\n" +
                        "    -- shiftedOut_uid185_alignmentShifter_uid65_fpSubTest(COMPARE,184)@1\n" +
                        "    shiftedOut_uid185_alignmentShifter_uid65_fpSubTest_a <= STD_LOGIC_VECTOR(\"00\" & expAmExpB_uid61_fpSubTest_q);\n" +
                        "    shiftedOut_uid185_alignmentShifter_uid65_fpSubTest_b <= STD_LOGIC_VECTOR(\"00000\" & wIntCst_uid184_alignmentShifter_uid65_fpSubTest_q);\n" +
                        "    shiftedOut_uid185_alignmentShifter_uid65_fpSubTest_o <= STD_LOGIC_VECTOR(UNSIGNED(shiftedOut_uid185_alignmentShifter_uid65_fpSubTest_a) - UNSIGNED(shiftedOut_uid185_alignmentShifter_uid65_fpSubTest_b));\n" +
                        "    shiftedOut_uid185_alignmentShifter_uid65_fpSubTest_n(0) <= not (shiftedOut_uid185_alignmentShifter_uid65_fpSubTest_o(10));\n" +
                        "\n" +
                        "    -- r_uid220_alignmentShifter_uid65_fpSubTest(MUX,219)@1\n" +
                        "    r_uid220_alignmentShifter_uid65_fpSubTest_s <= shiftedOut_uid185_alignmentShifter_uid65_fpSubTest_n;\n" +
                        "    r_uid220_alignmentShifter_uid65_fpSubTest_combproc: PROCESS (r_uid220_alignmentShifter_uid65_fpSubTest_s, rightShiftStage2_uid218_alignmentShifter_uid65_fpSubTest_q, zeroOutCst_uid219_alignmentShifter_uid65_fpSubTest_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (r_uid220_alignmentShifter_uid65_fpSubTest_s) IS\n" +
                        "            WHEN \"0\" => r_uid220_alignmentShifter_uid65_fpSubTest_q <= rightShiftStage2_uid218_alignmentShifter_uid65_fpSubTest_q;\n" +
                        "            WHEN \"1\" => r_uid220_alignmentShifter_uid65_fpSubTest_q <= zeroOutCst_uid219_alignmentShifter_uid65_fpSubTest_q;\n" +
                        "            WHEN OTHERS => r_uid220_alignmentShifter_uid65_fpSubTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- alignFracBPostShiftOut_uid69_fpSubTest(LOGICAL,68)@1\n" +
                        "    alignFracBPostShiftOut_uid69_fpSubTest_b <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR((48 downto 1 => iShiftedOut_uid68_fpSubTest_q(0)) & iShiftedOut_uid68_fpSubTest_q));\n" +
                        "    alignFracBPostShiftOut_uid69_fpSubTest_q <= r_uid220_alignmentShifter_uid65_fpSubTest_q and alignFracBPostShiftOut_uid69_fpSubTest_b;\n" +
                        "\n" +
                        "    -- stickyBits_uid70_fpSubTest_merged_bit_select(BITSELECT,252)@1\n" +
                        "    stickyBits_uid70_fpSubTest_merged_bit_select_b <= alignFracBPostShiftOut_uid69_fpSubTest_q(22 downto 0);\n" +
                        "    stickyBits_uid70_fpSubTest_merged_bit_select_c <= alignFracBPostShiftOut_uid69_fpSubTest_q(48 downto 23);\n" +
                        "\n" +
                        "    -- redist0_stickyBits_uid70_fpSubTest_merged_bit_select_c_1(DELAY,257)\n" +
                        "    redist0_stickyBits_uid70_fpSubTest_merged_bit_select_c_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 26, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => stickyBits_uid70_fpSubTest_merged_bit_select_c, xout => redist0_stickyBits_uid70_fpSubTest_merged_bit_select_c_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- fracBAddOp_uid81_fpSubTest(BITJOIN,80)@2\n" +
                        "    fracBAddOp_uid81_fpSubTest_q <= GND_q & redist0_stickyBits_uid70_fpSubTest_merged_bit_select_c_1_q;\n" +
                        "\n" +
                        "    -- fracBAddOpPostXor_uid82_fpSubTest(LOGICAL,81)@2\n" +
                        "    fracBAddOpPostXor_uid82_fpSubTest_b <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR((26 downto 1 => effSub_uid53_fpSubTest_q(0)) & effSub_uid53_fpSubTest_q));\n" +
                        "    fracBAddOpPostXor_uid82_fpSubTest_q <= fracBAddOp_uid81_fpSubTest_q xor fracBAddOpPostXor_uid82_fpSubTest_b;\n" +
                        "\n" +
                        "    -- zocst_uid77_fpSubTest(CONSTANT,76)\n" +
                        "    zocst_uid77_fpSubTest_q <= \"01\";\n" +
                        "\n" +
                        "    -- frac_aSig_uid23_fpSubTest(BITSELECT,22)@0\n" +
                        "    frac_aSig_uid23_fpSubTest_in <= aSig_uid17_fpSubTest_q(22 downto 0);\n" +
                        "    frac_aSig_uid23_fpSubTest_b <= frac_aSig_uid23_fpSubTest_in(22 downto 0);\n" +
                        "\n" +
                        "    -- redist21_frac_aSig_uid23_fpSubTest_b_2(DELAY,278)\n" +
                        "    redist21_frac_aSig_uid23_fpSubTest_b_2 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 23, depth => 2, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => frac_aSig_uid23_fpSubTest_b, xout => redist21_frac_aSig_uid23_fpSubTest_b_2_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- cmpEQ_stickyBits_cZwF_uid72_fpSubTest(LOGICAL,71)@1 + 1\n" +
                        "    cmpEQ_stickyBits_cZwF_uid72_fpSubTest_qi <= \"1\" WHEN stickyBits_uid70_fpSubTest_merged_bit_select_b = cstZeroWF_uid20_fpSubTest_q ELSE \"0\";\n" +
                        "    cmpEQ_stickyBits_cZwF_uid72_fpSubTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => cmpEQ_stickyBits_cZwF_uid72_fpSubTest_qi, xout => cmpEQ_stickyBits_cZwF_uid72_fpSubTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- effSubInvSticky_uid75_fpSubTest(LOGICAL,74)@2\n" +
                        "    effSubInvSticky_uid75_fpSubTest_q <= effSub_uid53_fpSubTest_q and cmpEQ_stickyBits_cZwF_uid72_fpSubTest_q;\n" +
                        "\n" +
                        "    -- fracAAddOp_uid78_fpSubTest(BITJOIN,77)@2\n" +
                        "    fracAAddOp_uid78_fpSubTest_q <= zocst_uid77_fpSubTest_q & redist21_frac_aSig_uid23_fpSubTest_b_2_q & GND_q & effSubInvSticky_uid75_fpSubTest_q;\n" +
                        "\n" +
                        "    -- fracAddResult_uid83_fpSubTest(ADD,82)@2\n" +
                        "    fracAddResult_uid83_fpSubTest_a <= STD_LOGIC_VECTOR(\"0\" & fracAAddOp_uid78_fpSubTest_q);\n" +
                        "    fracAddResult_uid83_fpSubTest_b <= STD_LOGIC_VECTOR(\"0\" & fracBAddOpPostXor_uid82_fpSubTest_q);\n" +
                        "    fracAddResult_uid83_fpSubTest_o <= STD_LOGIC_VECTOR(UNSIGNED(fracAddResult_uid83_fpSubTest_a) + UNSIGNED(fracAddResult_uid83_fpSubTest_b));\n" +
                        "    fracAddResult_uid83_fpSubTest_q <= fracAddResult_uid83_fpSubTest_o(27 downto 0);\n" +
                        "\n" +
                        "    -- rangeFracAddResultMwfp3Dto0_uid84_fpSubTest(BITSELECT,83)@2\n" +
                        "    rangeFracAddResultMwfp3Dto0_uid84_fpSubTest_in <= fracAddResult_uid83_fpSubTest_q(26 downto 0);\n" +
                        "    rangeFracAddResultMwfp3Dto0_uid84_fpSubTest_b <= rangeFracAddResultMwfp3Dto0_uid84_fpSubTest_in(26 downto 0);\n" +
                        "\n" +
                        "    -- invCmpEQ_stickyBits_cZwF_uid73_fpSubTest(LOGICAL,72)@2\n" +
                        "    invCmpEQ_stickyBits_cZwF_uid73_fpSubTest_q <= not (cmpEQ_stickyBits_cZwF_uid72_fpSubTest_q);\n" +
                        "\n" +
                        "    -- fracGRS_uid85_fpSubTest(BITJOIN,84)@2\n" +
                        "    fracGRS_uid85_fpSubTest_q <= rangeFracAddResultMwfp3Dto0_uid84_fpSubTest_b & invCmpEQ_stickyBits_cZwF_uid73_fpSubTest_q;\n" +
                        "\n" +
                        "    -- rVStage_uid152_lzCountVal_uid86_fpSubTest(BITSELECT,151)@2\n" +
                        "    rVStage_uid152_lzCountVal_uid86_fpSubTest_b <= fracGRS_uid85_fpSubTest_q(27 downto 12);\n" +
                        "\n" +
                        "    -- vCount_uid153_lzCountVal_uid86_fpSubTest(LOGICAL,152)@2\n" +
                        "    vCount_uid153_lzCountVal_uid86_fpSubTest_q <= \"1\" WHEN rVStage_uid152_lzCountVal_uid86_fpSubTest_b = zs_uid151_lzCountVal_uid86_fpSubTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- redist3_vCount_uid153_lzCountVal_uid86_fpSubTest_q_1(DELAY,260)\n" +
                        "    redist3_vCount_uid153_lzCountVal_uid86_fpSubTest_q_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => vCount_uid153_lzCountVal_uid86_fpSubTest_q, xout => redist3_vCount_uid153_lzCountVal_uid86_fpSubTest_q_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- vStage_uid155_lzCountVal_uid86_fpSubTest(BITSELECT,154)@2\n" +
                        "    vStage_uid155_lzCountVal_uid86_fpSubTest_in <= fracGRS_uid85_fpSubTest_q(11 downto 0);\n" +
                        "    vStage_uid155_lzCountVal_uid86_fpSubTest_b <= vStage_uid155_lzCountVal_uid86_fpSubTest_in(11 downto 0);\n" +
                        "\n" +
                        "    -- mO_uid154_lzCountVal_uid86_fpSubTest(CONSTANT,153)\n" +
                        "    mO_uid154_lzCountVal_uid86_fpSubTest_q <= \"1111\";\n" +
                        "\n" +
                        "    -- cStage_uid156_lzCountVal_uid86_fpSubTest(BITJOIN,155)@2\n" +
                        "    cStage_uid156_lzCountVal_uid86_fpSubTest_q <= vStage_uid155_lzCountVal_uid86_fpSubTest_b & mO_uid154_lzCountVal_uid86_fpSubTest_q;\n" +
                        "\n" +
                        "    -- vStagei_uid158_lzCountVal_uid86_fpSubTest(MUX,157)@2 + 1\n" +
                        "    vStagei_uid158_lzCountVal_uid86_fpSubTest_s <= vCount_uid153_lzCountVal_uid86_fpSubTest_q;\n" +
                        "    vStagei_uid158_lzCountVal_uid86_fpSubTest_clkproc: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            vStagei_uid158_lzCountVal_uid86_fpSubTest_q <= (others => '0');\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            CASE (vStagei_uid158_lzCountVal_uid86_fpSubTest_s) IS\n" +
                        "                WHEN \"0\" => vStagei_uid158_lzCountVal_uid86_fpSubTest_q <= rVStage_uid152_lzCountVal_uid86_fpSubTest_b;\n" +
                        "                WHEN \"1\" => vStagei_uid158_lzCountVal_uid86_fpSubTest_q <= cStage_uid156_lzCountVal_uid86_fpSubTest_q;\n" +
                        "                WHEN OTHERS => vStagei_uid158_lzCountVal_uid86_fpSubTest_q <= (others => '0');\n" +
                        "            END CASE;\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- rVStage_uid160_lzCountVal_uid86_fpSubTest_merged_bit_select(BITSELECT,253)@3\n" +
                        "    rVStage_uid160_lzCountVal_uid86_fpSubTest_merged_bit_select_b <= vStagei_uid158_lzCountVal_uid86_fpSubTest_q(15 downto 8);\n" +
                        "    rVStage_uid160_lzCountVal_uid86_fpSubTest_merged_bit_select_c <= vStagei_uid158_lzCountVal_uid86_fpSubTest_q(7 downto 0);\n" +
                        "\n" +
                        "    -- vCount_uid161_lzCountVal_uid86_fpSubTest(LOGICAL,160)@3\n" +
                        "    vCount_uid161_lzCountVal_uid86_fpSubTest_q <= \"1\" WHEN rVStage_uid160_lzCountVal_uid86_fpSubTest_merged_bit_select_b = cstAllZWE_uid21_fpSubTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- vStagei_uid164_lzCountVal_uid86_fpSubTest(MUX,163)@3\n" +
                        "    vStagei_uid164_lzCountVal_uid86_fpSubTest_s <= vCount_uid161_lzCountVal_uid86_fpSubTest_q;\n" +
                        "    vStagei_uid164_lzCountVal_uid86_fpSubTest_combproc: PROCESS (vStagei_uid164_lzCountVal_uid86_fpSubTest_s, rVStage_uid160_lzCountVal_uid86_fpSubTest_merged_bit_select_b, rVStage_uid160_lzCountVal_uid86_fpSubTest_merged_bit_select_c)\n" +
                        "    BEGIN\n" +
                        "        CASE (vStagei_uid164_lzCountVal_uid86_fpSubTest_s) IS\n" +
                        "            WHEN \"0\" => vStagei_uid164_lzCountVal_uid86_fpSubTest_q <= rVStage_uid160_lzCountVal_uid86_fpSubTest_merged_bit_select_b;\n" +
                        "            WHEN \"1\" => vStagei_uid164_lzCountVal_uid86_fpSubTest_q <= rVStage_uid160_lzCountVal_uid86_fpSubTest_merged_bit_select_c;\n" +
                        "            WHEN OTHERS => vStagei_uid164_lzCountVal_uid86_fpSubTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- rVStage_uid166_lzCountVal_uid86_fpSubTest_merged_bit_select(BITSELECT,254)@3\n" +
                        "    rVStage_uid166_lzCountVal_uid86_fpSubTest_merged_bit_select_b <= vStagei_uid164_lzCountVal_uid86_fpSubTest_q(7 downto 4);\n" +
                        "    rVStage_uid166_lzCountVal_uid86_fpSubTest_merged_bit_select_c <= vStagei_uid164_lzCountVal_uid86_fpSubTest_q(3 downto 0);\n" +
                        "\n" +
                        "    -- vCount_uid167_lzCountVal_uid86_fpSubTest(LOGICAL,166)@3\n" +
                        "    vCount_uid167_lzCountVal_uid86_fpSubTest_q <= \"1\" WHEN rVStage_uid166_lzCountVal_uid86_fpSubTest_merged_bit_select_b = zs_uid165_lzCountVal_uid86_fpSubTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- vStagei_uid170_lzCountVal_uid86_fpSubTest(MUX,169)@3\n" +
                        "    vStagei_uid170_lzCountVal_uid86_fpSubTest_s <= vCount_uid167_lzCountVal_uid86_fpSubTest_q;\n" +
                        "    vStagei_uid170_lzCountVal_uid86_fpSubTest_combproc: PROCESS (vStagei_uid170_lzCountVal_uid86_fpSubTest_s, rVStage_uid166_lzCountVal_uid86_fpSubTest_merged_bit_select_b, rVStage_uid166_lzCountVal_uid86_fpSubTest_merged_bit_select_c)\n" +
                        "    BEGIN\n" +
                        "        CASE (vStagei_uid170_lzCountVal_uid86_fpSubTest_s) IS\n" +
                        "            WHEN \"0\" => vStagei_uid170_lzCountVal_uid86_fpSubTest_q <= rVStage_uid166_lzCountVal_uid86_fpSubTest_merged_bit_select_b;\n" +
                        "            WHEN \"1\" => vStagei_uid170_lzCountVal_uid86_fpSubTest_q <= rVStage_uid166_lzCountVal_uid86_fpSubTest_merged_bit_select_c;\n" +
                        "            WHEN OTHERS => vStagei_uid170_lzCountVal_uid86_fpSubTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- rVStage_uid172_lzCountVal_uid86_fpSubTest_merged_bit_select(BITSELECT,255)@3\n" +
                        "    rVStage_uid172_lzCountVal_uid86_fpSubTest_merged_bit_select_b <= vStagei_uid170_lzCountVal_uid86_fpSubTest_q(3 downto 2);\n" +
                        "    rVStage_uid172_lzCountVal_uid86_fpSubTest_merged_bit_select_c <= vStagei_uid170_lzCountVal_uid86_fpSubTest_q(1 downto 0);\n" +
                        "\n" +
                        "    -- vCount_uid173_lzCountVal_uid86_fpSubTest(LOGICAL,172)@3\n" +
                        "    vCount_uid173_lzCountVal_uid86_fpSubTest_q <= \"1\" WHEN rVStage_uid172_lzCountVal_uid86_fpSubTest_merged_bit_select_b = zs_uid171_lzCountVal_uid86_fpSubTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- vStagei_uid176_lzCountVal_uid86_fpSubTest(MUX,175)@3\n" +
                        "    vStagei_uid176_lzCountVal_uid86_fpSubTest_s <= vCount_uid173_lzCountVal_uid86_fpSubTest_q;\n" +
                        "    vStagei_uid176_lzCountVal_uid86_fpSubTest_combproc: PROCESS (vStagei_uid176_lzCountVal_uid86_fpSubTest_s, rVStage_uid172_lzCountVal_uid86_fpSubTest_merged_bit_select_b, rVStage_uid172_lzCountVal_uid86_fpSubTest_merged_bit_select_c)\n" +
                        "    BEGIN\n" +
                        "        CASE (vStagei_uid176_lzCountVal_uid86_fpSubTest_s) IS\n" +
                        "            WHEN \"0\" => vStagei_uid176_lzCountVal_uid86_fpSubTest_q <= rVStage_uid172_lzCountVal_uid86_fpSubTest_merged_bit_select_b;\n" +
                        "            WHEN \"1\" => vStagei_uid176_lzCountVal_uid86_fpSubTest_q <= rVStage_uid172_lzCountVal_uid86_fpSubTest_merged_bit_select_c;\n" +
                        "            WHEN OTHERS => vStagei_uid176_lzCountVal_uid86_fpSubTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- rVStage_uid178_lzCountVal_uid86_fpSubTest(BITSELECT,177)@3\n" +
                        "    rVStage_uid178_lzCountVal_uid86_fpSubTest_b <= vStagei_uid176_lzCountVal_uid86_fpSubTest_q(1 downto 1);\n" +
                        "\n" +
                        "    -- vCount_uid179_lzCountVal_uid86_fpSubTest(LOGICAL,178)@3\n" +
                        "    vCount_uid179_lzCountVal_uid86_fpSubTest_q <= \"1\" WHEN rVStage_uid178_lzCountVal_uid86_fpSubTest_b = GND_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- r_uid180_lzCountVal_uid86_fpSubTest(BITJOIN,179)@3\n" +
                        "    r_uid180_lzCountVal_uid86_fpSubTest_q <= redist3_vCount_uid153_lzCountVal_uid86_fpSubTest_q_1_q & vCount_uid161_lzCountVal_uid86_fpSubTest_q & vCount_uid167_lzCountVal_uid86_fpSubTest_q & vCount_uid173_lzCountVal_uid86_fpSubTest_q & vCount_uid179_lzCountVal_uid86_fpSubTest_q;\n" +
                        "\n" +
                        "    -- redist1_r_uid180_lzCountVal_uid86_fpSubTest_q_1(DELAY,258)\n" +
                        "    redist1_r_uid180_lzCountVal_uid86_fpSubTest_q_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 5, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => r_uid180_lzCountVal_uid86_fpSubTest_q, xout => redist1_r_uid180_lzCountVal_uid86_fpSubTest_q_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- aMinusA_uid88_fpSubTest(LOGICAL,87)@4\n" +
                        "    aMinusA_uid88_fpSubTest_q <= \"1\" WHEN redist1_r_uid180_lzCountVal_uid86_fpSubTest_q_1_q = cAmA_uid87_fpSubTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- invAMinusA_uid130_fpSubTest(LOGICAL,129)@4\n" +
                        "    invAMinusA_uid130_fpSubTest_q <= not (aMinusA_uid88_fpSubTest_q);\n" +
                        "\n" +
                        "    -- redist10_sigA_uid51_fpSubTest_b_4(DELAY,267)\n" +
                        "    redist10_sigA_uid51_fpSubTest_b_4 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 3, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => redist9_sigA_uid51_fpSubTest_b_1_q, xout => redist10_sigA_uid51_fpSubTest_b_4_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- cstAllOWE_uid19_fpSubTest(CONSTANT,18)\n" +
                        "    cstAllOWE_uid19_fpSubTest_q <= \"11111111\";\n" +
                        "\n" +
                        "    -- expXIsMax_uid39_fpSubTest(LOGICAL,38)@0 + 1\n" +
                        "    expXIsMax_uid39_fpSubTest_qi <= \"1\" WHEN exp_bSig_uid36_fpSubTest_b = cstAllOWE_uid19_fpSubTest_q ELSE \"0\";\n" +
                        "    expXIsMax_uid39_fpSubTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => expXIsMax_uid39_fpSubTest_qi, xout => expXIsMax_uid39_fpSubTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist14_expXIsMax_uid39_fpSubTest_q_4(DELAY,271)\n" +
                        "    redist14_expXIsMax_uid39_fpSubTest_q_4 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 3, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => expXIsMax_uid39_fpSubTest_q, xout => redist14_expXIsMax_uid39_fpSubTest_q_4_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- invExpXIsMax_uid44_fpSubTest(LOGICAL,43)@4\n" +
                        "    invExpXIsMax_uid44_fpSubTest_q <= not (redist14_expXIsMax_uid39_fpSubTest_q_4_q);\n" +
                        "\n" +
                        "    -- redist11_InvExpXIsZero_uid45_fpSubTest_q_3(DELAY,268)\n" +
                        "    redist11_InvExpXIsZero_uid45_fpSubTest_q_3 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 3, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => InvExpXIsZero_uid45_fpSubTest_q, xout => redist11_InvExpXIsZero_uid45_fpSubTest_q_3_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- excR_bSig_uid46_fpSubTest(LOGICAL,45)@4\n" +
                        "    excR_bSig_uid46_fpSubTest_q <= redist11_InvExpXIsZero_uid45_fpSubTest_q_3_q and invExpXIsMax_uid44_fpSubTest_q;\n" +
                        "\n" +
                        "    -- redist22_exp_aSig_uid22_fpSubTest_b_3(DELAY,279)\n" +
                        "    redist22_exp_aSig_uid22_fpSubTest_b_3 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 8, depth => 3, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => exp_aSig_uid22_fpSubTest_b, xout => redist22_exp_aSig_uid22_fpSubTest_b_3_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- expXIsMax_uid25_fpSubTest(LOGICAL,24)@3 + 1\n" +
                        "    expXIsMax_uid25_fpSubTest_qi <= \"1\" WHEN redist22_exp_aSig_uid22_fpSubTest_b_3_q = cstAllOWE_uid19_fpSubTest_q ELSE \"0\";\n" +
                        "    expXIsMax_uid25_fpSubTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => expXIsMax_uid25_fpSubTest_qi, xout => expXIsMax_uid25_fpSubTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- invExpXIsMax_uid30_fpSubTest(LOGICAL,29)@4\n" +
                        "    invExpXIsMax_uid30_fpSubTest_q <= not (expXIsMax_uid25_fpSubTest_q);\n" +
                        "\n" +
                        "    -- excZ_aSig_uid17_uid24_fpSubTest(LOGICAL,23)@3 + 1\n" +
                        "    excZ_aSig_uid17_uid24_fpSubTest_qi <= \"1\" WHEN redist22_exp_aSig_uid22_fpSubTest_b_3_q = cstAllZWE_uid21_fpSubTest_q ELSE \"0\";\n" +
                        "    excZ_aSig_uid17_uid24_fpSubTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => excZ_aSig_uid17_uid24_fpSubTest_qi, xout => excZ_aSig_uid17_uid24_fpSubTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- InvExpXIsZero_uid31_fpSubTest(LOGICAL,30)@4\n" +
                        "    InvExpXIsZero_uid31_fpSubTest_q <= not (excZ_aSig_uid17_uid24_fpSubTest_q);\n" +
                        "\n" +
                        "    -- excR_aSig_uid32_fpSubTest(LOGICAL,31)@4\n" +
                        "    excR_aSig_uid32_fpSubTest_q <= InvExpXIsZero_uid31_fpSubTest_q and invExpXIsMax_uid30_fpSubTest_q;\n" +
                        "\n" +
                        "    -- signRReg_uid131_fpSubTest(LOGICAL,130)@4\n" +
                        "    signRReg_uid131_fpSubTest_q <= excR_aSig_uid32_fpSubTest_q and excR_bSig_uid46_fpSubTest_q and redist10_sigA_uid51_fpSubTest_b_4_q and invAMinusA_uid130_fpSubTest_q;\n" +
                        "\n" +
                        "    -- redist8_sigB_uid52_fpSubTest_b_4(DELAY,265)\n" +
                        "    redist8_sigB_uid52_fpSubTest_b_4 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 3, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => redist7_sigB_uid52_fpSubTest_b_1_q, xout => redist8_sigB_uid52_fpSubTest_b_4_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist16_excZ_bSig_uid18_uid38_fpSubTest_q_4(DELAY,273)\n" +
                        "    redist16_excZ_bSig_uid18_uid38_fpSubTest_q_4 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 3, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => redist15_excZ_bSig_uid18_uid38_fpSubTest_q_1_q, xout => redist16_excZ_bSig_uid18_uid38_fpSubTest_q_4_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- excAZBZSigASigB_uid135_fpSubTest(LOGICAL,134)@4\n" +
                        "    excAZBZSigASigB_uid135_fpSubTest_q <= excZ_aSig_uid17_uid24_fpSubTest_q and redist16_excZ_bSig_uid18_uid38_fpSubTest_q_4_q and redist10_sigA_uid51_fpSubTest_b_4_q and redist8_sigB_uid52_fpSubTest_b_4_q;\n" +
                        "\n" +
                        "    -- excBZARSigA_uid136_fpSubTest(LOGICAL,135)@4\n" +
                        "    excBZARSigA_uid136_fpSubTest_q <= redist16_excZ_bSig_uid18_uid38_fpSubTest_q_4_q and excR_aSig_uid32_fpSubTest_q and redist10_sigA_uid51_fpSubTest_b_4_q;\n" +
                        "\n" +
                        "    -- signRZero_uid137_fpSubTest(LOGICAL,136)@4\n" +
                        "    signRZero_uid137_fpSubTest_q <= excBZARSigA_uid136_fpSubTest_q or excAZBZSigASigB_uid135_fpSubTest_q;\n" +
                        "\n" +
                        "    -- fracXIsZero_uid40_fpSubTest(LOGICAL,39)@0 + 1\n" +
                        "    fracXIsZero_uid40_fpSubTest_qi <= \"1\" WHEN cstZeroWF_uid20_fpSubTest_q = frac_bSig_uid37_fpSubTest_b ELSE \"0\";\n" +
                        "    fracXIsZero_uid40_fpSubTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => fracXIsZero_uid40_fpSubTest_qi, xout => fracXIsZero_uid40_fpSubTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist13_fracXIsZero_uid40_fpSubTest_q_4(DELAY,270)\n" +
                        "    redist13_fracXIsZero_uid40_fpSubTest_q_4 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 3, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => fracXIsZero_uid40_fpSubTest_q, xout => redist13_fracXIsZero_uid40_fpSubTest_q_4_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- excI_bSig_uid42_fpSubTest(LOGICAL,41)@4\n" +
                        "    excI_bSig_uid42_fpSubTest_q <= redist14_expXIsMax_uid39_fpSubTest_q_4_q and redist13_fracXIsZero_uid40_fpSubTest_q_4_q;\n" +
                        "\n" +
                        "    -- sigBBInf_uid132_fpSubTest(LOGICAL,131)@4\n" +
                        "    sigBBInf_uid132_fpSubTest_q <= redist8_sigB_uid52_fpSubTest_b_4_q and excI_bSig_uid42_fpSubTest_q;\n" +
                        "\n" +
                        "    -- fracXIsZero_uid26_fpSubTest(LOGICAL,25)@2 + 1\n" +
                        "    fracXIsZero_uid26_fpSubTest_qi <= \"1\" WHEN cstZeroWF_uid20_fpSubTest_q = redist21_frac_aSig_uid23_fpSubTest_b_2_q ELSE \"0\";\n" +
                        "    fracXIsZero_uid26_fpSubTest_delay : dspba_delay\n";
        String data2 =  "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => fracXIsZero_uid26_fpSubTest_qi, xout => fracXIsZero_uid26_fpSubTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist19_fracXIsZero_uid26_fpSubTest_q_2(DELAY,276)\n" +
                        "    redist19_fracXIsZero_uid26_fpSubTest_q_2 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => fracXIsZero_uid26_fpSubTest_q, xout => redist19_fracXIsZero_uid26_fpSubTest_q_2_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- excI_aSig_uid28_fpSubTest(LOGICAL,27)@4\n" +
                        "    excI_aSig_uid28_fpSubTest_q <= expXIsMax_uid25_fpSubTest_q and redist19_fracXIsZero_uid26_fpSubTest_q_2_q;\n" +
                        "\n" +
                        "    -- sigAAInf_uid133_fpSubTest(LOGICAL,132)@4\n" +
                        "    sigAAInf_uid133_fpSubTest_q <= redist10_sigA_uid51_fpSubTest_b_4_q and excI_aSig_uid28_fpSubTest_q;\n" +
                        "\n" +
                        "    -- signRInf_uid134_fpSubTest(LOGICAL,133)@4\n" +
                        "    signRInf_uid134_fpSubTest_q <= sigAAInf_uid133_fpSubTest_q or sigBBInf_uid132_fpSubTest_q;\n" +
                        "\n" +
                        "    -- signRInfRZRReg_uid138_fpSubTest(LOGICAL,137)@4 + 1\n" +
                        "    signRInfRZRReg_uid138_fpSubTest_qi <= signRInf_uid134_fpSubTest_q or signRZero_uid137_fpSubTest_q or signRReg_uid131_fpSubTest_q;\n" +
                        "    signRInfRZRReg_uid138_fpSubTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => signRInfRZRReg_uid138_fpSubTest_qi, xout => signRInfRZRReg_uid138_fpSubTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- fracXIsNotZero_uid41_fpSubTest(LOGICAL,40)@4\n" +
                        "    fracXIsNotZero_uid41_fpSubTest_q <= not (redist13_fracXIsZero_uid40_fpSubTest_q_4_q);\n" +
                        "\n" +
                        "    -- excN_bSig_uid43_fpSubTest(LOGICAL,42)@4 + 1\n" +
                        "    excN_bSig_uid43_fpSubTest_qi <= redist14_expXIsMax_uid39_fpSubTest_q_4_q and fracXIsNotZero_uid41_fpSubTest_q;\n" +
                        "    excN_bSig_uid43_fpSubTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => excN_bSig_uid43_fpSubTest_qi, xout => excN_bSig_uid43_fpSubTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- fracXIsNotZero_uid27_fpSubTest(LOGICAL,26)@4\n" +
                        "    fracXIsNotZero_uid27_fpSubTest_q <= not (redist19_fracXIsZero_uid26_fpSubTest_q_2_q);\n" +
                        "\n" +
                        "    -- excN_aSig_uid29_fpSubTest(LOGICAL,28)@4 + 1\n" +
                        "    excN_aSig_uid29_fpSubTest_qi <= expXIsMax_uid25_fpSubTest_q and fracXIsNotZero_uid27_fpSubTest_q;\n" +
                        "    excN_aSig_uid29_fpSubTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => excN_aSig_uid29_fpSubTest_qi, xout => excN_aSig_uid29_fpSubTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- excRNaN2_uid125_fpSubTest(LOGICAL,124)@5\n" +
                        "    excRNaN2_uid125_fpSubTest_q <= excN_aSig_uid29_fpSubTest_q or excN_bSig_uid43_fpSubTest_q;\n" +
                        "\n" +
                        "    -- redist6_effSub_uid53_fpSubTest_q_4(DELAY,263)\n" +
                        "    redist6_effSub_uid53_fpSubTest_q_4 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 3, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => effSub_uid53_fpSubTest_q, xout => redist6_effSub_uid53_fpSubTest_q_4_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist12_excI_bSig_uid42_fpSubTest_q_1(DELAY,269)\n" +
                        "    redist12_excI_bSig_uid42_fpSubTest_q_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => excI_bSig_uid42_fpSubTest_q, xout => redist12_excI_bSig_uid42_fpSubTest_q_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist18_excI_aSig_uid28_fpSubTest_q_1(DELAY,275)\n" +
                        "    redist18_excI_aSig_uid28_fpSubTest_q_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => excI_aSig_uid28_fpSubTest_q, xout => redist18_excI_aSig_uid28_fpSubTest_q_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- excAIBISub_uid126_fpSubTest(LOGICAL,125)@5\n" +
                        "    excAIBISub_uid126_fpSubTest_q <= redist18_excI_aSig_uid28_fpSubTest_q_1_q and redist12_excI_bSig_uid42_fpSubTest_q_1_q and redist6_effSub_uid53_fpSubTest_q_4_q;\n" +
                        "\n" +
                        "    -- excRNaN_uid127_fpSubTest(LOGICAL,126)@5\n" +
                        "    excRNaN_uid127_fpSubTest_q <= excAIBISub_uid126_fpSubTest_q or excRNaN2_uid125_fpSubTest_q;\n" +
                        "\n" +
                        "    -- invExcRNaN_uid139_fpSubTest(LOGICAL,138)@5\n" +
                        "    invExcRNaN_uid139_fpSubTest_q <= not (excRNaN_uid127_fpSubTest_q);\n" +
                        "\n" +
                        "    -- VCC(CONSTANT,1)\n" +
                        "    VCC_q <= \"1\";\n" +
                        "\n" +
                        "    -- signRPostExc_uid140_fpSubTest(LOGICAL,139)@5\n" +
                        "    signRPostExc_uid140_fpSubTest_q <= invExcRNaN_uid139_fpSubTest_q and signRInfRZRReg_uid138_fpSubTest_q;\n" +
                        "\n" +
                        "    -- cRBit_uid100_fpSubTest(CONSTANT,99)\n" +
                        "    cRBit_uid100_fpSubTest_q <= \"01000\";\n" +
                        "\n" +
                        "    -- leftShiftStage2Idx1Rng1_uid247_fracPostNormExt_uid89_fpSubTest(BITSELECT,246)@4\n" +
                        "    leftShiftStage2Idx1Rng1_uid247_fracPostNormExt_uid89_fpSubTest_in <= leftShiftStage1_uid245_fracPostNormExt_uid89_fpSubTest_q(26 downto 0);\n" +
                        "    leftShiftStage2Idx1Rng1_uid247_fracPostNormExt_uid89_fpSubTest_b <= leftShiftStage2Idx1Rng1_uid247_fracPostNormExt_uid89_fpSubTest_in(26 downto 0);\n" +
                        "\n" +
                        "    -- leftShiftStage2Idx1_uid248_fracPostNormExt_uid89_fpSubTest(BITJOIN,247)@4\n" +
                        "    leftShiftStage2Idx1_uid248_fracPostNormExt_uid89_fpSubTest_q <= leftShiftStage2Idx1Rng1_uid247_fracPostNormExt_uid89_fpSubTest_b & GND_q;\n" +
                        "\n" +
                        "    -- leftShiftStage1Idx3Rng6_uid242_fracPostNormExt_uid89_fpSubTest(BITSELECT,241)@4\n" +
                        "    leftShiftStage1Idx3Rng6_uid242_fracPostNormExt_uid89_fpSubTest_in <= leftShiftStage0_uid234_fracPostNormExt_uid89_fpSubTest_q(21 downto 0);\n" +
                        "    leftShiftStage1Idx3Rng6_uid242_fracPostNormExt_uid89_fpSubTest_b <= leftShiftStage1Idx3Rng6_uid242_fracPostNormExt_uid89_fpSubTest_in(21 downto 0);\n" +
                        "\n" +
                        "    -- leftShiftStage1Idx3Pad6_uid241_fracPostNormExt_uid89_fpSubTest(CONSTANT,240)\n" +
                        "    leftShiftStage1Idx3Pad6_uid241_fracPostNormExt_uid89_fpSubTest_q <= \"000000\";\n" +
                        "\n" +
                        "    -- leftShiftStage1Idx3_uid243_fracPostNormExt_uid89_fpSubTest(BITJOIN,242)@4\n" +
                        "    leftShiftStage1Idx3_uid243_fracPostNormExt_uid89_fpSubTest_q <= leftShiftStage1Idx3Rng6_uid242_fracPostNormExt_uid89_fpSubTest_b & leftShiftStage1Idx3Pad6_uid241_fracPostNormExt_uid89_fpSubTest_q;\n" +
                        "\n" +
                        "    -- leftShiftStage1Idx2Rng4_uid239_fracPostNormExt_uid89_fpSubTest(BITSELECT,238)@4\n" +
                        "    leftShiftStage1Idx2Rng4_uid239_fracPostNormExt_uid89_fpSubTest_in <= leftShiftStage0_uid234_fracPostNormExt_uid89_fpSubTest_q(23 downto 0);\n" +
                        "    leftShiftStage1Idx2Rng4_uid239_fracPostNormExt_uid89_fpSubTest_b <= leftShiftStage1Idx2Rng4_uid239_fracPostNormExt_uid89_fpSubTest_in(23 downto 0);\n" +
                        "\n" +
                        "    -- leftShiftStage1Idx2_uid240_fracPostNormExt_uid89_fpSubTest(BITJOIN,239)@4\n" +
                        "    leftShiftStage1Idx2_uid240_fracPostNormExt_uid89_fpSubTest_q <= leftShiftStage1Idx2Rng4_uid239_fracPostNormExt_uid89_fpSubTest_b & zs_uid165_lzCountVal_uid86_fpSubTest_q;\n" +
                        "\n" +
                        "    -- leftShiftStage1Idx1Rng2_uid236_fracPostNormExt_uid89_fpSubTest(BITSELECT,235)@4\n" +
                        "    leftShiftStage1Idx1Rng2_uid236_fracPostNormExt_uid89_fpSubTest_in <= leftShiftStage0_uid234_fracPostNormExt_uid89_fpSubTest_q(25 downto 0);\n" +
                        "    leftShiftStage1Idx1Rng2_uid236_fracPostNormExt_uid89_fpSubTest_b <= leftShiftStage1Idx1Rng2_uid236_fracPostNormExt_uid89_fpSubTest_in(25 downto 0);\n" +
                        "\n" +
                        "    -- leftShiftStage1Idx1_uid237_fracPostNormExt_uid89_fpSubTest(BITJOIN,236)@4\n" +
                        "    leftShiftStage1Idx1_uid237_fracPostNormExt_uid89_fpSubTest_q <= leftShiftStage1Idx1Rng2_uid236_fracPostNormExt_uid89_fpSubTest_b & zs_uid171_lzCountVal_uid86_fpSubTest_q;\n" +
                        "\n" +
                        "    -- leftShiftStage0Idx3Rng24_uid231_fracPostNormExt_uid89_fpSubTest(BITSELECT,230)@4\n" +
                        "    leftShiftStage0Idx3Rng24_uid231_fracPostNormExt_uid89_fpSubTest_in <= redist5_fracGRS_uid85_fpSubTest_q_2_q(3 downto 0);\n" +
                        "    leftShiftStage0Idx3Rng24_uid231_fracPostNormExt_uid89_fpSubTest_b <= leftShiftStage0Idx3Rng24_uid231_fracPostNormExt_uid89_fpSubTest_in(3 downto 0);\n" +
                        "\n" +
                        "    -- leftShiftStage0Idx3Pad24_uid230_fracPostNormExt_uid89_fpSubTest(CONSTANT,229)\n" +
                        "    leftShiftStage0Idx3Pad24_uid230_fracPostNormExt_uid89_fpSubTest_q <= \"000000000000000000000000\";\n" +
                        "\n" +
                        "    -- leftShiftStage0Idx3_uid232_fracPostNormExt_uid89_fpSubTest(BITJOIN,231)@4\n" +
                        "    leftShiftStage0Idx3_uid232_fracPostNormExt_uid89_fpSubTest_q <= leftShiftStage0Idx3Rng24_uid231_fracPostNormExt_uid89_fpSubTest_b & leftShiftStage0Idx3Pad24_uid230_fracPostNormExt_uid89_fpSubTest_q;\n" +
                        "\n" +
                        "    -- redist2_vStage_uid155_lzCountVal_uid86_fpSubTest_b_2(DELAY,259)\n" +
                        "    redist2_vStage_uid155_lzCountVal_uid86_fpSubTest_b_2 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 12, depth => 2, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => vStage_uid155_lzCountVal_uid86_fpSubTest_b, xout => redist2_vStage_uid155_lzCountVal_uid86_fpSubTest_b_2_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- leftShiftStage0Idx2_uid229_fracPostNormExt_uid89_fpSubTest(BITJOIN,228)@4\n" +
                        "    leftShiftStage0Idx2_uid229_fracPostNormExt_uid89_fpSubTest_q <= redist2_vStage_uid155_lzCountVal_uid86_fpSubTest_b_2_q & zs_uid151_lzCountVal_uid86_fpSubTest_q;\n" +
                        "\n" +
                        "    -- leftShiftStage0Idx1Rng8_uid225_fracPostNormExt_uid89_fpSubTest(BITSELECT,224)@4\n" +
                        "    leftShiftStage0Idx1Rng8_uid225_fracPostNormExt_uid89_fpSubTest_in <= redist5_fracGRS_uid85_fpSubTest_q_2_q(19 downto 0);\n" +
                        "    leftShiftStage0Idx1Rng8_uid225_fracPostNormExt_uid89_fpSubTest_b <= leftShiftStage0Idx1Rng8_uid225_fracPostNormExt_uid89_fpSubTest_in(19 downto 0);\n" +
                        "\n" +
                        "    -- leftShiftStage0Idx1_uid226_fracPostNormExt_uid89_fpSubTest(BITJOIN,225)@4\n" +
                        "    leftShiftStage0Idx1_uid226_fracPostNormExt_uid89_fpSubTest_q <= leftShiftStage0Idx1Rng8_uid225_fracPostNormExt_uid89_fpSubTest_b & cstAllZWE_uid21_fpSubTest_q;\n" +
                        "\n" +
                        "    -- redist5_fracGRS_uid85_fpSubTest_q_2(DELAY,262)\n" +
                        "    redist5_fracGRS_uid85_fpSubTest_q_2 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 28, depth => 2, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => fracGRS_uid85_fpSubTest_q, xout => redist5_fracGRS_uid85_fpSubTest_q_2_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- leftShiftStage0_uid234_fracPostNormExt_uid89_fpSubTest(MUX,233)@4\n" +
                        "    leftShiftStage0_uid234_fracPostNormExt_uid89_fpSubTest_s <= leftShiftStageSel4Dto3_uid233_fracPostNormExt_uid89_fpSubTest_merged_bit_select_b;\n" +
                        "    leftShiftStage0_uid234_fracPostNormExt_uid89_fpSubTest_combproc: PROCESS (leftShiftStage0_uid234_fracPostNormExt_uid89_fpSubTest_s, redist5_fracGRS_uid85_fpSubTest_q_2_q, leftShiftStage0Idx1_uid226_fracPostNormExt_uid89_fpSubTest_q, leftShiftStage0Idx2_uid229_fracPostNormExt_uid89_fpSubTest_q, leftShiftStage0Idx3_uid232_fracPostNormExt_uid89_fpSubTest_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (leftShiftStage0_uid234_fracPostNormExt_uid89_fpSubTest_s) IS\n" +
                        "            WHEN \"00\" => leftShiftStage0_uid234_fracPostNormExt_uid89_fpSubTest_q <= redist5_fracGRS_uid85_fpSubTest_q_2_q;\n" +
                        "            WHEN \"01\" => leftShiftStage0_uid234_fracPostNormExt_uid89_fpSubTest_q <= leftShiftStage0Idx1_uid226_fracPostNormExt_uid89_fpSubTest_q;\n" +
                        "            WHEN \"10\" => leftShiftStage0_uid234_fracPostNormExt_uid89_fpSubTest_q <= leftShiftStage0Idx2_uid229_fracPostNormExt_uid89_fpSubTest_q;\n" +
                        "            WHEN \"11\" => leftShiftStage0_uid234_fracPostNormExt_uid89_fpSubTest_q <= leftShiftStage0Idx3_uid232_fracPostNormExt_uid89_fpSubTest_q;\n" +
                        "            WHEN OTHERS => leftShiftStage0_uid234_fracPostNormExt_uid89_fpSubTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- leftShiftStage1_uid245_fracPostNormExt_uid89_fpSubTest(MUX,244)@4\n" +
                        "    leftShiftStage1_uid245_fracPostNormExt_uid89_fpSubTest_s <= leftShiftStageSel4Dto3_uid233_fracPostNormExt_uid89_fpSubTest_merged_bit_select_c;\n" +
                        "    leftShiftStage1_uid245_fracPostNormExt_uid89_fpSubTest_combproc: PROCESS (leftShiftStage1_uid245_fracPostNormExt_uid89_fpSubTest_s, leftShiftStage0_uid234_fracPostNormExt_uid89_fpSubTest_q, leftShiftStage1Idx1_uid237_fracPostNormExt_uid89_fpSubTest_q, leftShiftStage1Idx2_uid240_fracPostNormExt_uid89_fpSubTest_q, leftShiftStage1Idx3_uid243_fracPostNormExt_uid89_fpSubTest_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (leftShiftStage1_uid245_fracPostNormExt_uid89_fpSubTest_s) IS\n" +
                        "            WHEN \"00\" => leftShiftStage1_uid245_fracPostNormExt_uid89_fpSubTest_q <= leftShiftStage0_uid234_fracPostNormExt_uid89_fpSubTest_q;\n" +
                        "            WHEN \"01\" => leftShiftStage1_uid245_fracPostNormExt_uid89_fpSubTest_q <= leftShiftStage1Idx1_uid237_fracPostNormExt_uid89_fpSubTest_q;\n" +
                        "            WHEN \"10\" => leftShiftStage1_uid245_fracPostNormExt_uid89_fpSubTest_q <= leftShiftStage1Idx2_uid240_fracPostNormExt_uid89_fpSubTest_q;\n" +
                        "            WHEN \"11\" => leftShiftStage1_uid245_fracPostNormExt_uid89_fpSubTest_q <= leftShiftStage1Idx3_uid243_fracPostNormExt_uid89_fpSubTest_q;\n" +
                        "            WHEN OTHERS => leftShiftStage1_uid245_fracPostNormExt_uid89_fpSubTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- leftShiftStageSel4Dto3_uid233_fracPostNormExt_uid89_fpSubTest_merged_bit_select(BITSELECT,256)@4\n" +
                        "    leftShiftStageSel4Dto3_uid233_fracPostNormExt_uid89_fpSubTest_merged_bit_select_b <= redist1_r_uid180_lzCountVal_uid86_fpSubTest_q_1_q(4 downto 3);\n" +
                        "    leftShiftStageSel4Dto3_uid233_fracPostNormExt_uid89_fpSubTest_merged_bit_select_c <= redist1_r_uid180_lzCountVal_uid86_fpSubTest_q_1_q(2 downto 1);\n" +
                        "    leftShiftStageSel4Dto3_uid233_fracPostNormExt_uid89_fpSubTest_merged_bit_select_d <= redist1_r_uid180_lzCountVal_uid86_fpSubTest_q_1_q(0 downto 0);\n" +
                        "\n" +
                        "    -- leftShiftStage2_uid250_fracPostNormExt_uid89_fpSubTest(MUX,249)@4\n" +
                        "    leftShiftStage2_uid250_fracPostNormExt_uid89_fpSubTest_s <= leftShiftStageSel4Dto3_uid233_fracPostNormExt_uid89_fpSubTest_merged_bit_select_d;\n" +
                        "    leftShiftStage2_uid250_fracPostNormExt_uid89_fpSubTest_combproc: PROCESS (leftShiftStage2_uid250_fracPostNormExt_uid89_fpSubTest_s, leftShiftStage1_uid245_fracPostNormExt_uid89_fpSubTest_q, leftShiftStage2Idx1_uid248_fracPostNormExt_uid89_fpSubTest_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (leftShiftStage2_uid250_fracPostNormExt_uid89_fpSubTest_s) IS\n" +
                        "            WHEN \"0\" => leftShiftStage2_uid250_fracPostNormExt_uid89_fpSubTest_q <= leftShiftStage1_uid245_fracPostNormExt_uid89_fpSubTest_q;\n" +
                        "            WHEN \"1\" => leftShiftStage2_uid250_fracPostNormExt_uid89_fpSubTest_q <= leftShiftStage2Idx1_uid248_fracPostNormExt_uid89_fpSubTest_q;\n" +
                        "            WHEN OTHERS => leftShiftStage2_uid250_fracPostNormExt_uid89_fpSubTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- LSB_uid98_fpSubTest(BITSELECT,97)@4\n" +
                        "    LSB_uid98_fpSubTest_in <= STD_LOGIC_VECTOR(leftShiftStage2_uid250_fracPostNormExt_uid89_fpSubTest_q(4 downto 0));\n";
        String data3 =  "    LSB_uid98_fpSubTest_b <= STD_LOGIC_VECTOR(LSB_uid98_fpSubTest_in(4 downto 4));\n" +
                        "\n" +
                        "    -- Guard_uid97_fpSubTest(BITSELECT,96)@4\n" +
                        "    Guard_uid97_fpSubTest_in <= STD_LOGIC_VECTOR(leftShiftStage2_uid250_fracPostNormExt_uid89_fpSubTest_q(3 downto 0));\n" +
                        "    Guard_uid97_fpSubTest_b <= STD_LOGIC_VECTOR(Guard_uid97_fpSubTest_in(3 downto 3));\n" +
                        "\n" +
                        "    -- Round_uid96_fpSubTest(BITSELECT,95)@4\n" +
                        "    Round_uid96_fpSubTest_in <= STD_LOGIC_VECTOR(leftShiftStage2_uid250_fracPostNormExt_uid89_fpSubTest_q(2 downto 0));\n" +
                        "    Round_uid96_fpSubTest_b <= STD_LOGIC_VECTOR(Round_uid96_fpSubTest_in(2 downto 2));\n" +
                        "\n" +
                        "    -- Sticky1_uid95_fpSubTest(BITSELECT,94)@4\n" +
                        "    Sticky1_uid95_fpSubTest_in <= STD_LOGIC_VECTOR(leftShiftStage2_uid250_fracPostNormExt_uid89_fpSubTest_q(1 downto 0));\n" +
                        "    Sticky1_uid95_fpSubTest_b <= STD_LOGIC_VECTOR(Sticky1_uid95_fpSubTest_in(1 downto 1));\n" +
                        "\n" +
                        "    -- Sticky0_uid94_fpSubTest(BITSELECT,93)@4\n" +
                        "    Sticky0_uid94_fpSubTest_in <= STD_LOGIC_VECTOR(leftShiftStage2_uid250_fracPostNormExt_uid89_fpSubTest_q(0 downto 0));\n" +
                        "    Sticky0_uid94_fpSubTest_b <= STD_LOGIC_VECTOR(Sticky0_uid94_fpSubTest_in(0 downto 0));\n" +
                        "\n" +
                        "    -- rndBitCond_uid99_fpSubTest(BITJOIN,98)@4\n" +
                        "    rndBitCond_uid99_fpSubTest_q <= LSB_uid98_fpSubTest_b & Guard_uid97_fpSubTest_b & Round_uid96_fpSubTest_b & Sticky1_uid95_fpSubTest_b & Sticky0_uid94_fpSubTest_b;\n" +
                        "\n" +
                        "    -- rBi_uid101_fpSubTest(LOGICAL,100)@4\n" +
                        "    rBi_uid101_fpSubTest_q <= \"1\" WHEN rndBitCond_uid99_fpSubTest_q = cRBit_uid100_fpSubTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- roundBit_uid102_fpSubTest(LOGICAL,101)@4\n" +
                        "    roundBit_uid102_fpSubTest_q <= not (rBi_uid101_fpSubTest_q);\n" +
                        "\n" +
                        "    -- oneCST_uid91_fpSubTest(CONSTANT,90)\n" +
                        "    oneCST_uid91_fpSubTest_q <= \"00000001\";\n" +
                        "\n" +
                        "    -- expInc_uid92_fpSubTest(ADD,91)@3 + 1\n" +
                        "    expInc_uid92_fpSubTest_a <= STD_LOGIC_VECTOR(\"0\" & redist22_exp_aSig_uid22_fpSubTest_b_3_q);\n" +
                        "    expInc_uid92_fpSubTest_b <= STD_LOGIC_VECTOR(\"0\" & oneCST_uid91_fpSubTest_q);\n" +
                        "    expInc_uid92_fpSubTest_clkproc: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            expInc_uid92_fpSubTest_o <= (others => '0');\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            expInc_uid92_fpSubTest_o <= STD_LOGIC_VECTOR(UNSIGNED(expInc_uid92_fpSubTest_a) + UNSIGNED(expInc_uid92_fpSubTest_b));\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "    expInc_uid92_fpSubTest_q <= expInc_uid92_fpSubTest_o(8 downto 0);\n" +
                        "\n" +
                        "    -- expPostNorm_uid93_fpSubTest(SUB,92)@4\n" +
                        "    expPostNorm_uid93_fpSubTest_a <= STD_LOGIC_VECTOR(\"0\" & expInc_uid92_fpSubTest_q);\n" +
                        "    expPostNorm_uid93_fpSubTest_b <= STD_LOGIC_VECTOR(\"00000\" & redist1_r_uid180_lzCountVal_uid86_fpSubTest_q_1_q);\n" +
                        "    expPostNorm_uid93_fpSubTest_o <= STD_LOGIC_VECTOR(UNSIGNED(expPostNorm_uid93_fpSubTest_a) - UNSIGNED(expPostNorm_uid93_fpSubTest_b));\n" +
                        "    expPostNorm_uid93_fpSubTest_q <= expPostNorm_uid93_fpSubTest_o(9 downto 0);\n" +
                        "\n" +
                        "    -- fracPostNorm_uid90_fpSubTest(BITSELECT,89)@4\n" +
                        "    fracPostNorm_uid90_fpSubTest_b <= leftShiftStage2_uid250_fracPostNormExt_uid89_fpSubTest_q(27 downto 1);\n" +
                        "\n" +
                        "    -- fracPostNormRndRange_uid103_fpSubTest(BITSELECT,102)@4\n" +
                        "    fracPostNormRndRange_uid103_fpSubTest_in <= fracPostNorm_uid90_fpSubTest_b(25 downto 0);\n" +
                        "    fracPostNormRndRange_uid103_fpSubTest_b <= fracPostNormRndRange_uid103_fpSubTest_in(25 downto 2);\n" +
                        "\n" +
                        "    -- expFracR_uid104_fpSubTest(BITJOIN,103)@4\n" +
                        "    expFracR_uid104_fpSubTest_q <= expPostNorm_uid93_fpSubTest_q & fracPostNormRndRange_uid103_fpSubTest_b;\n" +
                        "\n" +
                        "    -- rndExpFrac_uid105_fpSubTest(ADD,104)@4 + 1\n" +
                        "    rndExpFrac_uid105_fpSubTest_a <= STD_LOGIC_VECTOR(\"0\" & expFracR_uid104_fpSubTest_q);\n" +
                        "    rndExpFrac_uid105_fpSubTest_b <= STD_LOGIC_VECTOR(\"0000000000000000000000000000000000\" & roundBit_uid102_fpSubTest_q);\n" +
                        "    rndExpFrac_uid105_fpSubTest_clkproc: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            rndExpFrac_uid105_fpSubTest_o <= (others => '0');\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            rndExpFrac_uid105_fpSubTest_o <= STD_LOGIC_VECTOR(UNSIGNED(rndExpFrac_uid105_fpSubTest_a) + UNSIGNED(rndExpFrac_uid105_fpSubTest_b));\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "    rndExpFrac_uid105_fpSubTest_q <= rndExpFrac_uid105_fpSubTest_o(34 downto 0);\n" +
                        "\n" +
                        "    -- expRPreExc_uid118_fpSubTest(BITSELECT,117)@5\n" +
                        "    expRPreExc_uid118_fpSubTest_in <= rndExpFrac_uid105_fpSubTest_q(31 downto 0);\n" +
                        "    expRPreExc_uid118_fpSubTest_b <= expRPreExc_uid118_fpSubTest_in(31 downto 24);\n" +
                        "\n" +
                        "    -- rndExpFracOvfBits_uid110_fpSubTest(BITSELECT,109)@5\n" +
                        "    rndExpFracOvfBits_uid110_fpSubTest_in <= rndExpFrac_uid105_fpSubTest_q(33 downto 0);\n" +
                        "    rndExpFracOvfBits_uid110_fpSubTest_b <= rndExpFracOvfBits_uid110_fpSubTest_in(33 downto 32);\n" +
                        "\n" +
                        "    -- rOvfExtraBits_uid111_fpSubTest(LOGICAL,110)@5\n" +
                        "    rOvfExtraBits_uid111_fpSubTest_q <= \"1\" WHEN rndExpFracOvfBits_uid110_fpSubTest_b = zocst_uid77_fpSubTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- wEP2AllOwE_uid106_fpSubTest(CONSTANT,105)\n" +
                        "    wEP2AllOwE_uid106_fpSubTest_q <= \"0011111111\";\n" +
                        "\n" +
                        "    -- rndExp_uid107_fpSubTest(BITSELECT,106)@5\n" +
                        "    rndExp_uid107_fpSubTest_in <= rndExpFrac_uid105_fpSubTest_q(33 downto 0);\n" +
                        "    rndExp_uid107_fpSubTest_b <= rndExp_uid107_fpSubTest_in(33 downto 24);\n" +
                        "\n" +
                        "    -- rOvfEQMax_uid108_fpSubTest(LOGICAL,107)@5\n" +
                        "    rOvfEQMax_uid108_fpSubTest_q <= \"1\" WHEN rndExp_uid107_fpSubTest_b = wEP2AllOwE_uid106_fpSubTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- rOvf_uid112_fpSubTest(LOGICAL,111)@5\n" +
                        "    rOvf_uid112_fpSubTest_q <= rOvfEQMax_uid108_fpSubTest_q or rOvfExtraBits_uid111_fpSubTest_q;\n" +
                        "\n" +
                        "    -- regInputs_uid119_fpSubTest(LOGICAL,118)@4 + 1\n" +
                        "    regInputs_uid119_fpSubTest_qi <= excR_aSig_uid32_fpSubTest_q and excR_bSig_uid46_fpSubTest_q;\n" +
                        "    regInputs_uid119_fpSubTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => regInputs_uid119_fpSubTest_qi, xout => regInputs_uid119_fpSubTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- rInfOvf_uid122_fpSubTest(LOGICAL,121)@5\n" +
                        "    rInfOvf_uid122_fpSubTest_q <= regInputs_uid119_fpSubTest_q and rOvf_uid112_fpSubTest_q;\n" +
                        "\n" +
                        "    -- excRInfVInC_uid123_fpSubTest(BITJOIN,122)@5\n" +
                        "    excRInfVInC_uid123_fpSubTest_q <= rInfOvf_uid122_fpSubTest_q & excN_bSig_uid43_fpSubTest_q & excN_aSig_uid29_fpSubTest_q & redist12_excI_bSig_uid42_fpSubTest_q_1_q & redist18_excI_aSig_uid28_fpSubTest_q_1_q & redist6_effSub_uid53_fpSubTest_q_4_q;\n" +
                        "\n" +
                        "    -- excRInf_uid124_fpSubTest(LOOKUP,123)@5\n" +
                        "    excRInf_uid124_fpSubTest_combproc: PROCESS (excRInfVInC_uid123_fpSubTest_q)\n" +
                        "    BEGIN\n" +
                        "        -- Begin reserved scope level\n" +
                        "        CASE (excRInfVInC_uid123_fpSubTest_q) IS\n" +
                        "            WHEN \"000000\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"000001\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"000010\" => excRInf_uid124_fpSubTest_q <= \"1\";\n" +
                        "            WHEN \"000011\" => excRInf_uid124_fpSubTest_q <= \"1\";\n" +
                        "            WHEN \"000100\" => excRInf_uid124_fpSubTest_q <= \"1\";\n" +
                        "            WHEN \"000101\" => excRInf_uid124_fpSubTest_q <= \"1\";\n" +
                        "            WHEN \"000110\" => excRInf_uid124_fpSubTest_q <= \"1\";\n" +
                        "            WHEN \"000111\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"001000\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"001001\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"001010\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"001011\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"001100\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"001101\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"001110\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"001111\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"010000\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"010001\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"010010\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"010011\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"010100\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"010101\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"010110\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"010111\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"011000\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"011001\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"011010\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"011011\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"011100\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"011101\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"011110\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"011111\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"100000\" => excRInf_uid124_fpSubTest_q <= \"1\";\n" +
                        "            WHEN \"100001\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"100010\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"100011\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"100100\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"100101\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"100110\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"100111\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"101000\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"101001\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"101010\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"101011\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"101100\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"101101\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"101110\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"101111\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"110000\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"110001\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"110010\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"110011\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"110100\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"110101\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"110110\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"110111\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"111000\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"111001\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"111010\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"111011\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"111100\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"111101\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"111110\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"111111\" => excRInf_uid124_fpSubTest_q <= \"0\";\n" +
                        "            WHEN OTHERS => -- unreachable\n" +
                        "                           excRInf_uid124_fpSubTest_q <= (others => '-');\n" +
                        "        END CASE;\n" +
                        "        -- End reserved scope level\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- redist4_aMinusA_uid88_fpSubTest_q_1(DELAY,261)\n" +
                        "    redist4_aMinusA_uid88_fpSubTest_q_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => aMinusA_uid88_fpSubTest_q, xout => redist4_aMinusA_uid88_fpSubTest_q_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- rUdfExtraBit_uid115_fpSubTest(BITSELECT,114)@5\n" +
                        "    rUdfExtraBit_uid115_fpSubTest_in <= STD_LOGIC_VECTOR(rndExpFrac_uid105_fpSubTest_q(33 downto 0));\n" +
                        "    rUdfExtraBit_uid115_fpSubTest_b <= STD_LOGIC_VECTOR(rUdfExtraBit_uid115_fpSubTest_in(33 downto 33));\n" +
                        "\n" +
                        "    -- wEP2AllZ_uid113_fpSubTest(CONSTANT,112)\n" +
                        "    wEP2AllZ_uid113_fpSubTest_q <= \"0000000000\";\n" +
                        "\n" +
                        "    -- rUdfEQMin_uid114_fpSubTest(LOGICAL,113)@5\n" +
                        "    rUdfEQMin_uid114_fpSubTest_q <= \"1\" WHEN rndExp_uid107_fpSubTest_b = wEP2AllZ_uid113_fpSubTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- rUdf_uid116_fpSubTest(LOGICAL,115)@5\n" +
                        "    rUdf_uid116_fpSubTest_q <= rUdfEQMin_uid114_fpSubTest_q or rUdfExtraBit_uid115_fpSubTest_b;\n" +
                        "\n" +
                        "    -- redist17_excZ_bSig_uid18_uid38_fpSubTest_q_5(DELAY,274)\n" +
                        "    redist17_excZ_bSig_uid18_uid38_fpSubTest_q_5 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => redist16_excZ_bSig_uid18_uid38_fpSubTest_q_4_q, xout => redist17_excZ_bSig_uid18_uid38_fpSubTest_q_5_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist20_excZ_aSig_uid17_uid24_fpSubTest_q_2(DELAY,277)\n" +
                        "    redist20_excZ_aSig_uid17_uid24_fpSubTest_q_2 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => excZ_aSig_uid17_uid24_fpSubTest_q, xout => redist20_excZ_aSig_uid17_uid24_fpSubTest_q_2_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- excRZeroVInC_uid120_fpSubTest(BITJOIN,119)@5\n" +
                        "    excRZeroVInC_uid120_fpSubTest_q <= redist4_aMinusA_uid88_fpSubTest_q_1_q & rUdf_uid116_fpSubTest_q & regInputs_uid119_fpSubTest_q & redist17_excZ_bSig_uid18_uid38_fpSubTest_q_5_q & redist20_excZ_aSig_uid17_uid24_fpSubTest_q_2_q;\n" +
                        "\n" +
                        "    -- excRZero_uid121_fpSubTest(LOOKUP,120)@5\n" +
                        "    excRZero_uid121_fpSubTest_combproc: PROCESS (excRZeroVInC_uid120_fpSubTest_q)\n" +
                        "    BEGIN\n" +
                        "        -- Begin reserved scope level\n" +
                        "        CASE (excRZeroVInC_uid120_fpSubTest_q) IS\n" +
                        "            WHEN \"00000\" => excRZero_uid121_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"00001\" => excRZero_uid121_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"00010\" => excRZero_uid121_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"00011\" => excRZero_uid121_fpSubTest_q <= \"1\";\n" +
                        "            WHEN \"00100\" => excRZero_uid121_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"00101\" => excRZero_uid121_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"00110\" => excRZero_uid121_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"00111\" => excRZero_uid121_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"01000\" => excRZero_uid121_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"01001\" => excRZero_uid121_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"01010\" => excRZero_uid121_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"01011\" => excRZero_uid121_fpSubTest_q <= \"1\";\n" +
                        "            WHEN \"01100\" => excRZero_uid121_fpSubTest_q <= \"1\";\n" +
                        "            WHEN \"01101\" => excRZero_uid121_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"01110\" => excRZero_uid121_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"01111\" => excRZero_uid121_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"10000\" => excRZero_uid121_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"10001\" => excRZero_uid121_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"10010\" => excRZero_uid121_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"10011\" => excRZero_uid121_fpSubTest_q <= \"1\";\n" +
                        "            WHEN \"10100\" => excRZero_uid121_fpSubTest_q <= \"1\";\n" +
                        "            WHEN \"10101\" => excRZero_uid121_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"10110\" => excRZero_uid121_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"10111\" => excRZero_uid121_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"11000\" => excRZero_uid121_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"11001\" => excRZero_uid121_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"11010\" => excRZero_uid121_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"11011\" => excRZero_uid121_fpSubTest_q <= \"1\";\n" +
                        "            WHEN \"11100\" => excRZero_uid121_fpSubTest_q <= \"1\";\n" +
                        "            WHEN \"11101\" => excRZero_uid121_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"11110\" => excRZero_uid121_fpSubTest_q <= \"0\";\n" +
                        "            WHEN \"11111\" => excRZero_uid121_fpSubTest_q <= \"0\";\n" +
                        "            WHEN OTHERS => -- unreachable\n" +
                        "                           excRZero_uid121_fpSubTest_q <= (others => '-');\n" +
                        "        END CASE;\n" +
                        "        -- End reserved scope level\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- concExc_uid128_fpSubTest(BITJOIN,127)@5\n" +
                        "    concExc_uid128_fpSubTest_q <= excRNaN_uid127_fpSubTest_q & excRInf_uid124_fpSubTest_q & excRZero_uid121_fpSubTest_q;\n" +
                        "\n" +
                        "    -- excREnc_uid129_fpSubTest(LOOKUP,128)@5\n" +
                        "    excREnc_uid129_fpSubTest_combproc: PROCESS (concExc_uid128_fpSubTest_q)\n" +
                        "    BEGIN\n" +
                        "        -- Begin reserved scope level\n" +
                        "        CASE (concExc_uid128_fpSubTest_q) IS\n" +
                        "            WHEN \"000\" => excREnc_uid129_fpSubTest_q <= \"01\";\n" +
                        "            WHEN \"001\" => excREnc_uid129_fpSubTest_q <= \"00\";\n" +
                        "            WHEN \"010\" => excREnc_uid129_fpSubTest_q <= \"10\";\n" +
                        "            WHEN \"011\" => excREnc_uid129_fpSubTest_q <= \"10\";\n" +
                        "            WHEN \"100\" => excREnc_uid129_fpSubTest_q <= \"11\";\n" +
                        "            WHEN \"101\" => excREnc_uid129_fpSubTest_q <= \"11\";\n" +
                        "            WHEN \"110\" => excREnc_uid129_fpSubTest_q <= \"11\";\n" +
                        "            WHEN \"111\" => excREnc_uid129_fpSubTest_q <= \"11\";\n" +
                        "            WHEN OTHERS => -- unreachable\n" +
                        "                           excREnc_uid129_fpSubTest_q <= (others => '-');\n" +
                        "        END CASE;\n" +
                        "        -- End reserved scope level\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- expRPostExc_uid148_fpSubTest(MUX,147)@5\n" +
                        "    expRPostExc_uid148_fpSubTest_s <= excREnc_uid129_fpSubTest_q;\n" +
                        "    expRPostExc_uid148_fpSubTest_combproc: PROCESS (expRPostExc_uid148_fpSubTest_s, cstAllZWE_uid21_fpSubTest_q, expRPreExc_uid118_fpSubTest_b, cstAllOWE_uid19_fpSubTest_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (expRPostExc_uid148_fpSubTest_s) IS\n" +
                        "            WHEN \"00\" => expRPostExc_uid148_fpSubTest_q <= cstAllZWE_uid21_fpSubTest_q;\n" +
                        "            WHEN \"01\" => expRPostExc_uid148_fpSubTest_q <= expRPreExc_uid118_fpSubTest_b;\n" +
                        "            WHEN \"10\" => expRPostExc_uid148_fpSubTest_q <= cstAllOWE_uid19_fpSubTest_q;\n" +
                        "            WHEN \"11\" => expRPostExc_uid148_fpSubTest_q <= cstAllOWE_uid19_fpSubTest_q;\n" +
                        "            WHEN OTHERS => expRPostExc_uid148_fpSubTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- oneFracRPostExc2_uid141_fpSubTest(CONSTANT,140)\n" +
                        "    oneFracRPostExc2_uid141_fpSubTest_q <= \"00000000000000000000001\";\n" +
                        "\n" +
                        "    -- fracRPreExc_uid117_fpSubTest(BITSELECT,116)@5\n" +
                        "    fracRPreExc_uid117_fpSubTest_in <= rndExpFrac_uid105_fpSubTest_q(23 downto 0);\n" +
                        "    fracRPreExc_uid117_fpSubTest_b <= fracRPreExc_uid117_fpSubTest_in(23 downto 1);\n" +
                        "\n" +
                        "    -- fracRPostExc_uid144_fpSubTest(MUX,143)@5\n" +
                        "    fracRPostExc_uid144_fpSubTest_s <= excREnc_uid129_fpSubTest_q;\n" +
                        "    fracRPostExc_uid144_fpSubTest_combproc: PROCESS (fracRPostExc_uid144_fpSubTest_s, cstZeroWF_uid20_fpSubTest_q, fracRPreExc_uid117_fpSubTest_b, oneFracRPostExc2_uid141_fpSubTest_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (fracRPostExc_uid144_fpSubTest_s) IS\n" +
                        "            WHEN \"00\" => fracRPostExc_uid144_fpSubTest_q <= cstZeroWF_uid20_fpSubTest_q;\n" +
                        "            WHEN \"01\" => fracRPostExc_uid144_fpSubTest_q <= fracRPreExc_uid117_fpSubTest_b;\n" +
                        "            WHEN \"10\" => fracRPostExc_uid144_fpSubTest_q <= cstZeroWF_uid20_fpSubTest_q;\n" +
                        "            WHEN \"11\" => fracRPostExc_uid144_fpSubTest_q <= oneFracRPostExc2_uid141_fpSubTest_q;\n" +
                        "            WHEN OTHERS => fracRPostExc_uid144_fpSubTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- R_uid149_fpSubTest(BITJOIN,148)@5\n" +
                        "    R_uid149_fpSubTest_q <= signRPostExc_uid140_fpSubTest_q & expRPostExc_uid148_fpSubTest_q & fracRPostExc_uid144_fpSubTest_q;\n" +
                        "\n" +
                        "    -- xOut(GPOUT,4)@5\n" +
                        "    q <= R_uid149_fpSubTest_q;\n" +
                        "\n" +
                        "END normal;";
        new GeneralFunctions().write_file(Project_Folder_File, data1, data2, data3);
    }
    
    private void generate_FP_MUL_32_qip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -entity \"FP_MUL_32\" -library \"FP_MUL_32\" -name IP_TOOL_NAME \"altera_fp_functions\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32\" -library \"FP_MUL_32\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32\" -library \"FP_MUL_32\" -name IP_TOOL_ENV \"mwpim\"\n" +
                        "set_global_assignment -library \"FP_MUL_32\" -name MISC_FILE [file join $::quartus(qip_path) \"FP_MUL_32.cmp\"]\n" +
                        "set_global_assignment -entity \"FP_MUL_32\" -library \"FP_MUL_32\" -name IP_TARGETED_DEVICE_FAMILY \"Cyclone V\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32\" -library \"FP_MUL_32\" -name IP_GENERATED_DEVICE_FAMILY \"{Cyclone V}\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32\" -library \"FP_MUL_32\" -name IP_QSYS_MODE \"UNKNOWN\"\n" +
                        "set_global_assignment -name SYNTHESIS_ONLY_QIP ON\n" +
                        "set_global_assignment -entity \"FP_MUL_32\" -library \"FP_MUL_32\" -name IP_COMPONENT_NAME \"RlBfTVVMXzMy\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32\" -library \"FP_MUL_32\" -name IP_COMPONENT_DISPLAY_NAME \"QUxURVJBX0ZQX0ZVTkNUSU9OUw==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32\" -library \"FP_MUL_32\" -name IP_COMPONENT_REPORT_HIERARCHY \"Off\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32\" -library \"FP_MUL_32\" -name IP_COMPONENT_INTERNAL \"Off\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32\" -library \"FP_MUL_32\" -name IP_COMPONENT_AUTHOR \"QWx0ZXJhIENvcnBvcmF0aW9u\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32\" -library \"FP_MUL_32\" -name IP_COMPONENT_VERSION \"MTguMA==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32\" -library \"FP_MUL_32\" -name IP_COMPONENT_DESCRIPTION \"QSBjb2xsZWN0aW9uIG9mIGZsb2F0aW5nIHBvaW50IGZ1bmN0aW9ucw==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_NAME \"RlBfTVVMXzMyXzAwMDI=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_DISPLAY_NAME \"QUxURVJBX0ZQX0ZVTkNUSU9OUw==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_REPORT_HIERARCHY \"Off\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_INTERNAL \"Off\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_AUTHOR \"QWx0ZXJhIENvcnBvcmF0aW9u\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_VERSION \"MTguMA==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_DESCRIPTION \"QSBjb2xsZWN0aW9uIG9mIGZsb2F0aW5nIHBvaW50IGZ1bmN0aW9ucw==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"RlVOQ1RJT05fRkFNSUxZ::QVJJVEg=::RmFtaWx5\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"QVJJVEhfZnVuY3Rpb24=::TVVM::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"Q09OVkVSVF9mdW5jdGlvbg==::RlhQX0ZQ::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"QUxMX2Z1bmN0aW9u::QURE::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"RVhQX0xPR19mdW5jdGlvbg==::RVhQRQ==::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"VFJJR19mdW5jdGlvbg==::U0lO::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"Q09NUEFSRV9mdW5jdGlvbg==::TUlO::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"Uk9PVFNfZnVuY3Rpb24=::U1FSVA==::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"ZGVyaXZlZGZ1bmN0aW9u::TVVM::ZGVyaXZlZGZ1bmN0aW9u\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"ZnBfZm9ybWF0::c2luZ2xl::Rm9ybWF0\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"ZnBfZXhw::OA==::RXhwb25lbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"ZnBfZXhwX2Rlcml2ZWQ=::OA==::ZnBfZXhwX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"ZnBfbWFu::MjM=::TWFudGlzc2E=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"ZnBfbWFuX2Rlcml2ZWQ=::MjM=::ZnBfbWFuX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"ZXhwb25lbnRfd2lkdGg=::MjM=::RXhwb25lbnQgV2lkdGg=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"ZnJlcXVlbmN5X3RhcmdldA==::MTAw::VGFyZ2V0\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"bGF0ZW5jeV90YXJnZXQ=::Mg==::VGFyZ2V0\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"cGVyZm9ybWFuY2VfZ29hbA==::ZnJlcXVlbmN5::R29hbA==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"cm91bmRpbmdfbW9kZQ==::bmVhcmVzdCB3aXRoIHRpZSBicmVha2luZyBhd2F5IGZyb20gemVybw==::TW9kZQ==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"cm91bmRpbmdfbW9kZV9kZXJpdmVk::bmVhcmVzdCB3aXRoIHRpZSBicmVha2luZyB0byBldmVu::TW9kZQ==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"dXNlX3JvdW5kaW5nX21vZGU=::dHJ1ZQ==::dXNlX3JvdW5kaW5nX21vZGU=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"ZmFpdGhmdWxfcm91bmRpbmc=::ZmFsc2U=::UmVsYXggcm91bmRpbmcgdG8gcm91bmQgdXAgb3IgZG93biB0byByZWR1Y2UgcmVzb3VyY2UgdXNhZ2U=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"Z2VuX2VuYWJsZQ==::ZmFsc2U=::R2VuZXJhdGUgYW4gZW5hYmxlIHBvcnQ=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"ZGl2aWRlX3R5cGU=::MA==::TWV0aG9k\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"c2VsZWN0X3NpZ25hbF9lbmFibGU=::ZmFsc2U=::VXNlIFNlbGVjdCBTaWduYWw=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"c2NhbGVfYnlfcGk=::ZmFsc2U=::UmVwcmVzZW50IGFuZ2xlIGFzIG11bHRpcGxlIG9mIFBp\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"bnVtYmVyX29mX2lucHV0cw==::Mg==::SW5wdXQgVmVjdG9yIERpbWVuc2lvbg==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"dHJpZ19ub19yYW5nZV9yZWR1Y3Rpb24=::ZmFsc2U=::SW5wdXRzIGFyZSB3aXRoaW4gcmFuZ2UgLTJwaSB0byArMnBp\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"cmVwb3J0X3Jlc291cmNlc190b194bWw=::ZmFsc2U=::cmVwb3J0X3Jlc291cmNlc190b194bWw=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"ZnhwdF93aWR0aA==::MzI=::V2lkdGg=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"ZnhwdF9mcmFjdGlvbg==::MA==::RnJhY3Rpb24=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"ZnhwdF9zaWdu::MQ==::U2lnbg==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"ZnJlcXVlbmN5X2ZlZWRiYWNr::MA==::ZnJlcXVlbmN5X2ZlZWRiYWNr\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"bGF0ZW5jeV9mZWVkYmFjaw==::NA==::bGF0ZW5jeV9mZWVkYmFjaw==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"Zm9yY2VfZWxhYm9yYXRl::MA==::Zm9yY2VfZWxhYm9yYXRl\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X2Zvcm1hdA==::c2luZ2xl::T3V0cHV0IEZvcm1hdA==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X2V4cA==::OA==::T3V0cHV0IEV4cG9uZW50\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X2V4cF9kZXJpdmVk::OA==::ZnBfb3V0X2V4cF9kZXJpdmVk\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X21hbg==::MjM=::T3V0cHV0IE1hbnRpc3Nh\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X21hbl9kZXJpdmVk::OA==::ZnBfb3V0X21hbl9kZXJpdmVk\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fZm9ybWF0::c2luZ2xl::SW5wdXQgRm9ybWF0\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fZXhw::OA==::SW5wdXQgRXhwb25lbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fZXhwX2Rlcml2ZWQ=::OA==::ZnBfaW5fZXhwX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fbWFu::MjM=::SW5wdXQgTWFudGlzc2E=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fbWFuX2Rlcml2ZWQ=::OA==::ZnBfaW5fbWFuX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"ZW5hYmxlX2hhcmRfZnA=::dHJ1ZQ==::RW5hYmxlIEhhcmQgRmxvYXRpbmcgUG9pbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"bWFudWFsX2RzcF9wbGFubmluZw==::dHJ1ZQ==::RW5hYmxlIEhhcmQgRmxvYXRpbmcgUG9pbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"Zm9yY2VSZWdpc3RlcnM=::MTExMQ==::Zm9yY2VSZWdpc3RlcnM=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"UkVTX0RTUF9wYXJhbQ==::Mg==::TXVsdGlwbGllcw==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"UkVTX0xVVF9wYXJhbQ==::MjE5::TFVUcw==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"UkVTX01CSVRfcGFyYW0=::MA==::TWVtb3J5IEJpdHM=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"UkVTX01CTE9DS19wYXJhbQ==::MA==::TWVtb3J5IEJsb2Nrcw==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"c2VsZWN0ZWRfZGV2aWNlX2ZhbWlseQ==::Q3ljbG9uZSBW::c2VsZWN0ZWRfZGV2aWNlX2ZhbWlseQ==\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"c2VsZWN0ZWRfZGV2aWNlX3NwZWVkZ3JhZGU=::Nw==::c2VsZWN0ZWRfZGV2aWNlX3NwZWVkZ3JhZGU=\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_COMPONENT_PARAMETER \"dmFsaWRhdGlvbl9mYWlsZWQ=::ZmFsc2U=::dmFsaWRhdGlvbl9mYWlsZWQ=\"\n" +
                        "\n" +
                        "set_global_assignment -library \"FP_MUL_32\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_MUL_32.vhd\"]\n" +
                        "set_global_assignment -library \"FP_MUL_32\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_MUL_32/dspba_library_package.vhd\"]\n" +
                        "set_global_assignment -library \"FP_MUL_32\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_MUL_32/dspba_library.vhd\"]\n" +
                        "set_global_assignment -library \"FP_MUL_32\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_MUL_32/FP_MUL_32_0002.vhd\"]\n" +
                        "\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_TOOL_NAME \"altera_fp_functions\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32_0002\" -library \"FP_MUL_32\" -name IP_TOOL_ENV \"mwpim\"";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_FP_MUL_32_sip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -entity \"FP_MUL_32\" -library \"lib_FP_MUL_32\" -name IP_TOOL_NAME \"altera_fp_functions\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32\" -library \"lib_FP_MUL_32\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"FP_MUL_32\" -library \"lib_FP_MUL_32\" -name IP_TOOL_ENV \"mwpim\"\n" +
                        "set_global_assignment -library \"lib_FP_MUL_32\" -name SPD_FILE [file join $::quartus(sip_path) \"FP_MUL_32.spd\"]\n" +
                        "\n" +
                        "set_global_assignment -library \"lib_FP_MUL_32\" -name MISC_FILE [file join $::quartus(sip_path) \"FP_MUL_32_sim/dspba_library_package.vhd\"]\n" +
                        "set_global_assignment -library \"lib_FP_MUL_32\" -name MISC_FILE [file join $::quartus(sip_path) \"FP_MUL_32_sim/dspba_library.vhd\"]\n" +
                        "set_global_assignment -library \"lib_FP_MUL_32\" -name MISC_FILE [file join $::quartus(sip_path) \"FP_MUL_32_sim/FP_MUL_32.vhd\"]";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_FP_MUL_32_vhd_file(String Project_Folder_File) {
        String data =   "-- megafunction wizard: %ALTERA_FP_FUNCTIONS v18.0%\n" +
                        "-- GENERATION: XML\n" +
                        "-- FP_MUL_32.vhd\n" +
                        "\n" +
                        "-- Generated using ACDS version 18.0 614\n" +
                        "\n" +
                        "library IEEE;\n" +
                        "use IEEE.std_logic_1164.all;\n" +
                        "use IEEE.numeric_std.all;\n" +
                        "\n" +
                        "entity FP_MUL_32 is\n" +
                        "	port (\n" +
                        "		clk    : in  std_logic                     := '0';             --    clk.clk\n" +
                        "		areset : in  std_logic                     := '0';             -- areset.reset\n" +
                        "		a      : in  std_logic_vector(31 downto 0) := (others => '0'); --      a.a\n" +
                        "		b      : in  std_logic_vector(31 downto 0) := (others => '0'); --      b.b\n" +
                        "		q      : out std_logic_vector(31 downto 0)                     --      q.q\n" +
                        "	);\n" +
                        "end entity FP_MUL_32;\n" +
                        "\n" +
                        "architecture rtl of FP_MUL_32 is\n" +
                        "	component FP_MUL_32_0002 is\n" +
                        "		port (\n" +
                        "			clk    : in  std_logic                     := 'X';             -- clk\n" +
                        "			areset : in  std_logic                     := 'X';             -- reset\n" +
                        "			a      : in  std_logic_vector(31 downto 0) := (others => 'X'); -- a\n" +
                        "			b      : in  std_logic_vector(31 downto 0) := (others => 'X'); -- b\n" +
                        "			q      : out std_logic_vector(31 downto 0)                     -- q\n" +
                        "		);\n" +
                        "	end component FP_MUL_32_0002;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "	fp_mul_32_inst : component FP_MUL_32_0002\n" +
                        "		port map (\n" +
                        "			clk    => clk,    --    clk.clk\n" +
                        "			areset => areset, -- areset.reset\n" +
                        "			a      => a,      --      a.a\n" +
                        "			b      => b,      --      b.b\n" +
                        "			q      => q       --      q.q\n" +
                        "		);\n" +
                        "\n" +
                        "end architecture rtl; -- of FP_MUL_32\n" +
                        "-- Retrieval info: <?xml version=\"1.0\"?>\n" +
                        "--<!--\n" +
                        "--	Generated by Altera MegaWizard Launcher Utility version 1.0\n" +
                        "--	************************************************************\n" +
                        "--	THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!\n" +
                        "--	************************************************************\n" +
                        "--	Copyright (C) 1991-2020 Altera Corporation\n" +
                        "--	Any megafunction design, and related net list (encrypted or decrypted),\n" +
                        "--	support information, device programming or simulation file, and any other\n" +
                        "--	associated documentation or information provided by Altera or a partner\n" +
                        "--	under Altera's Megafunction Partnership Program may be used only to\n" +
                        "--	program PLD devices (but not masked PLD devices) from Altera.  Any other\n" +
                        "--	use of such megafunction design, net list, support information, device\n" +
                        "--	programming or simulation file, or any other related documentation or\n" +
                        "--	information is prohibited for any other purpose, including, but not\n" +
                        "--	limited to modification, reverse engineering, de-compiling, or use with\n" +
                        "--	any other silicon devices, unless such use is explicitly licensed under\n" +
                        "--	a separate agreement with Altera or a megafunction partner.  Title to\n" +
                        "--	the intellectual property, including patents, copyrights, trademarks,\n" +
                        "--	trade secrets, or maskworks, embodied in any such megafunction design,\n" +
                        "--	net list, support information, device programming or simulation file, or\n" +
                        "--	any other related documentation or information provided by Altera or a\n" +
                        "--	megafunction partner, remains with Altera, the megafunction partner, or\n" +
                        "--	their respective licensors.  No other licenses, including any licenses\n" +
                        "--	needed under any third party's intellectual property, are provided herein.\n" +
                        "---->\n" +
                        "-- Retrieval info: <instance entity-name=\"altera_fp_functions\" version=\"18.0\" >\n" +
                        "-- Retrieval info: 	<generic name=\"FUNCTION_FAMILY\" value=\"ARITH\" />\n" +
                        "-- Retrieval info: 	<generic name=\"ARITH_function\" value=\"MUL\" />\n" +
                        "-- Retrieval info: 	<generic name=\"CONVERT_function\" value=\"FXP_FP\" />\n" +
                        "-- Retrieval info: 	<generic name=\"ALL_function\" value=\"ADD\" />\n" +
                        "-- Retrieval info: 	<generic name=\"EXP_LOG_function\" value=\"EXPE\" />\n" +
                        "-- Retrieval info: 	<generic name=\"TRIG_function\" value=\"SIN\" />\n" +
                        "-- Retrieval info: 	<generic name=\"COMPARE_function\" value=\"MIN\" />\n" +
                        "-- Retrieval info: 	<generic name=\"ROOTS_function\" value=\"SQRT\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_format\" value=\"single\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_exp\" value=\"8\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_man\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"exponent_width\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"frequency_target\" value=\"100\" />\n" +
                        "-- Retrieval info: 	<generic name=\"latency_target\" value=\"2\" />\n" +
                        "-- Retrieval info: 	<generic name=\"performance_goal\" value=\"frequency\" />\n" +
                        "-- Retrieval info: 	<generic name=\"rounding_mode\" value=\"nearest with tie breaking away from zero\" />\n" +
                        "-- Retrieval info: 	<generic name=\"faithful_rounding\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gen_enable\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"divide_type\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"select_signal_enable\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"scale_by_pi\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"number_of_inputs\" value=\"2\" />\n" +
                        "-- Retrieval info: 	<generic name=\"trig_no_range_reduction\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"report_resources_to_xml\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fxpt_width\" value=\"32\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fxpt_fraction\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fxpt_sign\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_out_format\" value=\"single\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_out_exp\" value=\"8\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_out_man\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_in_format\" value=\"single\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_in_exp\" value=\"8\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_in_man\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"enable_hard_fp\" value=\"true\" />\n" +
                        "-- Retrieval info: 	<generic name=\"manual_dsp_planning\" value=\"true\" />\n" +
                        "-- Retrieval info: 	<generic name=\"forceRegisters\" value=\"1111\" />\n" +
                        "-- Retrieval info: 	<generic name=\"selected_device_family\" value=\"Cyclone V\" />\n" +
                        "-- Retrieval info: 	<generic name=\"selected_device_speedgrade\" value=\"7\" />\n" +
                        "-- Retrieval info: </instance>\n" +
                        "-- IPFS_FILES : FP_MUL_32.vho\n" +
                        "-- RELATED_FILES: FP_MUL_32.vhd, dspba_library_package.vhd, dspba_library.vhd, FP_MUL_32_0002.vhd";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_FP_MUL_32_0002_vhd_file(String Project_Folder_File) {
        String data =   "-- ------------------------------------------------------------------------- \n" +
                        "-- High Level Design Compiler for Intel(R) FPGAs Version 18.0 (Release Build #614)\n" +
                        "-- Quartus Prime development tool and MATLAB/Simulink Interface\n" +
                        "-- \n" +
                        "-- Legal Notice: Copyright 2018 Intel Corporation.  All rights reserved.\n" +
                        "-- Your use of  Intel Corporation's design tools,  logic functions and other\n" +
                        "-- software and  tools, and its AMPP partner logic functions, and any output\n" +
                        "-- files any  of the foregoing (including  device programming  or simulation\n" +
                        "-- files), and  any associated  documentation  or information  are expressly\n" +
                        "-- subject  to the terms and  conditions of the  Intel FPGA Software License\n" +
                        "-- Agreement, Intel MegaCore Function License Agreement, or other applicable\n" +
                        "-- license agreement,  including,  without limitation,  that your use is for\n" +
                        "-- the  sole  purpose of  programming  logic devices  manufactured by  Intel\n" +
                        "-- and  sold by Intel  or its authorized  distributors. Please refer  to the\n" +
                        "-- applicable agreement for further details.\n" +
                        "-- ---------------------------------------------------------------------------\n" +
                        "\n" +
                        "-- VHDL created from FP_MUL_32_0002\n" +
                        "-- VHDL created on Fri Jul 24 01:45:14 2020\n" +
                        "\n" +
                        "\n" +
                        "library IEEE;\n" +
                        "use IEEE.std_logic_1164.all;\n" +
                        "use IEEE.NUMERIC_STD.all;\n" +
                        "use IEEE.MATH_REAL.all;\n" +
                        "use std.TextIO.all;\n" +
                        "use work.dspba_library_package.all;\n" +
                        "\n" +
                        "LIBRARY altera_mf;\n" +
                        "USE altera_mf.altera_mf_components.all;\n" +
                        "LIBRARY altera_lnsim;\n" +
                        "USE altera_lnsim.altera_lnsim_components.altera_syncram;\n" +
                        "LIBRARY lpm;\n" +
                        "USE lpm.lpm_components.all;\n" +
                        "\n" +
                        "entity FP_MUL_32_0002 is\n" +
                        "    port (\n" +
                        "        a : in std_logic_vector(31 downto 0);  -- float32_m23\n" +
                        "        b : in std_logic_vector(31 downto 0);  -- float32_m23\n" +
                        "        q : out std_logic_vector(31 downto 0);  -- float32_m23\n" +
                        "        clk : in std_logic;\n" +
                        "        areset : in std_logic\n" +
                        "    );\n" +
                        "end FP_MUL_32_0002;\n" +
                        "\n" +
                        "architecture normal of FP_MUL_32_0002 is\n" +
                        "\n" +
                        "    attribute altera_attribute : string;\n" +
                        "    attribute altera_attribute of normal : architecture is \"-name AUTO_SHIFT_REGISTER_RECOGNITION OFF; -name PHYSICAL_SYNTHESIS_REGISTER_DUPLICATION ON; -name MESSAGE_DISABLE 10036; -name MESSAGE_DISABLE 10037; -name MESSAGE_DISABLE 14130; -name MESSAGE_DISABLE 14320; -name MESSAGE_DISABLE 15400; -name MESSAGE_DISABLE 14130; -name MESSAGE_DISABLE 10036; -name MESSAGE_DISABLE 12020; -name MESSAGE_DISABLE 12030; -name MESSAGE_DISABLE 12010; -name MESSAGE_DISABLE 12110; -name MESSAGE_DISABLE 14320; -name MESSAGE_DISABLE 13410; -name MESSAGE_DISABLE 113007\";\n" +
                        "    \n" +
                        "    signal GND_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal VCC_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expX_uid6_fpMulTest_b : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal expY_uid7_fpMulTest_b : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal signX_uid8_fpMulTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal signY_uid9_fpMulTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal cstAllOWE_uid10_fpMulTest_q : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal cstZeroWF_uid11_fpMulTest_q : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal cstAllZWE_uid12_fpMulTest_q : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal frac_x_uid14_fpMulTest_b : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal excZ_x_uid15_fpMulTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excZ_x_uid15_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expXIsMax_uid16_fpMulTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expXIsMax_uid16_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsZero_uid17_fpMulTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsZero_uid17_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsNotZero_uid18_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excI_x_uid19_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excN_x_uid20_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal invExpXIsMax_uid21_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal InvExpXIsZero_uid22_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excR_x_uid23_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal frac_y_uid28_fpMulTest_b : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal excZ_y_uid29_fpMulTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excZ_y_uid29_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expXIsMax_uid30_fpMulTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expXIsMax_uid30_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsZero_uid31_fpMulTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsZero_uid31_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsNotZero_uid32_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excI_y_uid33_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excN_y_uid34_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal invExpXIsMax_uid35_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal InvExpXIsZero_uid36_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excR_y_uid37_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal ofracX_uid40_fpMulTest_q : STD_LOGIC_VECTOR (23 downto 0);\n" +
                        "    signal ofracY_uid43_fpMulTest_q : STD_LOGIC_VECTOR (23 downto 0);\n" +
                        "    signal expSum_uid44_fpMulTest_a : STD_LOGIC_VECTOR (8 downto 0);\n" +
                        "    signal expSum_uid44_fpMulTest_b : STD_LOGIC_VECTOR (8 downto 0);\n" +
                        "    signal expSum_uid44_fpMulTest_o : STD_LOGIC_VECTOR (8 downto 0);\n" +
                        "    signal expSum_uid44_fpMulTest_q : STD_LOGIC_VECTOR (8 downto 0);\n" +
                        "    signal biasInc_uid45_fpMulTest_q : STD_LOGIC_VECTOR (9 downto 0);\n" +
                        "    signal expSumMBias_uid46_fpMulTest_a : STD_LOGIC_VECTOR (11 downto 0);\n" +
                        "    signal expSumMBias_uid46_fpMulTest_b : STD_LOGIC_VECTOR (11 downto 0);\n" +
                        "    signal expSumMBias_uid46_fpMulTest_o : STD_LOGIC_VECTOR (11 downto 0);\n" +
                        "    signal expSumMBias_uid46_fpMulTest_q : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal signR_uid48_fpMulTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal signR_uid48_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal normalizeBit_uid49_fpMulTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracRPostNormHigh_uid51_fpMulTest_in : STD_LOGIC_VECTOR (46 downto 0);\n" +
                        "    signal fracRPostNormHigh_uid51_fpMulTest_b : STD_LOGIC_VECTOR (23 downto 0);\n" +
                        "    signal fracRPostNormLow_uid52_fpMulTest_in : STD_LOGIC_VECTOR (45 downto 0);\n" +
                        "    signal fracRPostNormLow_uid52_fpMulTest_b : STD_LOGIC_VECTOR (23 downto 0);\n" +
                        "    signal fracRPostNorm_uid53_fpMulTest_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracRPostNorm_uid53_fpMulTest_q : STD_LOGIC_VECTOR (23 downto 0);\n" +
                        "    signal stickyRange_uid54_fpMulTest_in : STD_LOGIC_VECTOR (21 downto 0);\n" +
                        "    signal stickyRange_uid54_fpMulTest_b : STD_LOGIC_VECTOR (21 downto 0);\n" +
                        "    signal extraStickyBitOfProd_uid55_fpMulTest_in : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal extraStickyBitOfProd_uid55_fpMulTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal extraStickyBit_uid56_fpMulTest_s : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal extraStickyBit_uid56_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal stickyExtendedRange_uid57_fpMulTest_q : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal stickyRangeComparator_uid59_fpMulTest_qi : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal stickyRangeComparator_uid59_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal sticky_uid60_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracRPostNorm1dto0_uid61_fpMulTest_in : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal fracRPostNorm1dto0_uid61_fpMulTest_b : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal lrs_uid62_fpMulTest_q : STD_LOGIC_VECTOR (2 downto 0);\n" +
                        "    signal roundBitDetectionConstant_uid63_fpMulTest_q : STD_LOGIC_VECTOR (2 downto 0);\n" +
                        "    signal roundBitDetectionPattern_uid64_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal roundBit_uid65_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expFracPreRound_uid66_fpMulTest_q : STD_LOGIC_VECTOR (34 downto 0);\n" +
                        "    signal roundBitAndNormalizationOp_uid68_fpMulTest_q : STD_LOGIC_VECTOR (25 downto 0);\n" +
                        "    signal expFracRPostRounding_uid69_fpMulTest_a : STD_LOGIC_VECTOR (36 downto 0);\n" +
                        "    signal expFracRPostRounding_uid69_fpMulTest_b : STD_LOGIC_VECTOR (36 downto 0);\n" +
                        "    signal expFracRPostRounding_uid69_fpMulTest_o : STD_LOGIC_VECTOR (36 downto 0);\n" +
                        "    signal expFracRPostRounding_uid69_fpMulTest_q : STD_LOGIC_VECTOR (35 downto 0);\n" +
                        "    signal fracRPreExc_uid70_fpMulTest_in : STD_LOGIC_VECTOR (23 downto 0);\n" +
                        "    signal fracRPreExc_uid70_fpMulTest_b : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal expRPreExcExt_uid71_fpMulTest_b : STD_LOGIC_VECTOR (11 downto 0);\n" +
                        "    signal expRPreExc_uid72_fpMulTest_in : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal expRPreExc_uid72_fpMulTest_b : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal expUdf_uid73_fpMulTest_a : STD_LOGIC_VECTOR (13 downto 0);\n" +
                        "    signal expUdf_uid73_fpMulTest_b : STD_LOGIC_VECTOR (13 downto 0);\n" +
                        "    signal expUdf_uid73_fpMulTest_o : STD_LOGIC_VECTOR (13 downto 0);\n" +
                        "    signal expUdf_uid73_fpMulTest_n : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expOvf_uid75_fpMulTest_a : STD_LOGIC_VECTOR (13 downto 0);\n" +
                        "    signal expOvf_uid75_fpMulTest_b : STD_LOGIC_VECTOR (13 downto 0);\n" +
                        "    signal expOvf_uid75_fpMulTest_o : STD_LOGIC_VECTOR (13 downto 0);\n" +
                        "    signal expOvf_uid75_fpMulTest_n : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excXZAndExcYZ_uid76_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excXZAndExcYR_uid77_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excYZAndExcXR_uid78_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excZC3_uid79_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excRZero_uid80_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excXIAndExcYI_uid81_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excXRAndExcYI_uid82_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excYRAndExcXI_uid83_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal ExcROvfAndInReg_uid84_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excRInf_uid85_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excYZAndExcXI_uid86_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excXZAndExcYI_uid87_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal ZeroTimesInf_uid88_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excRNaN_uid89_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal concExc_uid90_fpMulTest_q : STD_LOGIC_VECTOR (2 downto 0);\n" +
                        "    signal excREnc_uid91_fpMulTest_q : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal oneFracRPostExc2_uid92_fpMulTest_q : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal fracRPostExc_uid95_fpMulTest_s : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal fracRPostExc_uid95_fpMulTest_q : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal expRPostExc_uid100_fpMulTest_s : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal expRPostExc_uid100_fpMulTest_q : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal invExcRNaN_uid101_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal signRPostExc_uid102_fpMulTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal R_uid103_fpMulTest_q : STD_LOGIC_VECTOR (31 downto 0);\n" +
                        "    signal prodXY_uid105_prod_uid47_fpMulTest_cma_reset : std_logic;\n" +
                        "    type prodXY_uid105_prod_uid47_fpMulTest_cma_a0type is array(NATURAL range <>) of UNSIGNED(23 downto 0);\n" +
                        "    signal prodXY_uid105_prod_uid47_fpMulTest_cma_a0 : prodXY_uid105_prod_uid47_fpMulTest_cma_a0type(0 to 0);\n" +
                        "    attribute preserve : boolean;\n" +
                        "    attribute preserve of prodXY_uid105_prod_uid47_fpMulTest_cma_a0 : signal is true;\n" +
                        "    signal prodXY_uid105_prod_uid47_fpMulTest_cma_c0 : prodXY_uid105_prod_uid47_fpMulTest_cma_a0type(0 to 0);\n" +
                        "    attribute preserve of prodXY_uid105_prod_uid47_fpMulTest_cma_c0 : signal is true;\n" +
                        "    type prodXY_uid105_prod_uid47_fpMulTest_cma_ptype is array(NATURAL range <>) of UNSIGNED(47 downto 0);\n" +
                        "    signal prodXY_uid105_prod_uid47_fpMulTest_cma_p : prodXY_uid105_prod_uid47_fpMulTest_cma_ptype(0 to 0);\n" +
                        "    signal prodXY_uid105_prod_uid47_fpMulTest_cma_u : prodXY_uid105_prod_uid47_fpMulTest_cma_ptype(0 to 0);\n" +
                        "    signal prodXY_uid105_prod_uid47_fpMulTest_cma_w : prodXY_uid105_prod_uid47_fpMulTest_cma_ptype(0 to 0);\n" +
                        "    signal prodXY_uid105_prod_uid47_fpMulTest_cma_x : prodXY_uid105_prod_uid47_fpMulTest_cma_ptype(0 to 0);\n" +
                        "    signal prodXY_uid105_prod_uid47_fpMulTest_cma_y : prodXY_uid105_prod_uid47_fpMulTest_cma_ptype(0 to 0);\n" +
                        "    signal prodXY_uid105_prod_uid47_fpMulTest_cma_s : prodXY_uid105_prod_uid47_fpMulTest_cma_ptype(0 to 0);\n" +
                        "    signal prodXY_uid105_prod_uid47_fpMulTest_cma_qq : STD_LOGIC_VECTOR (47 downto 0);\n" +
                        "    signal prodXY_uid105_prod_uid47_fpMulTest_cma_q : STD_LOGIC_VECTOR (47 downto 0);\n" +
                        "    signal prodXY_uid105_prod_uid47_fpMulTest_cma_ena0 : std_logic;\n" +
                        "    signal prodXY_uid105_prod_uid47_fpMulTest_cma_ena1 : std_logic;\n" +
                        "    signal redist0_expRPreExcExt_uid71_fpMulTest_b_1_q : STD_LOGIC_VECTOR (11 downto 0);\n" +
                        "    signal redist1_fracRPreExc_uid70_fpMulTest_b_1_q : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal redist2_normalizeBit_uid49_fpMulTest_b_1_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist3_signR_uid48_fpMulTest_q_4_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist4_expSum_uid44_fpMulTest_q_3_q : STD_LOGIC_VECTOR (8 downto 0);\n" +
                        "    signal redist5_fracXIsZero_uid31_fpMulTest_q_4_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist6_expXIsMax_uid30_fpMulTest_q_4_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist7_excZ_y_uid29_fpMulTest_q_4_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist8_fracXIsZero_uid17_fpMulTest_q_4_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist9_expXIsMax_uid16_fpMulTest_q_4_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist10_excZ_x_uid15_fpMulTest_q_4_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "\n" +
                        "    -- frac_x_uid14_fpMulTest(BITSELECT,13)@0\n" +
                        "    frac_x_uid14_fpMulTest_b <= a(22 downto 0);\n" +
                        "\n" +
                        "    -- cstZeroWF_uid11_fpMulTest(CONSTANT,10)\n" +
                        "    cstZeroWF_uid11_fpMulTest_q <= \"00000000000000000000000\";\n" +
                        "\n" +
                        "    -- fracXIsZero_uid17_fpMulTest(LOGICAL,16)@0 + 1\n" +
                        "    fracXIsZero_uid17_fpMulTest_qi <= \"1\" WHEN cstZeroWF_uid11_fpMulTest_q = frac_x_uid14_fpMulTest_b ELSE \"0\";\n" +
                        "    fracXIsZero_uid17_fpMulTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => fracXIsZero_uid17_fpMulTest_qi, xout => fracXIsZero_uid17_fpMulTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist8_fracXIsZero_uid17_fpMulTest_q_4(DELAY,116)\n" +
                        "    redist8_fracXIsZero_uid17_fpMulTest_q_4 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 3, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => fracXIsZero_uid17_fpMulTest_q, xout => redist8_fracXIsZero_uid17_fpMulTest_q_4_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- cstAllOWE_uid10_fpMulTest(CONSTANT,9)\n" +
                        "    cstAllOWE_uid10_fpMulTest_q <= \"11111111\";\n" +
                        "\n" +
                        "    -- expX_uid6_fpMulTest(BITSELECT,5)@0\n" +
                        "    expX_uid6_fpMulTest_b <= a(30 downto 23);\n" +
                        "\n" +
                        "    -- expXIsMax_uid16_fpMulTest(LOGICAL,15)@0 + 1\n" +
                        "    expXIsMax_uid16_fpMulTest_qi <= \"1\" WHEN expX_uid6_fpMulTest_b = cstAllOWE_uid10_fpMulTest_q ELSE \"0\";\n" +
                        "    expXIsMax_uid16_fpMulTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => expXIsMax_uid16_fpMulTest_qi, xout => expXIsMax_uid16_fpMulTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist9_expXIsMax_uid16_fpMulTest_q_4(DELAY,117)\n" +
                        "    redist9_expXIsMax_uid16_fpMulTest_q_4 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 3, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => expXIsMax_uid16_fpMulTest_q, xout => redist9_expXIsMax_uid16_fpMulTest_q_4_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- excI_x_uid19_fpMulTest(LOGICAL,18)@4\n" +
                        "    excI_x_uid19_fpMulTest_q <= redist9_expXIsMax_uid16_fpMulTest_q_4_q and redist8_fracXIsZero_uid17_fpMulTest_q_4_q;\n" +
                        "\n" +
                        "    -- cstAllZWE_uid12_fpMulTest(CONSTANT,11)\n" +
                        "    cstAllZWE_uid12_fpMulTest_q <= \"00000000\";\n" +
                        "\n" +
                        "    -- expY_uid7_fpMulTest(BITSELECT,6)@0\n" +
                        "    expY_uid7_fpMulTest_b <= b(30 downto 23);\n" +
                        "\n" +
                        "    -- excZ_y_uid29_fpMulTest(LOGICAL,28)@0 + 1\n" +
                        "    excZ_y_uid29_fpMulTest_qi <= \"1\" WHEN expY_uid7_fpMulTest_b = cstAllZWE_uid12_fpMulTest_q ELSE \"0\";\n" +
                        "    excZ_y_uid29_fpMulTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => excZ_y_uid29_fpMulTest_qi, xout => excZ_y_uid29_fpMulTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist7_excZ_y_uid29_fpMulTest_q_4(DELAY,115)\n" +
                        "    redist7_excZ_y_uid29_fpMulTest_q_4 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 3, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => excZ_y_uid29_fpMulTest_q, xout => redist7_excZ_y_uid29_fpMulTest_q_4_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- excYZAndExcXI_uid86_fpMulTest(LOGICAL,85)@4\n" +
                        "    excYZAndExcXI_uid86_fpMulTest_q <= redist7_excZ_y_uid29_fpMulTest_q_4_q and excI_x_uid19_fpMulTest_q;\n" +
                        "\n" +
                        "    -- frac_y_uid28_fpMulTest(BITSELECT,27)@0\n" +
                        "    frac_y_uid28_fpMulTest_b <= b(22 downto 0);\n" +
                        "\n" +
                        "    -- fracXIsZero_uid31_fpMulTest(LOGICAL,30)@0 + 1\n" +
                        "    fracXIsZero_uid31_fpMulTest_qi <= \"1\" WHEN cstZeroWF_uid11_fpMulTest_q = frac_y_uid28_fpMulTest_b ELSE \"0\";\n" +
                        "    fracXIsZero_uid31_fpMulTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => fracXIsZero_uid31_fpMulTest_qi, xout => fracXIsZero_uid31_fpMulTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist5_fracXIsZero_uid31_fpMulTest_q_4(DELAY,113)\n" +
                        "    redist5_fracXIsZero_uid31_fpMulTest_q_4 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 3, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => fracXIsZero_uid31_fpMulTest_q, xout => redist5_fracXIsZero_uid31_fpMulTest_q_4_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- expXIsMax_uid30_fpMulTest(LOGICAL,29)@0 + 1\n" +
                        "    expXIsMax_uid30_fpMulTest_qi <= \"1\" WHEN expY_uid7_fpMulTest_b = cstAllOWE_uid10_fpMulTest_q ELSE \"0\";\n" +
                        "    expXIsMax_uid30_fpMulTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => expXIsMax_uid30_fpMulTest_qi, xout => expXIsMax_uid30_fpMulTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist6_expXIsMax_uid30_fpMulTest_q_4(DELAY,114)\n" +
                        "    redist6_expXIsMax_uid30_fpMulTest_q_4 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 3, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => expXIsMax_uid30_fpMulTest_q, xout => redist6_expXIsMax_uid30_fpMulTest_q_4_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- excI_y_uid33_fpMulTest(LOGICAL,32)@4\n" +
                        "    excI_y_uid33_fpMulTest_q <= redist6_expXIsMax_uid30_fpMulTest_q_4_q and redist5_fracXIsZero_uid31_fpMulTest_q_4_q;\n" +
                        "\n" +
                        "    -- excZ_x_uid15_fpMulTest(LOGICAL,14)@0 + 1\n" +
                        "    excZ_x_uid15_fpMulTest_qi <= \"1\" WHEN expX_uid6_fpMulTest_b = cstAllZWE_uid12_fpMulTest_q ELSE \"0\";\n" +
                        "    excZ_x_uid15_fpMulTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => excZ_x_uid15_fpMulTest_qi, xout => excZ_x_uid15_fpMulTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist10_excZ_x_uid15_fpMulTest_q_4(DELAY,118)\n" +
                        "    redist10_excZ_x_uid15_fpMulTest_q_4 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 3, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => excZ_x_uid15_fpMulTest_q, xout => redist10_excZ_x_uid15_fpMulTest_q_4_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- excXZAndExcYI_uid87_fpMulTest(LOGICAL,86)@4\n" +
                        "    excXZAndExcYI_uid87_fpMulTest_q <= redist10_excZ_x_uid15_fpMulTest_q_4_q and excI_y_uid33_fpMulTest_q;\n" +
                        "\n" +
                        "    -- ZeroTimesInf_uid88_fpMulTest(LOGICAL,87)@4\n" +
                        "    ZeroTimesInf_uid88_fpMulTest_q <= excXZAndExcYI_uid87_fpMulTest_q or excYZAndExcXI_uid86_fpMulTest_q;\n" +
                        "\n" +
                        "    -- fracXIsNotZero_uid32_fpMulTest(LOGICAL,31)@4\n" +
                        "    fracXIsNotZero_uid32_fpMulTest_q <= not (redist5_fracXIsZero_uid31_fpMulTest_q_4_q);\n" +
                        "\n" +
                        "    -- excN_y_uid34_fpMulTest(LOGICAL,33)@4\n" +
                        "    excN_y_uid34_fpMulTest_q <= redist6_expXIsMax_uid30_fpMulTest_q_4_q and fracXIsNotZero_uid32_fpMulTest_q;\n" +
                        "\n" +
                        "    -- fracXIsNotZero_uid18_fpMulTest(LOGICAL,17)@4\n" +
                        "    fracXIsNotZero_uid18_fpMulTest_q <= not (redist8_fracXIsZero_uid17_fpMulTest_q_4_q);\n" +
                        "\n" +
                        "    -- excN_x_uid20_fpMulTest(LOGICAL,19)@4\n" +
                        "    excN_x_uid20_fpMulTest_q <= redist9_expXIsMax_uid16_fpMulTest_q_4_q and fracXIsNotZero_uid18_fpMulTest_q;\n" +
                        "\n" +
                        "    -- excRNaN_uid89_fpMulTest(LOGICAL,88)@4\n" +
                        "    excRNaN_uid89_fpMulTest_q <= excN_x_uid20_fpMulTest_q or excN_y_uid34_fpMulTest_q or ZeroTimesInf_uid88_fpMulTest_q;\n" +
                        "\n" +
                        "    -- invExcRNaN_uid101_fpMulTest(LOGICAL,100)@4\n" +
                        "    invExcRNaN_uid101_fpMulTest_q <= not (excRNaN_uid89_fpMulTest_q);\n" +
                        "\n" +
                        "    -- signY_uid9_fpMulTest(BITSELECT,8)@0\n" +
                        "    signY_uid9_fpMulTest_b <= STD_LOGIC_VECTOR(b(31 downto 31));\n" +
                        "\n" +
                        "    -- signX_uid8_fpMulTest(BITSELECT,7)@0\n" +
                        "    signX_uid8_fpMulTest_b <= STD_LOGIC_VECTOR(a(31 downto 31));\n" +
                        "\n" +
                        "    -- signR_uid48_fpMulTest(LOGICAL,47)@0 + 1\n" +
                        "    signR_uid48_fpMulTest_qi <= signX_uid8_fpMulTest_b xor signY_uid9_fpMulTest_b;\n" +
                        "    signR_uid48_fpMulTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => signR_uid48_fpMulTest_qi, xout => signR_uid48_fpMulTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- redist3_signR_uid48_fpMulTest_q_4(DELAY,111)\n" +
                        "    redist3_signR_uid48_fpMulTest_q_4 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 3, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => signR_uid48_fpMulTest_q, xout => redist3_signR_uid48_fpMulTest_q_4_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- VCC(CONSTANT,1)\n" +
                        "    VCC_q <= \"1\";\n" +
                        "\n" +
                        "    -- signRPostExc_uid102_fpMulTest(LOGICAL,101)@4\n" +
                        "    signRPostExc_uid102_fpMulTest_q <= redist3_signR_uid48_fpMulTest_q_4_q and invExcRNaN_uid101_fpMulTest_q;\n" +
                        "\n" +
                        "    -- GND(CONSTANT,0)\n" +
                        "    GND_q <= \"0\";\n" +
                        "\n" +
                        "    -- ofracY_uid43_fpMulTest(BITJOIN,42)@0\n" +
                        "    ofracY_uid43_fpMulTest_q <= VCC_q & frac_y_uid28_fpMulTest_b;\n" +
                        "\n" +
                        "    -- ofracX_uid40_fpMulTest(BITJOIN,39)@0\n" +
                        "    ofracX_uid40_fpMulTest_q <= VCC_q & frac_x_uid14_fpMulTest_b;\n" +
                        "\n" +
                        "    -- prodXY_uid105_prod_uid47_fpMulTest_cma(CHAINMULTADD,107)@0 + 2\n" +
                        "    prodXY_uid105_prod_uid47_fpMulTest_cma_reset <= areset;\n" +
                        "    prodXY_uid105_prod_uid47_fpMulTest_cma_ena0 <= '1';\n" +
                        "    prodXY_uid105_prod_uid47_fpMulTest_cma_ena1 <= prodXY_uid105_prod_uid47_fpMulTest_cma_ena0;\n" +
                        "    prodXY_uid105_prod_uid47_fpMulTest_cma_p(0) <= prodXY_uid105_prod_uid47_fpMulTest_cma_a0(0) * prodXY_uid105_prod_uid47_fpMulTest_cma_c0(0);\n" +
                        "    prodXY_uid105_prod_uid47_fpMulTest_cma_u(0) <= RESIZE(prodXY_uid105_prod_uid47_fpMulTest_cma_p(0),48);\n" +
                        "    prodXY_uid105_prod_uid47_fpMulTest_cma_w(0) <= prodXY_uid105_prod_uid47_fpMulTest_cma_u(0);\n" +
                        "    prodXY_uid105_prod_uid47_fpMulTest_cma_x(0) <= prodXY_uid105_prod_uid47_fpMulTest_cma_w(0);\n" +
                        "    prodXY_uid105_prod_uid47_fpMulTest_cma_y(0) <= prodXY_uid105_prod_uid47_fpMulTest_cma_x(0);\n" +
                        "    prodXY_uid105_prod_uid47_fpMulTest_cma_chainmultadd_input: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            prodXY_uid105_prod_uid47_fpMulTest_cma_a0 <= (others => (others => '0'));\n" +
                        "            prodXY_uid105_prod_uid47_fpMulTest_cma_c0 <= (others => (others => '0'));\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            IF (prodXY_uid105_prod_uid47_fpMulTest_cma_ena0 = '1') THEN\n" +
                        "                prodXY_uid105_prod_uid47_fpMulTest_cma_a0(0) <= RESIZE(UNSIGNED(ofracX_uid40_fpMulTest_q),24);\n" +
                        "                prodXY_uid105_prod_uid47_fpMulTest_cma_c0(0) <= RESIZE(UNSIGNED(ofracY_uid43_fpMulTest_q),24);\n" +
                        "            END IF;\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "    prodXY_uid105_prod_uid47_fpMulTest_cma_chainmultadd_output: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            prodXY_uid105_prod_uid47_fpMulTest_cma_s <= (others => (others => '0'));\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            IF (prodXY_uid105_prod_uid47_fpMulTest_cma_ena1 = '1') THEN\n" +
                        "                prodXY_uid105_prod_uid47_fpMulTest_cma_s(0) <= prodXY_uid105_prod_uid47_fpMulTest_cma_y(0);\n" +
                        "            END IF;\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "    prodXY_uid105_prod_uid47_fpMulTest_cma_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 48, depth => 0, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => STD_LOGIC_VECTOR(prodXY_uid105_prod_uid47_fpMulTest_cma_s(0)(47 downto 0)), xout => prodXY_uid105_prod_uid47_fpMulTest_cma_qq, clk => clk, aclr => areset );\n" +
                        "    prodXY_uid105_prod_uid47_fpMulTest_cma_q <= STD_LOGIC_VECTOR(prodXY_uid105_prod_uid47_fpMulTest_cma_qq(47 downto 0));\n" +
                        "\n" +
                        "    -- normalizeBit_uid49_fpMulTest(BITSELECT,48)@2\n" +
                        "    normalizeBit_uid49_fpMulTest_b <= STD_LOGIC_VECTOR(prodXY_uid105_prod_uid47_fpMulTest_cma_q(47 downto 47));\n" +
                        "\n" +
                        "    -- redist2_normalizeBit_uid49_fpMulTest_b_1(DELAY,110)\n" +
                        "    redist2_normalizeBit_uid49_fpMulTest_b_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => normalizeBit_uid49_fpMulTest_b, xout => redist2_normalizeBit_uid49_fpMulTest_b_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- roundBitDetectionConstant_uid63_fpMulTest(CONSTANT,62)\n" +
                        "    roundBitDetectionConstant_uid63_fpMulTest_q <= \"010\";\n" +
                        "\n" +
                        "    -- fracRPostNormHigh_uid51_fpMulTest(BITSELECT,50)@2\n" +
                        "    fracRPostNormHigh_uid51_fpMulTest_in <= prodXY_uid105_prod_uid47_fpMulTest_cma_q(46 downto 0);\n" +
                        "    fracRPostNormHigh_uid51_fpMulTest_b <= fracRPostNormHigh_uid51_fpMulTest_in(46 downto 23);\n" +
                        "\n" +
                        "    -- fracRPostNormLow_uid52_fpMulTest(BITSELECT,51)@2\n" +
                        "    fracRPostNormLow_uid52_fpMulTest_in <= prodXY_uid105_prod_uid47_fpMulTest_cma_q(45 downto 0);\n" +
                        "    fracRPostNormLow_uid52_fpMulTest_b <= fracRPostNormLow_uid52_fpMulTest_in(45 downto 22);\n" +
                        "\n" +
                        "    -- fracRPostNorm_uid53_fpMulTest(MUX,52)@2 + 1\n" +
                        "    fracRPostNorm_uid53_fpMulTest_s <= normalizeBit_uid49_fpMulTest_b;\n" +
                        "    fracRPostNorm_uid53_fpMulTest_clkproc: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            fracRPostNorm_uid53_fpMulTest_q <= (others => '0');\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            CASE (fracRPostNorm_uid53_fpMulTest_s) IS\n" +
                        "                WHEN \"0\" => fracRPostNorm_uid53_fpMulTest_q <= fracRPostNormLow_uid52_fpMulTest_b;\n" +
                        "                WHEN \"1\" => fracRPostNorm_uid53_fpMulTest_q <= fracRPostNormHigh_uid51_fpMulTest_b;\n" +
                        "                WHEN OTHERS => fracRPostNorm_uid53_fpMulTest_q <= (others => '0');\n" +
                        "            END CASE;\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- fracRPostNorm1dto0_uid61_fpMulTest(BITSELECT,60)@3\n" +
                        "    fracRPostNorm1dto0_uid61_fpMulTest_in <= fracRPostNorm_uid53_fpMulTest_q(1 downto 0);\n" +
                        "    fracRPostNorm1dto0_uid61_fpMulTest_b <= fracRPostNorm1dto0_uid61_fpMulTest_in(1 downto 0);\n" +
                        "\n" +
                        "    -- extraStickyBitOfProd_uid55_fpMulTest(BITSELECT,54)@2\n" +
                        "    extraStickyBitOfProd_uid55_fpMulTest_in <= STD_LOGIC_VECTOR(prodXY_uid105_prod_uid47_fpMulTest_cma_q(22 downto 0));\n" +
                        "    extraStickyBitOfProd_uid55_fpMulTest_b <= STD_LOGIC_VECTOR(extraStickyBitOfProd_uid55_fpMulTest_in(22 downto 22));\n" +
                        "\n" +
                        "    -- extraStickyBit_uid56_fpMulTest(MUX,55)@2\n" +
                        "    extraStickyBit_uid56_fpMulTest_s <= normalizeBit_uid49_fpMulTest_b;\n" +
                        "    extraStickyBit_uid56_fpMulTest_combproc: PROCESS (extraStickyBit_uid56_fpMulTest_s, GND_q, extraStickyBitOfProd_uid55_fpMulTest_b)\n" +
                        "    BEGIN\n" +
                        "        CASE (extraStickyBit_uid56_fpMulTest_s) IS\n" +
                        "            WHEN \"0\" => extraStickyBit_uid56_fpMulTest_q <= GND_q;\n" +
                        "            WHEN \"1\" => extraStickyBit_uid56_fpMulTest_q <= extraStickyBitOfProd_uid55_fpMulTest_b;\n" +
                        "            WHEN OTHERS => extraStickyBit_uid56_fpMulTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- stickyRange_uid54_fpMulTest(BITSELECT,53)@2\n" +
                        "    stickyRange_uid54_fpMulTest_in <= prodXY_uid105_prod_uid47_fpMulTest_cma_q(21 downto 0);\n" +
                        "    stickyRange_uid54_fpMulTest_b <= stickyRange_uid54_fpMulTest_in(21 downto 0);\n" +
                        "\n" +
                        "    -- stickyExtendedRange_uid57_fpMulTest(BITJOIN,56)@2\n" +
                        "    stickyExtendedRange_uid57_fpMulTest_q <= extraStickyBit_uid56_fpMulTest_q & stickyRange_uid54_fpMulTest_b;\n" +
                        "\n" +
                        "    -- stickyRangeComparator_uid59_fpMulTest(LOGICAL,58)@2 + 1\n" +
                        "    stickyRangeComparator_uid59_fpMulTest_qi <= \"1\" WHEN stickyExtendedRange_uid57_fpMulTest_q = cstZeroWF_uid11_fpMulTest_q ELSE \"0\";\n" +
                        "    stickyRangeComparator_uid59_fpMulTest_delay : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => stickyRangeComparator_uid59_fpMulTest_qi, xout => stickyRangeComparator_uid59_fpMulTest_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- sticky_uid60_fpMulTest(LOGICAL,59)@3\n" +
                        "    sticky_uid60_fpMulTest_q <= not (stickyRangeComparator_uid59_fpMulTest_q);\n" +
                        "\n" +
                        "    -- lrs_uid62_fpMulTest(BITJOIN,61)@3\n" +
                        "    lrs_uid62_fpMulTest_q <= fracRPostNorm1dto0_uid61_fpMulTest_b & sticky_uid60_fpMulTest_q;\n" +
                        "\n" +
                        "    -- roundBitDetectionPattern_uid64_fpMulTest(LOGICAL,63)@3\n" +
                        "    roundBitDetectionPattern_uid64_fpMulTest_q <= \"1\" WHEN lrs_uid62_fpMulTest_q = roundBitDetectionConstant_uid63_fpMulTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- roundBit_uid65_fpMulTest(LOGICAL,64)@3\n" +
                        "    roundBit_uid65_fpMulTest_q <= not (roundBitDetectionPattern_uid64_fpMulTest_q);\n" +
                        "\n" +
                        "    -- roundBitAndNormalizationOp_uid68_fpMulTest(BITJOIN,67)@3\n" +
                        "    roundBitAndNormalizationOp_uid68_fpMulTest_q <= GND_q & redist2_normalizeBit_uid49_fpMulTest_b_1_q & cstZeroWF_uid11_fpMulTest_q & roundBit_uid65_fpMulTest_q;\n" +
                        "\n" +
                        "    -- biasInc_uid45_fpMulTest(CONSTANT,44)\n" +
                        "    biasInc_uid45_fpMulTest_q <= \"0001111111\";\n" +
                        "\n" +
                        "    -- expSum_uid44_fpMulTest(ADD,43)@0 + 1\n" +
                        "    expSum_uid44_fpMulTest_a <= STD_LOGIC_VECTOR(\"0\" & expX_uid6_fpMulTest_b);\n" +
                        "    expSum_uid44_fpMulTest_b <= STD_LOGIC_VECTOR(\"0\" & expY_uid7_fpMulTest_b);\n" +
                        "    expSum_uid44_fpMulTest_clkproc: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            expSum_uid44_fpMulTest_o <= (others => '0');\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            expSum_uid44_fpMulTest_o <= STD_LOGIC_VECTOR(UNSIGNED(expSum_uid44_fpMulTest_a) + UNSIGNED(expSum_uid44_fpMulTest_b));\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "    expSum_uid44_fpMulTest_q <= expSum_uid44_fpMulTest_o(8 downto 0);\n" +
                        "\n" +
                        "    -- redist4_expSum_uid44_fpMulTest_q_3(DELAY,112)\n" +
                        "    redist4_expSum_uid44_fpMulTest_q_3 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 9, depth => 2, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => expSum_uid44_fpMulTest_q, xout => redist4_expSum_uid44_fpMulTest_q_3_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- expSumMBias_uid46_fpMulTest(SUB,45)@3\n" +
                        "    expSumMBias_uid46_fpMulTest_a <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR(\"000\" & redist4_expSum_uid44_fpMulTest_q_3_q));\n" +
                        "    expSumMBias_uid46_fpMulTest_b <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR((11 downto 10 => biasInc_uid45_fpMulTest_q(9)) & biasInc_uid45_fpMulTest_q));\n" +
                        "    expSumMBias_uid46_fpMulTest_o <= STD_LOGIC_VECTOR(SIGNED(expSumMBias_uid46_fpMulTest_a) - SIGNED(expSumMBias_uid46_fpMulTest_b));\n" +
                        "    expSumMBias_uid46_fpMulTest_q <= expSumMBias_uid46_fpMulTest_o(10 downto 0);\n" +
                        "\n" +
                        "    -- expFracPreRound_uid66_fpMulTest(BITJOIN,65)@3\n" +
                        "    expFracPreRound_uid66_fpMulTest_q <= expSumMBias_uid46_fpMulTest_q & fracRPostNorm_uid53_fpMulTest_q;\n" +
                        "\n" +
                        "    -- expFracRPostRounding_uid69_fpMulTest(ADD,68)@3\n" +
                        "    expFracRPostRounding_uid69_fpMulTest_a <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR((36 downto 35 => expFracPreRound_uid66_fpMulTest_q(34)) & expFracPreRound_uid66_fpMulTest_q));\n" +
                        "    expFracRPostRounding_uid69_fpMulTest_b <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR(\"00000000000\" & roundBitAndNormalizationOp_uid68_fpMulTest_q));\n" +
                        "    expFracRPostRounding_uid69_fpMulTest_o <= STD_LOGIC_VECTOR(SIGNED(expFracRPostRounding_uid69_fpMulTest_a) + SIGNED(expFracRPostRounding_uid69_fpMulTest_b));\n" +
                        "    expFracRPostRounding_uid69_fpMulTest_q <= expFracRPostRounding_uid69_fpMulTest_o(35 downto 0);\n" +
                        "\n" +
                        "    -- expRPreExcExt_uid71_fpMulTest(BITSELECT,70)@3\n" +
                        "    expRPreExcExt_uid71_fpMulTest_b <= STD_LOGIC_VECTOR(expFracRPostRounding_uid69_fpMulTest_q(35 downto 24));\n" +
                        "\n" +
                        "    -- redist0_expRPreExcExt_uid71_fpMulTest_b_1(DELAY,108)\n" +
                        "    redist0_expRPreExcExt_uid71_fpMulTest_b_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 12, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => expRPreExcExt_uid71_fpMulTest_b, xout => redist0_expRPreExcExt_uid71_fpMulTest_b_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- expRPreExc_uid72_fpMulTest(BITSELECT,71)@4\n" +
                        "    expRPreExc_uid72_fpMulTest_in <= redist0_expRPreExcExt_uid71_fpMulTest_b_1_q(7 downto 0);\n" +
                        "    expRPreExc_uid72_fpMulTest_b <= expRPreExc_uid72_fpMulTest_in(7 downto 0);\n" +
                        "\n" +
                        "    -- expOvf_uid75_fpMulTest(COMPARE,74)@4\n" +
                        "    expOvf_uid75_fpMulTest_a <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR((13 downto 12 => redist0_expRPreExcExt_uid71_fpMulTest_b_1_q(11)) & redist0_expRPreExcExt_uid71_fpMulTest_b_1_q));\n" +
                        "    expOvf_uid75_fpMulTest_b <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR(\"000000\" & cstAllOWE_uid10_fpMulTest_q));\n" +
                        "    expOvf_uid75_fpMulTest_o <= STD_LOGIC_VECTOR(SIGNED(expOvf_uid75_fpMulTest_a) - SIGNED(expOvf_uid75_fpMulTest_b));\n" +
                        "    expOvf_uid75_fpMulTest_n(0) <= not (expOvf_uid75_fpMulTest_o(13));\n" +
                        "\n" +
                        "    -- invExpXIsMax_uid35_fpMulTest(LOGICAL,34)@4\n" +
                        "    invExpXIsMax_uid35_fpMulTest_q <= not (redist6_expXIsMax_uid30_fpMulTest_q_4_q);\n" +
                        "\n" +
                        "    -- InvExpXIsZero_uid36_fpMulTest(LOGICAL,35)@4\n" +
                        "    InvExpXIsZero_uid36_fpMulTest_q <= not (redist7_excZ_y_uid29_fpMulTest_q_4_q);\n" +
                        "\n" +
                        "    -- excR_y_uid37_fpMulTest(LOGICAL,36)@4\n" +
                        "    excR_y_uid37_fpMulTest_q <= InvExpXIsZero_uid36_fpMulTest_q and invExpXIsMax_uid35_fpMulTest_q;\n" +
                        "\n" +
                        "    -- invExpXIsMax_uid21_fpMulTest(LOGICAL,20)@4\n" +
                        "    invExpXIsMax_uid21_fpMulTest_q <= not (redist9_expXIsMax_uid16_fpMulTest_q_4_q);\n" +
                        "\n" +
                        "    -- InvExpXIsZero_uid22_fpMulTest(LOGICAL,21)@4\n" +
                        "    InvExpXIsZero_uid22_fpMulTest_q <= not (redist10_excZ_x_uid15_fpMulTest_q_4_q);\n" +
                        "\n" +
                        "    -- excR_x_uid23_fpMulTest(LOGICAL,22)@4\n" +
                        "    excR_x_uid23_fpMulTest_q <= InvExpXIsZero_uid22_fpMulTest_q and invExpXIsMax_uid21_fpMulTest_q;\n" +
                        "\n" +
                        "    -- ExcROvfAndInReg_uid84_fpMulTest(LOGICAL,83)@4\n" +
                        "    ExcROvfAndInReg_uid84_fpMulTest_q <= excR_x_uid23_fpMulTest_q and excR_y_uid37_fpMulTest_q and expOvf_uid75_fpMulTest_n;\n" +
                        "\n" +
                        "    -- excYRAndExcXI_uid83_fpMulTest(LOGICAL,82)@4\n" +
                        "    excYRAndExcXI_uid83_fpMulTest_q <= excR_y_uid37_fpMulTest_q and excI_x_uid19_fpMulTest_q;\n" +
                        "\n" +
                        "    -- excXRAndExcYI_uid82_fpMulTest(LOGICAL,81)@4\n" +
                        "    excXRAndExcYI_uid82_fpMulTest_q <= excR_x_uid23_fpMulTest_q and excI_y_uid33_fpMulTest_q;\n" +
                        "\n" +
                        "    -- excXIAndExcYI_uid81_fpMulTest(LOGICAL,80)@4\n" +
                        "    excXIAndExcYI_uid81_fpMulTest_q <= excI_x_uid19_fpMulTest_q and excI_y_uid33_fpMulTest_q;\n" +
                        "\n" +
                        "    -- excRInf_uid85_fpMulTest(LOGICAL,84)@4\n" +
                        "    excRInf_uid85_fpMulTest_q <= excXIAndExcYI_uid81_fpMulTest_q or excXRAndExcYI_uid82_fpMulTest_q or excYRAndExcXI_uid83_fpMulTest_q or ExcROvfAndInReg_uid84_fpMulTest_q;\n" +
                        "\n" +
                        "    -- expUdf_uid73_fpMulTest(COMPARE,72)@4\n" +
                        "    expUdf_uid73_fpMulTest_a <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR(\"0000000000000\" & GND_q));\n" +
                        "    expUdf_uid73_fpMulTest_b <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR((13 downto 12 => redist0_expRPreExcExt_uid71_fpMulTest_b_1_q(11)) & redist0_expRPreExcExt_uid71_fpMulTest_b_1_q));\n" +
                        "    expUdf_uid73_fpMulTest_o <= STD_LOGIC_VECTOR(SIGNED(expUdf_uid73_fpMulTest_a) - SIGNED(expUdf_uid73_fpMulTest_b));\n" +
                        "    expUdf_uid73_fpMulTest_n(0) <= not (expUdf_uid73_fpMulTest_o(13));\n" +
                        "\n" +
                        "    -- excZC3_uid79_fpMulTest(LOGICAL,78)@4\n" +
                        "    excZC3_uid79_fpMulTest_q <= excR_x_uid23_fpMulTest_q and excR_y_uid37_fpMulTest_q and expUdf_uid73_fpMulTest_n;\n" +
                        "\n" +
                        "    -- excYZAndExcXR_uid78_fpMulTest(LOGICAL,77)@4\n" +
                        "    excYZAndExcXR_uid78_fpMulTest_q <= redist7_excZ_y_uid29_fpMulTest_q_4_q and excR_x_uid23_fpMulTest_q;\n" +
                        "\n" +
                        "    -- excXZAndExcYR_uid77_fpMulTest(LOGICAL,76)@4\n" +
                        "    excXZAndExcYR_uid77_fpMulTest_q <= redist10_excZ_x_uid15_fpMulTest_q_4_q and excR_y_uid37_fpMulTest_q;\n" +
                        "\n" +
                        "    -- excXZAndExcYZ_uid76_fpMulTest(LOGICAL,75)@4\n" +
                        "    excXZAndExcYZ_uid76_fpMulTest_q <= redist10_excZ_x_uid15_fpMulTest_q_4_q and redist7_excZ_y_uid29_fpMulTest_q_4_q;\n" +
                        "\n" +
                        "    -- excRZero_uid80_fpMulTest(LOGICAL,79)@4\n" +
                        "    excRZero_uid80_fpMulTest_q <= excXZAndExcYZ_uid76_fpMulTest_q or excXZAndExcYR_uid77_fpMulTest_q or excYZAndExcXR_uid78_fpMulTest_q or excZC3_uid79_fpMulTest_q;\n" +
                        "\n" +
                        "    -- concExc_uid90_fpMulTest(BITJOIN,89)@4\n" +
                        "    concExc_uid90_fpMulTest_q <= excRNaN_uid89_fpMulTest_q & excRInf_uid85_fpMulTest_q & excRZero_uid80_fpMulTest_q;\n" +
                        "\n" +
                        "    -- excREnc_uid91_fpMulTest(LOOKUP,90)@4\n" +
                        "    excREnc_uid91_fpMulTest_combproc: PROCESS (concExc_uid90_fpMulTest_q)\n" +
                        "    BEGIN\n" +
                        "        -- Begin reserved scope level\n" +
                        "        CASE (concExc_uid90_fpMulTest_q) IS\n" +
                        "            WHEN \"000\" => excREnc_uid91_fpMulTest_q <= \"01\";\n" +
                        "            WHEN \"001\" => excREnc_uid91_fpMulTest_q <= \"00\";\n" +
                        "            WHEN \"010\" => excREnc_uid91_fpMulTest_q <= \"10\";\n" +
                        "            WHEN \"011\" => excREnc_uid91_fpMulTest_q <= \"00\";\n" +
                        "            WHEN \"100\" => excREnc_uid91_fpMulTest_q <= \"11\";\n" +
                        "            WHEN \"101\" => excREnc_uid91_fpMulTest_q <= \"00\";\n" +
                        "            WHEN \"110\" => excREnc_uid91_fpMulTest_q <= \"00\";\n" +
                        "            WHEN \"111\" => excREnc_uid91_fpMulTest_q <= \"00\";\n" +
                        "            WHEN OTHERS => -- unreachable\n" +
                        "                           excREnc_uid91_fpMulTest_q <= (others => '-');\n" +
                        "        END CASE;\n" +
                        "        -- End reserved scope level\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- expRPostExc_uid100_fpMulTest(MUX,99)@4\n" +
                        "    expRPostExc_uid100_fpMulTest_s <= excREnc_uid91_fpMulTest_q;\n" +
                        "    expRPostExc_uid100_fpMulTest_combproc: PROCESS (expRPostExc_uid100_fpMulTest_s, cstAllZWE_uid12_fpMulTest_q, expRPreExc_uid72_fpMulTest_b, cstAllOWE_uid10_fpMulTest_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (expRPostExc_uid100_fpMulTest_s) IS\n" +
                        "            WHEN \"00\" => expRPostExc_uid100_fpMulTest_q <= cstAllZWE_uid12_fpMulTest_q;\n" +
                        "            WHEN \"01\" => expRPostExc_uid100_fpMulTest_q <= expRPreExc_uid72_fpMulTest_b;\n" +
                        "            WHEN \"10\" => expRPostExc_uid100_fpMulTest_q <= cstAllOWE_uid10_fpMulTest_q;\n" +
                        "            WHEN \"11\" => expRPostExc_uid100_fpMulTest_q <= cstAllOWE_uid10_fpMulTest_q;\n" +
                        "            WHEN OTHERS => expRPostExc_uid100_fpMulTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- oneFracRPostExc2_uid92_fpMulTest(CONSTANT,91)\n" +
                        "    oneFracRPostExc2_uid92_fpMulTest_q <= \"00000000000000000000001\";\n" +
                        "\n" +
                        "    -- fracRPreExc_uid70_fpMulTest(BITSELECT,69)@3\n" +
                        "    fracRPreExc_uid70_fpMulTest_in <= expFracRPostRounding_uid69_fpMulTest_q(23 downto 0);\n" +
                        "    fracRPreExc_uid70_fpMulTest_b <= fracRPreExc_uid70_fpMulTest_in(23 downto 1);\n" +
                        "\n" +
                        "    -- redist1_fracRPreExc_uid70_fpMulTest_b_1(DELAY,109)\n" +
                        "    redist1_fracRPreExc_uid70_fpMulTest_b_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 23, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => fracRPreExc_uid70_fpMulTest_b, xout => redist1_fracRPreExc_uid70_fpMulTest_b_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- fracRPostExc_uid95_fpMulTest(MUX,94)@4\n" +
                        "    fracRPostExc_uid95_fpMulTest_s <= excREnc_uid91_fpMulTest_q;\n" +
                        "    fracRPostExc_uid95_fpMulTest_combproc: PROCESS (fracRPostExc_uid95_fpMulTest_s, cstZeroWF_uid11_fpMulTest_q, redist1_fracRPreExc_uid70_fpMulTest_b_1_q, oneFracRPostExc2_uid92_fpMulTest_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (fracRPostExc_uid95_fpMulTest_s) IS\n" +
                        "            WHEN \"00\" => fracRPostExc_uid95_fpMulTest_q <= cstZeroWF_uid11_fpMulTest_q;\n" +
                        "            WHEN \"01\" => fracRPostExc_uid95_fpMulTest_q <= redist1_fracRPreExc_uid70_fpMulTest_b_1_q;\n" +
                        "            WHEN \"10\" => fracRPostExc_uid95_fpMulTest_q <= cstZeroWF_uid11_fpMulTest_q;\n" +
                        "            WHEN \"11\" => fracRPostExc_uid95_fpMulTest_q <= oneFracRPostExc2_uid92_fpMulTest_q;\n" +
                        "            WHEN OTHERS => fracRPostExc_uid95_fpMulTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- R_uid103_fpMulTest(BITJOIN,102)@4\n" +
                        "    R_uid103_fpMulTest_q <= signRPostExc_uid102_fpMulTest_q & expRPostExc_uid100_fpMulTest_q & fracRPostExc_uid95_fpMulTest_q;\n" +
                        "\n" +
                        "    -- xOut(GPOUT,4)@4\n" +
                        "    q <= R_uid103_fpMulTest_q;\n" +
                        "\n" +
                        "END normal;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_FP_S2D_qip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -entity \"FP_S2D\" -library \"FP_S2D\" -name IP_TOOL_NAME \"altera_fp_functions\"\n" +
                        "set_global_assignment -entity \"FP_S2D\" -library \"FP_S2D\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"FP_S2D\" -library \"FP_S2D\" -name IP_TOOL_ENV \"mwpim\"\n" +
                        "set_global_assignment -library \"FP_S2D\" -name MISC_FILE [file join $::quartus(qip_path) \"FP_S2D.cmp\"]\n" +
                        "set_global_assignment -entity \"FP_S2D\" -library \"FP_S2D\" -name IP_TARGETED_DEVICE_FAMILY \"Cyclone V\"\n" +
                        "set_global_assignment -entity \"FP_S2D\" -library \"FP_S2D\" -name IP_GENERATED_DEVICE_FAMILY \"{Cyclone V}\"\n" +
                        "set_global_assignment -entity \"FP_S2D\" -library \"FP_S2D\" -name IP_QSYS_MODE \"UNKNOWN\"\n" +
                        "set_global_assignment -name SYNTHESIS_ONLY_QIP ON\n" +
                        "set_global_assignment -entity \"FP_S2D\" -library \"FP_S2D\" -name IP_COMPONENT_NAME \"RlBfUzJE\"\n" +
                        "set_global_assignment -entity \"FP_S2D\" -library \"FP_S2D\" -name IP_COMPONENT_DISPLAY_NAME \"QUxURVJBX0ZQX0ZVTkNUSU9OUw==\"\n" +
                        "set_global_assignment -entity \"FP_S2D\" -library \"FP_S2D\" -name IP_COMPONENT_REPORT_HIERARCHY \"Off\"\n" +
                        "set_global_assignment -entity \"FP_S2D\" -library \"FP_S2D\" -name IP_COMPONENT_INTERNAL \"Off\"\n" +
                        "set_global_assignment -entity \"FP_S2D\" -library \"FP_S2D\" -name IP_COMPONENT_AUTHOR \"QWx0ZXJhIENvcnBvcmF0aW9u\"\n" +
                        "set_global_assignment -entity \"FP_S2D\" -library \"FP_S2D\" -name IP_COMPONENT_VERSION \"MTguMA==\"\n" +
                        "set_global_assignment -entity \"FP_S2D\" -library \"FP_S2D\" -name IP_COMPONENT_DESCRIPTION \"QSBjb2xsZWN0aW9uIG9mIGZsb2F0aW5nIHBvaW50IGZ1bmN0aW9ucw==\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_NAME \"RlBfUzJEXzAwMDI=\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_DISPLAY_NAME \"QUxURVJBX0ZQX0ZVTkNUSU9OUw==\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_REPORT_HIERARCHY \"Off\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_INTERNAL \"Off\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_AUTHOR \"QWx0ZXJhIENvcnBvcmF0aW9u\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_VERSION \"MTguMA==\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_DESCRIPTION \"QSBjb2xsZWN0aW9uIG9mIGZsb2F0aW5nIHBvaW50IGZ1bmN0aW9ucw==\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"RlVOQ1RJT05fRkFNSUxZ::Q09OVkVSVA==::RmFtaWx5\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"QVJJVEhfZnVuY3Rpb24=::QURE::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"Q09OVkVSVF9mdW5jdGlvbg==::RlBfRlA=::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"QUxMX2Z1bmN0aW9u::QURE::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"RVhQX0xPR19mdW5jdGlvbg==::RVhQRQ==::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"VFJJR19mdW5jdGlvbg==::U0lO::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"Q09NUEFSRV9mdW5jdGlvbg==::TUlO::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"Uk9PVFNfZnVuY3Rpb24=::U1FSVA==::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"ZGVyaXZlZGZ1bmN0aW9u::RlBfRlA=::ZGVyaXZlZGZ1bmN0aW9u\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"ZnBfZm9ybWF0::c2luZ2xl::Rm9ybWF0\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"ZnBfZXhw::OA==::RXhwb25lbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"ZnBfZXhwX2Rlcml2ZWQ=::OA==::ZnBfZXhwX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"ZnBfbWFu::MjM=::TWFudGlzc2E=\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"ZnBfbWFuX2Rlcml2ZWQ=::MjM=::ZnBfbWFuX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"ZXhwb25lbnRfd2lkdGg=::MjM=::RXhwb25lbnQgV2lkdGg=\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"ZnJlcXVlbmN5X3RhcmdldA==::NzU=::VGFyZ2V0\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"bGF0ZW5jeV90YXJnZXQ=::MA==::VGFyZ2V0\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"cGVyZm9ybWFuY2VfZ29hbA==::ZnJlcXVlbmN5::R29hbA==\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"cm91bmRpbmdfbW9kZQ==::bmVhcmVzdCB3aXRoIHRpZSBicmVha2luZyBhd2F5IGZyb20gemVybw==::TW9kZQ==\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"cm91bmRpbmdfbW9kZV9kZXJpdmVk::bmVhcmVzdCB3aXRoIHRpZSBicmVha2luZyB0byBldmVu::TW9kZQ==\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"dXNlX3JvdW5kaW5nX21vZGU=::ZmFsc2U=::dXNlX3JvdW5kaW5nX21vZGU=\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"ZmFpdGhmdWxfcm91bmRpbmc=::ZmFsc2U=::UmVsYXggcm91bmRpbmcgdG8gcm91bmQgdXAgb3IgZG93biB0byByZWR1Y2UgcmVzb3VyY2UgdXNhZ2U=\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"Z2VuX2VuYWJsZQ==::ZmFsc2U=::R2VuZXJhdGUgYW4gZW5hYmxlIHBvcnQ=\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"ZGl2aWRlX3R5cGU=::MA==::TWV0aG9k\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"c2VsZWN0X3NpZ25hbF9lbmFibGU=::ZmFsc2U=::VXNlIFNlbGVjdCBTaWduYWw=\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"c2NhbGVfYnlfcGk=::ZmFsc2U=::UmVwcmVzZW50IGFuZ2xlIGFzIG11bHRpcGxlIG9mIFBp\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"bnVtYmVyX29mX2lucHV0cw==::Mg==::SW5wdXQgVmVjdG9yIERpbWVuc2lvbg==\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"dHJpZ19ub19yYW5nZV9yZWR1Y3Rpb24=::ZmFsc2U=::SW5wdXRzIGFyZSB3aXRoaW4gcmFuZ2UgLTJwaSB0byArMnBp\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"cmVwb3J0X3Jlc291cmNlc190b194bWw=::ZmFsc2U=::cmVwb3J0X3Jlc291cmNlc190b194bWw=\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"ZnhwdF93aWR0aA==::MzI=::V2lkdGg=\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"ZnhwdF9mcmFjdGlvbg==::MA==::RnJhY3Rpb24=\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"ZnhwdF9zaWdu::MQ==::U2lnbg==\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"ZnJlcXVlbmN5X2ZlZWRiYWNr::Nzc=::ZnJlcXVlbmN5X2ZlZWRiYWNr\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"bGF0ZW5jeV9mZWVkYmFjaw==::MA==::bGF0ZW5jeV9mZWVkYmFjaw==\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"Zm9yY2VfZWxhYm9yYXRl::MQ==::Zm9yY2VfZWxhYm9yYXRl\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X2Zvcm1hdA==::ZG91Ymxl::T3V0cHV0IEZvcm1hdA==\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X2V4cA==::OA==::T3V0cHV0IEV4cG9uZW50\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X2V4cF9kZXJpdmVk::MTE=::ZnBfb3V0X2V4cF9kZXJpdmVk\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X21hbg==::MjM=::T3V0cHV0IE1hbnRpc3Nh\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X21hbl9kZXJpdmVk::NTI=::ZnBfb3V0X21hbl9kZXJpdmVk\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fZm9ybWF0::c2luZ2xl::SW5wdXQgRm9ybWF0\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fZXhw::OA==::SW5wdXQgRXhwb25lbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fZXhwX2Rlcml2ZWQ=::OA==::ZnBfaW5fZXhwX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fbWFu::MjM=::SW5wdXQgTWFudGlzc2E=\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fbWFuX2Rlcml2ZWQ=::MjM=::ZnBfaW5fbWFuX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"ZW5hYmxlX2hhcmRfZnA=::dHJ1ZQ==::RW5hYmxlIEhhcmQgRmxvYXRpbmcgUG9pbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"bWFudWFsX2RzcF9wbGFubmluZw==::dHJ1ZQ==::RW5hYmxlIEhhcmQgRmxvYXRpbmcgUG9pbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"Zm9yY2VSZWdpc3RlcnM=::MTExMQ==::Zm9yY2VSZWdpc3RlcnM=\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"UkVTX0RTUF9wYXJhbQ==::MA==::TXVsdGlwbGllcw==\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"UkVTX0xVVF9wYXJhbQ==::MTEy::TFVUcw==\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"UkVTX01CSVRfcGFyYW0=::MA==::TWVtb3J5IEJpdHM=\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"UkVTX01CTE9DS19wYXJhbQ==::MA==::TWVtb3J5IEJsb2Nrcw==\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"c2VsZWN0ZWRfZGV2aWNlX2ZhbWlseQ==::Q3ljbG9uZSBW::c2VsZWN0ZWRfZGV2aWNlX2ZhbWlseQ==\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"c2VsZWN0ZWRfZGV2aWNlX3NwZWVkZ3JhZGU=::Nw==::c2VsZWN0ZWRfZGV2aWNlX3NwZWVkZ3JhZGU=\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_COMPONENT_PARAMETER \"dmFsaWRhdGlvbl9mYWlsZWQ=::ZmFsc2U=::dmFsaWRhdGlvbl9mYWlsZWQ=\"\n" +
                        "\n" +
                        "set_global_assignment -library \"FP_S2D\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_S2D.vhd\"]\n" +
                        "set_global_assignment -library \"FP_S2D\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_S2D/dspba_library_package.vhd\"]\n" +
                        "set_global_assignment -library \"FP_S2D\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_S2D/dspba_library.vhd\"]\n" +
                        "set_global_assignment -library \"FP_S2D\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_S2D/FP_S2D_0002.vhd\"]\n" +
                        "\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_TOOL_NAME \"altera_fp_functions\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"FP_S2D_0002\" -library \"FP_S2D\" -name IP_TOOL_ENV \"mwpim\"";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_FP_S2D_sip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -entity \"FP_S2D\" -library \"lib_FP_S2D\" -name IP_TOOL_NAME \"altera_fp_functions\"\n" +
                        "set_global_assignment -entity \"FP_S2D\" -library \"lib_FP_S2D\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"FP_S2D\" -library \"lib_FP_S2D\" -name IP_TOOL_ENV \"mwpim\"\n" +
                        "set_global_assignment -library \"lib_FP_S2D\" -name SPD_FILE [file join $::quartus(sip_path) \"FP_S2D.spd\"]\n" +
                        "\n" +
                        "set_global_assignment -library \"lib_FP_S2D\" -name MISC_FILE [file join $::quartus(sip_path) \"FP_S2D_sim/dspba_library_package.vhd\"]\n" +
                        "set_global_assignment -library \"lib_FP_S2D\" -name MISC_FILE [file join $::quartus(sip_path) \"FP_S2D_sim/dspba_library.vhd\"]\n" +
                        "set_global_assignment -library \"lib_FP_S2D\" -name MISC_FILE [file join $::quartus(sip_path) \"FP_S2D_sim/FP_S2D.vhd\"]";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_FP_S2D_vhd_file(String Project_Folder_File) {
        String data =   "-- megafunction wizard: %ALTERA_FP_FUNCTIONS v18.0%\n" +
                        "-- GENERATION: XML\n" +
                        "-- FP_S2D.vhd\n" +
                        "\n" +
                        "-- Generated using ACDS version 18.0 614\n" +
                        "\n" +
                        "library IEEE;\n" +
                        "use IEEE.std_logic_1164.all;\n" +
                        "use IEEE.numeric_std.all;\n" +
                        "\n" +
                        "entity FP_S2D is\n" +
                        "	port (\n" +
                        "		clk    : in  std_logic                     := '0';             --    clk.clk\n" +
                        "		areset : in  std_logic                     := '0';             -- areset.reset\n" +
                        "		a      : in  std_logic_vector(31 downto 0) := (others => '0'); --      a.a\n" +
                        "		q      : out std_logic_vector(63 downto 0)                     --      q.q\n" +
                        "	);\n" +
                        "end entity FP_S2D;\n" +
                        "\n" +
                        "architecture rtl of FP_S2D is\n" +
                        "	component FP_S2D_0002 is\n" +
                        "		port (\n" +
                        "			clk    : in  std_logic                     := 'X';             -- clk\n" +
                        "			areset : in  std_logic                     := 'X';             -- reset\n" +
                        "			a      : in  std_logic_vector(31 downto 0) := (others => 'X'); -- a\n" +
                        "			q      : out std_logic_vector(63 downto 0)                     -- q\n" +
                        "		);\n" +
                        "	end component FP_S2D_0002;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "	fp_s2d_inst : component FP_S2D_0002\n" +
                        "		port map (\n" +
                        "			clk    => clk,    --    clk.clk\n" +
                        "			areset => areset, -- areset.reset\n" +
                        "			a      => a,      --      a.a\n" +
                        "			q      => q       --      q.q\n" +
                        "		);\n" +
                        "\n" +
                        "end architecture rtl; -- of FP_S2D\n" +
                        "-- Retrieval info: <?xml version=\"1.0\"?>\n" +
                        "--<!--\n" +
                        "--	Generated by Altera MegaWizard Launcher Utility version 1.0\n" +
                        "--	************************************************************\n" +
                        "--	THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!\n" +
                        "--	************************************************************\n" +
                        "--	Copyright (C) 1991-2020 Altera Corporation\n" +
                        "--	Any megafunction design, and related net list (encrypted or decrypted),\n" +
                        "--	support information, device programming or simulation file, and any other\n" +
                        "--	associated documentation or information provided by Altera or a partner\n" +
                        "--	under Altera's Megafunction Partnership Program may be used only to\n" +
                        "--	program PLD devices (but not masked PLD devices) from Altera.  Any other\n" +
                        "--	use of such megafunction design, net list, support information, device\n" +
                        "--	programming or simulation file, or any other related documentation or\n" +
                        "--	information is prohibited for any other purpose, including, but not\n" +
                        "--	limited to modification, reverse engineering, de-compiling, or use with\n" +
                        "--	any other silicon devices, unless such use is explicitly licensed under\n" +
                        "--	a separate agreement with Altera or a megafunction partner.  Title to\n" +
                        "--	the intellectual property, including patents, copyrights, trademarks,\n" +
                        "--	trade secrets, or maskworks, embodied in any such megafunction design,\n" +
                        "--	net list, support information, device programming or simulation file, or\n" +
                        "--	any other related documentation or information provided by Altera or a\n" +
                        "--	megafunction partner, remains with Altera, the megafunction partner, or\n" +
                        "--	their respective licensors.  No other licenses, including any licenses\n" +
                        "--	needed under any third party's intellectual property, are provided herein.\n" +
                        "---->\n" +
                        "-- Retrieval info: <instance entity-name=\"altera_fp_functions\" version=\"18.0\" >\n" +
                        "-- Retrieval info: 	<generic name=\"FUNCTION_FAMILY\" value=\"CONVERT\" />\n" +
                        "-- Retrieval info: 	<generic name=\"ARITH_function\" value=\"ADD\" />\n" +
                        "-- Retrieval info: 	<generic name=\"CONVERT_function\" value=\"FP_FP\" />\n" +
                        "-- Retrieval info: 	<generic name=\"ALL_function\" value=\"ADD\" />\n" +
                        "-- Retrieval info: 	<generic name=\"EXP_LOG_function\" value=\"EXPE\" />\n" +
                        "-- Retrieval info: 	<generic name=\"TRIG_function\" value=\"SIN\" />\n" +
                        "-- Retrieval info: 	<generic name=\"COMPARE_function\" value=\"MIN\" />\n" +
                        "-- Retrieval info: 	<generic name=\"ROOTS_function\" value=\"SQRT\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_format\" value=\"single\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_exp\" value=\"8\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_man\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"exponent_width\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"frequency_target\" value=\"75\" />\n" +
                        "-- Retrieval info: 	<generic name=\"latency_target\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"performance_goal\" value=\"frequency\" />\n" +
                        "-- Retrieval info: 	<generic name=\"rounding_mode\" value=\"nearest with tie breaking away from zero\" />\n" +
                        "-- Retrieval info: 	<generic name=\"faithful_rounding\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gen_enable\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"divide_type\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"select_signal_enable\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"scale_by_pi\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"number_of_inputs\" value=\"2\" />\n" +
                        "-- Retrieval info: 	<generic name=\"trig_no_range_reduction\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"report_resources_to_xml\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fxpt_width\" value=\"32\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fxpt_fraction\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fxpt_sign\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_out_format\" value=\"double\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_out_exp\" value=\"8\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_out_man\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_in_format\" value=\"single\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_in_exp\" value=\"8\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_in_man\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"enable_hard_fp\" value=\"true\" />\n" +
                        "-- Retrieval info: 	<generic name=\"manual_dsp_planning\" value=\"true\" />\n" +
                        "-- Retrieval info: 	<generic name=\"forceRegisters\" value=\"1111\" />\n" +
                        "-- Retrieval info: 	<generic name=\"selected_device_family\" value=\"Cyclone V\" />\n" +
                        "-- Retrieval info: 	<generic name=\"selected_device_speedgrade\" value=\"7\" />\n" +
                        "-- Retrieval info: </instance>\n" +
                        "-- IPFS_FILES : FP_S2D.vho\n" +
                        "-- RELATED_FILES: FP_S2D.vhd, dspba_library_package.vhd, dspba_library.vhd, FP_S2D_0002.vhd";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_FP_S2D_0002_vhd_file(String Project_Folder_File) {
        String data =   "-- ------------------------------------------------------------------------- \n" +
                        "-- High Level Design Compiler for Intel(R) FPGAs Version 18.0 (Release Build #614)\n" +
                        "-- Quartus Prime development tool and MATLAB/Simulink Interface\n" +
                        "-- \n" +
                        "-- Legal Notice: Copyright 2018 Intel Corporation.  All rights reserved.\n" +
                        "-- Your use of  Intel Corporation's design tools,  logic functions and other\n" +
                        "-- software and  tools, and its AMPP partner logic functions, and any output\n" +
                        "-- files any  of the foregoing (including  device programming  or simulation\n" +
                        "-- files), and  any associated  documentation  or information  are expressly\n" +
                        "-- subject  to the terms and  conditions of the  Intel FPGA Software License\n" +
                        "-- Agreement, Intel MegaCore Function License Agreement, or other applicable\n" +
                        "-- license agreement,  including,  without limitation,  that your use is for\n" +
                        "-- the  sole  purpose of  programming  logic devices  manufactured by  Intel\n" +
                        "-- and  sold by Intel  or its authorized  distributors. Please refer  to the\n" +
                        "-- applicable agreement for further details.\n" +
                        "-- ---------------------------------------------------------------------------\n" +
                        "\n" +
                        "-- VHDL created from FP_S2D_0002\n" +
                        "-- VHDL created on Fri Oct  2 04:32:53 2020\n" +
                        "\n" +
                        "\n" +
                        "library IEEE;\n" +
                        "use IEEE.std_logic_1164.all;\n" +
                        "use IEEE.NUMERIC_STD.all;\n" +
                        "use IEEE.MATH_REAL.all;\n" +
                        "use std.TextIO.all;\n" +
                        "use work.dspba_library_package.all;\n" +
                        "\n" +
                        "LIBRARY altera_mf;\n" +
                        "USE altera_mf.altera_mf_components.all;\n" +
                        "LIBRARY altera_lnsim;\n" +
                        "USE altera_lnsim.altera_lnsim_components.altera_syncram;\n" +
                        "LIBRARY lpm;\n" +
                        "USE lpm.lpm_components.all;\n" +
                        "\n" +
                        "entity FP_S2D_0002 is\n" +
                        "    port (\n" +
                        "        a : in std_logic_vector(31 downto 0);  -- float32_m23\n" +
                        "        q : out std_logic_vector(63 downto 0);  -- float64_m52\n" +
                        "        clk : in std_logic;\n" +
                        "        areset : in std_logic\n" +
                        "    );\n" +
                        "end FP_S2D_0002;\n" +
                        "\n" +
                        "architecture normal of FP_S2D_0002 is\n" +
                        "\n" +
                        "    attribute altera_attribute : string;\n" +
                        "    attribute altera_attribute of normal : architecture is \"-name AUTO_SHIFT_REGISTER_RECOGNITION OFF; -name PHYSICAL_SYNTHESIS_REGISTER_DUPLICATION ON; -name MESSAGE_DISABLE 10036; -name MESSAGE_DISABLE 10037; -name MESSAGE_DISABLE 14130; -name MESSAGE_DISABLE 14320; -name MESSAGE_DISABLE 15400; -name MESSAGE_DISABLE 14130; -name MESSAGE_DISABLE 10036; -name MESSAGE_DISABLE 12020; -name MESSAGE_DISABLE 12030; -name MESSAGE_DISABLE 12010; -name MESSAGE_DISABLE 12110; -name MESSAGE_DISABLE 14320; -name MESSAGE_DISABLE 13410; -name MESSAGE_DISABLE 113007\";\n" +
                        "    \n" +
                        "    signal GND_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal VCC_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal cstBiasOut_uid6_fpToFPTest_q : STD_LOGIC_VECTOR (11 downto 0);\n" +
                        "    signal cstAllOWE_uid7_fpToFPTest_q : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal cstZeroWF_uid8_fpToFPTest_q : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal cstAllZWE_uid9_fpToFPTest_q : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal exp_x_uid10_fpToFPTest_b : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal frac_x_uid11_fpToFPTest_b : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal excZ_x_uid12_fpToFPTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expXIsMax_uid13_fpToFPTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsZero_uid14_fpToFPTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsNotZero_uid15_fpToFPTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excI_x_uid16_fpToFPTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excN_x_uid17_fpToFPTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal invExpXIsMax_uid18_fpToFPTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal InvExpXIsZero_uid19_fpToFPTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excR_x_uid20_fpToFPTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal zP_uid23_fpToFPTest_q : STD_LOGIC_VECTOR (28 downto 0);\n" +
                        "    signal fracR_uid24_fpToFPTest_q : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal expRExt_uid25_fpToFPTest_a : STD_LOGIC_VECTOR (13 downto 0);\n" +
                        "    signal expRExt_uid25_fpToFPTest_b : STD_LOGIC_VECTOR (13 downto 0);\n" +
                        "    signal expRExt_uid25_fpToFPTest_o : STD_LOGIC_VECTOR (13 downto 0);\n" +
                        "    signal expRExt_uid25_fpToFPTest_q : STD_LOGIC_VECTOR (12 downto 0);\n" +
                        "    signal expR_uid26_fpToFPTest_in : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal expR_uid26_fpToFPTest_b : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal expUdf_uid27_fpToFPTest_a : STD_LOGIC_VECTOR (14 downto 0);\n" +
                        "    signal expUdf_uid27_fpToFPTest_b : STD_LOGIC_VECTOR (14 downto 0);\n" +
                        "    signal expUdf_uid27_fpToFPTest_o : STD_LOGIC_VECTOR (14 downto 0);\n" +
                        "    signal expUdf_uid27_fpToFPTest_n : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expWEOutAllO_uid28_fpToFPTest_q : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal expOvf_uid29_fpToFPTest_a : STD_LOGIC_VECTOR (14 downto 0);\n" +
                        "    signal expOvf_uid29_fpToFPTest_b : STD_LOGIC_VECTOR (14 downto 0);\n" +
                        "    signal expOvf_uid29_fpToFPTest_o : STD_LOGIC_VECTOR (14 downto 0);\n" +
                        "    signal expOvf_uid29_fpToFPTest_n : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal inRegAndUdf_uid30_fpToFPTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excRZero_uid31_fpToFPTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal inRegAndOvf_uid32_fpToFPTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excRInf_uid33_fpToFPTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal concExc_uid34_fpToFPTest_q : STD_LOGIC_VECTOR (2 downto 0);\n" +
                        "    signal excREnc_uid35_fpToFPTest_q : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal oneFracRPostExc2_uid36_fpToFPTest_q : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal zeroFracRPostExc_uid37_fpToFPTest_q : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal fracRPostExc_uid39_fpToFPTest_s : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal fracRPostExc_uid39_fpToFPTest_q : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal zeroExpRPostExc_uid42_fpToFPTest_q : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal expRPostExc_uid43_fpToFPTest_s : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal expRPostExc_uid43_fpToFPTest_q : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal signX_uid44_fpToFPTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fpRes_uid45_fpToFPTest_q : STD_LOGIC_VECTOR (63 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "\n" +
                        "    -- signX_uid44_fpToFPTest(BITSELECT,43)@0\n" +
                        "    signX_uid44_fpToFPTest_b <= STD_LOGIC_VECTOR(a(31 downto 31));\n" +
                        "\n" +
                        "    -- expWEOutAllO_uid28_fpToFPTest(CONSTANT,27)\n" +
                        "    expWEOutAllO_uid28_fpToFPTest_q <= \"11111111111\";\n" +
                        "\n" +
                        "    -- cstBiasOut_uid6_fpToFPTest(CONSTANT,5)\n" +
                        "    cstBiasOut_uid6_fpToFPTest_q <= \"001110000000\";\n" +
                        "\n" +
                        "    -- exp_x_uid10_fpToFPTest(BITSELECT,9)@0\n" +
                        "    exp_x_uid10_fpToFPTest_b <= a(30 downto 23);\n" +
                        "\n" +
                        "    -- expRExt_uid25_fpToFPTest(ADD,24)@0\n" +
                        "    expRExt_uid25_fpToFPTest_a <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR(\"000000\" & exp_x_uid10_fpToFPTest_b));\n" +
                        "    expRExt_uid25_fpToFPTest_b <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR((13 downto 12 => cstBiasOut_uid6_fpToFPTest_q(11)) & cstBiasOut_uid6_fpToFPTest_q));\n" +
                        "    expRExt_uid25_fpToFPTest_o <= STD_LOGIC_VECTOR(SIGNED(expRExt_uid25_fpToFPTest_a) + SIGNED(expRExt_uid25_fpToFPTest_b));\n" +
                        "    expRExt_uid25_fpToFPTest_q <= expRExt_uid25_fpToFPTest_o(12 downto 0);\n" +
                        "\n" +
                        "    -- expR_uid26_fpToFPTest(BITSELECT,25)@0\n" +
                        "    expR_uid26_fpToFPTest_in <= expRExt_uid25_fpToFPTest_q(10 downto 0);\n" +
                        "    expR_uid26_fpToFPTest_b <= expR_uid26_fpToFPTest_in(10 downto 0);\n" +
                        "\n" +
                        "    -- zeroExpRPostExc_uid42_fpToFPTest(CONSTANT,41)\n" +
                        "    zeroExpRPostExc_uid42_fpToFPTest_q <= \"00000000000\";\n" +
                        "\n" +
                        "    -- frac_x_uid11_fpToFPTest(BITSELECT,10)@0\n" +
                        "    frac_x_uid11_fpToFPTest_b <= a(22 downto 0);\n" +
                        "\n" +
                        "    -- cstZeroWF_uid8_fpToFPTest(CONSTANT,7)\n" +
                        "    cstZeroWF_uid8_fpToFPTest_q <= \"00000000000000000000000\";\n" +
                        "\n" +
                        "    -- fracXIsZero_uid14_fpToFPTest(LOGICAL,13)@0\n" +
                        "    fracXIsZero_uid14_fpToFPTest_q <= \"1\" WHEN cstZeroWF_uid8_fpToFPTest_q = frac_x_uid11_fpToFPTest_b ELSE \"0\";\n" +
                        "\n" +
                        "    -- fracXIsNotZero_uid15_fpToFPTest(LOGICAL,14)@0\n" +
                        "    fracXIsNotZero_uid15_fpToFPTest_q <= not (fracXIsZero_uid14_fpToFPTest_q);\n" +
                        "\n" +
                        "    -- cstAllOWE_uid7_fpToFPTest(CONSTANT,6)\n" +
                        "    cstAllOWE_uid7_fpToFPTest_q <= \"11111111\";\n" +
                        "\n" +
                        "    -- expXIsMax_uid13_fpToFPTest(LOGICAL,12)@0\n" +
                        "    expXIsMax_uid13_fpToFPTest_q <= \"1\" WHEN exp_x_uid10_fpToFPTest_b = cstAllOWE_uid7_fpToFPTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- excN_x_uid17_fpToFPTest(LOGICAL,16)@0\n" +
                        "    excN_x_uid17_fpToFPTest_q <= expXIsMax_uid13_fpToFPTest_q and fracXIsNotZero_uid15_fpToFPTest_q;\n" +
                        "\n" +
                        "    -- GND(CONSTANT,0)\n" +
                        "    GND_q <= \"0\";\n" +
                        "\n" +
                        "    -- expOvf_uid29_fpToFPTest(COMPARE,28)@0\n" +
                        "    expOvf_uid29_fpToFPTest_a <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR((14 downto 13 => expRExt_uid25_fpToFPTest_q(12)) & expRExt_uid25_fpToFPTest_q));\n" +
                        "    expOvf_uid29_fpToFPTest_b <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR(\"0000\" & expWEOutAllO_uid28_fpToFPTest_q));\n" +
                        "    expOvf_uid29_fpToFPTest_o <= STD_LOGIC_VECTOR(SIGNED(expOvf_uid29_fpToFPTest_a) - SIGNED(expOvf_uid29_fpToFPTest_b));\n" +
                        "    expOvf_uid29_fpToFPTest_n(0) <= not (expOvf_uid29_fpToFPTest_o(14));\n" +
                        "\n" +
                        "    -- invExpXIsMax_uid18_fpToFPTest(LOGICAL,17)@0\n" +
                        "    invExpXIsMax_uid18_fpToFPTest_q <= not (expXIsMax_uid13_fpToFPTest_q);\n" +
                        "\n" +
                        "    -- cstAllZWE_uid9_fpToFPTest(CONSTANT,8)\n" +
                        "    cstAllZWE_uid9_fpToFPTest_q <= \"00000000\";\n" +
                        "\n" +
                        "    -- excZ_x_uid12_fpToFPTest(LOGICAL,11)@0\n" +
                        "    excZ_x_uid12_fpToFPTest_q <= \"1\" WHEN exp_x_uid10_fpToFPTest_b = cstAllZWE_uid9_fpToFPTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- InvExpXIsZero_uid19_fpToFPTest(LOGICAL,18)@0\n" +
                        "    InvExpXIsZero_uid19_fpToFPTest_q <= not (excZ_x_uid12_fpToFPTest_q);\n" +
                        "\n" +
                        "    -- excR_x_uid20_fpToFPTest(LOGICAL,19)@0\n" +
                        "    excR_x_uid20_fpToFPTest_q <= InvExpXIsZero_uid19_fpToFPTest_q and invExpXIsMax_uid18_fpToFPTest_q;\n" +
                        "\n" +
                        "    -- inRegAndOvf_uid32_fpToFPTest(LOGICAL,31)@0\n" +
                        "    inRegAndOvf_uid32_fpToFPTest_q <= excR_x_uid20_fpToFPTest_q and expOvf_uid29_fpToFPTest_n;\n" +
                        "\n" +
                        "    -- excI_x_uid16_fpToFPTest(LOGICAL,15)@0\n" +
                        "    excI_x_uid16_fpToFPTest_q <= expXIsMax_uid13_fpToFPTest_q and fracXIsZero_uid14_fpToFPTest_q;\n" +
                        "\n" +
                        "    -- excRInf_uid33_fpToFPTest(LOGICAL,32)@0\n" +
                        "    excRInf_uid33_fpToFPTest_q <= excI_x_uid16_fpToFPTest_q or inRegAndOvf_uid32_fpToFPTest_q;\n" +
                        "\n" +
                        "    -- expUdf_uid27_fpToFPTest(COMPARE,26)@0\n" +
                        "    expUdf_uid27_fpToFPTest_a <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR(\"00000000000000\" & GND_q));\n" +
                        "    expUdf_uid27_fpToFPTest_b <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR((14 downto 13 => expRExt_uid25_fpToFPTest_q(12)) & expRExt_uid25_fpToFPTest_q));\n" +
                        "    expUdf_uid27_fpToFPTest_o <= STD_LOGIC_VECTOR(SIGNED(expUdf_uid27_fpToFPTest_a) - SIGNED(expUdf_uid27_fpToFPTest_b));\n" +
                        "    expUdf_uid27_fpToFPTest_n(0) <= not (expUdf_uid27_fpToFPTest_o(14));\n" +
                        "\n" +
                        "    -- inRegAndUdf_uid30_fpToFPTest(LOGICAL,29)@0\n" +
                        "    inRegAndUdf_uid30_fpToFPTest_q <= excR_x_uid20_fpToFPTest_q and expUdf_uid27_fpToFPTest_n;\n" +
                        "\n" +
                        "    -- excRZero_uid31_fpToFPTest(LOGICAL,30)@0\n" +
                        "    excRZero_uid31_fpToFPTest_q <= excZ_x_uid12_fpToFPTest_q or inRegAndUdf_uid30_fpToFPTest_q;\n" +
                        "\n" +
                        "    -- concExc_uid34_fpToFPTest(BITJOIN,33)@0\n" +
                        "    concExc_uid34_fpToFPTest_q <= excN_x_uid17_fpToFPTest_q & excRInf_uid33_fpToFPTest_q & excRZero_uid31_fpToFPTest_q;\n" +
                        "\n" +
                        "    -- excREnc_uid35_fpToFPTest(LOOKUP,34)@0\n" +
                        "    excREnc_uid35_fpToFPTest_combproc: PROCESS (concExc_uid34_fpToFPTest_q)\n" +
                        "    BEGIN\n" +
                        "        -- Begin reserved scope level\n" +
                        "        CASE (concExc_uid34_fpToFPTest_q) IS\n" +
                        "            WHEN \"000\" => excREnc_uid35_fpToFPTest_q <= \"01\";\n" +
                        "            WHEN \"001\" => excREnc_uid35_fpToFPTest_q <= \"00\";\n" +
                        "            WHEN \"010\" => excREnc_uid35_fpToFPTest_q <= \"10\";\n" +
                        "            WHEN \"011\" => excREnc_uid35_fpToFPTest_q <= \"00\";\n" +
                        "            WHEN \"100\" => excREnc_uid35_fpToFPTest_q <= \"11\";\n" +
                        "            WHEN \"101\" => excREnc_uid35_fpToFPTest_q <= \"00\";\n" +
                        "            WHEN \"110\" => excREnc_uid35_fpToFPTest_q <= \"00\";\n" +
                        "            WHEN \"111\" => excREnc_uid35_fpToFPTest_q <= \"00\";\n" +
                        "            WHEN OTHERS => -- unreachable\n" +
                        "                           excREnc_uid35_fpToFPTest_q <= (others => '-');\n" +
                        "        END CASE;\n" +
                        "        -- End reserved scope level\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- VCC(CONSTANT,1)\n" +
                        "    VCC_q <= \"1\";\n" +
                        "\n" +
                        "    -- expRPostExc_uid43_fpToFPTest(MUX,42)@0\n" +
                        "    expRPostExc_uid43_fpToFPTest_s <= excREnc_uid35_fpToFPTest_q;\n" +
                        "    expRPostExc_uid43_fpToFPTest_combproc: PROCESS (expRPostExc_uid43_fpToFPTest_s, zeroExpRPostExc_uid42_fpToFPTest_q, expR_uid26_fpToFPTest_b, expWEOutAllO_uid28_fpToFPTest_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (expRPostExc_uid43_fpToFPTest_s) IS\n" +
                        "            WHEN \"00\" => expRPostExc_uid43_fpToFPTest_q <= zeroExpRPostExc_uid42_fpToFPTest_q;\n" +
                        "            WHEN \"01\" => expRPostExc_uid43_fpToFPTest_q <= expR_uid26_fpToFPTest_b;\n" +
                        "            WHEN \"10\" => expRPostExc_uid43_fpToFPTest_q <= expWEOutAllO_uid28_fpToFPTest_q;\n" +
                        "            WHEN \"11\" => expRPostExc_uid43_fpToFPTest_q <= expWEOutAllO_uid28_fpToFPTest_q;\n" +
                        "            WHEN OTHERS => expRPostExc_uid43_fpToFPTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- oneFracRPostExc2_uid36_fpToFPTest(CONSTANT,35)\n" +
                        "    oneFracRPostExc2_uid36_fpToFPTest_q <= \"0000000000000000000000000000000000000000000000000001\";\n" +
                        "\n" +
                        "    -- zP_uid23_fpToFPTest(CONSTANT,22)\n" +
                        "    zP_uid23_fpToFPTest_q <= \"00000000000000000000000000000\";\n" +
                        "\n" +
                        "    -- fracR_uid24_fpToFPTest(BITJOIN,23)@0\n" +
                        "    fracR_uid24_fpToFPTest_q <= frac_x_uid11_fpToFPTest_b & zP_uid23_fpToFPTest_q;\n" +
                        "\n" +
                        "    -- zeroFracRPostExc_uid37_fpToFPTest(CONSTANT,36)\n" +
                        "    zeroFracRPostExc_uid37_fpToFPTest_q <= \"0000000000000000000000000000000000000000000000000000\";\n" +
                        "\n" +
                        "    -- fracRPostExc_uid39_fpToFPTest(MUX,38)@0\n" +
                        "    fracRPostExc_uid39_fpToFPTest_s <= excREnc_uid35_fpToFPTest_q;\n" +
                        "    fracRPostExc_uid39_fpToFPTest_combproc: PROCESS (fracRPostExc_uid39_fpToFPTest_s, zeroFracRPostExc_uid37_fpToFPTest_q, fracR_uid24_fpToFPTest_q, oneFracRPostExc2_uid36_fpToFPTest_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (fracRPostExc_uid39_fpToFPTest_s) IS\n" +
                        "            WHEN \"00\" => fracRPostExc_uid39_fpToFPTest_q <= zeroFracRPostExc_uid37_fpToFPTest_q;\n" +
                        "            WHEN \"01\" => fracRPostExc_uid39_fpToFPTest_q <= fracR_uid24_fpToFPTest_q;\n" +
                        "            WHEN \"10\" => fracRPostExc_uid39_fpToFPTest_q <= zeroFracRPostExc_uid37_fpToFPTest_q;\n" +
                        "            WHEN \"11\" => fracRPostExc_uid39_fpToFPTest_q <= oneFracRPostExc2_uid36_fpToFPTest_q;\n" +
                        "            WHEN OTHERS => fracRPostExc_uid39_fpToFPTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- fpRes_uid45_fpToFPTest(BITJOIN,44)@0\n" +
                        "    fpRes_uid45_fpToFPTest_q <= signX_uid44_fpToFPTest_b & expRPostExc_uid43_fpToFPTest_q & fracRPostExc_uid39_fpToFPTest_q;\n" +
                        "\n" +
                        "    -- xOut(GPOUT,4)@0\n" +
                        "    q <= fpRes_uid45_fpToFPTest_q;\n" +
                        "\n" +
                        "END normal;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_FP_D2S_qip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -entity \"FP_D2S\" -library \"FP_D2S\" -name IP_TOOL_NAME \"altera_fp_functions\"\n" +
                        "set_global_assignment -entity \"FP_D2S\" -library \"FP_D2S\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"FP_D2S\" -library \"FP_D2S\" -name IP_TOOL_ENV \"mwpim\"\n" +
                        "set_global_assignment -library \"FP_D2S\" -name MISC_FILE [file join $::quartus(qip_path) \"FP_D2S.cmp\"]\n" +
                        "set_global_assignment -entity \"FP_D2S\" -library \"FP_D2S\" -name IP_TARGETED_DEVICE_FAMILY \"Cyclone V\"\n" +
                        "set_global_assignment -entity \"FP_D2S\" -library \"FP_D2S\" -name IP_GENERATED_DEVICE_FAMILY \"{Cyclone V}\"\n" +
                        "set_global_assignment -entity \"FP_D2S\" -library \"FP_D2S\" -name IP_QSYS_MODE \"UNKNOWN\"\n" +
                        "set_global_assignment -name SYNTHESIS_ONLY_QIP ON\n" +
                        "set_global_assignment -entity \"FP_D2S\" -library \"FP_D2S\" -name IP_COMPONENT_NAME \"RlBfRDJT\"\n" +
                        "set_global_assignment -entity \"FP_D2S\" -library \"FP_D2S\" -name IP_COMPONENT_DISPLAY_NAME \"QUxURVJBX0ZQX0ZVTkNUSU9OUw==\"\n" +
                        "set_global_assignment -entity \"FP_D2S\" -library \"FP_D2S\" -name IP_COMPONENT_REPORT_HIERARCHY \"Off\"\n" +
                        "set_global_assignment -entity \"FP_D2S\" -library \"FP_D2S\" -name IP_COMPONENT_INTERNAL \"Off\"\n" +
                        "set_global_assignment -entity \"FP_D2S\" -library \"FP_D2S\" -name IP_COMPONENT_AUTHOR \"QWx0ZXJhIENvcnBvcmF0aW9u\"\n" +
                        "set_global_assignment -entity \"FP_D2S\" -library \"FP_D2S\" -name IP_COMPONENT_VERSION \"MTguMA==\"\n" +
                        "set_global_assignment -entity \"FP_D2S\" -library \"FP_D2S\" -name IP_COMPONENT_DESCRIPTION \"QSBjb2xsZWN0aW9uIG9mIGZsb2F0aW5nIHBvaW50IGZ1bmN0aW9ucw==\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_NAME \"RlBfRDJTXzAwMDI=\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_DISPLAY_NAME \"QUxURVJBX0ZQX0ZVTkNUSU9OUw==\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_REPORT_HIERARCHY \"Off\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_INTERNAL \"Off\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_AUTHOR \"QWx0ZXJhIENvcnBvcmF0aW9u\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_VERSION \"MTguMA==\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_DESCRIPTION \"QSBjb2xsZWN0aW9uIG9mIGZsb2F0aW5nIHBvaW50IGZ1bmN0aW9ucw==\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"RlVOQ1RJT05fRkFNSUxZ::Q09OVkVSVA==::RmFtaWx5\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"QVJJVEhfZnVuY3Rpb24=::QURE::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"Q09OVkVSVF9mdW5jdGlvbg==::RlBfRlA=::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"QUxMX2Z1bmN0aW9u::QURE::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"RVhQX0xPR19mdW5jdGlvbg==::RVhQRQ==::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"VFJJR19mdW5jdGlvbg==::U0lO::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"Q09NUEFSRV9mdW5jdGlvbg==::TUlO::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"Uk9PVFNfZnVuY3Rpb24=::U1FSVA==::TmFtZQ==\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"ZGVyaXZlZGZ1bmN0aW9u::RlBfRlA=::ZGVyaXZlZGZ1bmN0aW9u\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"ZnBfZm9ybWF0::c2luZ2xl::Rm9ybWF0\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"ZnBfZXhw::OA==::RXhwb25lbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"ZnBfZXhwX2Rlcml2ZWQ=::OA==::ZnBfZXhwX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"ZnBfbWFu::MjM=::TWFudGlzc2E=\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"ZnBfbWFuX2Rlcml2ZWQ=::MjM=::ZnBfbWFuX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"ZXhwb25lbnRfd2lkdGg=::MjM=::RXhwb25lbnQgV2lkdGg=\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"ZnJlcXVlbmN5X3RhcmdldA==::NzU=::VGFyZ2V0\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"bGF0ZW5jeV90YXJnZXQ=::Mg==::VGFyZ2V0\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"cGVyZm9ybWFuY2VfZ29hbA==::ZnJlcXVlbmN5::R29hbA==\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"cm91bmRpbmdfbW9kZQ==::bmVhcmVzdCB3aXRoIHRpZSBicmVha2luZyBhd2F5IGZyb20gemVybw==::TW9kZQ==\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"cm91bmRpbmdfbW9kZV9kZXJpdmVk::bmVhcmVzdCB3aXRoIHRpZSBicmVha2luZyB0byBldmVu::TW9kZQ==\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"dXNlX3JvdW5kaW5nX21vZGU=::ZmFsc2U=::dXNlX3JvdW5kaW5nX21vZGU=\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"ZmFpdGhmdWxfcm91bmRpbmc=::ZmFsc2U=::UmVsYXggcm91bmRpbmcgdG8gcm91bmQgdXAgb3IgZG93biB0byByZWR1Y2UgcmVzb3VyY2UgdXNhZ2U=\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"Z2VuX2VuYWJsZQ==::ZmFsc2U=::R2VuZXJhdGUgYW4gZW5hYmxlIHBvcnQ=\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"ZGl2aWRlX3R5cGU=::MA==::TWV0aG9k\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"c2VsZWN0X3NpZ25hbF9lbmFibGU=::ZmFsc2U=::VXNlIFNlbGVjdCBTaWduYWw=\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"c2NhbGVfYnlfcGk=::ZmFsc2U=::UmVwcmVzZW50IGFuZ2xlIGFzIG11bHRpcGxlIG9mIFBp\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"bnVtYmVyX29mX2lucHV0cw==::Mg==::SW5wdXQgVmVjdG9yIERpbWVuc2lvbg==\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"dHJpZ19ub19yYW5nZV9yZWR1Y3Rpb24=::ZmFsc2U=::SW5wdXRzIGFyZSB3aXRoaW4gcmFuZ2UgLTJwaSB0byArMnBp\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"cmVwb3J0X3Jlc291cmNlc190b194bWw=::ZmFsc2U=::cmVwb3J0X3Jlc291cmNlc190b194bWw=\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"ZnhwdF93aWR0aA==::MzI=::V2lkdGg=\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"ZnhwdF9mcmFjdGlvbg==::MA==::RnJhY3Rpb24=\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"ZnhwdF9zaWdu::MQ==::U2lnbg==\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"ZnJlcXVlbmN5X2ZlZWRiYWNr::MA==::ZnJlcXVlbmN5X2ZlZWRiYWNr\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"bGF0ZW5jeV9mZWVkYmFjaw==::MQ==::bGF0ZW5jeV9mZWVkYmFjaw==\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"Zm9yY2VfZWxhYm9yYXRl::MA==::Zm9yY2VfZWxhYm9yYXRl\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X2Zvcm1hdA==::c2luZ2xl::T3V0cHV0IEZvcm1hdA==\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X2V4cA==::OA==::T3V0cHV0IEV4cG9uZW50\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X2V4cF9kZXJpdmVk::OA==::ZnBfb3V0X2V4cF9kZXJpdmVk\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X21hbg==::MjM=::T3V0cHV0IE1hbnRpc3Nh\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"ZnBfb3V0X21hbl9kZXJpdmVk::MjM=::ZnBfb3V0X21hbl9kZXJpdmVk\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fZm9ybWF0::ZG91Ymxl::SW5wdXQgRm9ybWF0\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fZXhw::OA==::SW5wdXQgRXhwb25lbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fZXhwX2Rlcml2ZWQ=::MTE=::ZnBfaW5fZXhwX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fbWFu::MjM=::SW5wdXQgTWFudGlzc2E=\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"ZnBfaW5fbWFuX2Rlcml2ZWQ=::NTI=::ZnBfaW5fbWFuX2Rlcml2ZWQ=\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"ZW5hYmxlX2hhcmRfZnA=::dHJ1ZQ==::RW5hYmxlIEhhcmQgRmxvYXRpbmcgUG9pbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"bWFudWFsX2RzcF9wbGFubmluZw==::dHJ1ZQ==::RW5hYmxlIEhhcmQgRmxvYXRpbmcgUG9pbnQ=\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"Zm9yY2VSZWdpc3RlcnM=::MTExMQ==::Zm9yY2VSZWdpc3RlcnM=\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"UkVTX0RTUF9wYXJhbQ==::MA==::TXVsdGlwbGllcw==\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"UkVTX0xVVF9wYXJhbQ==::MTM5::TFVUcw==\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"UkVTX01CSVRfcGFyYW0=::MA==::TWVtb3J5IEJpdHM=\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"UkVTX01CTE9DS19wYXJhbQ==::MA==::TWVtb3J5IEJsb2Nrcw==\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"c2VsZWN0ZWRfZGV2aWNlX2ZhbWlseQ==::Q3ljbG9uZSBW::c2VsZWN0ZWRfZGV2aWNlX2ZhbWlseQ==\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"c2VsZWN0ZWRfZGV2aWNlX3NwZWVkZ3JhZGU=::Nw==::c2VsZWN0ZWRfZGV2aWNlX3NwZWVkZ3JhZGU=\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_COMPONENT_PARAMETER \"dmFsaWRhdGlvbl9mYWlsZWQ=::ZmFsc2U=::dmFsaWRhdGlvbl9mYWlsZWQ=\"\n" +
                        "\n" +
                        "set_global_assignment -library \"FP_D2S\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_D2S.vhd\"]\n" +
                        "set_global_assignment -library \"FP_D2S\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_D2S/dspba_library_package.vhd\"]\n" +
                        "set_global_assignment -library \"FP_D2S\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_D2S/dspba_library.vhd\"]\n" +
                        "set_global_assignment -library \"FP_D2S\" -name VHDL_FILE [file join $::quartus(qip_path) \"FP_D2S/FP_D2S_0002.vhd\"]\n" +
                        "\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_TOOL_NAME \"altera_fp_functions\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"FP_D2S_0002\" -library \"FP_D2S\" -name IP_TOOL_ENV \"mwpim\"";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_FP_D2S_sip_file(String Project_Folder_File) {
        String data =   "set_global_assignment -entity \"FP_D2S\" -library \"lib_FP_D2S\" -name IP_TOOL_NAME \"altera_fp_functions\"\n" +
                        "set_global_assignment -entity \"FP_D2S\" -library \"lib_FP_D2S\" -name IP_TOOL_VERSION \"18.0\"\n" +
                        "set_global_assignment -entity \"FP_D2S\" -library \"lib_FP_D2S\" -name IP_TOOL_ENV \"mwpim\"\n" +
                        "set_global_assignment -library \"lib_FP_D2S\" -name SPD_FILE [file join $::quartus(sip_path) \"FP_D2S.spd\"]\n" +
                        "\n" +
                        "set_global_assignment -library \"lib_FP_D2S\" -name MISC_FILE [file join $::quartus(sip_path) \"FP_D2S_sim/dspba_library_package.vhd\"]\n" +
                        "set_global_assignment -library \"lib_FP_D2S\" -name MISC_FILE [file join $::quartus(sip_path) \"FP_D2S_sim/dspba_library.vhd\"]\n" +
                        "set_global_assignment -library \"lib_FP_D2S\" -name MISC_FILE [file join $::quartus(sip_path) \"FP_D2S_sim/FP_D2S.vhd\"]";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_FP_D2S_vhd_file(String Project_Folder_File) {
        String data =   "-- megafunction wizard: %ALTERA_FP_FUNCTIONS v18.0%\n" +
                        "-- GENERATION: XML\n" +
                        "-- FP_D2S.vhd\n" +
                        "\n" +
                        "-- Generated using ACDS version 18.0 614\n" +
                        "\n" +
                        "library IEEE;\n" +
                        "use IEEE.std_logic_1164.all;\n" +
                        "use IEEE.numeric_std.all;\n" +
                        "\n" +
                        "entity FP_D2S is\n" +
                        "	port (\n" +
                        "		clk    : in  std_logic                     := '0';             --    clk.clk\n" +
                        "		areset : in  std_logic                     := '0';             -- areset.reset\n" +
                        "		a      : in  std_logic_vector(63 downto 0) := (others => '0'); --      a.a\n" +
                        "		q      : out std_logic_vector(31 downto 0)                     --      q.q\n" +
                        "	);\n" +
                        "end entity FP_D2S;\n" +
                        "\n" +
                        "architecture rtl of FP_D2S is\n" +
                        "	component FP_D2S_0002 is\n" +
                        "		port (\n" +
                        "			clk    : in  std_logic                     := 'X';             -- clk\n" +
                        "			areset : in  std_logic                     := 'X';             -- reset\n" +
                        "			a      : in  std_logic_vector(63 downto 0) := (others => 'X'); -- a\n" +
                        "			q      : out std_logic_vector(31 downto 0)                     -- q\n" +
                        "		);\n" +
                        "	end component FP_D2S_0002;\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "	fp_d2s_inst : component FP_D2S_0002\n" +
                        "		port map (\n" +
                        "			clk    => clk,    --    clk.clk\n" +
                        "			areset => areset, -- areset.reset\n" +
                        "			a      => a,      --      a.a\n" +
                        "			q      => q       --      q.q\n" +
                        "		);\n" +
                        "\n" +
                        "end architecture rtl; -- of FP_D2S\n" +
                        "-- Retrieval info: <?xml version=\"1.0\"?>\n" +
                        "--<!--\n" +
                        "--	Generated by Altera MegaWizard Launcher Utility version 1.0\n" +
                        "--	************************************************************\n" +
                        "--	THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!\n" +
                        "--	************************************************************\n" +
                        "--	Copyright (C) 1991-2020 Altera Corporation\n" +
                        "--	Any megafunction design, and related net list (encrypted or decrypted),\n" +
                        "--	support information, device programming or simulation file, and any other\n" +
                        "--	associated documentation or information provided by Altera or a partner\n" +
                        "--	under Altera's Megafunction Partnership Program may be used only to\n" +
                        "--	program PLD devices (but not masked PLD devices) from Altera.  Any other\n" +
                        "--	use of such megafunction design, net list, support information, device\n" +
                        "--	programming or simulation file, or any other related documentation or\n" +
                        "--	information is prohibited for any other purpose, including, but not\n" +
                        "--	limited to modification, reverse engineering, de-compiling, or use with\n" +
                        "--	any other silicon devices, unless such use is explicitly licensed under\n" +
                        "--	a separate agreement with Altera or a megafunction partner.  Title to\n" +
                        "--	the intellectual property, including patents, copyrights, trademarks,\n" +
                        "--	trade secrets, or maskworks, embodied in any such megafunction design,\n" +
                        "--	net list, support information, device programming or simulation file, or\n" +
                        "--	any other related documentation or information provided by Altera or a\n" +
                        "--	megafunction partner, remains with Altera, the megafunction partner, or\n" +
                        "--	their respective licensors.  No other licenses, including any licenses\n" +
                        "--	needed under any third party's intellectual property, are provided herein.\n" +
                        "---->\n" +
                        "-- Retrieval info: <instance entity-name=\"altera_fp_functions\" version=\"18.0\" >\n" +
                        "-- Retrieval info: 	<generic name=\"FUNCTION_FAMILY\" value=\"CONVERT\" />\n" +
                        "-- Retrieval info: 	<generic name=\"ARITH_function\" value=\"ADD\" />\n" +
                        "-- Retrieval info: 	<generic name=\"CONVERT_function\" value=\"FP_FP\" />\n" +
                        "-- Retrieval info: 	<generic name=\"ALL_function\" value=\"ADD\" />\n" +
                        "-- Retrieval info: 	<generic name=\"EXP_LOG_function\" value=\"EXPE\" />\n" +
                        "-- Retrieval info: 	<generic name=\"TRIG_function\" value=\"SIN\" />\n" +
                        "-- Retrieval info: 	<generic name=\"COMPARE_function\" value=\"MIN\" />\n" +
                        "-- Retrieval info: 	<generic name=\"ROOTS_function\" value=\"SQRT\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_format\" value=\"single\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_exp\" value=\"8\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_man\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"exponent_width\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"frequency_target\" value=\"75\" />\n" +
                        "-- Retrieval info: 	<generic name=\"latency_target\" value=\"2\" />\n" +
                        "-- Retrieval info: 	<generic name=\"performance_goal\" value=\"frequency\" />\n" +
                        "-- Retrieval info: 	<generic name=\"rounding_mode\" value=\"nearest with tie breaking away from zero\" />\n" +
                        "-- Retrieval info: 	<generic name=\"faithful_rounding\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"gen_enable\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"divide_type\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"select_signal_enable\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"scale_by_pi\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"number_of_inputs\" value=\"2\" />\n" +
                        "-- Retrieval info: 	<generic name=\"trig_no_range_reduction\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"report_resources_to_xml\" value=\"false\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fxpt_width\" value=\"32\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fxpt_fraction\" value=\"0\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fxpt_sign\" value=\"1\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_out_format\" value=\"single\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_out_exp\" value=\"8\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_out_man\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_in_format\" value=\"double\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_in_exp\" value=\"8\" />\n" +
                        "-- Retrieval info: 	<generic name=\"fp_in_man\" value=\"23\" />\n" +
                        "-- Retrieval info: 	<generic name=\"enable_hard_fp\" value=\"true\" />\n" +
                        "-- Retrieval info: 	<generic name=\"manual_dsp_planning\" value=\"true\" />\n" +
                        "-- Retrieval info: 	<generic name=\"forceRegisters\" value=\"1111\" />\n" +
                        "-- Retrieval info: 	<generic name=\"selected_device_family\" value=\"Cyclone V\" />\n" +
                        "-- Retrieval info: 	<generic name=\"selected_device_speedgrade\" value=\"7\" />\n" +
                        "-- Retrieval info: </instance>\n" +
                        "-- IPFS_FILES : FP_D2S.vho\n" +
                        "-- RELATED_FILES: FP_D2S.vhd, dspba_library_package.vhd, dspba_library.vhd, FP_D2S_0002.vhd";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_FP_D2S_0002_vhd_file(String Project_Folder_File) {
        String data =   "-- ------------------------------------------------------------------------- \n" +
                        "-- High Level Design Compiler for Intel(R) FPGAs Version 18.0 (Release Build #614)\n" +
                        "-- Quartus Prime development tool and MATLAB/Simulink Interface\n" +
                        "-- \n" +
                        "-- Legal Notice: Copyright 2018 Intel Corporation.  All rights reserved.\n" +
                        "-- Your use of  Intel Corporation's design tools,  logic functions and other\n" +
                        "-- software and  tools, and its AMPP partner logic functions, and any output\n" +
                        "-- files any  of the foregoing (including  device programming  or simulation\n" +
                        "-- files), and  any associated  documentation  or information  are expressly\n" +
                        "-- subject  to the terms and  conditions of the  Intel FPGA Software License\n" +
                        "-- Agreement, Intel MegaCore Function License Agreement, or other applicable\n" +
                        "-- license agreement,  including,  without limitation,  that your use is for\n" +
                        "-- the  sole  purpose of  programming  logic devices  manufactured by  Intel\n" +
                        "-- and  sold by Intel  or its authorized  distributors. Please refer  to the\n" +
                        "-- applicable agreement for further details.\n" +
                        "-- ---------------------------------------------------------------------------\n" +
                        "\n" +
                        "-- VHDL created from FP_D2S_0002\n" +
                        "-- VHDL created on Thu Oct  1 23:50:51 2020\n" +
                        "\n" +
                        "\n" +
                        "library IEEE;\n" +
                        "use IEEE.std_logic_1164.all;\n" +
                        "use IEEE.NUMERIC_STD.all;\n" +
                        "use IEEE.MATH_REAL.all;\n" +
                        "use std.TextIO.all;\n" +
                        "use work.dspba_library_package.all;\n" +
                        "\n" +
                        "LIBRARY altera_mf;\n" +
                        "USE altera_mf.altera_mf_components.all;\n" +
                        "LIBRARY altera_lnsim;\n" +
                        "USE altera_lnsim.altera_lnsim_components.altera_syncram;\n" +
                        "LIBRARY lpm;\n" +
                        "USE lpm.lpm_components.all;\n" +
                        "\n" +
                        "entity FP_D2S_0002 is\n" +
                        "    port (\n" +
                        "        a : in std_logic_vector(63 downto 0);  -- float64_m52\n" +
                        "        q : out std_logic_vector(31 downto 0);  -- float32_m23\n" +
                        "        clk : in std_logic;\n" +
                        "        areset : in std_logic\n" +
                        "    );\n" +
                        "end FP_D2S_0002;\n" +
                        "\n" +
                        "architecture normal of FP_D2S_0002 is\n" +
                        "\n" +
                        "    attribute altera_attribute : string;\n" +
                        "    attribute altera_attribute of normal : architecture is \"-name AUTO_SHIFT_REGISTER_RECOGNITION OFF; -name PHYSICAL_SYNTHESIS_REGISTER_DUPLICATION ON; -name MESSAGE_DISABLE 10036; -name MESSAGE_DISABLE 10037; -name MESSAGE_DISABLE 14130; -name MESSAGE_DISABLE 14320; -name MESSAGE_DISABLE 15400; -name MESSAGE_DISABLE 14130; -name MESSAGE_DISABLE 10036; -name MESSAGE_DISABLE 12020; -name MESSAGE_DISABLE 12030; -name MESSAGE_DISABLE 12010; -name MESSAGE_DISABLE 12110; -name MESSAGE_DISABLE 14320; -name MESSAGE_DISABLE 13410; -name MESSAGE_DISABLE 113007\";\n" +
                        "    \n" +
                        "    signal GND_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal VCC_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal cstBiasOut_uid6_fpToFPTest_q : STD_LOGIC_VECTOR (11 downto 0);\n" +
                        "    signal cstAllOWE_uid7_fpToFPTest_q : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal cstZeroWF_uid8_fpToFPTest_q : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal cstAllZWE_uid9_fpToFPTest_q : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal exp_x_uid10_fpToFPTest_b : STD_LOGIC_VECTOR (10 downto 0);\n" +
                        "    signal frac_x_uid11_fpToFPTest_b : STD_LOGIC_VECTOR (51 downto 0);\n" +
                        "    signal excZ_x_uid12_fpToFPTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expXIsMax_uid13_fpToFPTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsZero_uid14_fpToFPTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXIsNotZero_uid15_fpToFPTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excI_x_uid16_fpToFPTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excN_x_uid17_fpToFPTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal invExpXIsMax_uid18_fpToFPTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal InvExpXIsZero_uid19_fpToFPTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excR_x_uid20_fpToFPTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fracXWOP1_uid23_fpToFPTest_b : STD_LOGIC_VECTOR (23 downto 0);\n" +
                        "    signal expXFracX_uid24_fpToFPTest_q : STD_LOGIC_VECTOR (34 downto 0);\n" +
                        "    signal zeroPaddingInAddition_uid27_fpToFPTest_q : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal rndExpUpdate_uid28_fpToFPTest_q : STD_LOGIC_VECTOR (35 downto 0);\n" +
                        "    signal expFracR_uid29_fpToFPTest_a : STD_LOGIC_VECTOR (37 downto 0);\n" +
                        "    signal expFracR_uid29_fpToFPTest_b : STD_LOGIC_VECTOR (37 downto 0);\n" +
                        "    signal expFracR_uid29_fpToFPTest_o : STD_LOGIC_VECTOR (37 downto 0);\n" +
                        "    signal expFracR_uid29_fpToFPTest_q : STD_LOGIC_VECTOR (36 downto 0);\n" +
                        "    signal fracR_uid30_fpToFPTest_in : STD_LOGIC_VECTOR (23 downto 0);\n" +
                        "    signal fracR_uid30_fpToFPTest_b : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal expR_uid31_fpToFPTest_in : STD_LOGIC_VECTOR (31 downto 0);\n" +
                        "    signal expR_uid31_fpToFPTest_b : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal expRExt_uid32_fpToFPTest_b : STD_LOGIC_VECTOR (12 downto 0);\n" +
                        "    signal expUdf_uid33_fpToFPTest_a : STD_LOGIC_VECTOR (14 downto 0);\n" +
                        "    signal expUdf_uid33_fpToFPTest_b : STD_LOGIC_VECTOR (14 downto 0);\n" +
                        "    signal expUdf_uid33_fpToFPTest_o : STD_LOGIC_VECTOR (14 downto 0);\n" +
                        "    signal expUdf_uid33_fpToFPTest_n : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal expWEOutAllO_uid34_fpToFPTest_q : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal expOvf_uid35_fpToFPTest_a : STD_LOGIC_VECTOR (14 downto 0);\n" +
                        "    signal expOvf_uid35_fpToFPTest_b : STD_LOGIC_VECTOR (14 downto 0);\n" +
                        "    signal expOvf_uid35_fpToFPTest_o : STD_LOGIC_VECTOR (14 downto 0);\n" +
                        "    signal expOvf_uid35_fpToFPTest_n : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal inRegAndUdf_uid36_fpToFPTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excRZero_uid37_fpToFPTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal inRegAndOvf_uid38_fpToFPTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal excRInf_uid39_fpToFPTest_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal concExc_uid40_fpToFPTest_q : STD_LOGIC_VECTOR (2 downto 0);\n" +
                        "    signal excREnc_uid41_fpToFPTest_q : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal oneFracRPostExc2_uid42_fpToFPTest_q : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal fracRPostExc_uid45_fpToFPTest_s : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal fracRPostExc_uid45_fpToFPTest_q : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "    signal zeroExpRPostExc_uid48_fpToFPTest_q : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal expRPostExc_uid49_fpToFPTest_s : STD_LOGIC_VECTOR (1 downto 0);\n" +
                        "    signal expRPostExc_uid49_fpToFPTest_q : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal signX_uid50_fpToFPTest_b : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal fpRes_uid51_fpToFPTest_q : STD_LOGIC_VECTOR (31 downto 0);\n" +
                        "    signal redist0_signX_uid50_fpToFPTest_b_1_q : STD_LOGIC_VECTOR (0 downto 0);\n" +
                        "    signal redist1_expR_uid31_fpToFPTest_b_1_q : STD_LOGIC_VECTOR (7 downto 0);\n" +
                        "    signal redist2_fracR_uid30_fpToFPTest_b_1_q : STD_LOGIC_VECTOR (22 downto 0);\n" +
                        "\n" +
                        "begin\n" +
                        "\n" +
                        "\n" +
                        "    -- VCC(CONSTANT,1)\n" +
                        "    VCC_q <= \"1\";\n" +
                        "\n" +
                        "    -- signX_uid50_fpToFPTest(BITSELECT,49)@0\n" +
                        "    signX_uid50_fpToFPTest_b <= STD_LOGIC_VECTOR(a(63 downto 63));\n" +
                        "\n" +
                        "    -- redist0_signX_uid50_fpToFPTest_b_1(DELAY,52)\n" +
                        "    redist0_signX_uid50_fpToFPTest_b_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 1, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => signX_uid50_fpToFPTest_b, xout => redist0_signX_uid50_fpToFPTest_b_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- expWEOutAllO_uid34_fpToFPTest(CONSTANT,33)\n" +
                        "    expWEOutAllO_uid34_fpToFPTest_q <= \"11111111\";\n" +
                        "\n" +
                        "    -- cstBiasOut_uid6_fpToFPTest(CONSTANT,5)\n" +
                        "    cstBiasOut_uid6_fpToFPTest_q <= \"110010000000\";\n" +
                        "\n" +
                        "    -- zeroPaddingInAddition_uid27_fpToFPTest(CONSTANT,26)\n" +
                        "    zeroPaddingInAddition_uid27_fpToFPTest_q <= \"00000000000000000000000\";\n" +
                        "\n" +
                        "    -- rndExpUpdate_uid28_fpToFPTest(BITJOIN,27)@0\n" +
                        "    rndExpUpdate_uid28_fpToFPTest_q <= cstBiasOut_uid6_fpToFPTest_q & zeroPaddingInAddition_uid27_fpToFPTest_q & VCC_q;\n" +
                        "\n" +
                        "    -- exp_x_uid10_fpToFPTest(BITSELECT,9)@0\n" +
                        "    exp_x_uid10_fpToFPTest_b <= a(62 downto 52);\n" +
                        "\n" +
                        "    -- frac_x_uid11_fpToFPTest(BITSELECT,10)@0\n" +
                        "    frac_x_uid11_fpToFPTest_b <= a(51 downto 0);\n" +
                        "\n" +
                        "    -- fracXWOP1_uid23_fpToFPTest(BITSELECT,22)@0\n" +
                        "    fracXWOP1_uid23_fpToFPTest_b <= frac_x_uid11_fpToFPTest_b(51 downto 28);\n" +
                        "\n" +
                        "    -- expXFracX_uid24_fpToFPTest(BITJOIN,23)@0\n" +
                        "    expXFracX_uid24_fpToFPTest_q <= exp_x_uid10_fpToFPTest_b & fracXWOP1_uid23_fpToFPTest_b;\n" +
                        "\n" +
                        "    -- expFracR_uid29_fpToFPTest(ADD,28)@0\n" +
                        "    expFracR_uid29_fpToFPTest_a <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR(\"000\" & expXFracX_uid24_fpToFPTest_q));\n" +
                        "    expFracR_uid29_fpToFPTest_b <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR((37 downto 36 => rndExpUpdate_uid28_fpToFPTest_q(35)) & rndExpUpdate_uid28_fpToFPTest_q));\n" +
                        "    expFracR_uid29_fpToFPTest_o <= STD_LOGIC_VECTOR(SIGNED(expFracR_uid29_fpToFPTest_a) + SIGNED(expFracR_uid29_fpToFPTest_b));\n" +
                        "    expFracR_uid29_fpToFPTest_q <= expFracR_uid29_fpToFPTest_o(36 downto 0);\n" +
                        "\n" +
                        "    -- expR_uid31_fpToFPTest(BITSELECT,30)@0\n" +
                        "    expR_uid31_fpToFPTest_in <= expFracR_uid29_fpToFPTest_q(31 downto 0);\n" +
                        "    expR_uid31_fpToFPTest_b <= expR_uid31_fpToFPTest_in(31 downto 24);\n" +
                        "\n" +
                        "    -- redist1_expR_uid31_fpToFPTest_b_1(DELAY,53)\n" +
                        "    redist1_expR_uid31_fpToFPTest_b_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 8, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => expR_uid31_fpToFPTest_b, xout => redist1_expR_uid31_fpToFPTest_b_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- zeroExpRPostExc_uid48_fpToFPTest(CONSTANT,47)\n" +
                        "    zeroExpRPostExc_uid48_fpToFPTest_q <= \"00000000\";\n" +
                        "\n" +
                        "    -- cstZeroWF_uid8_fpToFPTest(CONSTANT,7)\n" +
                        "    cstZeroWF_uid8_fpToFPTest_q <= \"0000000000000000000000000000000000000000000000000000\";\n" +
                        "\n" +
                        "    -- fracXIsZero_uid14_fpToFPTest(LOGICAL,13)@0\n" +
                        "    fracXIsZero_uid14_fpToFPTest_q <= \"1\" WHEN cstZeroWF_uid8_fpToFPTest_q = frac_x_uid11_fpToFPTest_b ELSE \"0\";\n" +
                        "\n" +
                        "    -- fracXIsNotZero_uid15_fpToFPTest(LOGICAL,14)@0\n" +
                        "    fracXIsNotZero_uid15_fpToFPTest_q <= not (fracXIsZero_uid14_fpToFPTest_q);\n" +
                        "\n" +
                        "    -- cstAllOWE_uid7_fpToFPTest(CONSTANT,6)\n" +
                        "    cstAllOWE_uid7_fpToFPTest_q <= \"11111111111\";\n" +
                        "\n" +
                        "    -- expXIsMax_uid13_fpToFPTest(LOGICAL,12)@0\n" +
                        "    expXIsMax_uid13_fpToFPTest_q <= \"1\" WHEN exp_x_uid10_fpToFPTest_b = cstAllOWE_uid7_fpToFPTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- excN_x_uid17_fpToFPTest(LOGICAL,16)@0\n" +
                        "    excN_x_uid17_fpToFPTest_q <= expXIsMax_uid13_fpToFPTest_q and fracXIsNotZero_uid15_fpToFPTest_q;\n" +
                        "\n" +
                        "    -- GND(CONSTANT,0)\n" +
                        "    GND_q <= \"0\";\n" +
                        "\n" +
                        "    -- expRExt_uid32_fpToFPTest(BITSELECT,31)@0\n" +
                        "    expRExt_uid32_fpToFPTest_b <= STD_LOGIC_VECTOR(expFracR_uid29_fpToFPTest_q(36 downto 24));\n" +
                        "\n" +
                        "    -- expOvf_uid35_fpToFPTest(COMPARE,34)@0\n" +
                        "    expOvf_uid35_fpToFPTest_a <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR((14 downto 13 => expRExt_uid32_fpToFPTest_b(12)) & expRExt_uid32_fpToFPTest_b));\n" +
                        "    expOvf_uid35_fpToFPTest_b <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR(\"0000000\" & expWEOutAllO_uid34_fpToFPTest_q));\n" +
                        "    expOvf_uid35_fpToFPTest_o <= STD_LOGIC_VECTOR(SIGNED(expOvf_uid35_fpToFPTest_a) - SIGNED(expOvf_uid35_fpToFPTest_b));\n" +
                        "    expOvf_uid35_fpToFPTest_n(0) <= not (expOvf_uid35_fpToFPTest_o(14));\n" +
                        "\n" +
                        "    -- invExpXIsMax_uid18_fpToFPTest(LOGICAL,17)@0\n" +
                        "    invExpXIsMax_uid18_fpToFPTest_q <= not (expXIsMax_uid13_fpToFPTest_q);\n" +
                        "\n" +
                        "    -- cstAllZWE_uid9_fpToFPTest(CONSTANT,8)\n" +
                        "    cstAllZWE_uid9_fpToFPTest_q <= \"00000000000\";\n" +
                        "\n" +
                        "    -- excZ_x_uid12_fpToFPTest(LOGICAL,11)@0\n" +
                        "    excZ_x_uid12_fpToFPTest_q <= \"1\" WHEN exp_x_uid10_fpToFPTest_b = cstAllZWE_uid9_fpToFPTest_q ELSE \"0\";\n" +
                        "\n" +
                        "    -- InvExpXIsZero_uid19_fpToFPTest(LOGICAL,18)@0\n" +
                        "    InvExpXIsZero_uid19_fpToFPTest_q <= not (excZ_x_uid12_fpToFPTest_q);\n" +
                        "\n" +
                        "    -- excR_x_uid20_fpToFPTest(LOGICAL,19)@0\n" +
                        "    excR_x_uid20_fpToFPTest_q <= InvExpXIsZero_uid19_fpToFPTest_q and invExpXIsMax_uid18_fpToFPTest_q;\n" +
                        "\n" +
                        "    -- inRegAndOvf_uid38_fpToFPTest(LOGICAL,37)@0\n" +
                        "    inRegAndOvf_uid38_fpToFPTest_q <= excR_x_uid20_fpToFPTest_q and expOvf_uid35_fpToFPTest_n;\n" +
                        "\n" +
                        "    -- excI_x_uid16_fpToFPTest(LOGICAL,15)@0\n" +
                        "    excI_x_uid16_fpToFPTest_q <= expXIsMax_uid13_fpToFPTest_q and fracXIsZero_uid14_fpToFPTest_q;\n" +
                        "\n" +
                        "    -- excRInf_uid39_fpToFPTest(LOGICAL,38)@0\n" +
                        "    excRInf_uid39_fpToFPTest_q <= excI_x_uid16_fpToFPTest_q or inRegAndOvf_uid38_fpToFPTest_q;\n" +
                        "\n" +
                        "    -- expUdf_uid33_fpToFPTest(COMPARE,32)@0\n" +
                        "    expUdf_uid33_fpToFPTest_a <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR(\"00000000000000\" & GND_q));\n" +
                        "    expUdf_uid33_fpToFPTest_b <= STD_LOGIC_VECTOR(STD_LOGIC_VECTOR((14 downto 13 => expRExt_uid32_fpToFPTest_b(12)) & expRExt_uid32_fpToFPTest_b));\n" +
                        "    expUdf_uid33_fpToFPTest_o <= STD_LOGIC_VECTOR(SIGNED(expUdf_uid33_fpToFPTest_a) - SIGNED(expUdf_uid33_fpToFPTest_b));\n" +
                        "    expUdf_uid33_fpToFPTest_n(0) <= not (expUdf_uid33_fpToFPTest_o(14));\n" +
                        "\n" +
                        "    -- inRegAndUdf_uid36_fpToFPTest(LOGICAL,35)@0\n" +
                        "    inRegAndUdf_uid36_fpToFPTest_q <= excR_x_uid20_fpToFPTest_q and expUdf_uid33_fpToFPTest_n;\n" +
                        "\n" +
                        "    -- excRZero_uid37_fpToFPTest(LOGICAL,36)@0\n" +
                        "    excRZero_uid37_fpToFPTest_q <= excZ_x_uid12_fpToFPTest_q or inRegAndUdf_uid36_fpToFPTest_q;\n" +
                        "\n" +
                        "    -- concExc_uid40_fpToFPTest(BITJOIN,39)@0\n" +
                        "    concExc_uid40_fpToFPTest_q <= excN_x_uid17_fpToFPTest_q & excRInf_uid39_fpToFPTest_q & excRZero_uid37_fpToFPTest_q;\n" +
                        "\n" +
                        "    -- excREnc_uid41_fpToFPTest(LOOKUP,40)@0 + 1\n" +
                        "    excREnc_uid41_fpToFPTest_clkproc: PROCESS (clk, areset)\n" +
                        "    BEGIN\n" +
                        "        IF (areset = '1') THEN\n" +
                        "            excREnc_uid41_fpToFPTest_q <= \"01\";\n" +
                        "        ELSIF (clk'EVENT AND clk = '1') THEN\n" +
                        "            CASE (concExc_uid40_fpToFPTest_q) IS\n" +
                        "                WHEN \"000\" => excREnc_uid41_fpToFPTest_q <= \"01\";\n" +
                        "                WHEN \"001\" => excREnc_uid41_fpToFPTest_q <= \"00\";\n" +
                        "                WHEN \"010\" => excREnc_uid41_fpToFPTest_q <= \"10\";\n" +
                        "                WHEN \"011\" => excREnc_uid41_fpToFPTest_q <= \"00\";\n" +
                        "                WHEN \"100\" => excREnc_uid41_fpToFPTest_q <= \"11\";\n" +
                        "                WHEN \"101\" => excREnc_uid41_fpToFPTest_q <= \"00\";\n" +
                        "                WHEN \"110\" => excREnc_uid41_fpToFPTest_q <= \"00\";\n" +
                        "                WHEN \"111\" => excREnc_uid41_fpToFPTest_q <= \"00\";\n" +
                        "                WHEN OTHERS => -- unreachable\n" +
                        "                               excREnc_uid41_fpToFPTest_q <= (others => '-');\n" +
                        "            END CASE;\n" +
                        "        END IF;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- expRPostExc_uid49_fpToFPTest(MUX,48)@1\n" +
                        "    expRPostExc_uid49_fpToFPTest_s <= excREnc_uid41_fpToFPTest_q;\n" +
                        "    expRPostExc_uid49_fpToFPTest_combproc: PROCESS (expRPostExc_uid49_fpToFPTest_s, zeroExpRPostExc_uid48_fpToFPTest_q, redist1_expR_uid31_fpToFPTest_b_1_q, expWEOutAllO_uid34_fpToFPTest_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (expRPostExc_uid49_fpToFPTest_s) IS\n" +
                        "            WHEN \"00\" => expRPostExc_uid49_fpToFPTest_q <= zeroExpRPostExc_uid48_fpToFPTest_q;\n" +
                        "            WHEN \"01\" => expRPostExc_uid49_fpToFPTest_q <= redist1_expR_uid31_fpToFPTest_b_1_q;\n" +
                        "            WHEN \"10\" => expRPostExc_uid49_fpToFPTest_q <= expWEOutAllO_uid34_fpToFPTest_q;\n" +
                        "            WHEN \"11\" => expRPostExc_uid49_fpToFPTest_q <= expWEOutAllO_uid34_fpToFPTest_q;\n" +
                        "            WHEN OTHERS => expRPostExc_uid49_fpToFPTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- oneFracRPostExc2_uid42_fpToFPTest(CONSTANT,41)\n" +
                        "    oneFracRPostExc2_uid42_fpToFPTest_q <= \"00000000000000000000001\";\n" +
                        "\n" +
                        "    -- fracR_uid30_fpToFPTest(BITSELECT,29)@0\n" +
                        "    fracR_uid30_fpToFPTest_in <= expFracR_uid29_fpToFPTest_q(23 downto 0);\n" +
                        "    fracR_uid30_fpToFPTest_b <= fracR_uid30_fpToFPTest_in(23 downto 1);\n" +
                        "\n" +
                        "    -- redist2_fracR_uid30_fpToFPTest_b_1(DELAY,54)\n" +
                        "    redist2_fracR_uid30_fpToFPTest_b_1 : dspba_delay\n" +
                        "    GENERIC MAP ( width => 23, depth => 1, reset_kind => \"ASYNC\" )\n" +
                        "    PORT MAP ( xin => fracR_uid30_fpToFPTest_b, xout => redist2_fracR_uid30_fpToFPTest_b_1_q, clk => clk, aclr => areset );\n" +
                        "\n" +
                        "    -- fracRPostExc_uid45_fpToFPTest(MUX,44)@1\n" +
                        "    fracRPostExc_uid45_fpToFPTest_s <= excREnc_uid41_fpToFPTest_q;\n" +
                        "    fracRPostExc_uid45_fpToFPTest_combproc: PROCESS (fracRPostExc_uid45_fpToFPTest_s, zeroPaddingInAddition_uid27_fpToFPTest_q, redist2_fracR_uid30_fpToFPTest_b_1_q, oneFracRPostExc2_uid42_fpToFPTest_q)\n" +
                        "    BEGIN\n" +
                        "        CASE (fracRPostExc_uid45_fpToFPTest_s) IS\n" +
                        "            WHEN \"00\" => fracRPostExc_uid45_fpToFPTest_q <= zeroPaddingInAddition_uid27_fpToFPTest_q;\n" +
                        "            WHEN \"01\" => fracRPostExc_uid45_fpToFPTest_q <= redist2_fracR_uid30_fpToFPTest_b_1_q;\n" +
                        "            WHEN \"10\" => fracRPostExc_uid45_fpToFPTest_q <= zeroPaddingInAddition_uid27_fpToFPTest_q;\n" +
                        "            WHEN \"11\" => fracRPostExc_uid45_fpToFPTest_q <= oneFracRPostExc2_uid42_fpToFPTest_q;\n" +
                        "            WHEN OTHERS => fracRPostExc_uid45_fpToFPTest_q <= (others => '0');\n" +
                        "        END CASE;\n" +
                        "    END PROCESS;\n" +
                        "\n" +
                        "    -- fpRes_uid51_fpToFPTest(BITJOIN,50)@1\n" +
                        "    fpRes_uid51_fpToFPTest_q <= redist0_signX_uid50_fpToFPTest_b_1_q & expRPostExc_uid49_fpToFPTest_q & fracRPostExc_uid45_fpToFPTest_q;\n" +
                        "\n" +
                        "    -- xOut(GPOUT,4)@1\n" +
                        "    q <= fpRes_uid51_fpToFPTest_q;\n" +
                        "\n" +
                        "END normal;";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    /*private void generate_test_vhd_file(String Project_Folder_File) {
        String data =   "";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }

    private void generate_test_vhd_file(String Project_Folder_File) {
        String data =   "";
        new GeneralFunctions().write_file(Project_Folder_File, data);
    }*/
    
}
